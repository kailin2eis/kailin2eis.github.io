[{"title":"第二章 线性表(上)","url":"/p/14457/","content":"<h2 id=\"2-1-线性表的定义和基本操作\"><a href=\"#2-1-线性表的定义和基本操作\" class=\"headerlink\" title=\"2.1 线性表的定义和基本操作\"></a>2.1 线性表的定义和基本操作</h2><h3 id=\"什是线性表？🤔\"><a href=\"#什是线性表？🤔\" class=\"headerlink\" title=\"什是线性表？🤔\"></a>什是线性表？🤔</h3><p><strong>有点像函数</strong></p>\n<p>函数：一个 x 值只能对应一个 y 值<br>线性表：一个索引值只能有一个映射值</p>\n<p><strong>定义</strong>:线性表是具有相同数据类型的 n(n≥0) 个<font color='orange'>数据元素</font>的有限序列，其中n为表长，当n-0时线性表是一个<font color='orange'>空表</font>。若用L命名线性表，则其一般表示为</p>\n<p>L=(a1,a2,…,ai,ai+1,…,an)</p>\n<p><strong>几个概念</strong>:</p>\n<ul>\n<li>ai是线性表的”第i个”元素线性表中的位序。</li>\n<li>a1是<font color='orange'>表头元素</font>；an是<font color='orange'>表尾元素</font>。</li>\n<li>除第一个元素外，每个元素有且<font color='orange'>仅有一个直接前驱</font>；除最后一个元素外，每个元素有且<font color='orange'>仅有一个直接后继</font></li>\n</ul>\n<p><strong>特点</strong>:</p>\n<ul>\n<li>表中元素<font color='orange'>个数有限</font></li>\n<li>表中元素具有逻辑上的顺序性，表中元素有其<font color='orange'>先后次序</font></li>\n<li>表中元素都是数据元素，每个元素都是单个元素</li>\n<li>表中元素的数据类型都相同，这意味着<font color='orange'>每个元素占有相同大小的存储空间</font></li>\n<li>表中元素具有抽象性 </li>\n</ul>\n<p><font color='red'>注</font>:线性表是一种<font color='red'>逻辑结构</font>，表示元素之间一对一的相邻关系。顺序表和链表是指<font color='red'>存储结构</font>，两者属于不同的层面概念，不要混淆</p>\n<h3 id=\"线性表的基本操作\"><a href=\"#线性表的基本操作\" class=\"headerlink\" title=\"线性表的基本操作\"></a>线性表的基本操作</h3><p>详细文档可以参考 c++容器<a href=\"https://cplusplus.com/reference/list/list/\">list 的相关函数</a></p>\n<p><a href=\"../code/2.1.list.cpp\">c++代码示例</a></p>\n<ul>\n<li><p>InitList(&amp;L) ：初始化表，构造一个空的线性表</p>\n</li>\n<li><p>DestroyList(&amp;L) ：销毁线性表</p>\n</li>\n<li><p>ClearList(&amp;L) ：清空线性表</p>\n</li>\n<li><p>ListEmpty(&amp;L) ：置空线性表</p>\n</li>\n<li><p>ListLength(L) ： 求线性表长度</p>\n</li>\n<li><p>GetElem(L, i, &amp;e) ： 获取元素</p>\n</li>\n<li><p>LocateElem(L, e, compare())</p>\n</li>\n<li><p>PriorElem(L, cur_e, &amp;pre_e) ： 获取元素的前驱</p>\n</li>\n<li><p>NextElem(L,cur_e,&amp;next_e) ： 获得元素的后继</p>\n</li>\n<li><p>ListInsert(&amp;L,i,e) ：插入操作</p>\n</li>\n<li><p>ListDelete(&amp;L,i,&amp;e) ：删除操作</p>\n</li>\n<li><p>ListTraverse(&amp;L, vistited()) ：遍历 </p>\n</li>\n</ul>\n<p>Tips：</p>\n<ul>\n<li>对数据的操作——无非就是创建、销毁；增、删、改、查。</li>\n<li>在描述基本操作的时候，并不指明具体的参数类型，而是一种抽象的接口定义。</li>\n<li>实际开发中，可根据实际需求定义其他的基本操作。</li>\n<li>函数名和参数的形式、命名都可改变。但是尽量具有可读性，写成上面这种就很好，都是很好的命名方式了。</li>\n<li><strong>什么时候要传入引用”&amp;“——对参数的修改结果需要”带回来“。即操作的是同一份实实在在的数据目标，而不能是一个拷贝的复制品。</strong></li>\n</ul>\n<p><strong>问题</strong>：为什么要实现对<strong>数据结构</strong>的基本操作？</p>\n<ul>\n<li>团队合作编程，你定义的数据结构要让别人能很方便地使用（封装）。</li>\n<li>将常用的操作/运算封装成函数，避免重复工作，降低出错风险。</li>\n</ul>\n<h2 id=\"2-2-线性表的顺序表示\"><a href=\"#2-2-线性表的顺序表示\" class=\"headerlink\" title=\"2.2 线性表的顺序表示\"></a>2.2 线性表的顺序表示</h2><h3 id=\"顺序表的定义-Sequence-List\"><a href=\"#顺序表的定义-Sequence-List\" class=\"headerlink\" title=\"顺序表的定义 Sequence List\"></a>顺序表的定义 Sequence List</h3><ul>\n<li><p><strong>顺序表</strong>–用顺序存储的方式实现线性表顺序存储。</p>\n</li>\n<li><p><strong>顺序存储</strong>–把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。</p>\n</li>\n<li><p>顺序表的<strong>特点</strong>:</p>\n<ul>\n<li>表中元素的逻辑顺序与其物理顺序相同。</li>\n<li><font color='orange'>随机访问</font>，即通过首地址和元素序号可在时间O(1)内找到指定的元素。</li>\n<li><font color='orange'>存储密度高</font>，每个结点只存储数据元素。它不像链表那样还需要存放一个指针域。</li>\n<li>拓展容量不方便。即使采用动态分配的方式实现，拓展长度的时间复杂度也比较高。</li>\n<li>插入、删除操作不方便，需要移动大量元素。</li>\n</ul>\n</li>\n<li><p>顺序表的实现</p>\n<ul>\n<li><p>静态分配</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 10;\t\t\t\t<span class=\"comment\">//定义最大长度</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    ElemType data[MaxSize];\t\t<span class=\"comment\">//用静态的&quot;数组&quot;存放数据元素</span></span><br><span class=\"line\">    <span class=\"type\">int</span> length;\t\t\t\t\t<span class=\"comment\">//顺序表的当前长度</span></span><br><span class=\"line\">&#125;SqList;\t\t\t\t\t\t<span class=\"comment\">//顺序表的类型定义(静态分配方式)</span></span><br></pre></td></tr></table></figure>\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-1.png\" style=\"zoom: 75%;\" />\n\n<p><strong>问题</strong>：如果“数组”存满了怎么办？</p>\n<ul>\n<li>可以放弃了，顺序表的表长刚开始确定后就无法更改（存储空间是静态的）</li>\n<li>如果刚开始就声明一个很大的内存空间呢？会很浪费空间。</li>\n</ul>\n</li>\n<li><p>动态分配</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 100;\t\t\t\t<span class=\"comment\">//定义最大长度</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    ElemType *data;\t\t\t\t<span class=\"comment\">//指针指向第一个数据元素</span></span><br><span class=\"line\">    <span class=\"type\">int</span> MaxSize;\t\t\t\t<span class=\"comment\">//顺序表的最大容量</span></span><br><span class=\"line\">    <span class=\"type\">int</span> length;\t\t\t\t\t<span class=\"comment\">//顺序表的当前长度</span></span><br><span class=\"line\">&#125;SeqList;\t\t\t\t\t\t<span class=\"comment\">//顺序表的类型定义(动态分配方式)</span></span><br></pre></td></tr></table></figure>\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-2.png\" style=\"zoom: 75%;\" />\n</li>\n<li><p>C 的初始动态分配语句–malloc、free函数</p>\n<p><code>L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize);</code></p>\n<p>malloc函数返回一个指针，需要强制转型为你定义的数据元素类型指针</p>\n<blockquote>\n<p>char * p = (char* ) malloc(sizeof(char)*10)；</p>\n<p>//申请了10个char长度的连续空间，不初始化且不知道是否申请成功</p>\n<p>if(NULL == p)</p>\n<p>return；//申请内存空间失败</p>\n</blockquote>\n</li>\n<li><p>C++的初始动态分配语句–new、delete关键字</p>\n<p><code>L.data = new ElemType[InitSize];</code></p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"顺序表上基本操作\"><a href=\"#顺序表上基本操作\" class=\"headerlink\" title=\"顺序表上基本操作\"></a>顺序表上基本操作</h3><ul>\n<li><p>插入操作</p>\n<ul>\n<li><p>最好情况：表尾插入(即i=n+1)，时间复杂度为O(1)</p>\n</li>\n<li><p>最坏情况：表头插入(即i=1)，时间复杂度为O(n)</p>\n</li>\n<li><p>平均情况：插入到任一位置的概率相同，即i=1,2,3,…,length+1的概率都是p=1/(n+1)。 i=1，循环n次；i=2时，循环n-1次；… i=n+1时，循环0次<br>$$<br>E_{ins} = \\frac 1{n+1} \\sum^{n+1}_{i=1}(n-i+1) = \\frac 1{n+1}(n+\\cdots + 1 + 0) = \\frac n2<br>$$<br> ，平均时间复杂度为O(n)</p>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ListInsert</span><span class=\"params\">(SqList &amp;L, <span class=\"type\">int</span> i, <span class=\"type\">int</span> e)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=L.length; j&gt;=i; j--)&#123;\t<span class=\"comment\">//将第i个元素及之后的元素后移 </span></span><br><span class=\"line\">\t\tL.data[j] = L.data[j<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tL.data[i<span class=\"number\">-1</span>] = e;\t<span class=\"comment\">//在位置i处放入e</span></span><br><span class=\"line\">\tL.length++;\t\t<span class=\"comment\">//长度加1 </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于插入操作，如果使用者传入了一个<strong>不合法的值</strong>，那么我们的程序应该可以给予相应的反馈。至少要反馈插入是成功，还是失败了吧。所以我们可以优化一下，如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 插入操作代码</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">ListInsert</span><span class=\"params\">(SqList &amp;L, <span class=\"type\">int</span> i, ElemType e)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">1</span> || i &gt; L.length + <span class=\"number\">1</span> )          <span class=\"comment\">// 判断i的范围是否有效</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (L.length &gt;= MAXSIZE)            <span class=\"comment\">// 当前存储空间已满</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = L.length ; j &gt;= i ; j--)</span><br><span class=\"line\">        L.data[j] = L.data[j - <span class=\"number\">1</span>];           <span class=\"comment\">// 插入位置及之后位置后移</span></span><br><span class=\"line\">    L.data[i - <span class=\"number\">1</span>] = e;                       <span class=\"comment\">// 将新元素放入第i个位置</span></span><br><span class=\"line\">    L.length++;                              <span class=\"comment\">//表长增加1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-51.png\" style=\"zoom: 75%;\" />\n</li>\n<li><p>删除操作</p>\n<ul>\n<li><p>最好情况：删除表尾元素(即i=n)，时间复杂度为O(1)</p>\n</li>\n<li><p>最坏情况：删除表头元素(即i=1)，时间复杂度为O(n)</p>\n</li>\n<li><p>平均情况：删除任何一个元素的概率相同，即I=1,2,3,…,length的概率都是p=1/n。i=1，循环n-1次；i=2时，循环n-2次；…i=n时，循环0次<br>$$<br>E_{del} = \\frac 1n \\sum^n_{i=1}(n-i)=\\frac 1n \\frac {(n-1)n}2 = \\frac{n-1}2<br>$$<br> ，平均时间复杂度为O(n)</p>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除操作代码</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">ListDelete</span><span class=\"params\">(SqList&amp; L, <span class=\"type\">int</span> i, ElemType &amp;e)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">1</span> || i &gt; L.length)             <span class=\"comment\">// 判断i值是否合理</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    e = L.data[i - <span class=\"number\">1</span>];         <span class=\"comment\">//将被删除的元素赋给e</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt; L.length; j++)</span><br><span class=\"line\">        L.data[j - <span class=\"number\">1</span>] = L.data[j];  <span class=\"comment\">//将被删除的元素赋给e</span></span><br><span class=\"line\">    L.length--;  <span class=\"comment\">//线性表长度减1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-4.png\" style=\"zoom: 70%;\" />\n\n<ul>\n<li><p><strong>按位查找</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">ELemType <span class=\"title function_\">GetElem</span><span class=\"params\">(SeqList L, <span class=\"type\">int</span> i)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L.data[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度:O(1)   “<strong>随机存取</strong>“特性!</p>\n</li>\n<li><p><strong>按值查找</strong>（顺序查找）</p>\n<ul>\n<li><p>最好情况：查找的元素就在表头循环1次，时间复杂度为O(1)</p>\n</li>\n<li><p>最坏情况：查找的元素在表尾（或不存在）循环n次，时间复杂度为O(n)</p>\n</li>\n<li><p>平均情况：目标元素出现在任一位置的概率相同，都是1/n。目标在第1位，循环1次；…在第n位，循环n次。<br>$$<br>E_{find} = \\frac 1n \\sum^n_{i=1}i= \\frac{n+1}2<br>$$<br> ，平均时间复杂度为O(n)</p>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">LocateElem</span><span class=\"params\">(SeqList L,ElemType e)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;L.length;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(L.data[i]==e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i+<span class=\"number\">1</span>;\t\t<span class=\"comment\">//数组小标为i的元素值等于e,返回其位序i+1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\t\t\t<span class=\"comment\">//退出循环,说明查找失败</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-5.png\" style=\"zoom: 70%;\" />\n\n<blockquote>\n<p><strong>问题</strong>：此处，像int、float、char等类型，判断相等可以使用“= =”来判断。但若是结构类型的数据呢？还可以用“= =”吗？——不能。</p>\n<p>如果是结构类型的数据，判断其是否相等，你需要依次比较该结构体中的各个变量是否相等，最终判断两个结构类型变量是否相等。当然，你也可以将判断两个结构类型是否相等的代码封装成一个函数，以便复用。</p>\n<p>如果使用C++、JAVA，你也可以对“= =”进行运算符重载。</p>\n<p><strong>Tips</strong>：但是呢，如果你是在《数据结构》的考研初试的试卷当中，去手写代码的时候，你当然可以直接用“= =”来判断是否相等，不论是什么类型，而不需要考虑那么多，因为数据结构考的是一种思想、一种理解，而并不是具体的编程语言的实现。</p>\n<p>但是，如果考的是《C语言程序设计》，那么，也许你就要严格按照C语言的语法来写，即使是在试卷上手写代码。</p>\n</blockquote>\n<h3 id=\"习题\"><a href=\"#习题\" class=\"headerlink\" title=\"习题\"></a>习题</h3><ul>\n<li><p>11 顺序表的插入算法中，当 n 个空间已满时，可再申请增加分配 m 个空间，若申请失败，则说明系统没有（）可分配的存储空间 →n+m 个连续</p>\n<blockquote>\n<p>顺序存储需要连续的存储空间，在申请时需申请n+m个连续的存储空间，然后将线性表原来的n个元素复制到新申请的n+m个连续的存储空间的前n个单元。</p>\n</blockquote>\n</li>\n<li><p>综合题 10【2010】设将(n&gt;1)个整数存放到一堆数组R中。设计一个在时间和空间两方面都尽可能高效的算法。将R中保存的序列循环左移p（0&lt;p&lt;n）个位置，即将R中的数据由（X0, X1,…, Xn-1）变换为（Xp, Xp+1,…, Xn-1, X0, X1,…, Xp-1）。要求：</p>\n<p>1）给出算法的基本设计思想。</p>\n<p>2）根据设计思想，采用C、C++或Java语言描述算法，关键之处给出注释。</p>\n<p>3）说明你所设计算法的时间复杂度和空间复杂度。</p>\n<blockquote>\n<p>1）算法的基本设计思想： </p>\n<p>可以将这个问题看作是把数组ab转换成数组ba（a代表数组的前p个元素，b代表数组中余下的n-p个元素）:先将a逆置得到a^-1^b，再将b逆置得到a^-1^b^-1^，最后将整个a^-1^b^-1^逆置得到（a^-1^b^-1^）^-1^=ba。设Reverse函数执行将数组元素逆置的操作，对abcdefgh向左循环移动3（p=3）个位置的过程如下： </p>\n<p>Reverse(0,p-1)得到cbadefgh；  </p>\n<p>Reverse(p,n-1)得到cbahgfed；  </p>\n<p>Reverse(0,n-1)得到defghabc。</p>\n<p>注：Reverse中，两个参数分别表示数组中待转换元素的始末位置。</p>\n<p>2）使用C语言描述算法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Reverse</span><span class=\"params\">(<span class=\"type\">int</span> R[],<span class=\"type\">int</span> from,<span class=\"type\">int</span> to)</span> &#123;</span><br><span class=\"line\"><span class=\"type\">int</span> i,temp;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;(to-from+<span class=\"number\">1</span>)/<span class=\"number\">2</span>;i++)</span><br><span class=\"line\">&#123;    temp=R[from+i];</span><br><span class=\"line\">   R[from+i]=R[to-i];</span><br><span class=\"line\">   R[to-i]=temp;&#125;</span><br><span class=\"line\">&#125;<span class=\"comment\">//Reverse</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Converse</span><span class=\"params\">(<span class=\"type\">int</span> R[],<span class=\"type\">int</span> n,<span class=\"type\">int</span> p)</span>&#123;</span><br><span class=\"line\">Reverse(R,<span class=\"number\">0</span>,p<span class=\"number\">-1</span>);</span><br><span class=\"line\">Reverse(R,p,n<span class=\"number\">-1</span>);</span><br><span class=\"line\">Reverse(R,<span class=\"number\">0</span>,n<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3）上述算法中3个Reverse函数的时间复杂度分别为O(p/2)、O((n-p)/2)和O(n/2)，故所设计的算法的时间复杂度为O(n)，空间复杂度为O(1)。</p>\n<p><strong>另解</strong>，借助辅助数组来实现。  </p>\n<p>算法思想：创建大小为p的辅助数组S，将R中前p个整数依次暂存在S中，同时将R中后n-p个整数左移，然后将S中暂存的p个数依次放回到R中的后续单元。  </p>\n<p>时间复杂度为O(n)，空间复杂度为O(p)。</p>\n</blockquote>\n</li>\n<li><p>综合题 11【2011】一个长度为L(L&gt;=1)的升序序列S，处在第[L/2]个位置的数称为S的中位数。例如，若序列S1=(11，13，15，17，19)，则S1的中位数是15，两个序列的中位数是含它们所有元素的升序序列的中位数。例如，若S2=（2，4，6，8，20），则S1和S2的中位数是11。现在有两个等长升序序列A和B，试设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列A和B的中位数。要求：</p>\n<p>（1）给出算法的基本设计思想。</p>\n<p>（2）根据设计思想，采用C、C++或Java语言描述算法，关键之处给出注释。</p>\n<p>（3）说明你所设计算法的时间复杂度和空间复杂度。</p>\n<blockquote>\n<p>1）求两个序列A和B的中位数最简单的办法就是将两个升序序列进行归并排序，然后求其中位数。这种解法虽可求解，但在时间和空间两方面都不大符合高效的要求，但也能获得部分分值。 </p>\n<p>根据题目分析，分别求两个升序序列A和B的中位数，设为a和b。 </p>\n<p>① 若a=b，则a或b即为所求的中位数。 </p>\n<p>原因：容易验证，如果将两个序列归并排序，则最终序列中，排在子序列ab前边的元素为先前两个序列中排在a和b前边的元素；排在子序列ab后边的元素为先前两个序列中排在a和b后边的元素。所以子序列ab一定位于最终序列的中间，又因为a=b，显然a就是中位数。 </p>\n<p>② 否则（假设a&lt;b），中位数只能出现（a，b）范围内。 </p>\n<p>原因：同样可以用归并排序后的序列来验证，归并排序后必然有形如…a…b…的序列出现，中位数必出现在（a，b）之间。因此可以做如下处理：舍弃a所在序列A的较小一半，同时舍弃b所在序列B的较大一半。在保留两个升序序列中求出新的中位数a和b，重复上述过程，直到两个序列中只含一个元素时为止，则较小者即为所求的中位数。每次总的元素个数变为原来的一半。 </p>\n<p>算法的基本设计思想如下: </p>\n<p>分别求出序列A和B的中位数，设为a和b，求序列A和B的中位数过程如下: </p>\n<p>① 若a=b，则a或b即为所求中位数，算法结束。 </p>\n<p>② 若a&lt;b，则舍弃序列A中较小的一半，同时舍弃序列B中较大的一半，要求舍弃的长度相等。 </p>\n<p>③ 若a&gt;b，则舍弃序列A中较大的一半，同时舍弃序列B中较小的一半，要求舍弃的长度相等。 </p>\n<p>在保留的两个升序序列中，重复过程①、②、③，直到两个序列中只含一个元素时为止，较小者即为所求的中位数。 </p>\n<p>2）算法的实现如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">M_Search</span><span class=\"params\">(<span class=\"type\">int</span> A[],<span class=\"type\">int</span> B[],<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\"> <span class=\"type\">int</span> s1=<span class=\"number\">0</span>,d1=n<span class=\"number\">-1</span>,m1,s2=<span class=\"number\">0</span>,d2=n<span class=\"number\">-1</span>,m2;</span><br><span class=\"line\"> <span class=\"comment\">//分别表示序列A和B的首位数、末位数和中位数</span></span><br><span class=\"line\"> <span class=\"keyword\">while</span>(s1!=d1||s2!=d2)&#123;</span><br><span class=\"line\">     m1=(s1+d1)/<span class=\"number\">2</span>;</span><br><span class=\"line\">     m2=(s2+d2)/<span class=\"number\">2</span>;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(A[m1]==B[m2])</span><br><span class=\"line\">         <span class=\"keyword\">return</span> A[m1];           <span class=\"comment\">//满足条件①</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span>(A[m1]&lt;B[m2])&#123;            <span class=\"comment\">//满足条件②</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span>((s1+d1)%<span class=\"number\">2</span>==<span class=\"number\">0</span>)&#123;     <span class=\"comment\">//若元素个数为奇数</span></span><br><span class=\"line\">             s1=m1;              <span class=\"comment\">//舍弃A中间点以前的部分，且保留中间点</span></span><br><span class=\"line\">             d2=m2;              <span class=\"comment\">//舍弃B中间点以后的部分，且保留中间点</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">else</span>&#123;                  <span class=\"comment\">//元素个数为偶数</span></span><br><span class=\"line\">             s1=m1+<span class=\"number\">1</span>;              <span class=\"comment\">//舍弃A中间点及中间点以前部分</span></span><br><span class=\"line\">             d2=m2;                <span class=\"comment\">//舍弃B中间点以后部分且保留中间点</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">else</span>&#123;                        <span class=\"comment\">//满足条件③</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span>((s2+d2)%<span class=\"number\">2</span>==<span class=\"number\">0</span>) &#123;     <span class=\"comment\">//若元素个数为奇数</span></span><br><span class=\"line\">\t\t        d1=m1;              <span class=\"comment\">//舍弃A中间点以后的部分，且保留中间点</span></span><br><span class=\"line\">\t\t        s2=m2;              <span class=\"comment\">//舍弃B中间点以前的部分，且保留中间点</span></span><br><span class=\"line\">\t\t    &#125;\t</span><br><span class=\"line\">\t\t    <span class=\"keyword\">else</span>&#123;                  <span class=\"comment\">//元素个数为偶数\t</span></span><br><span class=\"line\">\t\t        d1=m1;              <span class=\"comment\">//舍弃A中间点以后部分，且保留中间点\t</span></span><br><span class=\"line\">\t\t        s2=m2+<span class=\"number\">1</span>;                <span class=\"comment\">//舍弃B中间点及中间点以前部分</span></span><br><span class=\"line\">\t\t    &#125;\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> A[s1]&lt;B[s2]? A[s1]:B[s2];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3）算法的时间复杂度为O(log₂n)，空间复杂度为O(1)。  </p>\n<p>【另解】对两个长度为n的升序序列A和B的元素按由小到大的顺序依次访问，这里访问的含义只是比较序列中两个元素的大小，并不实现两个序列的合并，因此空间复杂度为O(1)。按照上述规则访问到第n个元素时，这个元素即为两个序列A和B的中位数。</p>\n</blockquote>\n</li>\n<li><p>综合题 12【2013】已知一个整数序列A=(a0,a1,…,an-1)，其中0&lt;=ai&lt;=0(0&lt;=o&lt;=n)。若存在ap1=ap2=…=apm=x 且 m&gt;n/2(0&lt;=pk&lt;n,1&lt;=k&lt;=m),则称x为A的主元素。例如A=（0,5,5,3,5,7,5,5），则5为主元素；又如A =(0,5,5,3,5,1,5,7)，则A中没有主元素。假设A中的几个元素保存在一个一维数组中，请设计一个尽可能高效的算法，找出A的主元素。若存在主元素，则输出该元素；否则输出-1。要求：</p>\n<p>(1) 给出算法的基本设计思想</p>\n<p>(2) 根据设计思想，釆用C或C++或Java语言描述算法，关键之处给出注释。</p>\n<p>(3) 说明你所设计算法的时间复杂度和空间复杂度。</p>\n<blockquote>\n<p>(1)将第一个出现的元素num保存到c中，用count记录num出现的次数，初始时令count = 1。如果下一个遇到的元素仍然是num则将count加1，否则将count减1。如果此时count == 0，则将下一个元素保存到c中，并重置count为0。重复上述过程，直至扫描完全部元素。<br>判断此时的c是否为真正的主元素。统计c出现的次数，并保存到count中，如果count &gt; n / 2，则是主元素，否则不是。<br><strong>通俗来讲：就是不断消除两个不同的元素，最后剩的元素就是可能的主元素，然后再判断该可能的主元素个数是否大于n/2，若大于，则主元素就是该元素</strong>。</p>\n<p>(2)算法实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Majority</span><span class=\"params\">(<span class=\"type\">int</span> A[], <span class=\"type\">int</span> n)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i, c, count = <span class=\"number\">1</span>;<span class=\"comment\">//c用来保存候选主元素，count用来计数</span></span><br><span class=\"line\">\tc = A[<span class=\"number\">0</span>];           <span class=\"comment\">//设置A[0]为候选主元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; n; i++)<span class=\"comment\">//查找候选主元素</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (A[i] == c)</span><br><span class=\"line\">\t\t\tcount++;    <span class=\"comment\">//对A中的候选主元素计数</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (count &gt; <span class=\"number\">0</span>)<span class=\"comment\">//处理不是候选主元素时的情况</span></span><br><span class=\"line\">\t\t\t\tcount--;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;         <span class=\"comment\">//更换候选主元素，重新计数</span></span><br><span class=\"line\">\t\t\t\tc = A[i];</span><br><span class=\"line\">\t\t\t\tcount = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (count &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\tcount = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; n; i++)<span class=\"comment\">//统计候选主元素的实际出现情况</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (A[i] == c)</span><br><span class=\"line\">\t\t\t\tcount++;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (count &gt; n / <span class=\"number\">2</span>)\t<span class=\"keyword\">return</span> c;<span class=\"comment\">//确定候选主元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;<span class=\"comment\">//不存在主元素</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>(3)实现的程序时间复杂度为O(n)，空间复杂度为O(1)。</p>\n</blockquote>\n</li>\n<li><p>综合题 13【2018】给定一个含n(n&gt;=1)个整数的数组，请设计一个在时间上尽可能高效的算法，找出数组中未出现的最小正整数。例如，数组{-5，3，2，3}中未出现的最小正整数是1；数组{1, 2, 3}中未出现的最小正整数是4。要求：</p>\n<p>（1）给出算法的基本设计思想。 </p>\n<p>（2）根据设计思想，采用 C 或 C++语言描述算法，关键之处给出注释。 </p>\n<p>（3）说明你所设计算法的时间复杂度和空间复杂度。</p>\n<blockquote>\n<p>1)题目要求算法时间上尽可能高效，因此采用空间换时间的办法。分配一个用于标记的 数组 B[n]，用来记录 A 中是否出现了 1～n 中的正整数，B[0]对应正整数 1，B[n-1]对应正整数 n，初始化 B 中全部为 0。由于 A 中含有 n 个整数，因此可能返回的值是 1～n+1，当 A 中 n 个数恰好为 1～n 时返回 n+1。当数组 A 中出现了小于等于 0 或大于 n 的值时，会导致 1～n 中出现空余位置，返回结果必然在 1～n 中，因此对于 A 中出现了小于等于 0 或大于 n 的值可 以不采取任何操作。 </p>\n<p>经过以上分析可以得出算法流程：从 A[0]开始遍历 A，若 0&lt;A[i]&lt;=n，则令 B[A[i]-1] = 1； 否则不进行操作。对 A 遍历结束后，开始遍历数组 B，若能查找到第一个满足B[i]==0 的下标 i，返回 i+1 即为结果，此时说明 A 中未出现的最小正整数在 1～n 之间。若 B[i]全部不为 0， 返回 i+1（跳出循环时 i = n，i+1 等于 n+1），此时说明 A 中未出现的最小正整数是 n+1。</p>\n<p>2)算法实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">findMissMin</span><span class=\"params\">(<span class=\"type\">int</span> A[], <span class=\"type\">int</span> n)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"type\">int</span> i, *B;                          <span class=\"comment\">//标记数组</span></span><br><span class=\"line\"> B = (<span class=\"type\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>) * n); <span class=\"comment\">//分配空间</span></span><br><span class=\"line\"> <span class=\"built_in\">memset</span>(B, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>) * n);      <span class=\"comment\">//赋初值为 0</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (A[i] &gt; <span class=\"number\">0</span> &amp;&amp; A[i] &lt;= n) <span class=\"comment\">//若 A[i]的值介于 1～n，则标记数组 B</span></span><br><span class=\"line\">         B[A[i] - <span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\"> <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; n; i++) <span class=\"comment\">//扫描数组 B，找到目标值</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (B[i] == <span class=\"number\">0</span>)</span><br><span class=\"line\">         <span class=\"keyword\">break</span>;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> i + <span class=\"number\">1</span>; <span class=\"comment\">//返回结果</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3)时间复杂度：遍历 A 一次，遍历 B 一次，两次循环内操作步骤为 O(1)量级，因此时间 复杂度为 O(n)。空间复杂度：额外分配了 B[n]，空间复杂度为 O(n)。</p>\n<p><a href=\"https://www.codenong.com/cs105598468/\">https://www.codenong.com/cs105598468/</a></p>\n<p><a href=\"https://icode.best/i/29345031505648\">https://icode.best/i/29345031505648</a></p>\n</blockquote>\n</li>\n<li><p>综合题 14【2020】定义三元组(a,b,c)(a、b、c均为正数)的距离D=|a-b|+|b-c|+|c-a|。给定3个非空整数集合S1、S2和S3，按升序分别存储在3个数组中。请设计一个尽可能高效的算法，计算并输出所有可能的三元组(a,b,c)(a∈S1,b∈S2,c∈S3)中的最小距离。例如S1={-1,0,9}，S2={-25,-10,10,11}，S3={2,9,17,30,41},则最小距离为2，相应的三元组为(9,10,9)。</p>\n<p>（1）给出算法的基本设计思想。 </p>\n<p>（2）根据设计思想，采用 C 或 C++语言描述算法，关键之处给出注释。 </p>\n<p>（3）说明你所设计算法的时间复杂度和空间复杂度。</p>\n<blockquote>\n<p>(1)</p>\n<p>①使用Dmin记录所有已处理的三元组的最小距离，初值为一个足够大的整数。</p>\n<p>②集合S1、S2和S3分别保存在数组A、B、C中。数组的下标变量i=j=k=0,当i&lt; |S1|、j&lt; |S2|且k&lt; |S3|时（|S|表示集合中的元素个数），循环执行下面的“a)~c)”。</p>\n<p>a)计算（A[i]，B[j]，C[k]）的距离D；（计算D）</p>\n<p>b)若D&lt;Dmin，则Dmin=D；（更新D）</p>\n<p>c)将A[i]、B[j]、C[k]中的最小值的下标+1；</p>\n<p>③输出Dmin，结束</p>\n<p>(2)算法实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> INT_MAX 0x7fffffff</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">abs_</span><span class=\"params\">(<span class=\"type\">int</span> a)</span>&#123;<span class=\"comment\">//计算绝对值</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(a&lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span> -a;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">xls_min</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b,<span class=\"type\">int</span> c)</span>&#123;<span class=\"comment\">//a是否是三个数中的最小值</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(a&lt;=b&amp;&amp;a&lt;=c) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">findMinofTrip</span><span class=\"params\">(<span class=\"type\">int</span> A[],<span class=\"type\">int</span> n,<span class=\"type\">int</span> B[],<span class=\"type\">int</span> m,<span class=\"type\">int</span> C[],<span class=\"type\">int</span> p)</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//D_min用于记录三元组的最小距离，处置赋为INT_MAX</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> i=<span class=\"number\">0</span>,j=<span class=\"number\">0</span>,k=<span class=\"number\">0</span>,D_min=INT_MAX,D;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(i&lt;n&amp;&amp;j&lt;m&amp;&amp;k&lt;p&amp;&amp;D_min&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\tD=abs_(A[i]-B[j])+abs_(B[j]-C[k])+abs_(C[k]-A[i]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(D&lt;D_min) D_min=D;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(xls_min(A[i],B[j],C[k])) i++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(xls_min(B[j],C[k],A[i])) j++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> k++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> D_min;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>(3)设n=(|S1|+|S2|+|S3|),时间复杂度为O(n)，空间复杂度为O(1)</p>\n</blockquote>\n</li>\n</ul>\n","categories":["408数据结构"],"tags":["408数据结构"]},{"title":"第一章 绪论","url":"/p/24523/","content":"<h2 id=\"1-1-数据结构的基本概念\"><a href=\"#1-1-数据结构的基本概念\" class=\"headerlink\" title=\"1.1 数据结构的基本概念\"></a>1.1 数据结构的基本概念</h2><p><strong>解决问题方法的效率</strong></p>\n<ul>\n<li>跟数据的<strong>组织方式</strong>有关</li>\n<li>跟<strong>空间的利用率</strong>有关</li>\n<li>跟<strong>算法的巧妙</strong>程度有关</li>\n</ul>\n<p>什么是<font color='orange'>数据结构</font>？简单来说，数据结构就是一种<em>关系</em>。</p>\n<blockquote>\n<p>Algorithm + Data Structures = Programs</p>\n</blockquote>\n<ul>\n<li><strong>数据对象</strong>在计算机中的组织方式<ul>\n<li>逻辑结构<ul>\n<li>线性、树、图…</li>\n</ul>\n</li>\n<li>物理存储结构<ul>\n<li>顺序存储、链式存储</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>数据对象必定与一系列加在其上的<strong>操作</strong>相关联</li>\n<li>完成这些操作所用的方法就是<strong>算法</strong></li>\n</ul>\n<h3 id=\"基本概念和术语\"><a href=\"#基本概念和术语\" class=\"headerlink\" title=\"基本概念和术语\"></a>基本概念和术语</h3><ul>\n<li><p><strong>数据 Data</strong>:数据是<font color='orange'>信息的载体</font>，是描述客观事物属性的数、字符及所有能输入到计算机中并<font color='orange'>被计算机程序识别和处理</font>的符合的集合。数据是计算机程序加工的原料。</p>\n</li>\n<li><p><strong>数据元素 Data Element</strong>:数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。</p>\n</li>\n<li><p><strong>数据项 Data Item</strong>:一个数据元素可由若干<font color='orange'>数据项</font>组成，数据项是构成数据元素的不可分割的最小单位。</p>\n</li>\n<li><p><strong>数据对象 Data Object</strong>:数据对象是具有<font color='red'>相同性质</font>的数据元素的集合，是数据的一个子集。</p>\n</li>\n<li><p><strong>数据类型 Data Type</strong>:数据类型是一个值的集合和定义在此集合的一组操作的总称。</p>\n<ul>\n<li><p><strong>原子类型</strong>。其值不可再分的数据类型。</p>\n</li>\n<li><p><strong>结构类型</strong>。其值可用再分解为若干成分的数据类型</p>\n</li>\n<li><p><font color='red'>抽象数据类型</font>。抽象数据组织及与之相关的操作。</p>\n<p>描述数据类型的方法不依赖于具体实现</p>\n<ul>\n<li>与存放数据的机器无关</li>\n<li>与数据存储的物理结构无关</li>\n<li>与实现操作的算法和编程语言均无关</li>\n</ul>\n<p>只描述数据对象集和相关操作集 <strong>是什么</strong>，并不涉及 <strong>如何做到</strong> 的问题</p>\n<p>例:<strong>矩阵</strong> 的抽象数据类型的定义</p>\n<ul>\n<li><p><strong>类型名称</strong>:矩阵（ Matrix ）</p>\n</li>\n<li><p><strong>数据对象集</strong>:一个 M×N的矩阵 </p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds1-1.png\" style=\"zoom:80%;\" />\n\n<p>由 M×N 个三元组 &lt;a,i,j&gt; 构成，其中 a 是矩阵元素的值，i 是元素所在的行号，j 是元素所在的列号。</p>\n</li>\n<li><p><strong>操作集</strong>:对于任意矩阵A、B、C ∈ Matrix，以及整数i、j、M、N</p>\n<ul>\n<li><code>Matrix Create(int M, int N)</code>：返回一个 M×N 的矩阵；</li>\n<li><code>int GetMaxRow(Matrix A)</code>：返回矩阵 A 的总行数；</li>\n<li><code>int GetMaxCol(Matrix A)</code>：返回矩阵 A 的总列数；</li>\n<li><code>ElementType GetEntry(Matrix A, int i, int j)</code>：返回矩阵 A 的第 i 行、第 j 列元素；</li>\n<li><code>Matrix Add(Matrix A, Matrix B)</code>：如果 A 和 B 的行、列数一致，则返回矩阵 C=A+B ，否则返回错误标志；</li>\n<li><code>Matrix Multiply(Matrix A, Matrix B)</code>：如果 A 的列数等于 B 的行数，则返回矩阵 C = AB ，否则返回错误标志；</li>\n<li>……</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>数据结构 Data Structure</strong> :数据结构是相互之间存在一种或多种<font color='red'>特定关系</font>的数据元素的集合。</p>\n</li>\n</ul>\n<h3 id=\"数据结构三要素\"><a href=\"#数据结构三要素\" class=\"headerlink\" title=\"数据结构三要素\"></a>数据结构三要素</h3><ul>\n<li><p>数据的<strong>逻辑结构</strong><br><strong>集合</strong>:结构中的数据元素之间除”同属一个集合”外，别无其他关系</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds1-2.png\" style=\"zoom:67%;\" />\n\n<ul>\n<li><p><strong>线性结构</strong>:数据元素只存在一对一的关系。除了第一个元素，所有元素都有唯一前驱；</p>\n<p>除了最后一个元素，所有元素都有唯一后继。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds1-3.png\" style=\"zoom:67%;\" />\n</li>\n<li><p><strong>树形结构</strong>:数据元素之间存在一对多的关系。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds1-4.png\" style=\"zoom:67%;\" />\n</li>\n<li><p><strong>图状/网状结构</strong> :数据元素之间是多对多的关系</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds1-5.png\" style=\"zoom:67%;\" />\n</li>\n</ul>\n</li>\n<li><p>数据的<strong>存储结构</strong></p>\n<p>存储结构是指数据结构在计算机中的表示(又称映像)，也称<strong>物理结构</strong>。</p>\n<ul>\n<li><p><strong>顺序存储</strong>:把<font color='red'>逻辑上相邻的元素存储在物理位置上也相邻的存储单元中</font>，元素之间的关系由存储单元的邻接关系来体现。</p>\n<ul>\n<li>连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示。</li>\n<li>优点:可以实现随机存取，每个元素占用最少的存储空间</li>\n</ul>\n</li>\n<li><p>缺点:只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片</p>\n</li>\n<li><p><strong>链式存储</strong>:<font color='red'>逻辑上相邻的元素在物理位置上可以不相邻</font>，借助指示元素存储地址的指针来表示元素之间的逻辑关系。</p>\n<ul>\n<li>用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示。</li>\n<li>优点:不会出现碎片现象，能充分利用所有存储单元</li>\n<li>缺点:每个元素因存储指针而占用额外的存储空间。且只能实现顺序存取</li>\n</ul>\n</li>\n<li><p><strong>索引存储</strong>:在存储元素信息的同时，还建立附加的索引表。索引表的每项称为<strong>索引项</strong>，索引项的一般形式是(关键字，地址)</p>\n<ul>\n<li>优点:检索速度快</li>\n<li>缺点:附加的索引表额外占用存储空间。另外，增加和删除数据时也要修改索引表，因而会花费较多的时间。</li>\n</ul>\n</li>\n<li><p><strong>散列存储 / 哈希存储</strong>:根据元素的关键字之间直接计算出该元素的存储地址。</p>\n<ul>\n<li>优点:检索、增加和删除结点的操作都很快；</li>\n<li>缺点:若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds1-6.png\" style=\"zoom:67%;\" />\n</li>\n<li><p>数据的<strong>运算</strong>:施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。</p>\n</li>\n</ul>\n<h3 id=\"习题\"><a href=\"#习题\" class=\"headerlink\" title=\"习题\"></a>习题</h3><p>“Algorithm + Data Structures = Programs.” 是什么意思？谁说的？😉</p>\n<p>“算法 + 数据结构 = 程序” by 尼古拉斯·沃斯</p>\n<h2 id=\"1-2-算法和算法平均\"><a href=\"#1-2-算法和算法平均\" class=\"headerlink\" title=\"1.2 算法和算法平均\"></a>1.2 算法和算法平均</h2><h3 id=\"算法的基本概念\"><a href=\"#算法的基本概念\" class=\"headerlink\" title=\"算法的基本概念\"></a>算法的基本概念</h3><ul>\n<li><p>什么是算法?</p>\n<ul>\n<li>一个有限指令集</li>\n<li>接受一些输入（有些情况下不需要输入）</li>\n<li>产生输出</li>\n<li>一定在有限步骤之后终止</li>\n<li>每一条指令必须<ul>\n<li>有充分明确的目标，不可以有歧义</li>\n<li>计算机能处理的范围之内</li>\n<li>描述应不依赖于任何一种计算机语言以及具体的实现手段</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>重要特性</p>\n<ul>\n<li><p>有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在又穷时间内完成。</p>\n<p>注:<strong>算法</strong>必须是有穷的，而<strong>程序</strong>可用是无穷的</p>\n</li>\n<li><p>确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。</p>\n</li>\n<li><p>可行性：算法中描述的操作都可以通过已经实现的<strong>基本运算执行有限次</strong>来实现</p>\n</li>\n<li><p>输入：一个算法有零个或多个输入，这些输入取自某个特定的对象的集合。</p>\n</li>\n<li><p>输出：一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"“好”算法的特征\"><a href=\"#“好”算法的特征\" class=\"headerlink\" title=\"“好”算法的特征\"></a>“好”算法的特征</h3><p>设计算法时要<font color='red'>尽量追求</font>的目标</p>\n<ul>\n<li>正确性 Correctness。正确地解决求解问题。</li>\n<li>可读性 Readability。具有良好可读性，帮助人们理解。</li>\n<li>健壮性 Robustness。输入非法数据时，适当做出反应或处理，不会产生莫名其妙的输出</li>\n<li>效率与低存储量需求 Efficiency。时间复杂度低、空间复杂度低</li>\n</ul>\n<h3 id=\"算法效率的度量-🤩\"><a href=\"#算法效率的度量-🤩\" class=\"headerlink\" title=\"算法效率的度量 🤩\"></a>算法效率的度量 🤩</h3><h4 id=\"一文讲透复杂度的计算方式\"><a href=\"#一文讲透复杂度的计算方式\" class=\"headerlink\" title=\"一文讲透复杂度的计算方式\"></a><a href=\"https://www.cnblogs.com/lonely-wolf/p/15674526.html\">一文讲透复杂度的计算方式</a></h4><h4 id=\"时间复杂度-Time-Complex\"><a href=\"#时间复杂度-Time-Complex\" class=\"headerlink\" title=\"时间复杂度 Time Complex\"></a>时间复杂度 <a href=\"https://en.wikipedia.org/wiki/Time_complexity\">Time Complex</a></h4><ul>\n<li><p>定义：<br>$$<br>T(n) = O(f(n))<br>$$<br> 算法的基本操作执行次数还随问题的 输入数据集的不同而不同 </p>\n</li>\n<li><p>最坏时间复杂度 =Tworst(n)</p>\n</li>\n<li><p>平均时间复杂度Tavg(n)</p>\n</li>\n<li><p><strong>关系</strong>:Tavg(n)&lt;=Tworst(n)</p>\n</li>\n<li><p>最好时间复杂度 </p>\n</li>\n<li><p><strong>加法规则</strong>:<strong>多项相加，只保留最高阶的项，且系数变为1</strong></p>\n</li>\n</ul>\n<p>$$<br>T(n) = T_1(n)+T_2(n) = O(f(n))+O(g(n)) = O(\\max(f(n),g(n)))<br>$$</p>\n<ul>\n<li>乘法规则</li>\n</ul>\n<p>$$<br>T(n) = T_1(n)\\times T_2(n)=O(f(n))\\times O(g(n)) = O(f(n)\\times g(n))<br>$$</p>\n<ul>\n<li><p>只需挑循环中的一个基本操作分析它的执行次数与n的关系即可，如果有多层嵌套循环，只需关注最深层的循环循环了几次</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds1-7.png\" style=\"zoom:67%;\" />\n\n<table>\n<thead>\n<tr>\n<th>表达式</th>\n<th align=\"center\">时间复杂度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>T1(n) = 3n+3</td>\n<td align=\"center\">T1(n) = O(n)</td>\n</tr>\n<tr>\n<td>T2(n) = n² + 3n + 1000</td>\n<td align=\"center\">T2(n) = O(n²)</td>\n</tr>\n<tr>\n<td>T3(n) = n3 + n2 + 99999</td>\n<td align=\"center\">T3(n) = O(n3)</td>\n</tr>\n<tr>\n<td>T4(n) = n3 + n2log2n</td>\n<td align=\"center\">T4(n) = O( n3 )</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>常见的渐进时间复杂度为:<strong>常对幂指阶</strong><br>$$<br>O(1) &lt; O(\\log_2n)&lt;O(n)&lt;O(n \\log_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(n^k)&lt;O(n!)&lt;O(n^n)<br>$$</p>\n</li>\n<li><p><strong>来一道练习题</strong></p>\n<p>计算下述算法的时间复杂度T(n)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">loveYou</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&lt;=n)&#123;</span><br><span class=\"line\">        i=i*<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;I Love U %d\\n&quot;</span>,i);</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th></th>\n<th>第一次循环</th>\n<th>第二次循环</th>\n<th>第三次循环</th>\n<th>…</th>\n<th>第x次循环</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>i = 1</td>\n<td>i = 2</td>\n<td>i = 4</td>\n<td>i = 8</td>\n<td>…</td>\n<td>i = 2x</td>\n</tr>\n</tbody></table>\n<p>设最深层总共循环的次数为x，则循环了x次之后，i = 2^x，循环结束的条件为 i &gt; n，即<br>$$<br>2^x &gt; n ，x = log_2n + 1<br>$$</p>\n<p>$$<br>T(n) = O(x) = O(log_2n) + O(1) = O(log_2n)<br>$$</p>\n</li>\n</ul>\n<h4 id=\"空间复杂度-Space-Complexity\"><a href=\"#空间复杂度-Space-Complexity\" class=\"headerlink\" title=\"空间复杂度 Space Complexity\"></a>空间复杂度 <a href=\"https://en.wikipedia.org/wiki/Space_complexity\">Space Complexity</a></h4><ul>\n<li>定义:空间复杂度：空间开销与问题规模n之间的关系</li>\n</ul>\n<p>$$<br>S(n) = O(g(n))<br>$$</p>\n<ul>\n<li>算法原地工作是指算法所需的辅助空间为常量，即<code>O(1)</code></li>\n</ul>\n<p>示例：如何实现数组逆序？<br>方案一：空间复杂度为 1 的情况，即S(n) = O(1)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n / <span class=\"number\">2</span>；i++) <span class=\"comment\">// 遍历半个数组</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tt = a[i];              <span class=\"comment\">// 临时变量t</span></span><br><span class=\"line\">\ta[i] = a[n-i<span class=\"number\">-1</span>];       <span class=\"comment\">// 交换数值</span></span><br><span class=\"line\">\ta[n-i<span class=\"number\">-1</span>] = t;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方案二：空间复杂度为 n 的情况，即S(n) = O(n)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n； i++)  <span class=\"comment\">// 辅助数组b逆序存储a</span></span><br><span class=\"line\">\tb[i] = a[n-i<span class=\"number\">-1</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n, i++)   <span class=\"comment\">// 重新赋值给a</span></span><br><span class=\"line\">\ta[i] = b[i];</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"习题-1\"><a href=\"#习题-1\" class=\"headerlink\" title=\"习题\"></a>习题</h3><p>【2011】设n是描述问题规模的非负整数。下面的程序片段的时间复杂度是()</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">x=<span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(x&lt;n/<span class=\"number\">2</span>)</span><br><span class=\"line\">x=<span class=\"number\">2</span>*x;</span><br></pre></td></tr></table></figure>\n\n<p>$$<br>答案:O(\\log_2n)<br>$$</p>\n<blockquote>\n<p>执行O（n）次，则2的O（n）次方大于等于n/2时结束，因为x为2，所以每执行一次，等于自己多做一次幂运算，复杂度为log₂n</p>\n</blockquote>\n<p>【2012】求整数n(n&gt;0)的阶乘的算法如下,其时间复杂度</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">fact</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(n&lt;=<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n*fact(n<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>$$<br>答案:O(n)<br>$$</p>\n<blockquote>\n<p>递推公式T(n)=1+T(n-1),求出T(n)=n</p>\n</blockquote>\n<p>【2013】已知两个长度分别为m和n的升序链表，若将它们合并为长度为m+n的一个降序链表，则最坏情况下的时间复杂度是<br>$$<br>O(max(m,n))<br>$$</p>\n<blockquote>\n<p>两个升序链表合并，两两比较表中元素，每比较一次，确定一个元素的链接位置(取较小元素，头插法)。当一个链表比较结束后，将另一个链表的剩余元素插入即可。最坏的情况是两个链表中的元素依次进行比较，因为2max(m,n)&gt;=m+n,所以时间复杂度为O(max(m,n))。</p>\n<p><a href=\"https://blog.csdn.net/weixin_43722052/article/details/116133058\">CSDN解析</a></p>\n</blockquote>\n<p>【2014】下列程序段的时间复杂度是</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">count=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(k=<span class=\"number\">1</span>;k&lt;=n;k*=<span class=\"number\">2</span>)</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">      count++;</span><br></pre></td></tr></table></figure>\n\n<p>$$<br>O(n\\log_2n)<br>$$</p>\n<blockquote>\n<p>内层循环条件j&lt;=n与外层循环的变量无关，每次循环j自增1，每次内层循环都执行n次。外层循环条件为k&lt;=n，增量定义为k*=2，可知循环次数为2^k&lt;=n，即k&lt;=log₂n。所以内层循环的时间复杂度是O(n)，外层循环的时间复杂度是O(log₂n)。对于嵌套循环，根据乘法规则可知，该段程序的时间复杂度T(n)=T1(n)xT2(n)=O(n)xO(log₂n)=O(nlog₂n)</p>\n</blockquote>\n<p>【2017】下列函数的时间复杂度是</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">func</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> i=<span class=\"number\">0</span>, sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(sum&lt;n) sum+= ++i;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>$$<br>O(n^\\frac{1}{2})<br>$$</p>\n<blockquote>\n<p>sum += ++i; 相当于++i; sum = sum + i;进行到第k趟循环，sum = (1 + k)*k/2。显然需要进行O(n½)趟循环，因此这也是该函数的时间复杂度。</p>\n</blockquote>\n<p> 「算法原地工作的含义是指不需要任何额外的辅助空间」→ 错误</p>\n<blockquote>\n<p>算法原地工作的含义是指辅助空间是常量</p>\n</blockquote>\n<p>【2019】设n是描述问题规模的非负整数。下列程序段的时间复杂度是</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">x=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (n&gt;(x+<span class=\"number\">1</span>)*(x+<span class=\"number\">1</span>))</span><br><span class=\"line\">x=x+<span class=\"number\">1</span>；</span><br></pre></td></tr></table></figure>\n\n<p>$$<br>O(n^\\frac{1}{2})<br>$$</p>\n<p><strong>综合题</strong> 一个算法所需时间由下述递归方程表示，试求出该算法的时间复杂度的级别（或阶）<br>$$<br>T(n) = \\begin{cases} 1, &amp; n=1 \\\\ 2T(n/2)+n, &amp; n&gt;1 \\end{cases}<br>$$</p>\n<p>式中，n 是问题的规模，为简单起见，设 n 是 2 的整数次幂 →<br>$$<br>O(n\\log_2n)<br>$$</p>\n<blockquote>\n<p>T(n)=2T(n/2)+n</p>\n<p>两边同时除以n，得到</p>\n<p>T(n)/n=T(n/2)/(n/2)+1    ①</p>\n<p>T(n/2)/(n/2)= T(n/4)/(n/4)+1 ②</p>\n<p>…………</p>\n<p>T(2)/2=T(1)/1+1 (log₂n)</p>\n<p>注：因为每次式子的变化都是除以2变化的，所以式子的个数是log<del>2</del>n</p>\n<p>将下面的式子都代入到式子①中可以得到</p>\n<p>T(n)/n=T(1)/1+1*log₂n</p>\n<p>T(n)=n(T(1)/1+1*log₂n)</p>\n<p>T(1)=1</p>\n<p>所以T(n)=n(1+log₂n)</p>\n<p>所以O(n)=nlog₂n</p>\n</blockquote>\n<p>思考：斐波那契数列，用递归算法和非递归算法的时间复杂度如何？😜</p>\n<ul>\n<li><p>递归算法<br>$$<br>O(2^n)<br>$$</p>\n</li>\n<li><p>非递归算法<br>$$<br>O(n)<br>$$</p>\n</li>\n</ul>\n","categories":["408数据结构"],"tags":["408数据结构"]},{"title":"第二章 线性表(下)","url":"/p/12625/","content":"<h2 id=\"2-3-线性表的链式表示\"><a href=\"#2-3-线性表的链式表示\" class=\"headerlink\" title=\"2.3 线性表的链式表示\"></a>2.3 线性表的链式表示</h2><p><strong>链表</strong>——用<strong>链式存储</strong>方式实现的<strong>线性表</strong>。</p>\n<p>链表主要有四种：单链表、双链表、循环链表、静态链表。</p>\n<ul>\n<li>优点：不要求大片连续空间，改变容量方便</li>\n<li>缺点：不可随机存取，要耗费一定空间存指针域</li>\n</ul>\n<h3 id=\"单链表的定义\"><a href=\"#单链表的定义\" class=\"headerlink\" title=\"单链表的定义\"></a>单链表的定义</h3><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-6.png\" style=\"zoom: 75%;\" />\n\n<ul>\n<li>线性表的链式存储又称<strong>单链表</strong>，它是指通过一组任意的存储单元来存储线性表中的数据元素。为了建立数据元素之间的线性关系，对每个链表结点，<font color='red'>除存放元素自身的信息外，还需要存放一个指向其后继的指针</font>。</li>\n</ul>\n<p><strong>单链表的代码实现</strong>:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span>&#123;</span>\t\t<span class=\"comment\">//单链表结点的结构类型 </span></span><br><span class=\"line\">\tElemType data;\t<span class=\"comment\">//数据域 </span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">next</span>;</span>\t<span class=\"comment\">//指针域 </span></span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">p</span> =</span> (<span class=\"keyword\">struct</span> LNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> LNode));\t<span class=\"comment\">//增加一个新的结点</span></span><br></pre></td></tr></table></figure>\n\n<p>此处，我们发现，每次定义一个新结点，都要将它定义为<code>struct LNode</code>的类型。</p>\n<p>于是我们直接将原结构类型<code>struct LNode</code>使用typedef重命名一下，以简化。</p>\n<h4 id=\"typedef的使用问题\"><a href=\"#typedef的使用问题\" class=\"headerlink\" title=\"typedef的使用问题\"></a>typedef的使用问题</h4><blockquote>\n<p>typedef &lt;数据类型&gt; &lt;别名&gt;</p>\n<p>例如：  typedef int zhengshu;  typedef int * zhengshuzhizhen;</p>\n<p>这样以后，原本的  int a = 1;   int * p;</p>\n<p>就可以写为  zhengshu a = 1;  zhengshuzhizhen p;</p>\n</blockquote>\n<p><strong>于是就有了如下的类型定义代码</strong></p>\n<p><strong>结点的类型定义</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span>&#123;</span>\t\t\t\t<span class=\"comment\">//定义单链表结点类型</span></span><br><span class=\"line\">    ElemType data;\t\t\t\t\t<span class=\"comment\">//定义单链表结点类型(数据域)</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> * <span class=\"title\">next</span>;</span>\t\t\t<span class=\"comment\">//每个节点存放一个数据元素(指针域)</span></span><br><span class=\"line\">&#125;LNode,*LinkList;\t\t\t\t\t<span class=\"comment\">//LinkList为指向结构体LNode的指针类型</span></span><br><span class=\"line\"><span class=\"comment\">//增加一个新的结点:在内存中申请一个结点所需空间,并用指针p指向这个结点</span></span><br><span class=\"line\">LNode *p =(LNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上述定义代码等价于</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span>&#123;</span></span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> <span class=\"title\">LNode</span>;</span>\t\t\t<span class=\"comment\">//struct LNode = LNode</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> * <span class=\"title\">LinkList</span>;</span>\t<span class=\"comment\">//struct LNode *= LinkList </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//增加一个新的结点:在内存中申请一个结点所需空间,并用指针p指向这个结点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">p</span> =</span>(<span class=\"keyword\">struct</span> LNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> LNode))</span><br></pre></td></tr></table></figure>\n\n<p>通常只需声明一个头指针L来表示一个单链表，指向单链表的第一个结点</p>\n<p><code>LNode *L;        //声明一个指向单链表的第一个结点的指针</code><br>这样一来，我就可以这样写我的代码:<br><code>LinkList L;   //声明一个指向单链表的第一个结点的指针</code></p>\n<p><font color='orange'>但是，也并不是说，写LNode 的地方，都要写作LinkList。因为，代码不论怎么写，始终是为了简洁性、可读性的。看下面这个例子：</font></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span>&#123;</span></span><br><span class=\"line\">\tElemType * data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> * <span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;LNode, *LinkList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//单链表查找某元素</span></span><br><span class=\"line\">LNode * <span class=\"title function_\">GetElem</span><span class=\"params\">(LinkList L, <span class=\"type\">int</span> i)</span>&#123;\t<span class=\"comment\">//函数返回值LNode *是想强调其返回结果是一个结点；</span></span><br><span class=\"line\">    \t\t\t\t\t\t\t\t<span class=\"comment\">//参数L类型LinkList是想强调这是一个单链表（头结点代表单链表）</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> j = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tLNode *p = L-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(i==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(i&lt;<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(p!=<span class=\"literal\">NULL</span> &amp;&amp; j&lt;i)&#123;</span><br><span class=\"line\">\t\tp = p-&gt;next;</span><br><span class=\"line\">\t\tj++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p;\t<span class=\"comment\">//最终返回一个结点，类型为LNode *</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：此段代码中，并没有将LNode *全部写为LinkList。可以注意到，在我使用LNode *的地方，我往往是想要强调这是一个结点(例如函数返回值LNode *，例如其中用来索引的指针p是LNode *)，而在使用LinkList的地方，我想要强调的是这是一个单链表（例如函数的参数L是LinkList，它虽然是一个头结点，但它根本上是代表着一个单链表）</p>\n</blockquote>\n<p><strong>总之，这种重命名的方法（typedef），以及对重命名之后的别名的使用（是有所强调的，而不是一概而论的），希望能够好好体会。</strong></p>\n<h4 id=\"不带头结点的单链表\"><a href=\"#不带头结点的单链表\" class=\"headerlink\" title=\"不带头结点的单链表\"></a>不带头结点的单链表</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span>\t\t<span class=\"comment\">//定义单链表结点的结构类型</span></span><br><span class=\"line\">\tElemType data;\t\t<span class=\"comment\">//数据域 </span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">next</span>;</span>\t<span class=\"comment\">//指针域 </span></span><br><span class=\"line\">&#125;LNode, *LinkList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化一个空的单链表（不带头结点）</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">InitList</span><span class=\"params\">(LinkList &amp;L)</span> &#123;</span><br><span class=\"line\">\tL = <span class=\"literal\">NULL</span>;\t<span class=\"comment\">//空表，暂时还没有任何结点\t//初始并设为空，防止脏数据</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\tLinkList L;\t<span class=\"comment\">//声明一个指向单链表的指针\t//（1）</span></span><br><span class=\"line\">\tInitList(L);\t<span class=\"comment\">//初始化一个空表</span></span><br><span class=\"line\">\t<span class=\"comment\">//...... </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong>（1）处并没有创建一个结点。</p>\n<p>要始终去体会，<strong>别名的使用是在含义上有所强调的</strong>，而不仅仅是理论上来说代码能否编译问题</p>\n<h4 id=\"带头结点的单链表\"><a href=\"#带头结点的单链表\" class=\"headerlink\" title=\"带头结点的单链表\"></a>带头结点的单链表</h4><p>单链表第一个结点之前附加一个结点，称为头结点。</p>\n<p><a href=\"https://blog.csdn.net/zhenyusoso/article/details/6092843\">https://blog.csdn.net/zhenyusoso/article/details/6092843</a></p>\n<p>引入头结点后，可用带来两个优点:</p>\n<ol>\n<li>由于第一个数据结点的位置被存放在头结点的指针域中，因此在链表的第一个位置上的操作和在表的其他位置上的操作一致，无须进行特殊处理。</li>\n<li>无论链表是否为空，其头指针都指向头结点的非空指针(空表中头结点的指针域为空)，因此空表和非空表的处理也就得到了统一。</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span>&#123;</span></span><br><span class=\"line\">\tElemType data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;LNode, *LinkList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化一个单链表（带头结点） </span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">InitList</span><span class=\"params\">(LinkList &amp;L)</span>&#123;</span><br><span class=\"line\">\tL = (LNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));\t<span class=\"comment\">//分配一个头结点</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(L == <span class=\"literal\">NULL</span>)  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t<span class=\"comment\">//内存不足，分配失败</span></span><br><span class=\"line\">\tL-&gt;next = <span class=\"literal\">NULL</span>;\t<span class=\"comment\">//头结点之后暂时还没有结点</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\tLinkList L;\t<span class=\"comment\">//声明一个指向头结点的指针</span></span><br><span class=\"line\">\tInitList(L);\t<span class=\"comment\">//初始化一个空表</span></span><br><span class=\"line\">\t<span class=\"comment\">//...... </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong>：此头结点的数据域是不存储数据元素的，只有指针域有意义。这是为了方便后续的链表操作。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//判断单链表是否为空（带头结点） </span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Empty</span><span class=\"params\">(LinkList L)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(L-&gt;next == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"不带-带头结点的区别\"><a href=\"#不带-带头结点的区别\" class=\"headerlink\" title=\"不带/带头结点的区别\"></a>不带/带头结点的区别</h4><ul>\n<li>不带头结点，写代码更麻烦。对第一个数据结点和后续数据结点的处理需要用不同的代码逻辑。对空表和非空表的处理需要用不同的代码逻辑。</li>\n<li>带头结点，写代码更方便。一般都是带头结点的。</li>\n<li>不带头结点，头指针L所指向的下一个结点，就是实际用于存放数据的结点。而带头结点，头指针所指向的结点，也就是头结点，是不存放实际的数据元素的，而头结点指向的下一个结点才会用于存放数据。</li>\n<li>不带头结点，空表判断：<code>L==NULL</code>；带头结点，空表判断：<code>L-&gt;next==NULL</code></li>\n</ul>\n<h3 id=\"单链表上基本操作的实现\"><a href=\"#单链表上基本操作的实现\" class=\"headerlink\" title=\"单链表上基本操作的实现\"></a>单链表上基本操作的实现</h3><h4 id=\"采用头插法建立单链表\"><a href=\"#采用头插法建立单链表\" class=\"headerlink\" title=\"采用头插法建立单链表\"></a>采用头插法建立单链表</h4><ul>\n<li>头插法建立单链表时，读入数据的顺序与生成的链表中的元素的顺序是相反的。每个结点插入的时间为O(1),设单链表长n,时间复杂度O(n)。</li>\n<li><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-9.png\"  />\n\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">LinkList <span class=\"title function_\">List_HeadInsert</span><span class=\"params\">(LinkList &amp;L)</span>&#123;<span class=\"comment\">//逆向建立单链表</span></span><br><span class=\"line\">    LNode *s; <span class=\"type\">int</span> x;</span><br><span class=\"line\">    L=(LinkList)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));<span class=\"comment\">//创建头结点；</span></span><br><span class=\"line\">    L-&gt;next=<span class=\"literal\">NULL</span>;                    <span class=\"comment\">//初始为空链表[*]</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;x);                   <span class=\"comment\">//输入结点的值</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x! = <span class=\"number\">9999</span>)&#123;                 <span class=\"comment\">//输入9999表示结束</span></span><br><span class=\"line\">        s=(LNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));<span class=\"comment\">//创建新结点</span></span><br><span class=\"line\">        s- &gt;data=x;</span><br><span class=\"line\">        s- &gt;next=L- &gt;next;</span><br><span class=\"line\">        L- &gt;next=s;                   <span class=\"comment\">//将新结点插入表中，L为头指针</span></span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"http://data.biancheng.net/view/93.html\">头插法创建单链表（带源码+解析）</a></p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-8.png\" style=\"zoom: 75%;\" />\n\n<blockquote>\n<p>注意:在代码[*]处，初始化空链表的时候，必须将L的next置为NULL。否则插入若干数据结点后，表尾的next会是一个脏数据，而不是NULL。而尾插法为什么不用，是因为尾插法在最后执行了尾结点指针域置空的操作。但总之，你只要是初始化单链表，都先把头指针指向NULL，这是一个好习惯。</p>\n</blockquote>\n<blockquote>\n<p><strong>重要应用：链表的逆置</strong>！！<a href=\"https://www.bilibili.com/video/BV1yU4y1U7L2?spm_id_from=333.337.search-card.all.click&vd_source=278af11bcc7fe34571197ce600d488f4\">B站-链表逆置的两种方法</a></p>\n<p>在使用头插法插入数据的时候，你依次插入a、b、c。那么在此单链表中，从头结点开始，依次为：c、b、a。于是这里引起了一个重要的应用，<strong>链表的逆置</strong>。</p>\n<p>也就是再建立一个新的链表，之后将原来的链表从头到尾依次头插法插入新链表中，新链表就是原链表的逆置。</p>\n<p>当然，你也可以不建立新链表，而是在原链表，直接依次对每个结点，向原链表的头结点后执行头插，最终得到的结果也是原链表的逆置。</p>\n</blockquote>\n<h4 id=\"采用尾插法建立单链表\"><a href=\"#采用尾插法建立单链表\" class=\"headerlink\" title=\"采用尾插法建立单链表\"></a>采用尾插法建立单链表</h4><ul>\n<li><p>时间复杂度O(n)</p>\n</li>\n<li><p><strong>头插法</strong>建立单链表的算法虽然简单，但生成的链表中结点的次序和输入数据的顺序<strong>不一致</strong>。若希望两者次序一致，可采用尾插法。该方法是将新结点插入到当前链表的表尾上，为此必须增加一个尾指针r,使其始终指向当前链表的尾结点，如图所示。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-10.png\"  />\n\n</li>\n</ul>\n<p><strong>初始化单链表后，向单链表末尾进行后插操作</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在第i个位置插入元素e（带头结点）</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">ListInsert</span><span class=\"params\">(LinkList &amp;L, <span class=\"type\">int</span> i, ElemType e)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(i&lt;<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\tLNode *p;\t<span class=\"comment\">//指针p指向当前扫描到的结点</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> j=<span class=\"number\">0</span>;\t<span class=\"comment\">//当前p指向的是第几个结点</span></span><br><span class=\"line\">\tp = L;\t<span class=\"comment\">//L指向头结点</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(p!=<span class=\"literal\">NULL</span> &amp;&amp; j&lt;i<span class=\"number\">-1</span>) &#123;\t<span class=\"comment\">//循环找到第i-1个结点 </span></span><br><span class=\"line\">\t\tp = p-&gt;next;</span><br><span class=\"line\">\t\tj++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(p == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t<span class=\"comment\">//i值不合法</span></span><br><span class=\"line\">\tLNode *s = (LNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));</span><br><span class=\"line\">\ts-&gt;data = e;</span><br><span class=\"line\">\ts-&gt;next = p-&gt;next;</span><br><span class=\"line\">\tp-&gt;next = s;\t<span class=\"comment\">//将结点s连到p之后 </span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>但是此时有一个问题。即每次向表尾插入一个元素，都要从表头开始循环，找到表尾结点。那么若要插入n个元素进去，则时间复杂度为O(n²)。</p>\n<p>但是实际上，我们每次向表尾插入新的元素，没有必要每次都从表头再全部遍历一次。我们可以设立一个表尾指针r，专门用于指向表尾。之后若要插入新元素，对表尾指针r做一个后插操作即可。</p>\n<p>如何对表尾指针r做后插操作，见指定结点的后插操作。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">LinkList <span class=\"title function_\">List_TailInsert</span><span class=\"params\">(LinkList &amp;L)</span>&#123;<span class=\"comment\">//正向建立单链表</span></span><br><span class=\"line\">    <span class=\"type\">int</span> x;                            <span class=\"comment\">//设元素类型为整型</span></span><br><span class=\"line\">    L=(LinkList)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));<span class=\"comment\">//创建头结点；</span></span><br><span class=\"line\">    LNode *s,*r=L;                    <span class=\"comment\">//r为表尾指针</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;x);                   <span class=\"comment\">//输入结点的值</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x! =<span class=\"number\">9999</span>)&#123;                   <span class=\"comment\">//输入9999表示结束</span></span><br><span class=\"line\">        s=(LNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));</span><br><span class=\"line\">        s- &gt;data=x;</span><br><span class=\"line\">        r- &gt;next=s;                  <span class=\"comment\">//在r结点之后插入元素x</span></span><br><span class=\"line\">        r=s;                         <span class=\"comment\">//r指向新的表尾结点</span></span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    r- &gt;next=<span class=\"literal\">NULL</span>;                   <span class=\"comment\">//尾结点指针置空</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"按序号查找结点值\"><a href=\"#按序号查找结点值\" class=\"headerlink\" title=\"按序号查找结点值\"></a>按序号查找结点值</h4><p>在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止，否则返回最后一个结点指针域NULL。</p>\n<p>时间复杂度O(n)</p>\n<p><code>GetElem(L,i)</code>：按位查找操作。获取表L中第i个位置的元素的值。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//按位查找,返回第i个元素(带头结点)</span></span><br><span class=\"line\">LNode *<span class=\"title function_\">GetElem</span><span class=\"params\">(LinkList L,<span class=\"type\">int</span> i)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LNode *p;\t<span class=\"comment\">//指针p指向当前扫描到的结点</span></span><br><span class=\"line\">    <span class=\"type\">int</span> j = <span class=\"number\">0</span>;\t<span class=\"comment\">//当前p指向的是第几个结点</span></span><br><span class=\"line\">    p = L;\t\t<span class=\"comment\">//L指向头结点,头结点是第0个结点(不存数据)</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p!=<span class=\"literal\">NULL</span> &amp;&amp; j&lt;i)\t<span class=\"comment\">//循环找到第i个结点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p = p-&gt;next;\t\t<span class=\"comment\">//让p指针依次向后移</span></span><br><span class=\"line\">        j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果i=0</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-44.png\" style=\"zoom: 50%;\" />\n\n<p>如果i=8(i大于链表长度)</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-45.png\" style=\"zoom: 50%;\" />\n\n<p><strong>王道书版本</strong>:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">LLNode <span class=\"title function_\">GetElem</span><span class=\"params\">(LinkList L,<span class=\"type\">int</span> i)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//本算法取出单链表L（带头结点）中第i个位置的结点指针</span></span><br><span class=\"line\">    <span class=\"type\">int</span> j=<span class=\"number\">1</span>;  <span class=\"comment\">//计数，初始为1</span></span><br><span class=\"line\">    LNode *p = L-&gt;next;  <span class=\"comment\">//头结点指针赋给p</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i==<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> L;  <span class=\"comment\">//若i等于0，则返回头结点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i&lt;<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;  <span class=\"comment\">//若 i 无效，则返回 NULL</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>( p &amp;&amp; j&lt;i ) &#123;  <span class=\"comment\">//从第1个结点开始找，查找第i个结点</span></span><br><span class=\"line\">        p=p-&gt;next;</span><br><span class=\"line\">        j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p; <span class=\"comment\">//返回第i个结点的指针，如果i大于表长，p=NULL，直接返回p即可</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么，封装之后。我们下面会提到的<strong>按位插入</strong>、<strong>按位删除</strong>中相应的代码段就都可以直接调用这个封装好的函数来实现。</p>\n<p>如下所示:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在第i个位置插入元素e（带头结点）</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">ListInsert</span><span class=\"params\">(LinkList &amp;L, <span class=\"type\">int</span> i, ElemType e)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(i&lt;<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\tLNode *p = GetElem(L, i<span class=\"number\">-1</span>);\t<span class=\"comment\">//找到第i-1个结点</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> InsertNextNode(p, e);\t<span class=\"comment\">//p后插入新元素e</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"按值查找表结点\"><a href=\"#按值查找表结点\" class=\"headerlink\" title=\"按值查找表结点\"></a>按值查找表结点</h4><p>从单链表第一个结点开始，由前往后依次比较表中各结点数据域的值，若某结点数据域的值等于给定值e，则返回该结点的指针。若整个单链表中没有这样的结点，则返回NULL。按值查找结点的算法如下：</p>\n<p>时间复杂度O(n)</p>\n<p><code>LocateElem(L,e)</code>：按值查找操作。在表L中查找具有给定关键字值的元素</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">LNode *<span class=\"title function_\">LocateElem</span> <span class=\"params\">(LinkList L, ElemType e)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//本算法查找单链表 L （带头结点）中数据域值等于e的结点指针，否则返回NULL</span></span><br><span class=\"line\">    LNode *p=L-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p!=<span class=\"literal\">NULL</span> &amp;&amp; p-&gt;data!=e)  <span class=\"comment\">//从第1个结点开始查找data域为e的结点</span></span><br><span class=\"line\">        p=p-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;  <span class=\"comment\">//找到后返回该结点指针，否则返回NULL</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>此处同样需要注意一点：由于e的类型是ElemType，其有可能是基本类型，也有可能是结构类型。当其为结构类型时，就不能直接通过”! =”来判断了。原理同前文一致，不再赘述。</p>\n</blockquote>\n<p><a href=\"https://blog.csdn.net/pikaqiu_JBR99/article/details/107616129\">单链表的两种查找方式</a></p>\n<h4 id=\"插入结点操作-单链表的插入和删除\"><a href=\"#插入结点操作-单链表的插入和删除\" class=\"headerlink\" title=\"插入结点操作 单链表的插入和删除\"></a>插入结点操作 <a href=\"https://itcn.blog/p/1649535832.html\">单链表的插入和删除</a></h4><h5 id=\"按位序插入\"><a href=\"#按位序插入\" class=\"headerlink\" title=\"按位序插入\"></a>按位序插入</h5><h6 id=\"带头结点\"><a href=\"#带头结点\" class=\"headerlink\" title=\"带头结点\"></a>带头结点</h6><p><code>ListInsert(&amp;L,i,e)</code>：插入操作。<strong>在表L中的第i个位置上插入指定元素e</strong></p>\n<p>(找到第i-1个结点，将新结点插入其后)</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-36.png\" style=\"zoom:67%;\" />\n\n<p><strong>此时，带头结点的好处就体现出来了。当我插入的位置为1时，可以把头结点看作第0个结点，向头结点后进行插入。由此，我不论在何处插入一个结点，我的处理逻辑都是统一的</strong>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">ListInsert</span><span class=\"params\">(LinkList &amp;L,<span class=\"type\">int</span> i,ElemType e)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i&lt;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LNode *p;\t\t<span class=\"comment\">//指针p指向当前扫描到的结点</span></span><br><span class=\"line\">    <span class=\"type\">int</span> j=<span class=\"number\">0</span>;\t\t<span class=\"comment\">//当前p指向的是第几个结点</span></span><br><span class=\"line\">    p = L;\t\t\t<span class=\"comment\">//L指向头结点,头结点是第0个结点(不存是数据)</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(P! =<span class=\"literal\">NULL</span> &amp;&amp; j&lt;i<span class=\"number\">-1</span>)&#123;\t<span class=\"comment\">//循环找到第 i-1 个结点</span></span><br><span class=\"line\">        p=p-&gt;next;</span><br><span class=\"line\">        j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p==<span class=\"literal\">NULL</span>)\t\t<span class=\"comment\">//i值不合法</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LNode *s = (LNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));</span><br><span class=\"line\">    s-&gt;data=e;</span><br><span class=\"line\">    <span class=\"comment\">//将s指向结点的next指针指向p指向结点的next指针</span></span><br><span class=\"line\">    s-&gt;next = p-&gt;next;\t </span><br><span class=\"line\">    p-&gt;next = s;\t<span class=\"comment\">//将p指向结点的next指针指向s</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;\t<span class=\"comment\">//插入成功</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><font color='red'>分析</font>:</p>\n<p>如果 i=1(也就是在表头插入元素)：时间复杂度O(1)</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-37.png\" style=\"zoom: 50%;\" />\n\n<p>如果 i = 3(也就是在表中插入元素)</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-38.png\" style=\"zoom: 50%;\" />\n\n<p>如果 i = 5(也就是在表尾插入元素)：时间复杂度O(n)</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-39.png\" style=\"zoom: 50%;\" />\n\n<h6 id=\"不带头结点\"><a href=\"#不带头结点\" class=\"headerlink\" title=\"不带头结点\"></a>不带头结点</h6><p><code>ListInsert(&amp;L,i,e)</code>：插入操作。<strong>在表L中的第i个位置上插入指定元素e</strong></p>\n<p>(找到第i-1个结点，将新结点插入其后)</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-40.png\" style=\"zoom: 50%;\" />\n\n\n\n<p><strong>此时，由于不带头结点，也就是不存在“第0个”结点。因此i=1时需要特殊处理。</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">ListInsert</span><span class=\"params\">(LinkList &amp;L,<span class=\"type\">int</span> i,ElemType e)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i&lt;<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i==<span class=\"number\">1</span>)\t\t<span class=\"comment\">//插入第1个结点的操作与其他结点操作不同</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        LNode *s =(LNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));</span><br><span class=\"line\">        s-&gt;data = e;</span><br><span class=\"line\">        s-&gt;next = L;</span><br><span class=\"line\">        L = s;\t\t<span class=\"comment\">//头指针指向新结点</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LNode *p;\t\t<span class=\"comment\">//指针p指向当前扫描到的结点</span></span><br><span class=\"line\">    <span class=\"type\">int</span> j=<span class=\"number\">1</span>;\t\t<span class=\"comment\">//当前p指向的是第几个结点</span></span><br><span class=\"line\">    p = L;\t\t\t<span class=\"comment\">//p指向第1个结点(注意:不是头结点)</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(P!=<span class=\"literal\">NULL</span> &amp;&amp; j&lt;i<span class=\"number\">-1</span>)&#123;\t<span class=\"comment\">//循环找到第 i-1 个结点</span></span><br><span class=\"line\">        p=p-&gt;next;</span><br><span class=\"line\">        j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p==<span class=\"literal\">NULL</span>)\t\t<span class=\"comment\">//i值不合法</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LNode *s = (LNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));</span><br><span class=\"line\">    s-&gt;data=e;</span><br><span class=\"line\">    <span class=\"comment\">//将s指向结点的next指针指向p指向结点的next指针</span></span><br><span class=\"line\">    s-&gt;next = p-&gt;next;\t</span><br><span class=\"line\">    p-&gt;next = s;\t<span class=\"comment\">//将p指向结点的next指针指向s</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;\t<span class=\"comment\">//插入成功</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果不带头结点，则插入、删除第1个元素时，需要更改头指针L。</p>\n<p>如果带头结点的话，头指针肯定永远都是指向头结点的。</p>\n<p>但是除了第1个元素外，后续的元素操作，其逻辑和带头结点的一样。</p>\n</blockquote>\n<p><strong>结论</strong>：不带头结点写代码不方便，推荐用带头结点</p>\n<h5 id=\"指定结点的后插操作\"><a href=\"#指定结点的后插操作\" class=\"headerlink\" title=\"指定结点的后插操作\"></a>指定结点的后插操作</h5><p>后插操作：在结点之后插入元素</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-41.png\" style=\"zoom:67%;\" />\n\n<blockquote>\n<p>给定一个结点，在这个结点之后插入一个数据元素e。</p>\n<p>由于单链表的链接指针只能往后寻找，所以如果给定一个结点p的话，那么p之后的那些结点我们都是可知的，我们都可以用循环的方式把它们都找出来。</p>\n<p>但是p结点之前的，我们就没办法知道了。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//后插操作:在p结点之后插入元素e</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">InsertNextNode</span><span class=\"params\">(LNode *p,ElemType e)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LNode *s =(LNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s==<span class=\"literal\">NULL</span>)\t\t<span class=\"comment\">//某些情况下有可能分配失败,比如内存不足</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s-&gt;data = e;</span><br><span class=\"line\">    s-&gt;next = p-&gt;next;</span><br><span class=\"line\">    p-&gt;next = s;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，这个函数只是在已经找到p结点后执行的操作。其时间复杂度为O(1)。</p>\n<p>但是真正进行插入的时候，首先肯定是要先通过循环，找到结点p的。即如下代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在第i个位置插入元素e（带头结点）</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">ListInsert</span><span class=\"params\">(LinkList &amp;L, <span class=\"type\">int</span> i, ElemType e)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(i&lt;<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\tLNode *p;\t<span class=\"comment\">//指针p指向当前扫描到的结点</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> j = <span class=\"number\">0</span>;\t<span class=\"comment\">//当前p指向的是第几个结点</span></span><br><span class=\"line\">\tp = L;\t<span class=\"comment\">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(p!=<span class=\"literal\">NULL</span> &amp;&amp; j&lt;i<span class=\"number\">-1</span>) &#123;\t<span class=\"comment\">//循环找到第i-1个结点 </span></span><br><span class=\"line\">\t\tp = p-&gt;next;</span><br><span class=\"line\">\t\tj++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> InsertNextNode(p, e);\t<span class=\"comment\">//封装（当然，上面那几行也可以封装）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"指定结点的前插操作\"><a href=\"#指定结点的前插操作\" class=\"headerlink\" title=\"指定结点的前插操作\"></a>指定结点的前插操作</h5><p>前插操作是指在某结点的前面插入一个新结点，后插操作的定义刚好与之相反，在单链表插入算法中，通常都是釆用后插操作的。</p>\n<h6 id=\"单链表的基本插入算法\"><a href=\"#单链表的基本插入算法\" class=\"headerlink\" title=\"单链表的基本插入算法\"></a>单链表的基本插入算法</h6><p>插入操作是将值为x的新结点插入到单链表的第i个位置上。先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第i-1个结点，再在其后插入新结点。</p>\n<p>算法首先调用上面的按序号查找算法GetElem(L, i-1)，查找第i-1个结点。假设返回的第i-1个结点为 *p，然后令新结点 *s的指针域指向 *p的后继结点，再令结点 *p的指针域指向新插入的结点 *s。其操作过程如图所示。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-11.png\" style=\"zoom:80%;\" />\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">p=GetElem(L, i<span class=\"number\">-1</span>) ;  <span class=\"comment\">// 语句①，查找插入位置的前驱结点</span></span><br><span class=\"line\">s-&gt;next=p-&gt;next;  <span class=\"comment\">// 语句②，图 2-6 中辑作步骤 1</span></span><br><span class=\"line\">p-&gt;next=s;  <span class=\"comment\">// 语句③，图2-6中操作步骤2</span></span><br></pre></td></tr></table></figure>\n\n<p>算法中，语句②③的顺序不能颠倒，否则，当先执行p-&gt;next=s后，指向其原后继的指针就不存在了，再执行s-&gt;next = p-&gt;next时，相当于执行了 s-&gt;next=s,显然是错误的。本算法主要的时间开销在于查找第i-1个元素，时间复杂度为O(n)。若是在给定的结点后面插入新结点，则时间复杂度仅为O(1)。</p>\n<p>以上面的算法为例，首先调用函数GetElem()找到第i-1个结点，即待插入结点的前驱结点后，再对其执行后插操作。由此可知，对结点的前插操作均可以转化为后插操作，前提是从单链表的头结点开始顺序查找到其前驱结点，时间复杂度为O(n)。</p>\n<h6 id=\"拓展-对某一结点的前插操作\"><a href=\"#拓展-对某一结点的前插操作\" class=\"headerlink\" title=\"拓展:对某一结点的前插操作\"></a>拓展:对某一结点的前插操作</h6><p>此外，可以釆用另一种方式将其转化为后插操作来实现，设待插入结点为s，将插入到p的前面。我们仍然将s插入到p的后面，然后将p-&gt;data与s-&gt;data交换即可，这样既满足了逻辑关系，又能使得时间复杂度为O(1)。算法的代码片段如下：</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-42.png\" style=\"zoom:67%;\" />\n\n<blockquote>\n<p>在p结点之前插入元素e。</p>\n<p>此时就会出现一个问题：如何找到p结点的前驱？</p>\n<p>思路一：</p>\n<p>我们可以传入一个头指针。当给出头指针之后，那么我们链表的所有信息就都能够知道了。</p>\n<p>我们可以从头指针开始，依次遍历各个结点，从而找到p结点的前驱结点，再对p的前驱进行后插操作。</p>\n<p>那么用这种方法进行前插，时间复杂度是O(n)。</p>\n<p>思路二：</p>\n<p>我依然是对p进行后插。但是后插过后，我将p结点和新结点，之中的数据域进行互换。最终也能实现前插的效果。</p>\n<p>这种的本质是后插，时间复杂度O(1)。</p>\n</blockquote>\n<p><strong>思路二代码实现</strong>:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//前插操作:在p结点之前插入元素e</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">InsertPriorNode</span><span class=\"params\">(LNode *p,ElemType e)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LNode *s =(LNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s==<span class=\"literal\">NULL</span>)\t\t\t<span class=\"comment\">//内存分配失败</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s-&gt;next = p-&gt;next;\t</span><br><span class=\"line\">    p-&gt;next = s;\t\t<span class=\"comment\">//新结点 s 连接到 p 之后</span></span><br><span class=\"line\">    s-&gt;data = p-&gt;data;\t<span class=\"comment\">//将p中元素复制到s中</span></span><br><span class=\"line\">    p-&gt;data = e;\t\t<span class=\"comment\">//p中元素覆盖为e</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>王道书中的版本</strong>:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-43.png\" style=\"zoom:67%;\" />\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//前插操作:在p结点之前插入结点s</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">InsertPriorNode</span><span class=\"params\">(LNode *p,LNode *s)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p==<span class=\"literal\">NULL</span> || s==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s-&gt;next = p-&gt;next;</span><br><span class=\"line\">    p-&gt;next = s;\t\t\t\t<span class=\"comment\">//s连到p之后</span></span><br><span class=\"line\">    ElemType temp = p-&gt;data;\t<span class=\"comment\">//交换数据域部分</span></span><br><span class=\"line\">    p-&gt;data = s-&gt;data;</span><br><span class=\"line\">    s-&gt;data = temp;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"删除结点操作-单链表的插入和删除\"><a href=\"#删除结点操作-单链表的插入和删除\" class=\"headerlink\" title=\"删除结点操作 单链表的插入和删除\"></a>删除结点操作 <a href=\"https://itcn.blog/p/1649535832.html\">单链表的插入和删除</a></h4><p>删除操作是将单链表的第i个结点删除。先检查删除位置的合法性，然后查找表中第i-1个结点，即被删结点的前驱结点，再将其删除。其操作过程如图所示。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-12.png\"  />\n\n<p>假设结点p为找到的被删结点的前驱结点，为了实现这一操作后的逻辑关系的变化，仅需修改p的指针域，即将p的指针域next指向q的下一结点。</p>\n<p>时间复杂度O(n)</p>\n<h5 id=\"带头结点按位序删除\"><a href=\"#带头结点按位序删除\" class=\"headerlink\" title=\"带头结点按位序删除\"></a>带头结点按位序删除</h5><p><code>ListDelete(&amp;L,i,&amp;e)</code>：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值(找到第i-1个结点，将其指针指向第i+1个结点，并释放第i个结点)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">ListDelete</span><span class=\"params\">(LinkList &amp;L,<span class=\"type\">int</span> i,ElemType &amp;e)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i&lt;<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LNode *p;\t<span class=\"comment\">//指针p指向当前扫描到的结点</span></span><br><span class=\"line\">    <span class=\"type\">int</span> j = <span class=\"number\">0</span>;\t<span class=\"comment\">//当前p指向的是第几个结点</span></span><br><span class=\"line\">    p = L;\t\t<span class=\"comment\">//L指向头结点,头结点是第0个结点(不存数据)</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p!=<span class=\"literal\">NULL</span> &amp;&amp; j&lt;i<span class=\"number\">-1</span>)\t<span class=\"comment\">//循环找到第 i-1 个结点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        j++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p==<span class=\"literal\">NULL</span>)  \t\t\t<span class=\"comment\">// i值不合法</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p-&gt;next == <span class=\"literal\">NULL</span>)\t\t<span class=\"comment\">//第 i-1 个结点之后已无其他结点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LNode *q = p-&gt;next;\t\t<span class=\"comment\">//令q指向被删除结点</span></span><br><span class=\"line\">    e = q-&gt;data;\t\t\t<span class=\"comment\">//用e返回元素的值</span></span><br><span class=\"line\">    p-&gt;next = q-&gt;next;\t\t<span class=\"comment\">//将*q结点从链中断开</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(q);\t\t\t\t<span class=\"comment\">//释放结点的存储空间</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;\t\t\t<span class=\"comment\">//删除成功</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"扩展：删除指定结点p\"><a href=\"#扩展：删除指定结点p\" class=\"headerlink\" title=\"扩展：删除指定结点p\"></a>扩展：删除指定结点p</h5><p>要实现删除某一个给定结点p，通常的做法是先从链表的头结点开始顺序找到其前驱结点，然后再执行删除操作即可，算法的时间复杂度为O(n)。</p>\n<p>其实，删除结点p的操作可以用删除p的后继结点操作来实现，实质就是将其后继结点的值赋予其自身，然后删除后继结点，也能使得时间复杂度为O(1)。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//删除指定结点p</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">DeleteNode</span><span class=\"params\">(LNode *p)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LNode *q = p-&gt;next;\t\t<span class=\"comment\">//令q指向*p的后继结点</span></span><br><span class=\"line\">    p-&gt;data = p-&gt;next-&gt;data;<span class=\"comment\">//和后继结点交换数据域</span></span><br><span class=\"line\">    p-&gt;next = q-&gt;next;\t\t<span class=\"comment\">//将*q结点从链中&quot;断开&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(q);\t\t\t\t<span class=\"comment\">//释放后继结点的存储空间</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>但是有个问题:如果要删除的这个结点，刚好是单链表的最后一个结点。那么在进行p结点与其后继结点数据域的互换的时候，就会出现问题。即<code>p-&gt;data = p-&gt;next-&gt;data</code>;的时候，就会出现空指针的错误。</p>\n<p>那么如果是最后一个结点，该怎么办呢。那就只能从头结点开始，循环找到p的前驱，进行删除。时间复杂度O(n)。</p>\n</blockquote>\n<h4 id=\"求表长操作\"><a href=\"#求表长操作\" class=\"headerlink\" title=\"求表长操作\"></a>求表长操作</h4><p>求表长操作就是计算单链表中数据结点（不含头结点）的个数，需要从第一个结点开始顺序依次访问表中的每一个结点，为此需要设置一个计数器变量，每访问一个结点，计数器加1，直到访问到空结点为止。算法的时间复杂度为O(n)。</p>\n<p>需要注意的是，因为单链表的长度是不包括头结点的，因此，不带头结点和带头结点的单链表在求表长操作上会略有不同。对不带头结点的单链表，当表为空时，要单独处理。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//求表的长度</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Length</span><span class=\"params\">(LinkList L)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> len = <span class=\"number\">0</span>;\t\t\t<span class=\"comment\">//统计表长</span></span><br><span class=\"line\">    LNode *p = L;\t\t</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p-&gt;next !=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        len++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"双链表-双链表的基本操作\"><a href=\"#双链表-双链表的基本操作\" class=\"headerlink\" title=\"双链表 双链表的基本操作\"></a>双链表 <a href=\"https://blog.csdn.net/qq_16933601/article/details/105351119\">双链表的基本操作</a></h3><p>单链表结点中只有一个指向其后继的指针，这使得单链表只能从头结点依次顺序地向后遍历。若要访问某个结点的前驱结点（插入、删除操作时），只能从头开始遍历，访问后继结点的时间复杂度为O(1)，访问前驱结点的时间复杂度为O(n)。</p>\n<p>为了克服单链表的上述缺点，引入了双链表，双链表结点中有两个指针prior和next，分别指向其前驱结点和后继结点，如图所示。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-13.png\" style=\"zoom: 75%;\" />\n\n<p>结点类型定义</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DNode</span> &#123;</span>  <span class=\"comment\">//定义双链表结点类型</span></span><br><span class=\"line\">    ElemType data;  <span class=\"comment\">//数据域</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DNode</span> *<span class=\"title\">prior</span>, *<span class=\"title\">next</span>;</span>  <span class=\"comment\">//前驱和后继指针</span></span><br><span class=\"line\">&#125;DNode, *DLinklist;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"双链表的初始化\"><a href=\"#双链表的初始化\" class=\"headerlink\" title=\"双链表的初始化\"></a>双链表的初始化</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//初始化双链表(带头结点)</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">InitDLinkList</span><span class=\"params\">(DLinklist &amp;L)</span>&#123;</span><br><span class=\"line\">    L = (DNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(DNode));\t\t\t<span class=\"comment\">//分配一个头结点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L==<span class=\"literal\">NULL</span>)\t\t\t\t\t\t\t\t\t<span class=\"comment\">//内存不足,分配失败</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    L-&gt;prior = <span class=\"literal\">NULL</span>;\t\t\t\t\t\t\t<span class=\"comment\">//头结点的prior永远指向NULL</span></span><br><span class=\"line\">    L-&gt;next = <span class=\"literal\">NULL</span>;\t\t\t\t\t\t\t\t<span class=\"comment\">//头结点之后暂时还没有结点</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">testDLinkList</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//初始化双链表</span></span><br><span class=\"line\">    DLinklist L;</span><br><span class=\"line\">    InitDLinkList(L);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>DLinklist</code> 等价于<code>DNode *</code></li>\n<li><code>DLinklist</code> 强调这是一个链表</li>\n<li><code>DNode *</code> 强调这是一个结点</li>\n</ul>\n<h4 id=\"判断双链表是否为空\"><a href=\"#判断双链表是否为空\" class=\"headerlink\" title=\"判断双链表是否为空\"></a>判断双链表是否为空</h4><p>判断双链表是否为空:判断头结点的下一个是否为空</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//判断双链表是否为空(带头结点)</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Empty</span><span class=\"params\">(DLinklist L)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L-&gt;next == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"双链表的插入操作\"><a href=\"#双链表的插入操作\" class=\"headerlink\" title=\"双链表的插入操作\"></a>双链表的插入操作</h4><p>在双链表中p所指的结点之后插入结点s，其指针的变化过程如图所示</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-14.png\"  />\n\n<p>时间复杂度O(n)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">s-&gt;next=p-&gt;next;  <span class=\"comment\">// 语句①，将结点*s插入到结点*p之后</span></span><br><span class=\"line\">p-&gt;next-&gt;prior=s;  <span class=\"comment\">// 语句②</span></span><br><span class=\"line\">s-&gt;prior=p;  <span class=\"comment\">// 语句③</span></span><br><span class=\"line\">p-&gt;next=s;  <span class=\"comment\">// 语句④</span></span><br></pre></td></tr></table></figure>\n\n<p>上述代码的语句顺序不是唯一的，但也不是任意的，①②两步必须在④步之前，否则p的后继结点的指针就丢掉了，导致插入失败。</p>\n<blockquote>\n<p>但是，<strong>会有一个问题</strong>。</p>\n<p>当p结点为双链表最后一个结点时，在执行该操作时。其中<code>p-&gt;next-&gt;prior = s;</code>会出现空指针错误。</p>\n<p>因此我们要优化一下这段代码，如下所示。</p>\n</blockquote>\n<h5 id=\"后插操作\"><a href=\"#后插操作\" class=\"headerlink\" title=\"后插操作\"></a>后插操作</h5><p>如果p结点是最后一个结点(特殊情况)：</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-46.png\" style=\"zoom: 50%;\" />\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在p结点之后插入s结点</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">InsertNextDNode</span><span class=\"params\">(DNode *p,DNode *s)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p=<span class=\"literal\">NULL</span> || s=<span class=\"literal\">NULL</span>)\t\t\t\t\t\t\t<span class=\"comment\">//非法参数</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s-&gt;next = p-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p-&gt;next != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//如果p结点有后继结点</span></span><br><span class=\"line\">        p-&gt;next-&gt;prior = s;</span><br><span class=\"line\">    &#125;<span class=\"comment\">//如果p没有后继节点，则当然不需要修改p的后继节点的前驱指针</span></span><br><span class=\"line\">    s-&gt;prior = p;</span><br><span class=\"line\">    p-&gt;next = s;\t</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果p是中间一个结点:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-47.png\" style=\"zoom:67%;\" />\n\n<blockquote>\n<p>同样要注意赋值时的顺序。有些能调换，有些调换了就是错误的逻辑。</p>\n<p>实现了双链表后，在对p结点执行前插操作时。就可以立即找到p结点的前驱结点q，再对q进行后插操作即可。实际上都是可以转化为，利用后插来实现。</p>\n</blockquote>\n<h5 id=\"按位序插入-1\"><a href=\"#按位序插入-1\" class=\"headerlink\" title=\"按位序插入\"></a>按位序插入</h5><p>按位序插入：只需从头结点开始，找到某一个位序的前驱结点，然后对这个前驱结点执行后插操作</p>\n<h5 id=\"前插操作\"><a href=\"#前插操作\" class=\"headerlink\" title=\"前插操作\"></a>前插操作</h5><p>前插操作：只需找到此结点的前驱结点，然后对其前驱结点进行后插操作，即为前插操作</p>\n<h4 id=\"双链表的删除操作\"><a href=\"#双链表的删除操作\" class=\"headerlink\" title=\"双链表的删除操作\"></a>双链表的删除操作</h4><p>删除双链表中结点p的后继结点q，其指针的变化过程如图所示。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-15.png\"  />\n\n<p>时间复杂度O(n)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">p-&gt;next=q-&gt;next;  <span class=\"comment\">// 图2-10中步骤①</span></span><br><span class=\"line\">q-&gt;next-&gt;prior=p;  <span class=\"comment\">//图 2-10 中步骤②</span></span><br><span class=\"line\"><span class=\"built_in\">free</span> (q) ; <span class=\"comment\">//释放结点空间</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>但这样写，同样会有一个问题。就是q为最后一个结点的时候。q的后继节点为NULL，没有前驱结点prior。也就是[*]会引起空指针错误。</p>\n</blockquote>\n<p>当q结点不是最后一个结点时：</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-48.png\" style=\"zoom:67%;\" />\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//删除p结点的后继结点</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">DeleteNextDNode</span><span class=\"params\">(DNode *p)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    DNode *q = p-&gt;next;\t\t\t\t<span class=\"comment\">//找到p的后继结点q</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(q = <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t\t\t\t<span class=\"comment\">//p没有后继结点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    p-&gt;next = q-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(q-&gt;next != <span class=\"literal\">NULL</span>)\t\t\t\t<span class=\"comment\">//q结点不是最后一个结点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        q-&gt;next-&gt;prior = p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(q);\t\t\t\t\t\t<span class=\"comment\">//释放结点空间</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当q结点是最后一个结点时:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-49.png\" style=\"zoom: 50%;\" />\n\n<h4 id=\"双链表的销毁\"><a href=\"#双链表的销毁\" class=\"headerlink\" title=\"双链表的销毁\"></a>双链表的销毁</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">DestoryList</span><span class=\"params\">(DLinklist &amp;L)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//循环释放各个数据结点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(L-&gt;next !=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        DeleteNextDNode(L);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(L);\t\t<span class=\"comment\">//释放头结点</span></span><br><span class=\"line\">    L=<span class=\"literal\">NULL</span>;\t\t\t<span class=\"comment\">//头指针指向NULL</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"双链表的遍历\"><a href=\"#双链表的遍历\" class=\"headerlink\" title=\"双链表的遍历\"></a>双链表的遍历</h4><h5 id=\"后向遍历\"><a href=\"#后向遍历\" class=\"headerlink\" title=\"后向遍历\"></a>后向遍历</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//对结点p做相应处理</span></span><br><span class=\"line\">    p = p-&gt;next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"前向遍历\"><a href=\"#前向遍历\" class=\"headerlink\" title=\"前向遍历\"></a>前向遍历</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//对结点p做相应处理</span></span><br><span class=\"line\">    p = p-&gt;prior;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"前向遍历-跳过头结点\"><a href=\"#前向遍历-跳过头结点\" class=\"headerlink\" title=\"前向遍历(跳过头结点)\"></a>前向遍历(跳过头结点)</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(p-&gt;prior!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//对结点p做相应处理</span></span><br><span class=\"line\">    p = p-&gt;prior;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>知道怎么前向、后向遍历，那么按位查找、按值查找也就没什么问题。</p>\n<ul>\n<li>按位查找：在知道如何前后向遍历的基础上，设置一个遍历次数i，每遍历一次，执行i++，即可实现按位查找。</li>\n<li>按值查找：在知道如何前后向遍历的基础上，每遍历到一个结点，判断该结点的数据域是否等于e，即可实现按值查找。</li>\n</ul>\n<p>时间复杂度O(n)。</p>\n</blockquote>\n<h3 id=\"循环链表\"><a href=\"#循环链表\" class=\"headerlink\" title=\"循环链表\"></a>循环链表</h3><h4 id=\"循环单链表\"><a href=\"#循环单链表\" class=\"headerlink\" title=\"循环单链表\"></a>循环单链表</h4><p>循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-16.png\" style=\"zoom:67%;\" />\n\n<p>在循环单链表中，表尾结点的next域指向L，故表中没有指针域为NULL的结点，因此，<font color='orange'>循环单链表的判空条件不是头结点的指针是否为空，而是它是否等于头指针</font>。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-21.png\" style=\"zoom: 75%;\" />\n\n<p>循环单链表的插入、删除算法与单链表的几乎一样，所不同的是如果操作是在表尾进行，则执行的操作不相同，以让单链表继续保持循环的性质。当然，正是因为循环单链表是一个 “环”，因此，在任何一个位置上的插入和删除操作都是等价的，无须判断是否是表尾。</p>\n<p>在单链表中只能从表头结点开始往后顺序遍历整个链表，而循环单链表可以从表中的任一结点开始遍历整个链表。有时对单链表常做的操作是在表头和表尾进行的，此时可对循环单链表不设头指针而仅设尾指针，从而使得操作效率更高。</p>\n<h5 id=\"初始化循环单链表\"><a href=\"#初始化循环单链表\" class=\"headerlink\" title=\"初始化循环单链表\"></a>初始化循环单链表</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span>&#123;</span>\t\t<span class=\"comment\">//定义单链表结点类型</span></span><br><span class=\"line\">    ElemType data;\t\t\t<span class=\"comment\">//每个结点存放一个数据元素</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">next</span>;</span>\t\t<span class=\"comment\">//指针指向下一个结点</span></span><br><span class=\"line\">&#125;LNode,*LinkList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化一个循环单链表</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">InitList</span><span class=\"params\">(LinkList &amp;L)</span>&#123;</span><br><span class=\"line\">    L = (LNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));\t\t<span class=\"comment\">//分配一个头结点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    L-&gt;next = L;\t\t\t\t\t\t\t<span class=\"comment\">//头结点next指向头结点</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"判断循环单链表是否为空\"><a href=\"#判断循环单链表是否为空\" class=\"headerlink\" title=\"判断循环单链表是否为空\"></a>判断循环单链表是否为空</h5><p>判断循环单链表是否为空:判断头结点的next指针是否指向它自己</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Empty</span><span class=\"params\">(LinkList L)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L-&gt;next == L)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"判断循环单链表表尾结点\"><a href=\"#判断循环单链表表尾结点\" class=\"headerlink\" title=\"判断循环单链表表尾结点\"></a>判断循环单链表表尾结点</h5><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-50.png\" style=\"zoom: 33%;\" />\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//判断结点p是否是循环单链表的表尾结点</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">isTail</span><span class=\"params\">(LinkList L,LNode *p)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p-&gt;next == L)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"循环单链表的好处\"><a href=\"#循环单链表的好处\" class=\"headerlink\" title=\"循环单链表的好处\"></a>循环单链表的好处</h5><p><strong>单链表</strong></p>\n<ul>\n<li>从一个结点出发，只能找到后续的各个结点，而前驱的各个结点，除非获得单链表的表头指针，否则无法得知。</li>\n<li>从头结点找到尾部，依次循环遍历，时间复杂度为O(n)。</li>\n</ul>\n<p><strong>循环单链表</strong></p>\n<ul>\n<li>从一个结点出发可以找到其他任意一个结点。</li>\n<li><strong>我们让L不再指向头结点，而是指向尾结点</strong>。那么从尾部找到头部，时间复杂度为O(1)。那么此时，我既有尾结点，又有头结点了（往后找一个即可）。而很多时候，链表的操作都是在头部或尾部。那么这样一来，就大大方便了操作，时间复杂度为O(1)。</li>\n</ul>\n<h4 id=\"循环双链表\"><a href=\"#循环双链表\" class=\"headerlink\" title=\"循环双链表\"></a>循环双链表</h4><p>由循环单链表的定义不难推出循环双链表，不同的是在循环双链表中，头结点的prior 指针还要指向表尾结点</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-17.png\" style=\"zoom: 80%;\" />\n\n<p>在循环双链表L中，某结点*p为尾结点时，p-&gt;next=L;当循环双链表为空表时，其头结点的prior域和next域都等于L</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-18.png\" style=\"zoom: 75%;\" />\n\n<p>循环双链表的<strong>优势</strong>:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-19.png\" style=\"zoom: 75%;\" />\n\n<p>我们知道，在p为表尾结点的时候，<font color='orange'>箭头</font>处的语句会出现空指针错误。但如果我们是<strong>循环双链表</strong>的话，那么上述代码的逻辑就是<strong>完全正确</strong>的。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-20.png\" style=\"zoom: 75%;\" />\n\n<p>我们知道，在q为表尾结点的时候，<font color='orange'>箭头</font>处的语句会出现空指针错误。但如果我们是<strong>循环双链表</strong>的话，那么上述代码的逻辑就是<strong>完全正确</strong>的。</p>\n<h3 id=\"静态链表\"><a href=\"#静态链表\" class=\"headerlink\" title=\"静态链表\"></a>静态链表</h3><p>静态链表是<font color='cornflowerblue'>借助数组来描述线性表的链式存储结构</font>，结点也有数据域data和指针域next，与前面所讲的链表中的指针不同的是，这里的指针是<strong>结点的相对地址</strong>(数组下标)，又称为<strong>游标</strong>。和顺序表一样，静态链表也要预先分配一块连续的内存空间。</p>\n<p><strong>静态链表和单链表的对应关系如图</strong></p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-22.png\" style=\"zoom: 75%;\" />\n\n<blockquote>\n<p>单链表中的结点是离散的，分布在内存中的各个角落。每个节点包括一个数据域（数据元素），还有一个指针域（指向下一个结点的指针（地址））。</p>\n</blockquote>\n<blockquote>\n<p>静态链表分配一整片的内存空间，其中的数据元素存放在这片内存空间的某些位置。静态链表中的每个结点包含了数据元素，还有下一个结点的数组下标（游标）。</p>\n<p>静态链表中，0号结点充当“头结点”，它是不存放数据元素的。</p>\n<p>静态链表中每个结点的游标相当于单链表中的指针域。只不过指针域是指明了下一个结点的具体地址，而游标只是指明了在此数组中的下标。</p>\n<p>静态链表如果要表示该结点为最后一个结点的话，可以将它的游标的值设为-1。</p>\n</blockquote>\n<blockquote>\n<p>这样一来，若0号结点的游标为2，那么就可以直接寻找到下标为2的结点的地址。（即静态链表的起始地址<code>addr + sizeof(Node) * 2</code>，实际上就是数组）</p>\n</blockquote>\n<h4 id=\"结点类型定义\"><a href=\"#结点类型定义\" class=\"headerlink\" title=\"结点类型定义\"></a>结点类型定义</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 50  <span class=\"comment\">//静态链表的最大长度</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span>  <span class=\"comment\">//静态链表结构类型的定义</span></span><br><span class=\"line\">    ElemType data;  <span class=\"comment\">//存储数据元素</span></span><br><span class=\"line\">    <span class=\"type\">int</span> next;  <span class=\"comment\">//下一个元素的数组下标</span></span><br><span class=\"line\">&#125;SLinkList[MaxSize];</span><br></pre></td></tr></table></figure>\n\n<p>上下的代码定义等价</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 50  <span class=\"comment\">//静态链表的最大长度</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span>  <span class=\"comment\">//静态链表结构类型的定义</span></span><br><span class=\"line\">    ElemType data;  <span class=\"comment\">//存储数据元素</span></span><br><span class=\"line\">    <span class=\"type\">int</span> next;  <span class=\"comment\">//下一个元素的数组下标</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> <span class=\"title\">SLinkList</span>[<span class=\"title\">MaxSize</span>];</span><span class=\"comment\">//可用SLinkList定义&quot;一个长度为MaxSize的Node型数组&quot;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>问题</strong>：</p>\n<p>用typedef给一个结构类型起别名我理解，但是这个别名怎么是一个“数组”呢？</p>\n<p>实际上这样写以后。你就可以直接通过<strong>SLinkList</strong>定义“<strong>一个长度为MaxSize的Node型数组</strong>”了。</p>\n<p>即如下所示，这两个写法是等价的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">testSLinkList</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\tSLinkList a;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">testSLinkList2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> <span class=\"title\">a</span>[<span class=\"title\">MaxSize</span>];</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>追问：</strong></p>\n<p>我理解了这种定义方式的作用了。但是为什么要这样写呢？这样写不别扭吗？为什么不用我们传统的<code>struct Node a[MaxSize];</code>呢？</p>\n<p>其实这个地方，和我们之前提到过的<code>LinkLise</code>和<code>LNode *</code>其想要<strong>强调含义</strong>是一个道理。</p>\n<p>我使用<code>SLinkList a;</code>来定义，是想<strong>强调</strong>我这里正在定义一个<strong>静态链表</strong>。你一看就明白了，a是一个静态链表。</p>\n<p>但是使用<code>struct Node a[MaxSize];</code>，它仅仅是定义一个Node型的数组a。</p>\n</blockquote>\n<h4 id=\"基本操作的实现\"><a href=\"#基本操作的实现\" class=\"headerlink\" title=\"基本操作的实现\"></a>基本操作的实现</h4><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-24.png\" style=\"zoom: 75%;\" />\n\n<h3 id=\"顺序表和链表的比较\"><a href=\"#顺序表和链表的比较\" class=\"headerlink\" title=\"顺序表和链表的比较\"></a>顺序表和链表的比较</h3><p><strong>逻辑结构</strong>:都属于线性表，都是线性结构</p>\n<p><strong>物理结构</strong>:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-25.png\" style=\"zoom: 75%;\" />\n\n<p><strong>基本操作</strong>:</p>\n<ul>\n<li><p><strong>创建</strong>:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-52.png\" style=\"zoom:55%;\" />\n</li>\n<li><p><strong>销毁</strong>:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-53.png\" style=\"zoom:55%;\" />\n</li>\n<li><p><strong>增、删</strong>:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-54.png\" style=\"zoom:55%;\" />\n</li>\n<li><p><strong>查</strong>:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-55.png\" style=\"zoom:55%;\" />\n\n</li>\n</ul>\n<p><strong>在实际应用中应该怎样选取存储结构呢</strong>？</p>\n<ul>\n<li><p><strong>基于存储的考虑</strong></p>\n<p>难以估计线性表的长度或存储规模时，不宜采用顺序表；链表不用事先估计存储规模，但链表的存储密度较低，显然链式存储结构的存储密度是小于1的。</p>\n</li>\n<li><p><strong>基于运算的考虑</strong></p>\n<p>在顺序表中按序号访问ai的时间复杂度为O(1)，而链表中按序号访问的时间复杂度为O(n)，因此若经常做的运算是按序号访问数据元素，则显然顺序表优于链表。</p>\n<p>在顺序表中进行插入、删除操作时，平均移动表中一半的元素，当数据元素的信息量较大且表较长时，这一点是不应忽视的；在链表中进行插入、删除操作时，虽然也要找插入位置，但操作主要是比较操作，从这个角度考虑显然后者优于前者。</p>\n</li>\n<li><p><strong>基于环境的考虑</strong></p>\n<p>顺序表容易实现，任何高级语言中都有数组类型；链表的操作是基于指针的，相对来说前者实现较为简单，这也是用户考虑的一个因素。</p>\n</li>\n</ul>\n<p><strong>开放式问题的回答思路</strong></p>\n<p><strong>注意</strong>：对于一些开放式问题的答题思路，例如</p>\n<ul>\n<li>请描述顺序表和链表的…（区别、联系…）</li>\n<li>实现线性表时，用顺序表还是链表好？</li>\n</ul>\n<p>你都可以用这样的思路（框架），来让自己的答题逻辑更加的清晰。</p>\n<p><strong>这样的思路（框架）</strong>：指的是本节中，对顺序表和链表分别从<strong>逻辑结构</strong>、<strong>存储结构</strong>、<strong>基本操作</strong>三个角度进行了对比，并指出<strong>优缺点</strong>、<strong>效率</strong>上的差异等。</p>\n<blockquote>\n<p>具体的回答思路，例如：</p>\n<p>顺序表和链表的逻辑结构都是线性结构，都属于线性表。</p>\n<p>但是二者的存储结构不同，顺序表采用顺序存储…，具有…的特点，从而导致其优点…，缺点…；而链表采用链式存储，具有…的特点，从而导致其优点…，缺点…。</p>\n<p>由于采用不同的存储方式实现，因此基本操作的实现效率也不同。当初始化时…；当插入一个数据元素时…；当删除一个数据元素时…；当查找一个数据元素时…。</p>\n</blockquote>\n<p>当然，也并不是说这其中的每一个点都必须写出来，意思就是，你可以根据实际情况，按照这个大致思路进行回答，并且选择把哪些点答上去，哪些可以不答上去。总之，思路是清晰的。</p>\n<p>此外，这样的框架性的思路除了便于答题外，也有助于自己的复习、回顾。</p>\n<h3 id=\"习题\"><a href=\"#习题\" class=\"headerlink\" title=\"习题\"></a>习题</h3><ul>\n<li><p>【2016】已知一个带有表头结点的双向循环链表L，结点结构为<code>prev|data|next</code>,其中，prev 和 next 分别是指向其直接前驱和直接后继结点的指针。现要删除指针 p 所指的结点，正确的语句序列是</p>\n<blockquote>\n<p> p-&gt;next-&gt;prev=p-&gt;prev; p-&gt;prev-&gt;next=p-&gt;next; free(p);</p>\n</blockquote>\n</li>\n<li><p>【2016】已知表头元素为 c 的单链表在内存中的存储状态如下表所示。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-30.png\"  />\n\n<p>现将 f 存放于 1014H 处并插入到单链表中，若 f 在逻辑上位于 a 和 e 之间，则 a, e, d 的“链接地址”依次是–&gt;1014H 1004H NULL</p>\n<blockquote>\n<p>链表的遍历顺序c（1008H）-&gt;a（1000H）-&gt;e（1010H）-&gt;b（1004H）-&gt;d（100CH）-&gt;null，然后你插入f到a,e 之间，则a要链接的地址就变成了f的地址，则a的链接地址为1014H ，而f的链接地址则是为e的地址1010H，最后的e后面的链接是没有变的依然是到b。总结：插入后链表的遍历顺序c（1008H）-&gt;a（1000H）-&gt;f(1014H)-&gt;e（1010H）-&gt;b（1004H）-&gt;d（100CH）-&gt;null</p>\n</blockquote>\n</li>\n<li><p>【2021】已知头指针h指向一个带头结点的非空单循环链表，结点结构为<code>data|next</code>,其中next是指向直接后继结点的指针，p是尾指针，q是临时指针。现要删除该链表的第一个元素，正确的语句序列是–&gt; </p>\n<p>q= h-&gt;next; h-&gt;next=q-&gt;next; if(p==q) p=h; free(q);</p>\n<blockquote>\n<p>删除该链表的第一个元素就是让你删除头结点后面的第一个结点。</p>\n<p>普通情况:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-31.png\" style=\"zoom:67%;\" />\n\n<p>特殊情况:要注意当我们删除head后面的节点以后，整个链表就只剩下head节点一个了。 那尾指针只能指向head，所以D选项里的if(p==q)  p=h; free(q);就非常正确。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-32.png\" style=\"zoom:67%;\" />\n</blockquote>\n</li>\n<li><p>综合【2009】已知一个带有表头结点的单链表，结点结构为<code>data|link</code> 假设该链表只给出了头指针list。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第k个位置上的结点（k为正整数）。若查找成功，算法输出该结点的data域的值，并返回1；否则，只返回0。要求： </p>\n<p>① 描述算法的基本设计思想 </p>\n<p>② 描述算法的详细实现步骤 </p>\n<p>③ 根据设计思想和实现步骤，采用程序设计语言描述算法，关键之处请给出简要注释</p>\n<blockquote>\n<p>1)关键是设计尽可能高效的算法，通过链表的一次遍历，找到倒数第k个结点的位置。算法的基本设计思想是:定义两个指针变量p和q，初始时均指向头结点的下一个结点(链表的第一个结点)，p指针沿链表移动；当p指针移动到第k个结点时，q指针开始与p指针同步移动；当p指针移动到最后一个结点时，q指针所指示结点为倒数第k个结点。</p>\n<p>2)算法详细实现步骤:</p>\n<p>1.count=0,p和q指向链表表头结点的下一个结点。</p>\n<p>2.若p为空，转5</p>\n<p>3.若count等于k，则q指向下一个结点；否则，count=count+1。</p>\n<p>4.p指向下一个结点，转2</p>\n<p>5.若count等于k，则查找成功，输出该结点的data域的值，返回1；否则，说明k值超过了线性表的长度，查找失败，返回0.</p>\n<p>6.算法结束。</p>\n<p>3)算法实现如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">link</span>;</span></span><br><span class=\"line\">&#125;LNode, *LinkList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Search_k</span><span class=\"params\">(LinkList <span class=\"built_in\">list</span>,<span class=\"type\">int</span> k)</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//查找链表list倒数第k个结点，并输出该结点data域的值</span></span><br><span class=\"line\">\tLNode *p=<span class=\"built_in\">list</span>-&gt;link;<span class=\"comment\">//指针p,q指向链表的第一个结点 </span></span><br><span class=\"line\">\tLNode *q=<span class=\"built_in\">list</span>-&gt;link;</span><br><span class=\"line\">\t<span class=\"type\">int</span> count=<span class=\"number\">0</span>;<span class=\"comment\">//计数器初始化为0 </span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(p! =<span class=\"literal\">NULL</span>)&#123;<span class=\"comment\">//指针p依次遍历链表直至最后一个结点 </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(count&lt;k) count++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>  q=q-&gt;link;</span><br><span class=\"line\">\t\t p=p-&gt;link;</span><br><span class=\"line\">\t&#125; <span class=\"comment\">//while</span></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t上面这几行是这个算法的核心思想，我来解释一下</span></span><br><span class=\"line\"><span class=\"comment\">\t首先算法开始运行时，p在动，而q不动</span></span><br><span class=\"line\"><span class=\"comment\">\t直到p向右移动了k次，此时k和count相等，这时候p和q一起向右移动</span></span><br><span class=\"line\"><span class=\"comment\">\t如果k小于链表的长度，则返回q指针指向的数据域 </span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(count&lt;k)<span class=\"comment\">//若k值大于链表的长度，则找不到该结点，返回0 </span></span><br><span class=\"line\">\t   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,q-&gt;data);<span class=\"comment\">//找到该结点则返回该结点的数据域 </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>综合【2012】假定采用带头结点的单链表保存单词，当两个单词有相同的后缀时，可共享相同的后缀存储空间，例如,”loading”和”being”的存储影像如下图所示。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-33.png\"  />\n\n<p>设str1和str2分别指向两个单词所在单链表的头结点，链表结点结构为<code>data|next</code>，请设计一个时间上尽可能高效的算法，找出由str1和str2所指向两个链表共同后缀的起始位置(如图中字符i所在结点的位置p)。要求:</p>\n<p>1)给出算法的设计思想</p>\n<p>2)根据设计思想，采用程序语言描述算法，关键之处给出注释</p>\n<p>3)说明你所设计算法的时间复杂度</p>\n<blockquote>\n<p>1)分别求出str1和str2所指的两个链表的长度m和n；<br>将两个链表以表尾对齐：令指针p、q分别指向str1和str2的头结点；如果m&gt;=n，则p指针先走，使p指向链表中的第m-n+1个结点；如果m&lt;n，则使q指针指向链表的第n-m+1个结点；即：使得指针p、q所指的结点到表尾的长度相等；<br>反复将指针q和q同步向后移动，当p、q指向同一位置时停止，即：共同后缀的起始位置。算法结束。<br>2）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span>&#123;</span></span><br><span class=\"line\"> <span class=\"type\">char</span> data;</span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;LNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//求链表的长度;</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">GetListLen</span><span class=\"params\">(LNode *head)</span>&#123;</span><br><span class=\"line\"> <span class=\"type\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\"> <span class=\"keyword\">while</span>(head-&gt;next != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">     len++;</span><br><span class=\"line\">     head = head-&gt;next;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//找出共同后缀的起始位置；</span></span><br><span class=\"line\">LNode* <span class=\"title function_\">find_addr</span><span class=\"params\">(LNode *str1,LNode *str2)</span>&#123;</span><br><span class=\"line\"> <span class=\"type\">int</span> m,n;</span><br><span class=\"line\"> m = GetListLen(str1);</span><br><span class=\"line\"> n = GetListLen(str2);</span><br><span class=\"line\"></span><br><span class=\"line\"> LNode *p,*q;</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(m &gt;= n)&#123;</span><br><span class=\"line\">     <span class=\"keyword\">for</span>(p = str1;m&gt;n;m--)&#123;</span><br><span class=\"line\">         p = p-&gt;next;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">for</span>(q = str2;n&gt;m;n--)&#123;</span><br><span class=\"line\">         q = q-&gt;next;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">//得到p和q的起始位置后，找出共同后缀的起始地址；</span></span><br><span class=\"line\"> <span class=\"keyword\">while</span>(p-&gt;next !=<span class=\"literal\">NULL</span> &amp;&amp; p-&gt;next != q-&gt;next)&#123;</span><br><span class=\"line\">     p = p-&gt;next;</span><br><span class=\"line\">     q = q-&gt;next;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> p-&gt;next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3)<strong>O(max(m,n))</strong>（m、n分别为两个链表的长度）；</p>\n</blockquote>\n</li>\n<li><p>综合【2015】用单链表保存m个整数，结点的结构为[data]|[link]，且|data|&lt;=n(n为正整数)。现要求设计一个时间复杂度尽可能高效的算法，对于链表中data的绝对值相等的结点，仅保留第一次出现的结点而删除其余绝对值相等的结点。例如，若给定的单链表head如下:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-34.png\" style=\"zoom:80%;\" />\n\n<p>则删除结点后的head为：</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-35.png\" style=\"zoom:80%;\" />\n\n<p>要求：  </p>\n<p>   1）给出算法的基本设计思想。  </p>\n<p>   2）使用C或C++语言，给出单链表结点的数据类型定义。  </p>\n<p>   3）根据设计思想，采用C或C++语言描述算法，关键之处给出注释。  </p>\n<p>   4）说明你所设计算法的时间复杂度和空间复杂度。</p>\n<blockquote>\n<p>1）算法的基本设计思想 </p>\n<p>算法的核心思想是用空间换时间。使用辅助数组记录链表中已出现的数值，从而只需对链表进行一趟扫描。 因为|data|≤n，故辅助数组q的大小为n+1，各元素的初值均为0。依次扫描链表中的各结点，同时检查q[|data|]的值，如果为0，则保留该结点，并令q[|data|]=1；否则，将该结点从链表中删除。 </p>\n<p>2）使用C语言描述的单链表结点的数据类型定义</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span></span><br><span class=\"line\"><span class=\"type\">int</span>         data;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>   *<span class=\"title\">link</span>;</span></span><br><span class=\"line\">&#125;NODE;</span><br><span class=\"line\">Typedef NODE *PNODE;</span><br></pre></td></tr></table></figure>\n\n<p>3）算法实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">func</span> <span class=\"params\">(PNODE h,<span class=\"type\">int</span> n)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">PNODE p=h,r;</span><br><span class=\"line\"><span class=\"type\">int</span> *q,m;</span><br><span class=\"line\">q=(<span class=\"type\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>)*(n+<span class=\"number\">1</span>));  <span class=\"comment\">//申请n+1个位置的辅助空间</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n+<span class=\"number\">1</span>;i++)                <span class=\"comment\">//数组元素初值置0</span></span><br><span class=\"line\">*(q+i)=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(p-&gt;link!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">m=p-&gt;link-&gt;data&gt;<span class=\"number\">0</span>? p-&gt;link-&gt;data:-p-&gt;link-&gt;data;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(*(q+m)==<span class=\"number\">0</span>)                      <span class=\"comment\">//判断该结点的data是否已出现过</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">*(q+m)=<span class=\"number\">1</span>;                      <span class=\"comment\">//首次出现</span></span><br><span class=\"line\">p=p-&gt;link;                     <span class=\"comment\">//保留</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span>                               <span class=\"comment\">//重复出现</span></span><br><span class=\"line\">&#123;   r=p-&gt;link;                     <span class=\"comment\">//删除</span></span><br><span class=\"line\">p-&gt;link=r-&gt;link</span><br><span class=\"line\"><span class=\"built_in\">free</span>(r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">free</span>(q);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4）时间复杂度为O(m)，空间复杂度为O(n)</p>\n</blockquote>\n</li>\n<li><p>【2019】设线性表L=(a1,a2,a3,…,a(n-2),a(n-1),an)采用带头结点的单链表保存，链表中的结点定义如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>* <span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125; NODE;</span><br></pre></td></tr></table></figure>\n\n<p>请设计一个空间复杂度为 <code>O(1)</code> 且时间上尽可能高效的算法，重新排列 L 中的各节点，得到线性表 <code>L&#39;=(a1, an, a2, a(n-1), a3, a(n-2), ...)</code>。要求:</p>\n<p>1)给出算法的设计思想</p>\n<p>2)根据设计思想，采用程序语言描述算法，关键之处给出注释</p>\n<p>3)说明你所设计算法的时间复杂度</p>\n<blockquote>\n<p>1)先观察L=(a1,a2,a3,…,a(n-2),a(n-1),an)和L’=(a1,an,a2,a(n-1),a3,a(n-2),…)，发现L’是由L摘取第一个元素，再摘取倒数第一个元素……依次合并而成的。为了方便链表后半段取元素，需要先将L后半段原地逆置[题目要求空间复杂度为O(1)，不能借助栈]，否则每取最后一个结点都需要遍历一次链表。1.先找出链表L的中间结点，为此设置两个指针p和q,指针p每次走一步，指针q每次走两步，当指针q到达链尾时，指针p正好在链表的中间结点；2.然后将L的后半段结点原地逆置。3.从单链表前后两段中依次各取一个结点，按要求重排。</p>\n<p>2)算法实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Change_list</span><span class=\"params\">(Linklist h)</span>&#123;</span><br><span class=\"line\">\tLNode *p,*q,*r,*s;</span><br><span class=\"line\">\tp=q=h;</span><br><span class=\"line\">\t<span class=\"comment\">/*双指针找链表的中点*/</span> </span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(q-&gt;next!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">\t\tp=p-&gt;next;\t\t\t\t\t<span class=\"comment\">//p走一步 </span></span><br><span class=\"line\">\t\tq=q-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(q-&gt;next!=<span class=\"literal\">NULL</span>)q=q-&gt;next; <span class=\"comment\">//q走两步 </span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">/*链表的逆置*/</span></span><br><span class=\"line\">\tq=p-&gt;next;\t\t\t<span class=\"comment\">//p所指结点为中点 </span></span><br><span class=\"line\">\tp-&gt;next=<span class=\"literal\">NULL</span>;\t\t<span class=\"comment\">//q为后半链表的首结点 </span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(q!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">\t\tr=q-&gt;next;</span><br><span class=\"line\">\t\tq-&gt;next=p-&gt;next;</span><br><span class=\"line\">\t\tp-&gt;next=q;</span><br><span class=\"line\">\t\tq=r;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">/*后半部分的链表头插进入前半部分*/</span></span><br><span class=\"line\">\ts=h-&gt;next;</span><br><span class=\"line\">\tq=p-&gt;next;</span><br><span class=\"line\">\tp-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(q!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">\t\tq-&gt;next=s-&gt;next;<span class=\"comment\">//将q所指结点插入到s所指结点之后 </span></span><br><span class=\"line\">\t\ts-&gt;next=q;</span><br><span class=\"line\">\t\ts=q-&gt;next;\t\t<span class=\"comment\">//将s指向前半段的下一个插入点 </span></span><br><span class=\"line\">\t\tq=r;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>3)第一步找中间结点的时间复杂度为O(n),第二步逆置的时间复杂度为O(n)，第3步合并链表的时间复杂度为O(n),所以该算法的时间复杂度为O(n)。</p>\n</blockquote>\n</li>\n</ul>\n","categories":["408数据结构"],"tags":["408数据结构"]},{"title":"第三章 栈、队列和数组(下)","url":"/p/58315/","content":"<h2 id=\"3-3-栈和队列的应用\"><a href=\"#3-3-栈和队列的应用\" class=\"headerlink\" title=\"3.3 栈和队列的应用\"></a>3.3 栈和队列的应用</h2><h3 id=\"栈在括号匹配中的应用\"><a href=\"#栈在括号匹配中的应用\" class=\"headerlink\" title=\"栈在括号匹配中的应用\"></a>栈在括号匹配中的应用</h3><h4 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h4><p>在我们写代码的过程中，不论是大括号、小括号，还是中括号，它们总是成双成对的出现的。</p>\n<p>我们如果只写了左括号，而没有写与它对应的右括号，那么编辑器就会检测出来错误。</p>\n<p>此外，左括号、右括号除了在数量上要匹配以外，在形状上也要匹配。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-53.png\" style=\"zoom:67%;\" />\n\n<p><strong>遇到左括号就入栈，遇到右括号就出栈</strong></p>\n<p>例如：扫描下方括号，碰到左括号就将其压入栈底，碰到右括号就将其出栈匹配</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-54.png\" style=\"zoom: 50%;\" />\n\n\n\n<p>这里的算法演示动画非常好理解：<a href=\"https://www.bilibili.com/video/BV1b7411N798?p=26\">王道考研 栈在括号匹配中的应用</a></p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-55.png\" style=\"zoom: 50%;\" />\n\n<p><strong>流程图</strong>:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-56.png\" style=\"zoom: 75%;\" />\n\n<h4 id=\"算法实现\"><a href=\"#算法实现\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 考试中可直接食用基本操作,建议简要说明接口</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 10\t\t\t\t\t\t\t<span class=\"comment\">// 定义栈中元素的最大个数</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span>\t\t\t\t\t\t\t    </span><br><span class=\"line\">    <span class=\"type\">char</span> data[MaxSize];\t\t\t\t\t\t<span class=\"comment\">// 静态数组存放栈中元素</span></span><br><span class=\"line\">    <span class=\"type\">int</span> top;\t\t\t\t\t\t\t\t<span class=\"comment\">// 栈顶指针</span></span><br><span class=\"line\">&#125;SqStack;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化栈</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitStack</span><span class=\"params\">(SqStack &amp;S)</span></span><br><span class=\"line\"><span class=\"comment\">// 判断栈是否为空</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">StackEmpty</span><span class=\"params\">(SqStack &amp;S)</span></span><br><span class=\"line\"><span class=\"comment\">// 新元素入栈</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Push</span><span class=\"params\">(SqStack &amp;S,<span class=\"type\">char</span> x)</span></span><br><span class=\"line\"><span class=\"comment\">// 栈顶元素出栈,用x返回</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Pop</span><span class=\"params\">(SqStack &amp;S,<span class=\"type\">char</span> &amp;x)</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 字符数组(存储括号字符)和字符数组长度  </span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">bracketCheck</span><span class=\"params\">(<span class=\"type\">char</span> str[],<span class=\"type\">int</span> length)</span>&#123;</span><br><span class=\"line\">    SqStack S;</span><br><span class=\"line\">    InitStack(S);\t\t\t\t\t\t\t<span class=\"comment\">// 初始化一个栈</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">0</span>; i &lt; length;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str[i] == <span class=\"string\">&#x27;(&#x27;</span> || str[i] == <span class=\"string\">&#x27;[&#x27;</span> || str[i] == <span class=\"string\">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class=\"line\">            Push(S.str[i]);\t\t\t\t\t<span class=\"comment\">// 扫描到左括号,入栈</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(StackEmpty(S))&#123;\t\t\t\t<span class=\"comment\">// 扫描到右括号,且当前栈空</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t\t\t\t<span class=\"comment\">// 匹配失败</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">char</span> topElem;</span><br><span class=\"line\">            Pop(S,topElem);\t\t\t\t\t<span class=\"comment\">// 栈顶元素出栈</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(str[i]==<span class=\"string\">&#x27;)&#x27;</span> &amp;&amp; topElem!= <span class=\"string\">&#x27;(&#x27;</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(str[i]==<span class=\"string\">&#x27;]&#x27;</span> &amp;&amp; topElem!= <span class=\"string\">&#x27;[&#x27;</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(str[i]==<span class=\"string\">&#x27;&#125;&#x27;</span> &amp;&amp; topElem!= <span class=\"string\">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> StackEmpty(S);\t\t\t\t\t<span class=\"comment\">// 检索完全部括号后,栈空说明匹配成功</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>注意一个小问题</strong>：</p>\n<p>由于我们要写的是括号匹配的算法实现，使用栈这种数据结构。</p>\n<p>关键是要说明其中通过栈进行括号匹配的算法逻辑。</p>\n<p>那么其中，栈的初始化、判空、入栈、出栈等操作，就可以不写详细细节，而直接使用。但是还是要简要声明操作函数的接口。用注释讲明其大概作用</p>\n</blockquote>\n<p>这种方法是用<strong>顺序存储</strong>的方式，有可能存满。其实实际开发的时候还是使用链栈为好。但是在考试的时候，使用顺序栈去写会更简单，也没什么问题。</p>\n<h3 id=\"栈在表达式求值中的应用\"><a href=\"#栈在表达式求值中的应用\" class=\"headerlink\" title=\"栈在表达式求值中的应用\"></a>栈在表达式求值中的应用</h3><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-57.png\" style=\"zoom:67%;\" />\n\n<p><strong>前缀表达式</strong>：前缀表达式(也叫波兰表达式)，运算符在两个操作数<strong>前面</strong></p>\n<p><strong>后缀表达式</strong>：后缀表达式(也叫逆波兰表达式)，运算符在两个操作数<strong>后面</strong></p>\n<p><strong>中缀表达式</strong>：运算符在两个操作数中间</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-58.png\" style=\"zoom:67%;\" />\n\n<p><font color='cornflowerblue'>这里做一下解释：例如中缀表达式为：a + b - c</font></p>\n<p><strong>后缀表达式计算</strong>：</p>\n<ul>\n<li><p>我们可以先计算 a + b，转换为后缀表达式为 ab+，再将 ab+ 作为一个整体与 c 进行减法操作，(ab+)-c</p>\n<p>转换为后缀表达式为 ab+c-</p>\n</li>\n<li><p>我们也可以先计算 b - c，转换为后缀表达式为 bc-，再将 bc- 作为一个整体与 a 进行加法操作，a+(bc-)</p>\n<p>转换为后缀表达式为 abc-+</p>\n</li>\n</ul>\n<blockquote>\n<p>这两个后缀表达式的结果，肯定都是正确的，表达的都是同一个中缀表达式。</p>\n<p>但是，如果我们要用计算机来实现中缀转后缀的算法的话，我们只应该得到一种输出结果（因为算法应该具有确定性，即同样的输入只能得到同样的输出），那么实际上，用算法实现的结果，应该是前一种后缀表达式的结果。</p>\n<p>以下几种情况同理。<strong>那么，怎样能够保证得到的是前一种后缀表达式的结果呢？</strong>接下来要提到“左优先“原则。</p>\n</blockquote>\n<p><strong>前缀表达式计算</strong>：</p>\n<ul>\n<li><p>我们可以先计算 a + b，转换为前缀表达式为 +ab，再将 +ab 作为一个整体与 c 进行减法操作，(+ab)-c</p>\n<p>转换为前缀表达式为 -+abc</p>\n</li>\n<li><p>我们也可以先计算 b - c,转换为前缀表达式为 -bc，再将 -bc 作为一个整体与 a 进行加法操作，a+(-bc)</p>\n<p>转换为前缀表达式为 +a-bc</p>\n</li>\n</ul>\n<p><font color='orange'>这里做一下解释：例如中缀表达式为：a + b - c * d</font></p>\n<p><strong>后缀表达式计算</strong>：</p>\n<ul>\n<li>我们可以先计算 a + b，转换为后缀表达式为 ab+，再接着计算 c * d，转换为后缀表达式为 cd* ，接着让 ab+ 和 cd * 分别作为两个整体进行减法操作，(ab+)-(cd*) 转换为后缀表达式为 ab+cd *-</li>\n</ul>\n<p><strong>前缀表达式计算</strong>：</p>\n<ul>\n<li>我们可以先计算 a + b，转换为前缀表达式为 +ab，再接着计算 c * d，转换为前缀表达式为 <em>cd，接着让 +ab 和 cd * 分别作为两个整体进行减法操作，(+ab)-(</em>cd) 转换为前缀表达式为 -+ab *cd</li>\n</ul>\n<h4 id=\"中缀表达式转后缀表达式\"><a href=\"#中缀表达式转后缀表达式\" class=\"headerlink\" title=\"中缀表达式转后缀表达式\"></a>中缀表达式转后缀表达式</h4><p><strong>方法</strong>：</p>\n<ol>\n<li>确定中缀表达式中各个运算符的运算顺序</li>\n<li>选择下一个运算符，按照 [<strong>左操作数 右操作数 运算符</strong>] 的方式组合成一个新的操作数</li>\n</ol>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-59.png\" style=\"zoom: 85%;\" />\n\n<ul>\n<li><p>左优先原则：只要左边的运算符能先计算，就优先算左边的。</p>\n</li>\n<li><p>我们知道运算符的运算顺序不唯一，对应的后缀表达式也不唯一。但是如果我们遵从左优先原则，那么就可以保证对应的后缀表达式唯一，而且机算也是按照左优先原则，这样我们就可以保证手算和机算的结果相同。</p>\n</li>\n<li><p>例如如下案例：</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-60.png\" style=\"zoom:69%;\" />\n\n</li>\n</ul>\n<h5 id=\"后缀表达式的手算\"><a href=\"#后缀表达式的手算\" class=\"headerlink\" title=\"后缀表达式的手算\"></a>后缀表达式的手算</h5><p><font color='orange'>我们将中缀表达式转换为后缀表达式，我们怎么计算这个后缀表达式呢？</font></p>\n<p><font color='cornflowerblue'>计算方法：从左往右扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对应运算，合体为一个操作数。</font></p>\n<p>我们来看一个例子</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-61.png\" style=\"zoom:67%;\" />\n\n<p>如上图后缀表达式</p>\n<ul>\n<li>我们从左向右扫描，先扫描到 ➕ 号，我们让 ➕ 号前面最近的两个操作数执行 ➕ 运算，合体为 2，于是变为 <ul>\n<li>15 7 2 ➖ ➗ 3 ✖ 2 1 1 ➕ ➕ ➖</li>\n</ul>\n</li>\n<li>我们继续将上述后缀表达式从左向右扫描，先扫描到 ➖ ，我们让 ➖ 前面最近的两个操作数执行 ➖ 运算，合体为 5<ul>\n<li>15 5 ➗ 3 ✖ 2 1 1 ➕ ➕ ➖</li>\n</ul>\n</li>\n<li>我们继续将上述后缀表达式从左向右扫描，先扫描到 ➗，我们让 ➗ 前面最近的两个操作数执行 ➗ 运算，合体为 3<ul>\n<li>3 3 ✖ 2 1 1 ➕ ➕ ➖</li>\n</ul>\n</li>\n<li>我们继续将上述后缀表达式从左向右扫描，先扫描到 ✖，我们让 ✖ 前面最近的两个操作数执行 ✖ 运算，合体为 9<ul>\n<li>9 2 1 1 ➕ ➕ ➖</li>\n</ul>\n</li>\n<li>我们继续将上述后缀表达式从左向右扫描，先扫描到 ➕，我们让 ➕ 前面最近的两个操作数执行 ➕ 运算，合体为 2<ul>\n<li>9 2 2 ➕ ➖</li>\n</ul>\n</li>\n<li>我们继续将上述后缀表达式从左向右扫描，先扫描到 ➕，我们让 ➕ 前面最近的两个操作数执行 ➕ 运算，合体为 4<ul>\n<li>9 4 ➖</li>\n</ul>\n</li>\n<li>最后从左向右扫描，扫描到 ➖，我们让 ➖ 前面最近的两个操作数执行 ➖ 运算，合体为 5<ul>\n<li>5</li>\n</ul>\n</li>\n<li>所以最终结果为 5</li>\n</ul>\n<h5 id=\"后缀表达式的机算\"><a href=\"#后缀表达式的机算\" class=\"headerlink\" title=\"后缀表达式的机算\"></a>后缀表达式的机算</h5><p>我们让运算符前面最近的两个操作数执行对应运算，最后出现的操作数最先被运算，这符合栈<strong>后进先出</strong>的特点，所以我们机算后缀表达式是用栈实现的。步骤如下:</p>\n<p>①从左往右扫描下一个元素，直到处理完所有元素。</p>\n<p>②若扫描到操作数，则压入栈，并回到①；否则执行③。</p>\n<p>③若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到①。</p>\n<p>例如：</p>\n<ol>\n<li><p>我们扫描如图的后缀表达式，扫描到 A，压入栈，扫描到 B，压入栈</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-62.png\" style=\"zoom:67%;\" />\n</li>\n<li><p>扫描到运算符 +，弹出两个栈顶元素 B、A，执行 + 运算，A + B，再将运算结果压入栈顶</p>\n<ul>\n<li>注意,<font color='orange'>先出栈的是右操作数</font>，这里 B 先出栈，所以 B 为右操作数</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-63.png\" style=\"zoom:67%;\" />\n</li>\n<li><p>接着继续从左向右扫描，扫描到 C，压入栈，扫描到 D，压入栈。</p>\n<p>扫描到运算符 *，弹出两个栈顶元素 D、C，执行 * 运算，C * D，再将运算结果压入栈顶</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-64.png\" style=\"zoom:67%;\" />\n</li>\n<li><p>接着继续从左向右扫描，扫描到 E，压入栈中。</p>\n<p>扫描到运算符 / ，弹出栈顶元素 E、C*D，执行 / 运算，(C * D)/E，再将结果压入栈顶</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-65.png\" style=\"zoom:67%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-66.png\" style=\"zoom:67%;\" />\n</li>\n<li><p>接着扫描到运算符 -，弹出两个栈顶元素 (C * D)/E 、A+B，执行 - 操作，(A+B)-((C*D)/E)</p>\n<p>将运算结果压入栈顶</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-67.png\" style=\"zoom:67%;\" />\n</li>\n<li><p>接着从左向右扫描，扫描到 F ，压入栈</p>\n<p>扫描到运算符 +，弹出两个栈顶元素 F、(A+B)-((C*D)/E)，执行 + 操作，(A+B)-((C * D)/E) + F</p>\n<p>将结果压入栈顶</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-68.png\" style=\"zoom:67%;\" />\n</li>\n<li><p>若表达式合法，则最后栈中只会留下一个元素，就是后缀表达式的最终结果</p>\n</li>\n</ol>\n<blockquote>\n<p>由于本例中的元素均设成未知数，所以最后计算出的后缀表达式的结果是一个中缀表达式。若有具体数的话则栈中只会有一个元素，即为运算结果。这种后缀表达式的机算方式可以粗略理解为将后缀转中缀后再计算。</p>\n</blockquote>\n<p><font color='red'>所以其实人喜欢看中缀表达式，计算机更喜欢看后缀表达式。</font></p>\n<h4 id=\"后缀表达式转中缀表达式\"><a href=\"#后缀表达式转中缀表达式\" class=\"headerlink\" title=\"后缀表达式转中缀表达式\"></a>后缀表达式转中缀表达式</h4><p><font color='cornflowerblue'>我们知道了中缀表达式转换后缀表达式，那么后缀表达式如何转换为中缀表达式呢？</font></p>\n<p>从左往右扫描，每遇到一个运算符，就让<font color='orange'>运算符插入前面最近的两个操作数之间，然后操作数两边带上括号</font></p>\n<p>我们来看一个例子:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-69.png\" style=\"zoom:67%;\" />\n\n<p>如上图后缀表达式:</p>\n<ol>\n<li>从左向右扫描，先扫描到运算符 ➕ ，变为栈在递归中的应用<ul>\n<li>15 7 (1+1) ➖ ➗ 3 ✖ 2 1 1 ➕ ➕ ➖</li>\n</ul>\n</li>\n<li>接着继续从左到右扫描，先扫描到运算符 ➖<ul>\n<li>15 (7-(1+1)) ➗ 3 ✖ 2 1 1 ➕ ➕ ➖</li>\n</ul>\n</li>\n<li>接着继续从左到右扫描，先扫描到运算符 ➗<ul>\n<li>( 15 ÷ (7-(1+1)) ) 3 ✖ 2 1 1 ➕ ➕ ➖</li>\n</ul>\n</li>\n<li>接着继续从左到右扫描，先扫描到运算符 ✖<ul>\n<li>(( 15 ÷ (7-(1+1)) ) * 3) 2 1 1 ➕ ➕ ➖</li>\n</ul>\n</li>\n<li>接着继续从左到右扫描，先扫描到运算符 ➕<ul>\n<li>(( 15 ÷ (7-(1+1)) ) * 3) 2 (1+1) ➕ ➖</li>\n</ul>\n</li>\n<li>接着继续从左到右扫描，先扫描到运算符 ➕<ul>\n<li>(( 15 ÷ (7-(1+1)) ) * 3) (2+(1+1)) ➖</li>\n</ul>\n</li>\n<li>接着继续从左到右扫描，先扫描到运算符 ➖<ul>\n<li>(( 15 ÷ (7-(1+1)) ) * 3) - (2+(1+1))</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"中缀表达式转前缀表达式\"><a href=\"#中缀表达式转前缀表达式\" class=\"headerlink\" title=\"中缀表达式转前缀表达式\"></a>中缀表达式转前缀表达式</h4><ul>\n<li><p>①确定中缀表达式中<strong>各个运算符的运算顺序</strong>。</p>\n</li>\n<li><p>②选择下一个运算符，按照「<strong>运算符 左操作数 右操作数</strong>」的方式组合成一个新的操作数。</p>\n</li>\n<li><p>③如果还有运算符没被处理，就继续②。</p>\n</li>\n</ul>\n<p>注意:</p>\n<ul>\n<li><p>中缀表达式转后缀表达式是 <strong>左优先</strong> 原则</p>\n</li>\n<li><p>中缀表达式转前缀表达式是 <strong>右优先</strong> 原则</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-70.png\" style=\"zoom: 50%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-71.png\" style=\"zoom: 50%;\" />\n\n</li>\n</ul>\n<p>右优先原则：只要右边的运算符能先机算，就优先算右边的</p>\n<h5 id=\"前缀表达式的机算\"><a href=\"#前缀表达式的机算\" class=\"headerlink\" title=\"前缀表达式的机算\"></a>前缀表达式的机算</h5><p>用栈实现前缀表达式的计算：</p>\n<ul>\n<li><p>①<strong>从右往左</strong>扫描下一个元素，直到处理完所有元素。</p>\n</li>\n<li><p>②若扫描到操作数，则压入栈，并回到①；否则执行③。</p>\n</li>\n<li><p>③若扫描到运算符，则弹出两个栈顶元素，执行响应运算，运算结果压回栈顶，回到①。</p>\n</li>\n</ul>\n<p><strong>注意</strong>：先出栈的是“左操作数”。</p>\n<h4 id=\"中缀表达式转后缀表达式机算\"><a href=\"#中缀表达式转后缀表达式机算\" class=\"headerlink\" title=\"中缀表达式转后缀表达式机算\"></a>中缀表达式转后缀表达式机算</h4><p>初始化一个栈，用于<font color='orange'>保存暂时还不能确定运算顺序的运算符</font>。</p>\n<p>从左到右处理各个元素，直到末尾。可能遇到三种情况：</p>\n<ol>\n<li>遇到<strong>操作数</strong>。直接加入后缀表达式</li>\n<li>遇到<strong>界限符</strong>。遇到左括号 <code>(</code> 直接入栈；遇到右括号 <code>)</code> 则依次弹出栈内运算符并加入后缀表达式，直到弹出左括号<code>(</code> 为止。注意：左括号<code>(</code> 不加入后缀表达式。</li>\n<li>遇到<strong>运算符</strong>。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到 <code>(</code> 或栈空则停止。之后再把当前运算符入栈。</li>\n</ol>\n<p>按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</p>\n<hr>\n<p>我们来看一下例子：</p>\n<ol>\n<li><p>如下图的中缀表达式转后缀表达式，从左到右扫描</p>\n<ul>\n<li>先扫描到操作数 A，直接加入后缀表达式</li>\n<li>再扫描到运算符 ➕，由于栈是空栈，所以将运算符 ➕ 入栈</li>\n<li>再扫描到操作数 B，直接加入后缀表达式</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-72.png\" style=\"zoom:70%;\" />\n</li>\n<li><p>继续从左到右扫描</p>\n<ul>\n<li>扫描到运算符 ➖，此时栈中有运算符 ➕，加号和减号的运算符优先级相同，则弹出 ➕，并加入后缀表达式，此时后缀表达式为 AB+，此时栈空，将运算符 ➖ 入栈</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-73.png\" style=\"zoom:70%;\" />\n</li>\n<li><p>继续从左到右扫描</p>\n<ul>\n<li>扫描到操作数 C，直接加入后缀表达式，此时后缀表达式为 AB+C</li>\n<li>扫描到运算符 <code>*</code> ，栈中此时只有 ➖ 减法运算符，没有比乘法运算符优先级高的，所以将 <code>*</code> 压入栈中</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-74.png\" style=\"zoom:70%;\" />\n</li>\n<li><p>继续从左到右扫描</p>\n<ul>\n<li>扫描到操作数 D，直接加入后缀表达式，此时后缀表达式为 AB+CD</li>\n<li>扫描到运算符<code>/</code>，此时栈中有 <code>*</code> <code>-</code> 两个运算符，乘法运算符和除法运算符优先级相同，所以将 <code>*</code> 乘法运算符弹出，并加入后缀表达式，此时后缀表达式为 AB+CD*</li>\n<li>此时栈中只剩下 <code>-</code> 减法运算符，没有比 <code>/</code> 除法运算符优先级更高或相同的了，所以将 <code>/</code> 除法运算符压入栈中</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-75.png\" style=\"zoom:70%;\" />\n</li>\n<li><p>继续从左到右扫描</p>\n<ul>\n<li>扫描到操作数 E，直接加入后缀表达式，此时后缀表达式为 AB+CD*E</li>\n<li>扫描到运算符 ➕，此时栈中有 <code>/</code> <code>-</code> 两个运算符，依次弹出栈中优先级高于或等于 ➕ 加号运算符的所有运算符，所以将 <code>/</code> <code>-</code> 依次弹出并加入后缀表达式，此时后缀表达式为 AB+CD*E/-</li>\n</ul>\n</li>\n<li><p>继续从左到右扫描</p>\n<ul>\n<li>扫描到操作数 F，直接加入后缀表达式，此时后缀表达式为 AB+CD*E/-F</li>\n<li>扫描完成，将栈中剩余运算符弹出栈并加入后缀表达式，所以弹出 ➕ 运算符并加入后缀表达式，最终后缀表达式为AB+CD*E/-F+</li>\n</ul>\n</li>\n</ol>\n<hr>\n<p><strong>我们接着来看一个带有界限符的例子</strong>：</p>\n<ol>\n<li><p>如下图的中缀表达式转后缀表达式，从左到右扫描</p>\n<ul>\n<li>扫描到操作数 A， 直接加入后缀表达式。</li>\n<li>扫描到运算符 ➕，此时栈为空，所以入栈。</li>\n<li>扫描到操作数 B，直接加入后缀表达式。</li>\n<li>扫描到运算符 <code>*</code> ，此时栈中只有加法运算符 ➕，没有比 <code>*</code> 乘法运算符优先级更高或相同的，所以将 <code>*</code> 入栈。</li>\n<li>扫描到左括号 <code>(</code> ，直接入栈。</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-76.png\" style=\"zoom:67%;\" />\n</li>\n<li><p>继续从左到右扫描</p>\n<ul>\n<li>扫描到操作数 C，直接加入后缀表达式。</li>\n<li>扫面描到运算符 ➖，此时本该依次弹出运算符高于或等于 ➖ 运算符的所有运算符，但是由于碰到了左括号<code>(</code> ，所以停止进行弹出。将 ➖ 减法运算符压入栈中。</li>\n<li>扫描到操作数 D，直接加入后缀表达式。</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-77.png\" style=\"zoom: 67%;\" />\n</li>\n<li><p>继续从左到右扫描</p>\n<ul>\n<li>扫描到右括号 <code>)</code> ，则依次弹出栈内运算符并加入后缀表达式，直到遇到左括号 <code>(</code> 为止。</li>\n<li>所以先弹出 ➖ 运算符，加入后缀表达式。</li>\n<li>再弹出左括号<code>(</code> ，但是<strong>左括号不加入后缀表达式</strong>。</li>\n<li>所以此时后缀表达式为 ABCD-。</li>\n<li>此时栈中运算符有 <code>*</code> <code>+</code>。</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-78.png\" style=\"zoom:67%;\" />\n</li>\n<li><p>继续从左到右扫描</p>\n<ul>\n<li>扫描到 ➖ 运算符，依次弹出优先级高于或者等于 ➖ 运算符并加入后缀表达式中</li>\n<li>所以将 <code>*</code> <code>+</code> 运算符弹出并加入后缀表达式，此时后缀表达式为 ABCD-*+</li>\n<li>然后将扫描到的 ➖ 运算符加入栈中</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-79.png\" style=\"zoom:67%;\" />\n</li>\n<li><p>继续从左到右扫描</p>\n<ul>\n<li>扫描到操作数 E，直接加入后缀表达式</li>\n<li>扫描到运算符 <code>/</code> ，栈中没有优先级高于或者等于 <code>/</code> 除法运算符的，所以将 <code>/</code> 压入栈</li>\n<li>扫描到 F，直接加入后缀表达式，此时后缀表达式为 ABCD-*+EF</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-80.png\" style=\"zoom:67%;\" />\n</li>\n<li><p>最后将栈中剩余运算符依次弹出，并加入后缀表达式</p>\n<ul>\n<li>所以最终的后缀表达式为：ABCD-*+EF/-</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"中缀表达式的计算-用栈实现\"><a href=\"#中缀表达式的计算-用栈实现\" class=\"headerlink\" title=\"中缀表达式的计算(用栈实现)\"></a>中缀表达式的计算(用栈实现)</h4><p>用栈实现中缀表达式的计算</p>\n<p>初始化两个栈，<strong>操作数栈</strong>和<strong>运算符栈</strong>。</p>\n<ul>\n<li>若扫描到操作数，则压入操作数栈</li>\n<li>若扫描到运算符或界限符，则按照 “中缀转后缀” 相同的逻辑压入运算符栈(<font color='orange'>期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈</font>)</li>\n</ul>\n<hr>\n<p>我们来看一个例子:</p>\n<ol>\n<li><p>我们从左向右扫描中缀表达式</p>\n<ul>\n<li>扫描到操作数 A，压入操作数栈</li>\n<li>扫描到运算符 ➕，此时栈为空，则压入栈</li>\n<li>扫描到操作数 B，压入操作数栈</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-81.png\" style=\"zoom:67%;\" />\n</li>\n<li><p>继续从左向右扫描</p>\n<ul>\n<li>扫描到运算符 ➖，弹出栈中优先级高于或等于 ➖ 运算符的所有运算符<ul>\n<li>所以弹出 ➕ 运算符，并将扫描到的运算符 ➖ 压入运算符栈</li>\n</ul>\n</li>\n<li>每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈<ul>\n<li>所以弹出 B、A，运算结果为 A + B，然后将运算结果压回操作数栈。</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-82.png\" style=\"zoom:67%;\" />\n</li>\n<li><p>继续从左向右扫描</p>\n<ul>\n<li>扫面描到操作数 C，压入操作数栈中</li>\n<li>扫描到运算符 <code>*</code> ，运算符栈中没有优先级高于或者等于 <code>*</code> 乘法运算符的，所以将 <code>*</code> 压入运算符栈</li>\n<li>扫描到操作数 D，压入操作数栈中</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-83.png\" style=\"zoom:67%;\" />\n</li>\n<li><p>继续从左向右扫描</p>\n<ul>\n<li>扫描到运算符 <code>/</code>，弹出运算符优先级高于或者等于 <code>/</code> 除号运算符的所有运算符，并将扫描到的 <code>/</code> 压入运算符栈</li>\n<li>运算符栈中此时有 <code>*</code> <code>-</code> 两个运算符，所以弹出 <code>*</code> 乘法运算符</li>\n<li>每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈</li>\n<li>所以弹出 D、C 两个操作数，并执行 * 运算，运算结果为 C * D，将运算结果压入操作数栈中</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-84.png\" style=\"zoom:67%;\" />\n</li>\n<li><p>继续从左向右扫描</p>\n<ul>\n<li>扫描到操作数 E，直接压入操作数栈</li>\n<li>扫描到运算符 ➕，弹出运算符优先级高于或者 ➕ 加法运算符的所有运算符，并将扫描到的运算符 ➕ 压入运算符栈</li>\n<li>所以将 / 除法运算符弹出，一个运算符弹出则需要两个操作数栈的栈顶元素弹出，运算结果为 (C*D)/E，然后将运算结果压入操作数栈</li>\n<li>之后将 - 减法运算符弹出，一个一个运算符弹出则需要两个操作数栈的栈顶元素弹出，运算结果为 (A+B)-((C*D)/E) ,然后将运算结果压入操作数栈</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-85.png\" style=\"zoom:67%;\" />\n</li>\n<li><p>继续从左向右扫描</p>\n<ul>\n<li>扫描到操作数 F，直接压入操作数栈</li>\n<li>扫描中缀表达式完成，运算符栈中还有 ➕ 运算符，弹出 ➕ 运算符，对应弹出两个操作数栈的栈顶元素进行计算，则最终结果为 (A+B)-((C*D)/E)+F</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"栈在递归中的应用\"><a href=\"#栈在递归中的应用\" class=\"headerlink\" title=\"栈在递归中的应用\"></a>栈在递归中的应用</h3><p><strong>函数调用的特点</strong>：最后被调用的函数最先执行结束(LIFO)</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-86.png\" style=\"zoom:75%;\" />\n\n<p>例如，对于上述函数调用</p>\n<ol>\n<li>开始运行main函数，将main函数里面的返回地址、实参、局部变量先压入栈中</li>\n<li>执行func1函数，将其返回地址、实参、局部变量再压入栈中</li>\n<li>执行func2函数，将其返回地址、实参、局部变量再压入栈中</li>\n</ol>\n<hr>\n<p>计算正整数的阶乘n！</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-87.png\" style=\"zoom:67%;\" />\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 计算正整数的阶乘n！</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">factorial</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n==<span class=\"number\">0</span> || n==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n*factorial(n<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x = factorial(<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(x);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>递归算法可以把原始问题转换为属性相同，但规模较小的问题</p>\n<p>每进入一层递归，就将递归调用所需信息压入栈顶；每退出一层递归，就从栈顶弹出相应信息</p>\n<p><strong>缺点</strong>：太多层递归可能会导致栈溢出</p>\n<h3 id=\"队列在层次遍历中的应用\"><a href=\"#队列在层次遍历中的应用\" class=\"headerlink\" title=\"队列在层次遍历中的应用\"></a>队列在层次遍历中的应用</h3><p>树的层次遍历(在”树”章节)</p>\n<p>图的层次遍历(在”图”章节)</p>\n<h3 id=\"队列在操作系统中的应用\"><a href=\"#队列在操作系统中的应用\" class=\"headerlink\" title=\"队列在操作系统中的应用\"></a>队列在操作系统中的应用</h3><p>多个进程争抢着使用有限的系统资源时，FCFS(First Come First Service,<strong>先来先服务</strong>)是一种常用策略</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-88.png\" style=\"zoom:67%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-89.png\" style=\"zoom:67%;\" />\n\n<h3 id=\"习题\"><a href=\"#习题\" class=\"headerlink\" title=\"习题\"></a>习题</h3><ul>\n<li><p>【2009】为解决计算机主机与打印机之间速度不匹配的问题，通常设置一个打印数据缓冲区，主机将要输出的数据依次写入该缓冲区，而打印机则依次从该缓冲区中取出数据。该缓冲区的逻辑结构应该是→B</p>\n<p>A 栈<br>B 队列<br>C 树<br>D 图 </p>\n<blockquote>\n<p>这是典型的一种队列结构，一端放入另一端依次取出，也就是先进入的先取出</p>\n</blockquote>\n</li>\n<li><p>执行什么操作时，需要使用队列作为辅助存储空间→B</p>\n<p>A 查找散列（哈希）表<br>B 广度优先搜索图<br>C 前序（根）遍历二叉树<br>D 深度优先搜索图 </p>\n</li>\n<li><p>【2012】已知操作符包括+、-、_、/、(和)。将中缀表达式<code>a + b - a * ( ( c + d) / e - f ) + g</code>转换为等价的后缀表达式<code>a b + a c d + e / f - * - g +</code>时，用栈来存放暂时还不能确定运算次序的操作符。若栈初始为空，则转换过程中同时保存在栈中的操作符的最大个数是 →5</p>\n<blockquote>\n<p>写成伪代码是这样：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">stack</span> 操作符栈;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i=<span class=\"number\">1</span> to n&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> 当前操作符是操作数</span><br><span class=\"line\">\t\t直接打印;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> 当前操作符是操作符&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> 当前操作符是<span class=\"string\">&#x27;(&#x27;</span></span><br><span class=\"line\">\t\t\t压入栈内;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> 当前操作符是<span class=\"string\">&#x27;)&#x27;</span></span><br><span class=\"line\">\t\t\t不断弹出并打印栈顶元素直至栈顶为<span class=\"string\">&#x27;(&#x27;</span>;</span><br><span class=\"line\">\t\t\t弹出栈顶;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> 当前操作符优先级高于栈顶操作符 || 栈为空</span><br><span class=\"line\">\t\t\t压入栈内;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t不断弹出并打印栈顶元素直至栈顶优先级不大于当前元素;</span><br><span class=\"line\">\t\t\t当前操作符入栈;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">打印栈中剩余操作符; </span><br></pre></td></tr></table></figure>\n\n<p>优先级从低至高：(、+、-、*、/、^</p>\n<p>回到本题，流程如下：（数字标明当前栈中元素个数）</p>\n<ol>\n<li>遇+，入栈，1个</li>\n<li>遇-，-的优先级不大于+，弹出+，压入-，1个</li>\n<li>遇 *， * 的优先级大于-，入栈，2个</li>\n<li>遇(，入栈，3个</li>\n<li>遇(，入栈，4个</li>\n<li>遇+，+的优先级大于(，入栈，5个</li>\n<li>遇)，弹出+，弹出(，3个</li>\n<li>遇/，/的优先级大于(，入栈，4个</li>\n<li>遇-，-的优先级不大于/，弹出/，压入-，4个</li>\n<li>遇)，弹出-，弹出(，2个</li>\n<li>遇+，+的优先级不大于*，弹出 *，压入+，2个</li>\n</ol>\n<p>操作符遍历完毕，栈中最后自底而上为-和+，依次弹出。</p>\n<p>综上，栈中元素最多的时候有5个</p>\n</blockquote>\n</li>\n<li><p>【2014】假设栈初始为空，将中缀表达式 <code>a / b + ( c * d - e * f ) / g</code> 转化为等价 的后缀表达式的过程中，当扫描到 f 时，栈中的元素依次是 →<code>+ ( - *</code></p>\n<blockquote>\n<p>将中缀表达式转换为后缀表达式的算法思想如下：从左向右开始扫描中缀表达式；  </p>\n<p>遇到数字时，加入后缀表达式；遇到运算符时：  </p>\n<p>a. 若为’(‘，入栈；  </p>\n<p>b. 若为’)’，则依次把栈中的的运算符加入后缀表达式中，直到出现’(‘，从栈中删除’(‘ ；  </p>\n<p>c. 若为除括号外的其他运算符，当其优先级高于除’(‘以外的栈顶运算符时，直接入栈。否则从栈顶开始，依次弹出比当前处理的运算符优先级高和优先级相等的运算符，直到一个比它优先级低的或者遇到了一个左括号为止。  </p>\n<p>当扫描的中缀表达式结束时，栈中的所有运算符依次出栈加入后缀表达式。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-90.png\" style=\"zoom:67%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-91.png\" style=\"zoom: 80%;\" />\n\n<p>由此可知，当扫描到f 的时候，栈中的元素依次是+(-*，选B。 </p>\n<p>在此，再给出中缀表达式转换为前缀或后缀表达式的一种手工做法，以上面给出的中缀表达式为例： </p>\n<p>第一步：按照运算符的优先级对所有的运算单位加括号。式子变成了：<code>((a/b)+(((c*d)-(e*f))/g))</code> </p>\n<p>第二步：转换为前缀或后缀表达式。 </p>\n<p>前缀：把运算符号移动到对应的括号前面，则变成了：<code>+(/(ab)/(-(*(cd)*(ef))g))</code> 把括号去掉：<code>+/ab/-*cd*efg</code> 前缀式子出现。 </p>\n<p>后缀：把运算符号移动到对应的括号后面，则变成了：<code>((ab)/(((cd)*(ef)*)-g)/)+</code> 把括号去掉：<code>ab/cd*ef*-g/+</code> 后缀式子出现。 </p>\n<p>当题目要求直接求前缀或后缀表达式时，这种方法会比上一种快捷得多。</p>\n</blockquote>\n</li>\n<li><p>【2015】已知程序如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">S</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n&lt;=<span class=\"number\">0</span>)?<span class=\"number\">0</span>:s(n<span class=\"number\">-1</span>) +n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;S(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>程序运行时使用栈来保存调用过程的信息，自栈底到栈顶保存的信息依次对应的是-&gt;</p>\n<p>main()→S(1)→S(0)</p>\n<blockquote>\n<p>1.程序执行顺序main()-&gt;S(1)-&gt;S(2)。 </p>\n<p>2.函数在调用过程中PC（程序计数器）的操作是保护现场-&gt;将所有数据拷贝到栈-&gt;跳转到子函数 </p>\n<p>3.根据栈的数据结构的特点（首先栈的数据结构是处理函数调用这个情况最好的办法），先入后出，因此，栈底为main()，栈顶为S(1)</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"3-4-特殊矩阵和压缩存储\"><a href=\"#3-4-特殊矩阵和压缩存储\" class=\"headerlink\" title=\"3.4 特殊矩阵和压缩存储\"></a>3.4 特殊矩阵和压缩存储</h2><h3 id=\"数组的存储结构\"><a href=\"#数组的存储结构\" class=\"headerlink\" title=\"数组的存储结构\"></a>数组的存储结构</h3><h4 id=\"一维数组的存储结构\"><a href=\"#一维数组的存储结构\" class=\"headerlink\" title=\"一维数组的存储结构\"></a>一维数组的存储结构</h4><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-92.png\" style=\"zoom:67%;\" />\n\n<p>各数组元素大小相同，且物理上连续存放。</p>\n<p>因此，只需要知道其起始地址，就可以知道任何一个数组下标所对应元素的存放地址是多少。</p>\n<h4 id=\"二维数组的存储结构\"><a href=\"#二维数组的存储结构\" class=\"headerlink\" title=\"二维数组的存储结构\"></a>二维数组的存储结构</h4><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-93.png\" style=\"zoom:67%;\" />\n\n<p>在内存空间中存储时，由于要进行线性存储，因此要将逻辑上的非线性给改变为线性的存储模式。因此，有两种存储策略：<strong>行优先存储</strong>、<strong>列优先存储</strong>。</p>\n<ul>\n<li>行优先：先存行，一行存完存第二行</li>\n<li>列优先：先存列，一列存完存第二列</li>\n</ul>\n<p><font color='orange'>我们采用行优先或者列优先的存储方式存放二维数组，这样我们就可以通过二维数组的行号和列号来计算出这个元素所对应的存储地址。</font></p>\n<h5 id=\"行优先\"><a href=\"#行优先\" class=\"headerlink\" title=\"行优先\"></a>行优先</h5><p>我们来看行优先的一个例子</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-94.png\" style=\"zoom:70%;\" />\n\n<p>(i*N+j)指的是 b[i] [j] 之前有多少个元素，每个元素再乘存储空间，就是 b[i] [j] 元素前面的存储空间</p>\n<p>再加上起始地址 LOC，就得到 b[i] [j] 的存储地址</p>\n<h5 id=\"列优先\"><a href=\"#列优先\" class=\"headerlink\" title=\"列优先\"></a>列优先</h5><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-95.png\" style=\"zoom:70%;\" />\n\n<p>(j*M+i)指的是 b[i] [j] 之前有多少个元素, 每个元素再乘存储空间，就是 b[i] [j] 元素前面的存储空间</p>\n<p>再加上起始地址 LOC，就得到 b[i] [j] 的存储地址</p>\n<blockquote>\n<p>M行N列的二维数组<code>b[M][N]</code>中，</p>\n<ul>\n<li>若按行优先存储，则<code>b[i] [j]</code>的存储地址 =<code>LOC + (i*N + j) * sizeof(ElemType)</code></li>\n</ul>\n<p>即每一行有多少个元素，乘它前面有多少行，再加上它位于第几列。</p>\n<ul>\n<li>若按列优先存储，则<code>b[i] [j]</code>的存储地址 =<code>LOC + (j*M + i) * sizeof(ElemType)</code></li>\n</ul>\n<p>即每一列有多少个元素，乘它前面有多少列，再加上它位于第几行。</p>\n</blockquote>\n<h3 id=\"矩阵的存储\"><a href=\"#矩阵的存储\" class=\"headerlink\" title=\"矩阵的存储\"></a>矩阵的存储</h3><h4 id=\"普通矩阵的存储\"><a href=\"#普通矩阵的存储\" class=\"headerlink\" title=\"普通矩阵的存储\"></a>普通矩阵的存储</h4><p>最容易想到的就是用一个<strong>二维数组存储</strong>。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-96.png\" style=\"zoom: 85%;\" />\n\n<h4 id=\"对称矩阵的压缩存储\"><a href=\"#对称矩阵的压缩存储\" class=\"headerlink\" title=\"对称矩阵的压缩存储\"></a>对称矩阵的压缩存储</h4><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-115.png\" style=\"zoom: 80%;\" />\n\n<blockquote>\n<p>由于上三角区和下三角区的数据是完全相同的，因此我们在存储数据的时候，只需要存储主对角线及上下某一个三角区即可。</p>\n<p>以只存储<strong>主对角线</strong>与<strong>下三角区</strong>为例。</p>\n<p>按<strong>行优先</strong>原则将各元素存入一维数组中。（第一行存1个数据，第二行存2个数据，第三行存3个数据…）</p>\n</blockquote>\n<p>策略：只存储主对角线 + 下三角区</p>\n<ul>\n<li>按行优先原则将各元素存入一维数组中，共存 (1+n)*n/2 个元素，由于一维数组下标从 0 开始，所以最后一个元素下标是 (1+n) * n/2 - 1</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-116.png\" style=\"zoom: 60%;\" />\n\n<p><font color='cornflowerblue'>我们最终的目的是将矩阵压缩存储后怎样才能方便使用</font>，这样我们就可以建立一个映射函数，矩阵下标 -&gt; 一维数组下标，这样我们想要访问矩阵中某一行某一列的元素时，只需要通过映射函数一转，就可以知道它存放在一维数组的哪个位置。如何做呢？</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-117.png\" style=\"zoom:60%;\" />\n\n<ul>\n<li>按行优先的原则，a[i] [j] 是第 (1+2+…+(i-1)) + j 个元素，但是由于一维数组下标是从 0 开始的，所以对应的一维数组下标为(1+2+…+(i-1)) + j -1</li>\n</ul>\n<ul>\n<li><p><font color='cornflowerblue'>但是如果我们想访问上三角区的元素呢？</font>虽然上三角区并没有进行存储，但是由于对称矩阵的特性，a[i] [j] = a[j] [i]，我们可以进行转换，相当于我们访问的仍然是下三角区的元素</p>\n</li>\n<li><p>按列优先的原则，第一列存储n个元素，第二列存储n-1个元素，第三列存储n-2个元素，第(j-1)列总共有[n+(n-1)+(n-2)+…+(n-j+2)]个元素，所以a[i] [j] 是第 [[n+(n-1)+(n-2)+…+(n-j+2)]+(i-j)+1] 个元素</p>\n</li>\n</ul>\n<h4 id=\"三角矩阵的压缩存储\"><a href=\"#三角矩阵的压缩存储\" class=\"headerlink\" title=\"三角矩阵的压缩存储\"></a>三角矩阵的压缩存储</h4><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/co4-35.png\" style=\"zoom:55%;\" />\n\n<p>策略：如图</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/co4-36.png\" style=\"zoom:55%;\" />\n\n<p><font color='cornflowerblue'>那我们如何用呢？</font>还是建立一个映射函数，这里的映射函数与对称矩阵的映射函数一样，不同的是如果我们访问上三角区常量，我们需要将其映射为一维数组的最后一个元素，因为<strong>一维数组最后一个元素存储常量C</strong>。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-118.png\" style=\"zoom:55%;\" />\n\n<p>按行优先的原则，a[i] [j]前面有 i-1 行，第一行存储n个元素，第二行存储n-1个元素，第三行存储n-3个元素，第(i-1)行存储(n-i+2)个元素，所以a[i] [j]前面共有[[n+(n-1)+(n-2)+…+(n-i+2)+(j-i)]]个元素</p>\n<h4 id=\"三对角矩阵的压缩存储\"><a href=\"#三对角矩阵的压缩存储\" class=\"headerlink\" title=\"三对角矩阵的压缩存储\"></a>三对角矩阵的压缩存储</h4><p>三对角矩阵，主对角线上的元素可以不为0，主对角线上元素的上下左右相邻元素也可以不为0，但是其余元素必须为0</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-119.png\" style=\"zoom: 55%;\" />\n\n<p>按<strong>行优先的原则</strong>，只存储带状部分，除了第一行和最后一行为 2 个元素，其余行均为 3 个元素，所以总共需要存储 (3n-2) 个元素,由于数组下标默认从0开始，所以最后一个数组下标为 (3n-3)</p>\n<blockquote>\n<p>怎么把a(i,j)映射到与之对应的一维数组下标处？</p>\n<p>若|i-j| &gt;1，其值肯定是0。反之则去数组里面找。</p>\n<p>按行优先的原则，a(i,j)是一维数组中的第几个元素？</p>\n<p>它是第i行，在它前面有i-1行，共3(i-1)-1个元素。而且它是第i行的第j-i+2个元素。</p>\n<p>所以a(i,j)是第2i+j-2个元素。数组下标若从0开始，则以上数字均需减1。</p>\n</blockquote>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-120.png\" style=\"zoom:55%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-121.png\" style=\"zoom:55%;\" />\n\n<blockquote>\n<p>反过来考虑，假设我们已知一维数组下标k，如何得知其在矩阵中的行、列，即i、j？</p>\n<p>由于数组下标是从0开始的，因此下标k的元素是第k+1个元素。</p>\n<p>第k+1个元素在第几行、第几列？</p>\n<p>设其在第i行、第j列。</p>\n<p>前i-1行共3(i-1)-1个元素。</p>\n<p>所以显然，3(i-1)-1 &lt; k+1 ≤ 3i-1</p>\n<p>根据这个不等式，将i解出即可。同时j也轻易能够得出了。</p>\n</blockquote>\n<h4 id=\"稀疏矩阵的压缩存储\"><a href=\"#稀疏矩阵的压缩存储\" class=\"headerlink\" title=\"稀疏矩阵的压缩存储\"></a>稀疏矩阵的压缩存储</h4><h5 id=\"顺序存储——三元组\"><a href=\"#顺序存储——三元组\" class=\"headerlink\" title=\"顺序存储——三元组\"></a>顺序存储——三元组</h5><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-122.png\" style=\"zoom:55%;\" />\n\n<p>显然，用这种方法存储稀疏矩阵的数据的话，若要访问某一行某一列的数据，就要从头顺序的依次扫描三元组，对其行号、列号遍历，直到查找到目标。就不具备随机存取的特性了。</p>\n<h5 id=\"链式存储——十字链表法\"><a href=\"#链式存储——十字链表法\" class=\"headerlink\" title=\"链式存储——十字链表法\"></a>链式存储——十字链表法</h5><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-123.png\" style=\"zoom:55%;\" />\n\n<p>在“上侧”定义一个数组，用来存放每一列的指针，叫做<strong>向下域</strong>（down），指向第j列的第一个元素；</p>\n<p>在“左侧”定义一个数组，用来存放每一行的指针，叫做<strong>向右域</strong>（right），指向第i行的第一个元素。</p>\n<p>每个非零元素成为一个数据结点，被存放着。</p>\n<p>（也就是向下域、向右域都指向当前列/行的第一个非零数据所形成的数据结点）</p>\n<p>其中，每个非零数据结点，除存放三元组（<strong>行，列，值</strong>）外，还存放两个指针，分别指向<strong>同列的下一个元素</strong>、<strong>同行的下一个元素</strong>。</p>\n<h3 id=\"习题-1\"><a href=\"#习题-1\" class=\"headerlink\" title=\"习题\"></a>习题</h3><ul>\n<li><p>【2016】有一个100阶的三对角矩阵M，其元素m{i,j}(1&lt;=i,j&lt;=100),按行优先依次压缩存入下标从0开始的一维数组N中。元素m{30,30} 在N中的下标是→87</p>\n<blockquote>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-111.png\" style=\"zoom: 50%;\" />\n</blockquote>\n</li>\n<li><p>【2017】适用于压缩存储稀疏矩阵的两种存储结构是–&gt;A</p>\n<p>A 三元组表和十字链表</p>\n<p>B 三元组表和邻接矩阵</p>\n<p>C 十字链表和二叉链表</p>\n<p>D 邻接矩阵和十字链表</p>\n<blockquote>\n<p>三元组表的结点存储了行row、列col、值value三种信息，是主要用来存储稀疏矩阵的一种数据结构。十字链表将行单链表和列单链表结合起来存储稀疏矩阵。邻接矩阵空间复杂度达O(n2)，不适于存储稀疏矩阵。二叉链表又名左孩子右兄弟表示法，可用于表示树或森林。</p>\n</blockquote>\n</li>\n<li><p>【2018】设有一个12x12的对称矩阵M，将其上三角部分的元素m{i,j}(1&lt;=i&lt;=j&lt;=12)按行优先存入C语言的一维数组N中，元素m{6,6}在N中的下标是–&gt;50</p>\n<blockquote>\n<p>上三角矩阵从第一行开始元素数量依次是：<strong>12，11，10，9，8，7，6，5，4，3，2，1</strong>，m6,6表示上三角区域的第<strong>6</strong>行第<strong>1</strong>个，所以m6,6为第51个元素，占数组位置为a[50]。</p>\n</blockquote>\n</li>\n<li><p>【2020】将一个10x10对称矩阵M的上三角部分的元素m{i,j}(1&lt;=i&lt;=j&lt;=10)按列优先存入C语言的一维数组N中，元素𝑚{7,2}在 N 中的下标是–&gt;22</p>\n<blockquote>\n<p>上三角矩阵列优先的存储模式：先存储具有一个元素第一列，再存储具有两个元素 的第二列，以此类推</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-109.png\"  />\n\n<p>𝑚{7,2} 说明 1-6 列均已存满，，故此元素是第 1+2+3+4+5+6+2 个被存储单元 </p>\n<p>【注意】C 语言数组的下标从 0 开始 故𝑚7,2在 N 中的下标为 23-1=22，即 N[22]</p>\n</blockquote>\n</li>\n<li><p>【2021】二维数组A按行优先方式存储，每个元素占用1个存储单元。若元素A[0] [0]的存储地址是100，A[3] [3]的存储地址是220，则元素 A[5] [5] 的存储地址是-&gt;300</p>\n<blockquote>\n<p>二维数组A按行优先存储，每个元素占用1个存储单元，由A[0] [0]和A[3] [3]的存储地址可知A[3] [3]是二维数组A的第121个元素，假设二维数组A的每行有n个元素，则nx3+4=121,则n=39,故元素A[5] [5]的存储地址为100+39x5+6-1=300</p>\n</blockquote>\n</li>\n</ul>\n","categories":["408数据结构"],"tags":["408数据结构"]},{"title":"第三章 栈、队列和数组(上)","url":"/p/63528/","content":"<h2 id=\"3-1-栈-Stack\"><a href=\"#3-1-栈-Stack\" class=\"headerlink\" title=\"3.1 栈 Stack\"></a>3.1 栈 Stack</h2><h3 id=\"栈的基本概念\"><a href=\"#栈的基本概念\" class=\"headerlink\" title=\"栈的基本概念\"></a>栈的基本概念</h3><ul>\n<li><p>栈的定义</p>\n<ul>\n<li><p>栈是<font color='orange'>只允许在一端进行插入或删除操作的线性表</font>。限定这种线性表只能在某一端进行插入和删除操作。</p>\n<ul>\n<li>栈顶:线性表允许进行插入删除的那一端。</li>\n<li>栈底:固定的，不允许进行插入和删除的另一端。</li>\n<li>空栈:栈里没有存任何数据元素，相当于线性表的空表。</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-2.svg\"  />\n</li>\n<li><p><strong>特性</strong>：后进先出 Last In First Out, LIFO</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-1.png\" style=\"zoom: 75%;\" />\n\n\n\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>栈的数学性质：卡特兰数 Catalan Number</p>\n<p>卡特兰数一般可用于这种结论:n个不同元素进栈，出栈元素不同排列的个数为:</p>\n<ul>\n<li>$$<br>\\frac 1{n+1}C^n_{2n}<br>$$</li>\n</ul>\n<p>所以，如果像上面那样有五个元素进栈，那么所有合法的出栈顺序有:<br>$$<br>\\frac 1{5+1}C^5_{10}=42<br>$$<br>可见，即使只有5个元素进栈，合法的出栈顺序就有42种，就很多了。所以考试题基本不会让你全部写出所有的，而是以选择题的形式让你选出一个合法的出栈顺序。</p>\n</li>\n</ul>\n<h3 id=\"栈的基本操作\"><a href=\"#栈的基本操作\" class=\"headerlink\" title=\"栈的基本操作\"></a>栈的基本操作</h3><ul>\n<li>InitStack(&amp;S)：<font color='red'>初始化</font>栈操作。构造一个空栈S，分配内存空间。</li>\n<li>DestroyStack(&amp;S)：<font color='red'>销毁</font>栈操作，并<font color='red'>释放</font>栈S所占的内存空间</li>\n<li>StackEmpty(S)：判定S是否为空栈。空，则返回ture,否则返回false</li>\n<li>StackLength(S)：求栈的长度 <a href=\"https://cplusplus.com/reference/stack/stack/size/\">cpp::std::stack::size</a></li>\n<li>GetTop(S, &amp;e)：取栈顶元素 <a href=\"https://cplusplus.com/reference/stack/stack/top/\">cpp::std::stack::top</a></li>\n<li>ClearStack(&amp;S)：栈置空操作 <a href=\"https://cplusplus.com/reference/stack/stack/empty/\">cpp::std::stack::empty</a></li>\n<li>Push(&amp;S, e)：入栈操作（压栈）<a href=\"https://cplusplus.com/reference/stack/stack/push/\">cpp::std::stack::push</a></li>\n<li>Pop(&amp;S, &amp;e)：出栈操作（弹栈）</li>\n</ul>\n<h3 id=\"栈的顺序存储结构\"><a href=\"#栈的顺序存储结构\" class=\"headerlink\" title=\"栈的顺序存储结构\"></a>栈的顺序存储结构</h3><ul>\n<li><p>结点的类型定义</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAXSIZE 100 <span class=\"comment\">//定义栈中元素的最大个数</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">  ElemType data[MAXSIZE];<span class=\"comment\">//静态数组存放栈中元素</span></span><br><span class=\"line\">  <span class=\"type\">int</span> top;  <span class=\"comment\">// 栈顶指针</span></span><br><span class=\"line\">&#125; SqStack;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">testStack</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\tSqStack S;\t<span class=\"comment\">//声明一个顺序栈</span></span><br><span class=\"line\">\t<span class=\"comment\">//......</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>栈顶指针：S.top，初始时设置 S.top = -1;</p>\n<p>栈顶元素：s.data[s.Top]；</p>\n<p>进栈操作：栈不满时，栈顶指针先加1，再送值到栈顶元素。</p>\n<p>出栈操作：栈非空时，先去栈顶元素值，再将栈顶指针减1。</p>\n<p>栈空条件：S.top == -1；</p>\n<p>栈满条件：S.top == MaxSize-1;</p>\n<p>栈长：S.top +1 。</p>\n<p>此类一开始分配了最大空间的顺序栈要对栈溢出有相应的处理机制。</p>\n</li>\n<li><p>顺序栈的基本运算</p>\n<ul>\n<li><p>初始化<code>InitStack(&amp;S)</code>:初始化栈，构造一个空栈S，分配内存空间</p>\n<p>初始化栈就是让栈顶指针 top 指向 -1，因为栈顶指针指向的是栈顶元素，开始的时候没有元素，所以栈顶指针指向 0 这个位置是不合适的</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-3.png\" style=\"zoom: 75%;\" />\n</li>\n<li><p>判栈空<code>StackEmpty(S)</code>:如上图，由于栈空的时候，数组中是没有任何元素的。如果要让栈顶指针指向0，显然是不合适的。所以空栈让栈顶指针的值为-1。因此，判断是否栈空时，只需要判断它的栈顶指针top是否等于-1就可以。</p>\n</li>\n<li><p>进栈<code>Push(&amp;S,x)</code>:进栈，若栈S未满，则将 x 加入使之成为新栈顶；进栈时先让栈顶指针 top 加一，之后将新元素放在 top 指针所指向的位置</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-4.png\" style=\"zoom: 75%;\" />\n\n<p>或者写的更简洁一点，如下。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//新元素入栈</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Push</span><span class=\"params\">(SqStack &amp;S, ElemType x)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S.top == MaxSize<span class=\"number\">-1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t<span class=\"comment\">//栈满，报错</span></span><br><span class=\"line\">\tS.data[++S.top] = x;\t<span class=\"comment\">//合并两句 </span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>出栈<code>Pop(&amp;S,&amp;x)</code>:出栈，若栈S非空，则弹出栈顶元素，并用x返回</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-5.png\" style=\"zoom:75%;\" />\n\n<p>同上文，此处也可以将其中两句合并成一句更简洁的写法，如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//出栈操作</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Pop</span><span class=\"params\">(SqStack &amp;S, ElemType &amp;x)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S.top == <span class=\"number\">-1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t<span class=\"comment\">//栈空，报错</span></span><br><span class=\"line\">\tx = S.data[S.top--];\t<span class=\"comment\">//合并两句</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>读栈顶元素<code>GetTop(S,&amp;x)</code>:读取栈顶元素，若栈 S 非空，则用 x 返回栈顶元素</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-6.png\" style=\"zoom: 75%;\" />\n</li>\n</ul>\n</li>\n<li><p>另一种操作方式</p>\n<p><strong>初始化</strong>时，令栈顶指针指向0，而不是-1。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 10</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\tElemType data[MaxSize];</span><br><span class=\"line\">\t<span class=\"type\">int</span> top;</span><br><span class=\"line\">&#125;SqStack; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化栈</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitStack</span><span class=\"params\">(SqStack &amp;S)</span> &#123;</span><br><span class=\"line\">\tS.top = <span class=\"number\">0</span>;\t<span class=\"comment\">//初始指向0 </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//判断栈空</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">StackEmpty</span><span class=\"params\">(SqStack S)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S.top == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;<span class=\"comment\">//此时注意栈空条件</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>进栈、出栈</strong>时。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//新元素入栈</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Push</span><span class=\"params\">(SqStack &amp;S, ElemType x)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S.top == MaxSize) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t<span class=\"comment\">//判断栈满的条件不同</span></span><br><span class=\"line\">\tS.data[S.top++] = x;\t<span class=\"comment\">//赋值操作与指针移动操作顺序不同</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//出栈操作</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Pop</span><span class=\"params\">(SqStack &amp;S, ElemType &amp;x)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S.top == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\tx = S.data[--S.top];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>栈顶指针为-1和0的区别<br>在遇到相关问题时，一定要注意看清初始化栈顶指针的值。<br>（1）当初始化为-1时，栈顶指针指向的是当前栈中的实际位置，而当初始化为为0时，栈顶指针指向的是下一次要插入的位置。<br>（2）在进行入栈和出栈的操作时，二者核心操作是相反的。<br>（3）在获取栈顶元素的操作中，如果初始化栈顶为0，那么需要先对指针减1才能取到栈顶元素的值，这点与初始化栈顶为-1时的操作有所不同。并且，如果函数定义中参数使用了引用传递，那么栈顶指针还需要再加1，保持栈顶指针原来的位置。如果使用值传递，则不需要，因为值传递不会改变原来的栈。</p>\n</blockquote>\n</li>\n<li><p>共享栈</p>\n<p><strong>顺序栈的缺点</strong>：栈的大小不可变。</p>\n<ul>\n<li>可以用链式存储的方式进行存储。</li>\n<li>也可以在初始化的时候就声明一个较大的存储空间。</li>\n</ul>\n<blockquote>\n<p>但我们知道，若一开始就申请较大空间的话，会造成空间的浪费。但是，我们可以通过<strong>共享栈</strong>的方式，来提高这一大片内存空间的利用率。</p>\n<p>共享栈的意思就是，两个栈共享同一片空间。</p>\n</blockquote>\n<p>我们可以设置两个栈顶指针。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-7.png\" style=\"zoom:75%;\" />\n\n<p>如果要往0号栈存放数据元素的话，是由下到上依次递增的；</p>\n<p>如果要往1号栈存放数据元素的话，是由上到下依次递减的。</p>\n<p>这两个栈，从逻辑上来说是两个不同的栈，但是在物理上，它们又共享同一片存储空间。这样就提高了空间利用率。</p>\n<p>共享栈也是会满的。判断共享栈是否满了的条件，就是看<code>top0 + 1 == top1</code></p>\n<p><a href=\"https://www.cxymm.net/article/zag666/105600288\">一文搞懂共享栈</a></p>\n</li>\n</ul>\n<p><font color='green'>用一个数组实现两个栈</font></p>\n<p><strong>思路</strong>:从 <strong>两头开始向中间生长</strong>，当两个栈的 <strong>栈顶指针相遇</strong> 时，表示两个栈都满了</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAXSIZE 100</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ElementType int</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ERROR -1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DStack</span> &#123;</span></span><br><span class=\"line\">    ElementType Data[MAXSIZE];</span><br><span class=\"line\">    <span class=\"type\">int</span> Top1;  <span class=\"comment\">// 栈 1 的栈顶指针</span></span><br><span class=\"line\">    <span class=\"type\">int</span> Top2;  <span class=\"comment\">// 栈 2 的栈顶指针</span></span><br><span class=\"line\">&#125; S;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Push</span><span class=\"params\">(<span class=\"keyword\">struct</span> DStack* PtrS, ElementType item, <span class=\"type\">int</span> Tag)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Tag 作为区分两个堆栈的标志，取值为 1 和 2 */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PtrS-&gt;Top2 - PtrS-&gt;Top1 == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;栈满\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Tag == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        PtrS-&gt;Data[++(PtrS-&gt;Top1)] = item;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        PtrS-&gt;Data[--(PtrS-&gt;Top2)] = item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ElementType <span class=\"title function_\">Pop</span><span class=\"params\">(<span class=\"keyword\">struct</span> DStack* PtrS, <span class=\"type\">int</span> Tag)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Tag 作为区分两个堆栈的标志，取值为 1 和 2 */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Tag == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (PtrS-&gt;Top1 == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;栈1空\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> PtrS-&gt;Data[(PtrS-&gt;Top1)--];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (PtrS-&gt;Top2 == MAXSIZE) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;栈2空\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> PtrS-&gt;Data[(PtrS-&gt;Top2)++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"栈的链式存储结构\"><a href=\"#栈的链式存储结构\" class=\"headerlink\" title=\"栈的链式存储结构\"></a>栈的链式存储结构</h3><ul>\n<li><p>采用链式存储的栈称为<font color='purple'>链栈</font>，其优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况</p>\n</li>\n<li><p>结点的类型定义</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StackNode</span> &#123;</span></span><br><span class=\"line\">  SElemType data;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StackNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125; StackNode, *LinkStack;</span><br></pre></td></tr></table></figure>\n\n<p>进栈和出栈操作就对应于单链表的插入和删除操作（只在头结点那一端进行）。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-112.png\" style=\"zoom:55%;\" />\n\n<p>那么对于单链表在头结点处的插入删除，我们在第二章已经讲的很详细了，这里就不再赘述。</p>\n<p>和单链表类似。对于链栈，我们也可以实现<strong>带头结点</strong>的版本，和<strong>不带头结点</strong>的版本，道理同单链表是一样的。</p>\n</li>\n<li><p>初始化</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stack <span class=\"title function_\">CreateStack</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 构建一个栈的头结点，返回指针 */</span></span><br><span class=\"line\">    Stack S;</span><br><span class=\"line\">    S = (Stack)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> SNode));</span><br><span class=\"line\">    S-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> S;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>入栈</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Push</span><span class=\"params\">(ElementType item, Stack S)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 将元素 item 压入栈 S */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SNode</span>* <span class=\"title\">TmpCell</span>;</span></span><br><span class=\"line\">    TmpCell = (<span class=\"keyword\">struct</span> SNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> SNode));</span><br><span class=\"line\">    TmpCell-&gt;Data = item;</span><br><span class=\"line\">    TmpCell-&gt;next = S-&gt;next;</span><br><span class=\"line\">    S-&gt;next = TmpCell;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>出栈</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">ElementType <span class=\"title function_\">Pop</span><span class=\"params\">(Stack S)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 删除并返回栈 S 的栈顶元素 */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SNode</span>* <span class=\"title\">FirstCell</span>;</span></span><br><span class=\"line\">    ElementType TopElem;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IsEmpty(S)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;栈空\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        FirstCell = S-&gt;next;</span><br><span class=\"line\">        S-&gt;next = FirstCell-&gt;next;</span><br><span class=\"line\">        TopElem = FirstCell-&gt;Data;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(FirstCell);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> TopElem;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>判栈空</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">IsEmpty</span><span class=\"params\">(Stack S)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 判断栈 S 是否为空，若为空函数返回整数 1，否则返回 0 */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (S-&gt;next == <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"习题\"><a href=\"#习题\" class=\"headerlink\" title=\"习题\"></a>习题</h3><ul>\n<li><p>【2010】若元素 abcdef 依次进栈，允许出栈、退栈操作交替进行，但不允许连续 3 次进行退栈操作，不可能得到的出栈序列是→D</p>\n<p>A. d c e b f a<br>B. c b d a e f<br>C. b c a e f d<br>D. a f e d c b</p>\n<blockquote>\n<p>选项A,可由a入栈，b入栈，c入栈，d入栈，<font color='red'>d出栈</font>，<font color='red'>c出栈</font>，e入栈，<font color='red'>e出栈</font>，<font color='red'>b出栈</font>，f入栈，<font color='red'>f出栈</font>，<font color='red'>a出栈</font>得到</p>\n<p>选项B,可由a入栈，b入栈，c入栈，<font color='red'>c出栈</font>，<font color='red'>b出栈</font>，d入栈，<font color='red'>d出栈</font>，<font color='red'>a出栈</font>，e入栈，<font color='red'>e出栈</font>，f入栈，<font color='red'>f出栈</font>得到</p>\n<p>选项C，可由a入栈，b入栈，<font color='red'>b出栈</font>，c入栈，<font color='red'>c出栈</font>，<font color='red'>a出栈</font>，d入栈，e入栈，<font color='red'>e出栈</font>，f入栈，<font color='red'>f出栈</font>，<font color='red'>d出栈</font>得到</p>\n<p>选项D，可由a入栈，<font color='red'>a出栈</font>，b入栈，c入栈，d入栈，e入栈，f入栈，<font color='red'>f出栈</font>，<font color='red'>e出栈</font>，<font color='red'>d出栈</font>，<font color='red'>c出栈</font>，<font color='red'>b出栈</font>得到  但不允许连续3次退栈</p>\n</blockquote>\n</li>\n<li><p>【2009】设栈S和队列Q的初始状态均为空，元素abcdefg依次进入栈S。若每个元素出栈后立即进入队列Q，且7个元素出队的顺序是bdcfeag，则栈S的容量至少是–&gt;3</p>\n<blockquote>\n<p>由于<strong>队列的特点是先进先出</strong>，即栈S的出栈顺序就是队Q的出队顺序。故本题只需注意栈的特点是先进后出。出入栈的详细过程见下表。</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>说明</th>\n<th>栈内</th>\n<th>栈外</th>\n<th>序号</th>\n<th>说明</th>\n<th>栈内</th>\n<th>栈外</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>a入栈</td>\n<td>a</td>\n<td></td>\n<td>8</td>\n<td>e入栈</td>\n<td>ae</td>\n<td>bdc</td>\n</tr>\n<tr>\n<td>2</td>\n<td>b入栈</td>\n<td>ab</td>\n<td></td>\n<td>9</td>\n<td>f入栈</td>\n<td>aef</td>\n<td>bdc</td>\n</tr>\n<tr>\n<td>3</td>\n<td>b出栈</td>\n<td>a</td>\n<td>b</td>\n<td>10</td>\n<td>f出栈</td>\n<td>ae</td>\n<td>bdcf</td>\n</tr>\n<tr>\n<td>4</td>\n<td>c入栈</td>\n<td>ac</td>\n<td>b</td>\n<td>11</td>\n<td>e出栈</td>\n<td>a</td>\n<td>bdcfe</td>\n</tr>\n<tr>\n<td>5</td>\n<td>d入栈</td>\n<td>acd</td>\n<td>b</td>\n<td>12</td>\n<td>a出栈</td>\n<td></td>\n<td>bdcfea</td>\n</tr>\n<tr>\n<td>6</td>\n<td>d出栈</td>\n<td>ac</td>\n<td>bd</td>\n<td>13</td>\n<td>g入栈</td>\n<td>g</td>\n<td>bdcfea</td>\n</tr>\n<tr>\n<td>7</td>\n<td>c出栈</td>\n<td>a</td>\n<td>bdc</td>\n<td>14</td>\n<td>g出栈</td>\n<td></td>\n<td>bdcfeag</td>\n</tr>\n</tbody></table>\n<p>栈内的最大深度为3，故栈S的容量至少是3。</p>\n<p>【另解】元素的出栈顺序是b，d，c，f，e，a，g，可推出进栈出栈顺序为Push(S,a)，Push(S,b)，Pop(S,b)，Push(S,c)，Push(S,d)，Pop(S,d)，Pop(S,c)，Push(S,e)，Push(S,f)，Pop(S,f)，Pop(S,e)，Pop(S,a)，Push(S,g)，Pop(S,g)。假设初始所需容量为0，每做一次Push进行一次“+1”操作，每做一次Pop进行一次“-1”操作，记录容量的最大值为3。</p>\n</blockquote>\n</li>\n<li><p>【2011】元素a,b,c,d,e依次进入初始为空的栈中，若元素进栈后可停留、可出栈，直到所有元素都出栈，则在所有可能的出栈序列中，以元素d开头的序列个数是–&gt;4</p>\n<blockquote>\n<p>考虑到题目要求是d先出栈，所以abcd的入栈顺序已经确定，e的入栈和出栈决定有几种顺序。 </p>\n<p>1.abcd依次入栈，d出栈，e入栈，然后剩下的出栈顺序为ecba </p>\n<p>2.abcd依次入栈，d出栈，c出栈，e入栈，e出栈，剩下的出栈顺序ba </p>\n<p>3.abcd依次入栈，d出栈，c出栈，b出栈，e入栈，e出栈，a出栈 </p>\n<p>4.abcd依次入栈，d出栈，c出栈，b出栈，a出栈，e入栈，e出栈，a出栈</p>\n</blockquote>\n</li>\n<li><p>【2013】一个栈的入栈序列为1,2,3,…,n,出栈序列是P1,P2,P3,…,Pn。若P2 = 3，则 P3 可能取值的个数是–&gt;(n-1)个</p>\n<blockquote>\n<p>首先，栈的先进后出原则大家应该是知道的。</p>\n<p>根据题意 P2 = 3，可以知道P1的可能情况有三种：<strong>1,2或4</strong> 。（看到有些人只想到了1，2）</p>\n<p>为啥这样想呢？这里估计还有一个关键是要<strong>考虑到 n 的大小</strong>。</p>\n<p><strong>当 n = 3 时</strong>， P2 = 3 的话，那么 P1 有两种情况 1 和 2 。</p>\n<ul>\n<li>如果 P1 = 1 ，那么 P3 = 2 ；</li>\n<li>如果 P1 = 2 ，那么 P3 = 1 ；</li>\n</ul>\n<p>此时的话我们就可以看到 P3 只有两种可能 1或者2       （n - 1）个。</p>\n<p><strong>当 n &gt; 3 时</strong>： P2 = 3 的话，那么 P1 有三种情况1,2和4。</p>\n<ul>\n<li>如果 P1 = 1 ，那么 P3 = 2，4，5，…  n     （n - 2）个    </li>\n<li>如果 P1 = 2 ，那么 P3 = 1，4，5，…  n     （n - 2）个    </li>\n<li>如果 P1 = 4 ，那么 P3 = 2，5，6，…  n     （n - 3）个  </li>\n</ul>\n<p>此时的话我们就可以看到 P3 的情况有 1，2，4，5，… n （n - 1）个。</p>\n<p>综上所述就是 P3 可能取值的个数是 （n - 1）个。</p>\n</blockquote>\n</li>\n<li><p>【2017】下列关于栈的叙述中，错误的是-&gt;I、Ⅲ、Ⅳ</p>\n<p>Ⅰ．采用非递归方式重写递归程序时必须使用栈 </p>\n<p>Ⅱ．函数调用时，系统要用栈保存必要的信息 </p>\n<p>Ⅲ．只要确定了入桟次序，即可确定出栈次序</p>\n<p>Ⅳ．栈是一种受限的线性表，允许在其两端进行操作</p>\n<blockquote>\n<p>I. 尾递归可以直接使用循环</p>\n<p>II.确定了入桟次序，不能确定出栈次序</p>\n<p>IV．栈是一种受限的线性表，允许在其一端（栈顶）进行操作</p>\n</blockquote>\n</li>\n<li><p>【2018】若栈S1中保存整数，栈S2中保存运算符，函数F()依次执行下述各步操作:</p>\n<p>（1）从S1中依次弹出两个操作数a和b；<br>（2）从S2中弹出一个运算符op；<br>（3）执行相应的运算b op a；<br>（4）将运算结果压入S1中。</p>\n<p>  假定S1中的操作数依次是5,8,3,2（2在栈顶），S2中的运算符依次是*,-,+（+在栈顶） </p>\n<p>  调用3次F()后，S1栈顶保存的值是–&gt;15</p>\n<blockquote>\n<p>S1第一次弹出a,b 即 2,3  S2 弹出 “ +”  操作为 b + a  即 （3 + 2） 压入 S1 现在 S1 为 5 8 5 </p>\n<p>S1第二次弹出a,b 即 5，8 S2弹出”-“ 操作为 b - a 即（8-5）压入S1 现在 S1 为 5 3 </p>\n<p>S1第三次弹出a,b 即 3,5  S2弹出 “<em>” 操作为 b</em>a  即 5*3 压入S 现在S1 为 15<br>所以三次后S1 栈顶为15</p>\n</blockquote>\n</li>\n<li><p>【2020】对空栈S进行Push和Pop操作，入栈序列为a,b,c,d,e，经过Push，Push，Pop，Push，Pop，Push，Push，Pop 操作后得到的出栈序列是–&gt;b,c,e</p>\n<blockquote>\n<p>根据题意，出入栈操作的过程如下:</p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>栈内元素</th>\n<th>出栈元素</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Push</td>\n<td>a</td>\n<td></td>\n</tr>\n<tr>\n<td>Push</td>\n<td>a b</td>\n<td></td>\n</tr>\n<tr>\n<td>Pop</td>\n<td>a</td>\n<td>b</td>\n</tr>\n<tr>\n<td>Push</td>\n<td>a c</td>\n<td></td>\n</tr>\n<tr>\n<td>Pop</td>\n<td>a</td>\n<td>c</td>\n</tr>\n<tr>\n<td>Push</td>\n<td>a d</td>\n<td></td>\n</tr>\n<tr>\n<td>Push</td>\n<td>a d e</td>\n<td></td>\n</tr>\n<tr>\n<td>Pop</td>\n<td>a d</td>\n<td>e</td>\n</tr>\n</tbody></table>\n<p>所以出栈元素序列为b,c,e</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"3-2-队列-Queue\"><a href=\"#3-2-队列-Queue\" class=\"headerlink\" title=\"3.2 队列 Queue\"></a>3.2 队列 Queue</h2><h3 id=\"队列的基本概念\"><a href=\"#队列的基本概念\" class=\"headerlink\" title=\"队列的基本概念\"></a>队列的基本概念</h3><h3 id=\"队列的定义\"><a href=\"#队列的定义\" class=\"headerlink\" title=\"队列的定义\"></a>队列的定义</h3><ul>\n<li><p>队列简称队，也是一种操作受限的线性表，<font color='orange'>只允许在表的一端进行插入，而在表的另一端进行删除</font></p>\n</li>\n<li><p>向队列中插入元素称为<strong>入队</strong>或<strong>进队</strong></p>\n</li>\n<li><p>删除元素称为<strong>出队</strong>或<strong>离队</strong></p>\n</li>\n<li><p>特性：先进先出 First In First Out, FIFO</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-8.png\" style=\"zoom: 75%;\" />\n\n</li>\n</ul>\n<h3 id=\"队列常见的基本操作\"><a href=\"#队列常见的基本操作\" class=\"headerlink\" title=\"队列常见的基本操作\"></a>队列常见的基本操作</h3><ul>\n<li>InitQueue(&amp;Q)：初始化队列。</li>\n<li>DestoryQueue(&amp;Q)：销毁队列。并释放队列Q所占用的内存空间。</li>\n<li>ClearQueue(&amp;Q)：清空队列。</li>\n<li>QueueLength(Q)：求队列长度。</li>\n<li>GetHead(Q,&amp;e)：得到队头元素，若队列Q非空，则将队头元素赋值给e。</li>\n<li>EnQueue(&amp;Q, e)：入队，若队列Q未满，将e加入，使之成为新的<font color='purple'>队尾</font>font&gt;。</li>\n<li>DeQueue(&amp;Q, &amp;e)：出队，若队列Q非空，删除<font color='purple'>队头</font>font&gt;元素，并用e返回。</li>\n<li>QueueEmpty(Q)：判队列空，若队列Q为空返回true，否则返回false。</li>\n</ul>\n<h3 id=\"队列的顺序存储结构\"><a href=\"#队列的顺序存储结构\" class=\"headerlink\" title=\"队列的顺序存储结构\"></a>队列的顺序存储结构</h3><h4 id=\"队列的顺序存储\"><a href=\"#队列的顺序存储\" class=\"headerlink\" title=\"队列的顺序存储\"></a>队列的顺序存储</h4><p>队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针：队头指针front指向队头元素。队尾指针rear指向队尾元素的下一个位置（其实和单链表有无头结点是一样的，队尾指针你想指向最后一个元素或者最后一个元素的下一位都行，注意相应的操作随之变动就行）。</p>\n<ul>\n<li><p><strong>结点类型定义</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAXSIZE 100 <span class=\"comment\">// 最大队列长度</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    QElemType *base; <span class=\"comment\">// 初始化的动态分配存储空间</span></span><br><span class=\"line\">    <span class=\"type\">int</span> front;       <span class=\"comment\">// 队头指针</span></span><br><span class=\"line\">    <span class=\"type\">int</span> rear;        <span class=\"comment\">// 队尾指针</span></span><br><span class=\"line\">&#125; SqQueue;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">testQueue</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    SqQueue Q;\t<span class=\"comment\">//声明一个队列（顺序存储）</span></span><br><span class=\"line\">    <span class=\"comment\">//......</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>初始状态（队空条件）：Q.front == Q.rear == 0。</p>\n<p>进队操作：队不满时，先送值到队尾元素，再将队尾指针加1。</p>\n<p>出队操作：队不空时，先去队头元素值，再将队头指针加1。</p>\n</li>\n<li><p><strong>初始化操作</strong></p>\n<p><code>InitQueue(&amp;Q)</code> : 初始化队列，构造一个空队列 Q</p>\n<p>我们可以规定，让队头指针指向队头元素；让队尾指针指向队尾元素的后一个位置（接下来应该插入数据元素的位置）。那么在初始化的时候，我们可以令队头、队尾指针均指向0。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 10\t\t\t\t\t<span class=\"comment\">// 定义队列中元素的最大个数</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    ELemType data[MaxSize];\t\t\t<span class=\"comment\">// 用静态数组存放队列元素</span></span><br><span class=\"line\">    <span class=\"type\">int</span> front,rear;\t\t\t\t\t<span class=\"comment\">// 队头指针和队尾指针</span></span><br><span class=\"line\">&#125;SqQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化队列</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitQueue</span><span class=\"params\">(SqQueue &amp;Q)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始时,队头、队尾指针指向0</span></span><br><span class=\"line\">    Q.rear = Q.front = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>队头指针 front 指向队头元素</p>\n</li>\n<li><p>队尾指针 rear 指向队尾元素的后一个位置(下一个应该插入的位置)</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-15.png\" style=\"zoom: 50%;\" />\n</li>\n</ul>\n</li>\n<li><p><strong>判断队列是否为空</strong></p>\n<p><code>QueueEmpty(Q)</code> : 判断队列是否为空，若队列Q为空则返回 true，否则返回 false</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 判断队列是否为空</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">QueueEmpty</span><span class=\"params\">(SqQueue Q)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.rear == Q.front)&#123;\t\t\t<span class=\"comment\">// 队空条件</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-16.png\" style=\"zoom: 50%;\" />\n</li>\n<li><p><strong>入队操作</strong></p>\n<p><code>EnQueue(&amp;Q,x)</code> : 入队，若队列 Q 未满，将 x 加入，使之称为新的队尾</p>\n<p>只能从队尾入队。把这一次要插入的数据元素，把它放到队尾指针所指向的位置。把队尾指针加1。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//入队</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">EnQueue</span><span class=\"params\">(SqQueue &amp;Q, ElemType x)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(队列已满) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t<span class=\"comment\">//队满则报错</span></span><br><span class=\"line\">\tQ.data[Q.rear] = x;\t<span class=\"comment\">//将x插入队尾</span></span><br><span class=\"line\">\tQ.rear = Q.rear + <span class=\"number\">1</span>;\t<span class=\"comment\">//队尾指针后移</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><font color='cornflowerblue'>那么我们是否可以认为，队列已满的条件，就是<code>rear == MaxSize</code>呢？</font></p>\n<p>并不是这样。</p>\n<p>因为，在<code>rear == MaxSize</code>的情况下，若队头出队了一些元素，则队列显然不满。但rear仍然是等于MaxSize的。</p>\n<p>同时，接下来的新元素，是要插入到队头元素之前的空位当中的。</p>\n<p><font color='cornflowerblue'>那么怎样让队尾指针指向接下来要插入的队头元素前的空位处呢？</font></p>\n<p>只需进行一个<strong>取余操作</strong>即可。</p>\n<p>看下列图</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-17.png\" style=\"zoom:55%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-19.png\" style=\"zoom:55%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-20.png\" style=\"zoom:55%;\" />\n\n<p>所以队尾指针 rear 其实是从队头指向队尾，再从队尾指向队头，这样循环移动。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-21.png\" style=\"zoom:55%;\" />\n\n<p>这样使用模运算将存储空间在逻辑上变成了 “<strong>环状</strong>”，我们也称之为<font color='red'>循环队列</font>(稍后引出)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 10\t\t\t\t\t<span class=\"comment\">// 定义队列中元素的最大个数</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">  ELemType data[MaxSize];\t\t\t<span class=\"comment\">// 用静态数组存放队列元素</span></span><br><span class=\"line\">    <span class=\"type\">int</span> front,rear;\t\t\t\t\t<span class=\"comment\">// 队头指针和队尾指针</span></span><br><span class=\"line\">&#125;SqQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 入队</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">EnQueue</span><span class=\"params\">(SqQueue &amp;Q,ElemeType x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((Q.rear + <span class=\"number\">1</span>)%MaxSize == Q.front)&#123;\t<span class=\"comment\">// 判断队满</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t\t\t\t\t\t<span class=\"comment\">// 队满则报错</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Q.data[Q.rear] = x;\t\t\t\t\t\t<span class=\"comment\">// 将 x 插入队尾</span></span><br><span class=\"line\">    Q.rear = (Q.rear + <span class=\"number\">1</span>)%MaxSize;\t\t\t<span class=\"comment\">// 队尾指针加1取模,用模运算将存储空间在逻辑上变成了&quot;环状&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么此时就可以知道，队列已满的条件为：队尾指针的下一个位置是队头，即<code>(Q.rear + 1) % MaxSize == Q.front</code>。</p>\n<blockquote>\n<p>此处，有些人会认为。队尾指针指向的就是“接下来应该插入元素的位置”，也就是队尾指针指向的位置是一个空闲空间。<strong>那么为什么队尾指针所指向的位置的下一个是队头时，就判满了呢？</strong>不是还有一个空间空间吗？如果“真正满了”的话，应该是队尾指针指向队头指针呀。</p>\n<p>要知道，队尾指针和队头指针相等，那是我们在初始化队列的时候，让队头指针和队尾指针指向同一个位置的。此外，我们也根据队尾指针与队头指针是否指向同一个位置，来判断队列是否为空。</p>\n</blockquote>\n<blockquote>\n<p>这样就没办法。所以我们必须牺牲一个存储单元。来将判满与判空区分开来。</p>\n</blockquote>\n</li>\n<li><p><strong>出队操作</strong></p>\n<p><code>DeQueue(&amp;Q,&amp;x)</code> : 出队，若队列 Q 非空，删除队头元素，并用 x 返回</p>\n<p>只能从队头出队</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-110.png\" style=\"zoom: 33%;\" />\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 10\t\t\t\t\t<span class=\"comment\">// 定义队列中元素的最大个数</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    ELemType data[MaxSize];\t\t\t<span class=\"comment\">// 用静态数组存放队列元素</span></span><br><span class=\"line\">    <span class=\"type\">int</span> front,rear;\t\t\t\t\t<span class=\"comment\">// 队头指针和队尾指针</span></span><br><span class=\"line\">&#125;SqQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 出队(删除一个队头元素,并用 x 返回)</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">DeQueue</span><span class=\"params\">(SqQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.rear ==Q.front)&#123;\t\t\t\t\t<span class=\"comment\">// 判断队空</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t\t\t\t\t\t<span class=\"comment\">// 队空则报错</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    X = Q.data[Q.front];</span><br><span class=\"line\">    Q.front = (Q.front +<span class=\"number\">1</span>)%MaxSize;\t\t\t<span class=\"comment\">// 队头指针后移</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;\t\t\t\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>获得队头元素值</strong></p>\n<p><code>GetHead(Q,&amp;x)</code> ：读取队头元素，若队列Q非空，则将队头元素</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 10\t\t\t\t\t<span class=\"comment\">// 定义队列中元素的最大个数</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    ELemType data[MaxSize];\t\t\t<span class=\"comment\">// 用静态数组存放队列元素</span></span><br><span class=\"line\">    <span class=\"type\">int</span> front,rear;\t\t\t\t\t<span class=\"comment\">// 队头指针和队尾指针</span></span><br><span class=\"line\">&#125;SqQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获得队头元素的值,用 x 返回</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">GetHead</span><span class=\"params\">(SqQueue Q,ElemType &amp;x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.rear == Q.front)&#123;\t\t\t<span class=\"comment\">// 判断队空</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;   \t\t\t<span class=\"comment\">// 队空则报错</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    X = Q.data[Q.front];\t\t\t<span class=\"comment\">// 获得队头元素值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>假溢出</strong></p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-11.png\" style=\"zoom:67%;\" />\n\n<p>(a)所示为队列的初始状态，有Q.front == Q.front == 0成立，该条件可以作为队列判空的条件。但能否用Q.rear == MaxSize作为队列满的条件呢？显然不能，图(d)中，队列中仅有一个元素，但仍然满足该条件，这时队列出现“上溢出”，按理说，此时就不能将其他元素加入队列。但这种溢出并不是真正的溢出，在data数组中仍然存在可以存放元素的空位置，所以这是一种“<font color='red'>假溢出</font>”。</p>\n</li>\n</ul>\n<h4 id=\"循环队列\"><a href=\"#循环队列\" class=\"headerlink\" title=\"循环队列\"></a>循环队列</h4><p>为了解决顺序队列的“<font color='red'>假溢出</font>”也就是空间只能用一次，严重浪费的问题，我们引出一个<strong>循环队列</strong>的概念。</p>\n<p>循环队列就是将顺序队列臆造为一个环状的空间，即把存储队列元素的表从逻辑上视为一个环（用链表来的指针来向下会清晰很多），称为循环队列。当队首指针<code>Q.front=MaxSize-1</code>后，再前进一个位置就自动到0，实现上可以用取余来实现。</p>\n<p>初始时：<code>Q.front = Q.rear = 0</code>;</p>\n<p>队首指针进1：<code>Q.front = (Q.front+1)%MaxSize</code></p>\n<p>队尾指针进1：<code>Q.rear = (Q.rear+1)%MaxSize</code></p>\n<p>对列长度：<code>（Q.rear+MaxSize-Q.front）%MaxSize</code></p>\n<p>出队入队时：指针都按顺时针方向进1。<br><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-12.png\" style=\"zoom:67%;\" /></p>\n<p>根据我们前面所述，队空的时候：<code>Q.front = Q.rear</code>；那这样的话考虑一下队满的时候咋表示，顺着思路走，位指针要指向队尾的下一个，那不就是：<code>Q.rear = Q.front</code> 。这样不就队空队满无法区分了吗？</p>\n<p><font color='orange'>为了区分队空队满的情况</font>，有以下三种处理方式：</p>\n<ol>\n<li><p>牺牲一个单元来区分队空还是队满，如队时少用一个队列单元，约定以“队头指针在队尾指针的下一位置作为队满的标志”。如图(d2)所示。</p>\n<p><strong>队满</strong>：<code>(Q.rear+1)%MaxSize  == Q.front</code>；</p>\n<p><strong>队空</strong>：<code>Q.front == Q.rear</code>。</p>\n<p><strong>队列中元素个数</strong>：<code>(Q.rear - Q.front + MaxSize)%MaxSize</code>。</p>\n</li>\n<li><p>类型中增设一个数据成员，专门记录队列中元素的个数。</p>\n</li>\n<li><p>类型中增设tag数据成员，以区分是队满还是队空。tag等于0时，若因删除导致<code>Q.front == Q.rear</code>，则为队空；tag等于1时，若因插入导致<code>Q.front == Q.rear</code>，则为队满。</p>\n</li>\n</ol>\n<p><font color='red'>接下来会具体谈到如何判断队列已满</font></p>\n<h4 id=\"循环队列的操作\"><a href=\"#循环队列的操作\" class=\"headerlink\" title=\"循环队列的操作\"></a>循环队列的操作</h4><ul>\n<li><p><strong>初始化</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitQueue</span><span class=\"params\">(SqQueue &amp;Q)</span>&#123;</span><br><span class=\"line\">    Q.base = new QElemType[MAXSIZE];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!Q.base) <span class=\"built_in\">exit</span>(OVERFLOW);</span><br><span class=\"line\">    Q.front = Q.rear = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>判队空</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">isEmpty</span><span class=\"params\">(SqQueue Q)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.rear == Q.front) <span class=\"comment\">// 队空条件</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-13.png\" style=\"zoom:67%;\" />\n\n<ul>\n<li><p><strong>入队</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">EnQueue</span><span class=\"params\">(SqQueue &amp;Q, QElemType e)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>((Q.rear+<span class=\"number\">1</span>) % MAXQSIZE == Q.front)  <span class=\"comment\">//判断队满</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 队满则报错</span></span><br><span class=\"line\">  Q.base[Q.rear] = e;<span class=\"comment\">//新元素插入队尾</span></span><br><span class=\"line\">  Q.rear = (Q.rear + <span class=\"number\">1</span>) % MAXQSIZE;<span class=\"comment\">//队尾指针加1取模  用模运算将存储空间在逻辑上变成了&quot;环状&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>出队</strong></p>\n<p><code>DeQueue(&amp;Q,&amp;x)</code> : 出队，若队列 Q 非空，删除队头元素，并用 x 返回</p>\n<p>只能从队头出队</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-22.png\" style=\"zoom:55%;\" />\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">DeQueue</span><span class=\"params\">(SqQueue &amp;Q, QElemType &amp;e)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(Q.rear == Q.front)  <span class=\"comment\">//判断队空</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 队空则报错</span></span><br><span class=\"line\">    e = Q.base[Q.front];</span><br><span class=\"line\">    Q.front = (Q.front + <span class=\"number\">1</span>) % MAXQSIZE;<span class=\"comment\">//队头指针后移</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-14.png\" style=\"zoom:67%;\" />\n\n<ul>\n<li><p><strong>获得队头元素</strong></p>\n<p><code>GetHead(Q,&amp;x)</code> ：读取队头元素，若队列Q非空，则将队头元素</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">GetHead</span><span class=\"params\">(SqQueue Q, ElemType &amp;e)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.rear==Q.front)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  <span class=\"comment\">//队空则报错</span></span><br><span class=\"line\">    e=Q.data[Q.front];<span class=\"comment\">//获得队头元素</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"判断队列已满-已空\"><a href=\"#判断队列已满-已空\" class=\"headerlink\" title=\"判断队列已满/已空\"></a>判断队列已满/已空</h4><p>我们前面说判断队列满的时候，不得不牺牲一个存储单元，否则就与我们的队空相互矛盾，但是有时候出题老师可不想让我们浪费这一个存储单元，所以判断队列已满/已空有两种方案</p>\n<ul>\n<li>方案一：浪费一个存储单元</li>\n<li>方案二：不浪费一个存储单元，用一个 size</li>\n<li>方案三：不浪费存储单元，用一个 tag 标记</li>\n</ul>\n<h5 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h5><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-26.png\" style=\"zoom:75%;\" />\n\n<ul>\n<li><p>队列已满的条件：队尾指针的再下一个位置是队头，即 <code>(Q.rear+1)%MaxSize == Q.front</code></p>\n</li>\n<li><p>队空的条件是：队尾指针和队头指针指向相同，<code>Q.rear == Q.front</code></p>\n</li>\n<li><p>队列元素个数：<code>(rear + MaxSize - front)%MaxSize</code></p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-23.png\" style=\"zoom: 67%;\" />\n\n</li>\n</ul>\n<p><font color='orange'>这种方案其实算是牺牲了一个存储空间来区分队满、队空</font></p>\n<h5 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h5><p><strong>但有时在题目中，不允许牺牲那一个存储空间，因此我们要另想一种方案</strong>:</p>\n<p>在队列的结构体类型中，额外定义一个属性<code>int size;</code>，用来表示队列当前长度。刚开始我们将size设为0，之后每次插入一个元素，就size++，每删除一个元素，就size–-。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-27.png\" style=\"zoom:75%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-24.png\" style=\"zoom: 55%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-25.png\" style=\"zoom:55%;\" />\n\n<p>虽然队头和队尾指针都指向了同一位置，但是由于 size 的存在，所以仍然可以判断队列是满的还是空的。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 10\t\t\t\t\t<span class=\"comment\">// 定义队列中元素的最大个数</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    ELemType data[MaxSize];\t\t\t<span class=\"comment\">// 用静态数组存放队列元素</span></span><br><span class=\"line\">    <span class=\"type\">int</span> front,rear;\t\t\t\t\t<span class=\"comment\">// 队头指针和队尾指针</span></span><br><span class=\"line\">    <span class=\"type\">int</span> size;\t\t\t\t\t\t<span class=\"comment\">// 队列当前长度</span></span><br><span class=\"line\">&#125;SqQueue;</span><br><span class=\"line\"><span class=\"comment\">// 初始化队列</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitQueue</span><span class=\"params\">(SqQueue &amp;Q)</span>&#123;</span><br><span class=\"line\">    Q.rear = Q.front = <span class=\"number\">0</span>;<span class=\"comment\">// 初始时,队头、队尾指针指向0</span></span><br><span class=\"line\">    size = <span class=\"number\">0</span>;<span class=\"comment\">// 队列长度也为0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 入队</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">EnQueue</span><span class=\"params\">(SqQueue &amp;Q,ElemeType x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.size == MaxSize)&#123;\t\t\t\t\t<span class=\"comment\">// 判断队满</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t\t\t\t\t\t<span class=\"comment\">// 队满则报错</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Q.data[Q.rear] = x;\t\t\t\t\t\t<span class=\"comment\">// 将 x 插入队尾</span></span><br><span class=\"line\">    Q.rear = (Q.rear + <span class=\"number\">1</span>)%MaxSize;\t\t\t<span class=\"comment\">// 队尾指针加1取模,用模运算将存储空间在逻辑上变成了&quot;环状&quot;</span></span><br><span class=\"line\">    size++;\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 每一次入队成功我们让队列长度 + 1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 出队(删除一个队头元素,并用 x 返回)</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">DeQueue</span><span class=\"params\">(SqQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.size == <span class=\"number\">0</span>)&#123;\t\t\t\t\t\t<span class=\"comment\">// 判断队空</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t\t\t\t\t\t<span class=\"comment\">// 队空则报错</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    X = Q.data[Q.front];</span><br><span class=\"line\">    Q.front = (Q.front +<span class=\"number\">1</span>)%MaxSize;\t\t\t<span class=\"comment\">// 队头指针后移</span></span><br><span class=\"line\">    size--;\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 每一次出队成功我们让队列长度 - 1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;\t\t\t\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"方案三\"><a href=\"#方案三\" class=\"headerlink\" title=\"方案三\"></a>方案三</h5><p>在队列的结构类型中，定义一个<code>int tag;</code>，当tag为0的时候，表示最近一次执行的操作是删除操作；当tag为1的时候，表示最近一次执行的操作是插入操作。</p>\n<p>那么，也就是每次删除操作后，都将tag置为0；每次插入操作后，都将tag置为1。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-28.png\" style=\"zoom:75%;\" />\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 10\t\t\t\t\t<span class=\"comment\">// 定义队列中元素的最大个数</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    ELemType data[MaxSize];\t\t\t<span class=\"comment\">// 用静态数组存放队列元素</span></span><br><span class=\"line\">    <span class=\"type\">int</span> front,rear;\t\t\t\t\t<span class=\"comment\">// 队头指针和队尾指针</span></span><br><span class=\"line\">    <span class=\"type\">int</span> tag;\t\t\t\t\t\t<span class=\"comment\">// 最近进行的是删除(0)/插入(1)</span></span><br><span class=\"line\">&#125;SqQueue;</span><br><span class=\"line\"><span class=\"comment\">// 初始化队列</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitQueue</span><span class=\"params\">(SqQueue &amp;Q)</span>&#123;</span><br><span class=\"line\">    Q.rear = Q.front = <span class=\"number\">0</span>;<span class=\"comment\">// 初始时,队头、队尾指针指向0</span></span><br><span class=\"line\">    tag = <span class=\"number\">0</span>;<span class=\"comment\">// 标志为0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 入队</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">EnQueue</span><span class=\"params\">(SqQueue &amp;Q,ElemeType x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.front == Q.rear &amp;&amp; tag == <span class=\"number\">1</span>)&#123;\t\t<span class=\"comment\">// 判断队满,只有插入操作,才可能导致队满</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t\t\t\t\t\t<span class=\"comment\">// 队满则报错</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Q.data[Q.rear] = x;\t\t\t\t\t\t<span class=\"comment\">// 将 x 插入队尾</span></span><br><span class=\"line\">    Q.rear = (Q.rear + <span class=\"number\">1</span>)%MaxSize;\t\t\t<span class=\"comment\">// 队尾指针加1取模,用模运算将存储空间在逻辑上变成了&quot;环状&quot;</span></span><br><span class=\"line\">    tag == <span class=\"number\">1</span>;\t\t\t\t\t\t\t\t<span class=\"comment\">// 每次插入操作成功时,都令 tag = 1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 出队(删除一个队头元素,并用 x 返回)</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">DeQueue</span><span class=\"params\">(SqQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.front == Q.rear &amp;&amp; tag == <span class=\"number\">0</span>)&#123;\t\t<span class=\"comment\">// 判断队空,只有删除操作,才可能导致队空</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t\t\t\t\t\t<span class=\"comment\">// 队空则报错</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    X = Q.data[Q.front];</span><br><span class=\"line\">    Q.front = (Q.front +<span class=\"number\">1</span>)%MaxSize;\t\t\t<span class=\"comment\">// 队头指针后移</span></span><br><span class=\"line\">    tag == <span class=\"number\">0</span>;\t\t\t\t\t\t\t\t<span class=\"comment\">// 每次删除操作成功时,都令 tag = 0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;\t\t\t\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"其他出题方法\"><a href=\"#其他出题方法\" class=\"headerlink\" title=\"其他出题方法\"></a>其他出题方法</h4><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-114.png\" style=\"zoom:69%;\" />\n\n<p>还有一种出题方法，就是队尾指针 rear 指向的不是队尾元素的下一个，而是队尾元素的位置</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-113.png\" style=\"zoom: 33%;\" />\n\n<ul>\n<li><p>初始化</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化队列</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitQueue</span><span class=\"params\">(SqQueue &amp;Q)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始时,队头指针指向0,队尾指针指向 n - 1</span></span><br><span class=\"line\">    Q.front = <span class=\"number\">0</span>;</span><br><span class=\"line\">    Q.rear = n - <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-40.png\" style=\"zoom:55%;\" />\n</li>\n<li><p>入队操作</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 入队</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">EnQueue</span><span class=\"params\">(SqQueue &amp;Q,ElemeType x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((Q.rear + <span class=\"number\">1</span>)%MaxSize == Q.front)&#123;\t<span class=\"comment\">// 判断队满</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t\t\t\t\t\t<span class=\"comment\">// 队满则报错</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Q.rear = (Q.rear + <span class=\"number\">1</span>)%MaxSize;\t\t\t<span class=\"comment\">// 先将队尾指针向上移一位</span></span><br><span class=\"line\">    Q.data[Q.rear] = x;\t\t\t\t\t\t<span class=\"comment\">// 再将 x 插入队尾</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"队列的链式存储结构\"><a href=\"#队列的链式存储结构\" class=\"headerlink\" title=\"队列的链式存储结构\"></a>队列的链式存储结构</h3><h4 id=\"队列的链式存储\"><a href=\"#队列的链式存储\" class=\"headerlink\" title=\"队列的链式存储\"></a>队列的链式存储</h4><p>队列的链式表示称为<strong>链队列</strong>，它实际上是一个同时带有队头指针和队尾指针的单链表。 头指针指向队头结点，尾指针指向队尾结点，即单链表的最后一个结点（注意与顺序存储的不同）。</p>\n<p><strong>结点类型定义</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span>  <span class=\"comment\">//链式队列结点</span></span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;LinkNode;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span>  <span class=\"comment\">//链式队列</span></span><br><span class=\"line\">    LinkNode *front, *rear;  <span class=\"comment\">//队列的队头和队尾指针</span></span><br><span class=\"line\">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>\n\n<p>当<code>Q.front == NULL &amp;&amp; Q.rear == NULL</code>时，链式队列为空。</p>\n<p>出队时，首先判断队是否为空，若不空，则取出队头元素，将其从链表中华摘除，并让<code>Q.front = Q.front-&gt;next</code>；</p>\n<p>入队时，建立一个新的结点，将该结点插入到链表的尾部，并让<code>Q.rear = Q.rear-&gt;next</code>。</p>\n<p>从上述描述看出，出现了和顺序队列同样的问题，就是操作浪费空间（空间只能用一次），且耗时。</p>\n<h4 id=\"链式队列的基本操作\"><a href=\"#链式队列的基本操作\" class=\"headerlink\" title=\"链式队列的基本操作\"></a>链式队列的基本操作</h4><h5 id=\"带头结点\"><a href=\"#带头结点\" class=\"headerlink\" title=\"带头结点\"></a>带头结点</h5><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-29.png\" style=\"zoom:67%;\" />\n\n<ul>\n<li><p><strong>初始化</strong></p>\n<p>先申请一个结点，然后让队头指针 front、队尾指针 rear 都指向这个结点</p>\n<p>之后让此结点的指针域指向NULL</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-30.png\" style=\"zoom: 50%;\" />\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化队列(带头结点)</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitQueue</span><span class=\"params\">(LinkQueue &amp;Q)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始时, front、rear 都指向头结点</span></span><br><span class=\"line\">    Q.front = Q.rear = (LinkNode*)<span class=\"built_in\">malloc</span>(size(LinkNode));</span><br><span class=\"line\">    Q.front-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>判队空</strong></p>\n<p>判断队列是否为空，只需要看队头指针和队尾指针是否指向相同，指向相同队列为空，指向不相同队列不为空</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 判断队列是否为空(带头结点)</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">IsEmpty</span><span class=\"params\">(LinkQueue Q)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.front == Q.rear)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>入队</strong></p>\n<p>入队只能在队尾入队</p>\n<ul>\n<li>先申请一个结点s，将新入队元素 x 放入这个结点中</li>\n</ul>\n</li>\n</ul>\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-31.png\" style=\"zoom: 50%;\" />\n\n<ul>\n<li>将 s 结点的指针域指向 NULL，之后将 s 结点插入到 rear 之后</li>\n</ul>\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-32.png\" style=\"zoom: 50%;\" />\n\n<ul>\n<li>修改表尾指针为 s 结点</li>\n</ul>\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-33.png\" style=\"zoom: 50%;\" />\n\n  <figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 新元素入队(带头结点)</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EnQue</span><span class=\"params\">(LinkQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class=\"line\">    LinkNode *s =(LinkNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LinkNode));\t\t\t\t<span class=\"comment\">// 用 malloc 申请一个新结点</span></span><br><span class=\"line\">    s-&gt;data = x;\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 将 x 放入这个结点中</span></span><br><span class=\"line\">    s-&gt;next = <span class=\"literal\">NULL</span>;\t\t\t\t<span class=\"comment\">// 插入操作在表尾进行,新插入的结点x肯定是在表尾,所以将x结点指针域设为NULL</span></span><br><span class=\"line\">    Q.rear-&gt;next = s;\t\t\t\t\t\t<span class=\"comment\">// 新结点插入到 rear 之后</span></span><br><span class=\"line\">    Q.rear = s;\t\t\t\t\t\t\t\t<span class=\"comment\">// 修改表尾指针</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>出队</strong></p>\n<p>带头结点出队只能从队头出队</p>\n<ul>\n<li>申请一个新结点 p 指向头结点后面的一个结点(也就是队头结点)，用变量 x 返回队头结点元素</li>\n</ul>\n</li>\n</ul>\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-34.png\" style=\"zoom: 50%;\" />\n\n<ul>\n<li>修改头结点的 next 指针，使其指向 p 结点的下一个结点</li>\n</ul>\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-35.png\" style=\"zoom: 50%;\" />\n\n<ul>\n<li><p>如果出队的结点是最后一个结点，我们要修改队尾指针rear，让其指向头结点</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-36.png\" style=\"zoom:45%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-37.png\" style=\"zoom:45%;\" />\n</li>\n<li><p>释放 p 结点</p>\n</li>\n</ul>\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-38.png\" style=\"zoom: 50%;\" />\n\n  <figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 队头元素出队(不带头结点)</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">DeQueue</span><span class=\"params\">(LinkQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.front == Q.rear)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t\t\t\t\t\t<span class=\"comment\">// 空队</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LinkNode *p = Q.front-&gt;next;\t\t\t<span class=\"comment\">// 申请新结点p 指向头结点的后面一个结点</span></span><br><span class=\"line\">    x = p-&gt;data;\t\t\t\t\t\t\t<span class=\"comment\">// 用变量 x 返回队头元素</span></span><br><span class=\"line\">    Q.front-&gt;next = p-&gt;next;\t\t\t\t<span class=\"comment\">// 修改头结点的 next 指针</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.rear == p)&#123;\t\t\t\t\t\t<span class=\"comment\">// 如果此次是最后一个结点出队</span></span><br><span class=\"line\">        Q.rear = Q.front;\t\t\t\t\t<span class=\"comment\">// 修改 rear 指针</span></span><br><span class=\"line\">    &#125;\t\t</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(p);\t\t\t\t\t\t\t\t<span class=\"comment\">// 释放结点空间</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"不带头结点\"><a href=\"#不带头结点\" class=\"headerlink\" title=\"不带头结点\"></a>不带头结点</h5><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-41.png\" style=\"zoom:67%;\" />\n\n<ul>\n<li><p>初始化</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-42.png\" style=\"zoom: 50%;\" />\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化队列(不带头结点)</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitQueue</span><span class=\"params\">(LinkQueue &amp;Q)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始时, front、rear 都指向NULL</span></span><br><span class=\"line\">    Q.front = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    Q.rear = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>判队列空</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 判断队列是否为空(不带头结点)</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">IsEmpty</span><span class=\"params\">(LinkQueue Q)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.front == <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>入队操作</p>\n<p>不带头结点的队列，第一个元素入队时需要特别处理</p>\n<ul>\n<li>先申请一个新结点 s，将新入队元素 x 放入这个结点中，将此结点的 next 指针域 指向 NULL</li>\n</ul>\n</li>\n</ul>\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-43.png\" style=\"zoom: 50%;\" />\n\n<ul>\n<li>需要判断如果这个队列为空，那么就意味着新结点 s 是这个队列的第一个结点，需要将 front、rear 都指向这个新结点 s</li>\n</ul>\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-44.png\" style=\"zoom: 50%;\" />\n\n<ul>\n<li>如果队列不为空，就是执行后插操作了</li>\n</ul>\n  <figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 新元素入队(不带头结点)</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EnQue</span><span class=\"params\">(LinkQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class=\"line\">    LinkNode *s =(LinkNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LinkNode));\t\t<span class=\"comment\">// 申请新结点</span></span><br><span class=\"line\">    s-&gt;data = x;\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 向此结点写入数据元素 x</span></span><br><span class=\"line\">    s-&gt;next = <span class=\"literal\">NULL</span>;\t\t\t\t<span class=\"comment\">// 插入操作在表尾进行,新插入的结点x肯定是在表尾,所以将x结点指针域设为NULL</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.front == <span class=\"literal\">NULL</span>)&#123;\t\t\t\t\t<span class=\"comment\">// 如果队列为空\t</span></span><br><span class=\"line\">        Q.front = s;\t\t\t\t\t\t<span class=\"comment\">// 不带头结点的队列，第一个元素入队时需要特别处理\t</span></span><br><span class=\"line\">        Q.rear = s;\t\t\t\t\t\t\t<span class=\"comment\">// 在空队列中插入第一个元素,修改队头队尾指针</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        Q.rear-&gt;next = s;\t\t\t\t\t\t<span class=\"comment\">// 新结点插入到 rear 之后</span></span><br><span class=\"line\">    \tQ.rear = s;\t\t\t\t\t\t\t\t<span class=\"comment\">// 修改表尾指针</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>出队操作</p>\n<p>不带头结点出队只能从队头出队</p>\n<ul>\n<li>首先申请新结点 p 指向此次出队的结点(队头结点)，用变量 x 返回队头元素</li>\n</ul>\n</li>\n</ul>\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-45.png\" style=\"zoom: 50%;\" />\n\n<ul>\n<li>修改队头指针 front 指向，需要将 front 、rear 指针指向 NULL(将其恢复为空队的状态)</li>\n</ul>\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-46.png\" style=\"zoom: 50%;\" />\n\n<ul>\n<li>释放结点 p</li>\n</ul>\n  <figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 队头元素出队(不带头结点)</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">DeQueue</span><span class=\"params\">(LinkQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.front == <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t\t\t\t\t\t\t\t<span class=\"comment\">// 空队</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LinkNode *p = Q.front;\t\t\t\t\t\t\t<span class=\"comment\">// 申请新结点 p 指向此次出队的结点</span></span><br><span class=\"line\">    x = p-&gt;data;\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 用变量 x 返回队头元素</span></span><br><span class=\"line\">    Q.front = p-&gt;next;\t\t\t\t\t\t\t\t<span class=\"comment\">// 修改 front 指针</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.rear == p)&#123;</span><br><span class=\"line\">        Q.front = <span class=\"literal\">NULL</span>;\t\t\t\t\t\t\t\t<span class=\"comment\">// front 指向 NULL</span></span><br><span class=\"line\">        Q.rear = <span class=\"literal\">NULL</span>;\t\t\t\t\t\t\t\t<span class=\"comment\">// rear 指向 NULL</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(P);\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 释放结点空间</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"队列满的条件\"><a href=\"#队列满的条件\" class=\"headerlink\" title=\"队列满的条件\"></a>队列满的条件</h5><p>之前顺序存储实现的队列，由于是用静态数组分配的，其空间是有限的、不可拓展的，所以其最大空间被耗尽时队满。</p>\n<p>而此处用链式存储实现的队列，它的容量是可以扩展的，一般不会队满，除非内存不足。</p>\n<p>因此，在顺序存储的队列当中，我们花了很多办法去判断队列是否已满；而在链式存储实现的队列当中，我们一般不用关心已满的问题。</p>\n<h3 id=\"双端队列\"><a href=\"#双端队列\" class=\"headerlink\" title=\"双端队列\"></a>双端队列</h3><ul>\n<li><p>双端队列是指<font color='orange'>允许两端都可以进行入队和出队操作的队列</font>，其元素的逻<font color='orange'>辑结构仍是线性结构</font>font&gt;</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-47.png\" style=\"zoom:67%;\" />\n</li>\n<li><p>将队列的两端分别称为前端和后端，两端都可以入队和出队</p>\n</li>\n<li><p>输出受限的双端队列：允许在一端进行插入和删除，另一端只允许插入</p>\n</li>\n<li><p>输入受限的双端队列：允许在一端进行插入和删除，另一端只允许删除</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-48.png\" style=\"zoom:67%;\" />\n\n</li>\n</ul>\n<blockquote>\n<p>若对于一个双端队列，我只使用其中一端的插入、删除操作，那么我的使用效果就等同于使用一个栈。</p>\n<p>也就是说，栈能够实现的功能，双端队列一定能实现。</p>\n<p>队列同理。</p>\n</blockquote>\n<p><strong>考点</strong></p>\n<p>此处双端队列比较喜欢考察的考点，就是<strong>判断输出序列的合法性</strong>。（类似于栈那里的考点）</p>\n<h3 id=\"习题-1\"><a href=\"#习题-1\" class=\"headerlink\" title=\"习题\"></a>习题</h3><ul>\n<li><p>【2010】某队列允许在其两端进行入队操作，但仅允许在一端进行出队操作。若元素a,b,c,d,e依次入此队列后再进行出队操作，则不可能得到的出队序列是-&gt;d b c a e</p>\n<blockquote>\n<p>双端队列的题可以用以下技巧： </p>\n<p>入队顺序为a b c d e，则出队顺序必然包含在序列e d c b a b c d e中，找出选项中不符合条件的序列即可。 </p>\n<ul>\n<li>A e d c <strong>b</strong> <strong>a</strong> b <strong>c d e</strong> 符合      </li>\n<li>B e <strong>d</strong> c <strong>b</strong> <strong>a</strong> b <strong>c</strong> d <strong>e</strong> 符合      </li>\n<li>C e <strong>d</strong> c <strong>b</strong> a b <strong>c</strong> d e 不符合      </li>\n<li>D <strong>e</strong> d <strong>c</strong> <strong>b a</strong> b c <strong>d</strong> e 符合</li>\n</ul>\n</blockquote>\n</li>\n<li><p>【2011】已知循环队列存储在一维数组A[0…n-1]中，且队列非空时front和rear分别指向队头元素和队尾元素。若初试队列为空，且要求第一个进入队列的元素存储在A[0]处，则初始时front和rear的值分别是→0，n-1</p>\n<blockquote>\n<p>循环队列需要留出一个空间，方便判断队列是否为满（循环队列解决假溢出）； </p>\n<p>常用的队列实现： </p>\n<p>当队列为空时，front == rear；其中rear指向队尾元素的下一个位置，即下一个元素入队的位置 </p>\n<p>入队操作：先赋值，再rear = (rear+1)%MAXSIZE；此时rear仍然指向队尾元素的下一个位置 </p>\n<p>但是题目中！！！有一句！！！front和rear分别指向队头元素和队尾元素！！！  </p>\n<p>rear指向队尾元素！！！  </p>\n<p>把常用的队列实现方法来了个886  </p>\n<p>那么，在这道题中，判断队满和队空我是一时半会想不下去了。。。（front == (rear + 1)%MAXSIZE 既可以是满，也可以是空啊= =，除非说还要留一个空间出来）  </p>\n<p>但是！！！  </p>\n<p>这道题说，初始时队列为空，无论如何还是front == (rear + 1)%MAXSIZE.  </p>\n<p>简单的说就是，队列是空的，rear指向队尾元素，front指向队头元素，入队了，（rear +1）%n，这个时候A[0]既是队头元素，也是队尾元素，rear = front = 0；所以是rear = n-1</p>\n</blockquote>\n</li>\n<li><p>【2014】循环队列放在一维数组A[0…M-1]中，end1指向队头元素，end2指向队尾元素的后一个位置。假设队列两端均可进行入队和出队操作，队列中最多能容纳M-1个元素。初始时为空。下列判断队空和队满的条件中，正确的是–&gt;队空：end1 == end2；                                  队满：end1 == (end2+1)mod M</p>\n<blockquote>\n<p>end1指向队头元素，那么可知出队的操作是先从A[end1]读数，然后end1再加1。end2指向队尾元素的后一个位置，那么可知入队操作是先存数到A[end2]，然后end2再加1。若把A[0]储存第一个元素，当队列初始时，入队操作是先把数据放到A[0]，然后end2自增，即可知end2初值为0；而end1指向的是队头元素，队头元素的在数组A中的下标为0，所以得知end1初值也为0，可知队空条件为end1==end2；然后考虑队列满时，因为队列最多能容纳M-1个元素，假设队列存储在下标为0到下标为M-2的M-1个区域，队头为A[0]，队尾为A[M-2]，此时队列满，考虑在这种情况下end1和end2的状态，end1指向队头元素，可知end1=0，end2指向队尾元素的后一个位置，可知end2=M-2+1=M-1，所以可知队满的条件为end1= =(end2+1)mod M</p>\n</blockquote>\n</li>\n<li><p>用链式存储方式的队列进行删除操作时需要→D</p>\n<p>A 仅修改头指针</p>\n<p>B 仅修改尾指针</p>\n<p>C 头尾指针都要修改</p>\n<p>D 头尾指针可能都要修改</p>\n<blockquote>\n<p>当队列元素&gt;1时，删除操作只修改头指针；当队列元素=1时，删除操作头尾指针都要修改</p>\n</blockquote>\n</li>\n<li><p>16 假设循环单链表表示的队列长度为n，队头固定在链表尾，若只设头指针，则进队操作的时间复杂度为→O(n)</p>\n</li>\n<li><p>【2018】现有队列Q与栈S，初始时Q中的元素依次是1,2,3,4,5,6(1在队头)，s为空。若仅允许下列3种操作:①出队并输出出队元素；②出队并将出队元素入栈；③出栈并输出出栈元素，则不能得到的输出序列是–&gt;C</p>\n<p>A. 1, 2, 5, 6, 4, 3</p>\n<p>B. 2, 3, 4, 5, 6, 1</p>\n<p>C. 3, 4, 5, 6, 1, 2</p>\n<p>D. 6, 5, 4, 3, 2, 1</p>\n<blockquote>\n<p>A的操作顺序为①①②②①①③③。B的操作顺序为②①①①①①③。D的操作顺序为②②②②②①③③③③③。对于C:首先输出3，说明1和2必须先依次入栈，而此后2肯定比1先输出，因此无法得到1，2的输出顺序。</p>\n</blockquote>\n</li>\n<li><p>【2016】设有如下图所示的火车车轨，入口到出口之间有n条轨道，列车的行进方向均为从左至右，列车可驶入任意一条轨道。现有编号为1～9的9列列车，驶入的次序依次是8，4，2，5，3，9，1，6，7。若期望驶出的次序依次为1~9，则n至少是–&gt;C</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-49.png\" style=\"zoom:50%;\" />\n\n<p>A.2       B.3<br>C.4       D.5</p>\n<blockquote>\n<p>将其视为多条队列，每条队列满足：先入队的元素小于**队的元素(如果8和4在同一队列，8在4的后面），这样8入队列1，4入队列2，2入队列3，5入队列2（也可以将5入队列3，但这时剩下的元素就必须放到一个新的队列中，无法使其“至少”），3入队列3，9入队列1，这时共占了3个队列，后面还有元素1，直接再占用一个新的队列4，1从队列4出队后，6、7可以入队到队列2、3、4，综上：最少占用4个队列。其中，确保满足：1）队列中后面的元素大于前面的元素；2）确保占用最少</p>\n</blockquote>\n</li>\n<li><p>【2021】初始为空的队列Q的一端仅能进行入队操作，另外一段既能进行入队操作又能进行出队操作。若Q的入队序列是1，2，3，4，5，则不能得到的出队序列是–&gt;D</p>\n<p>A. 5、4、3、1、2</p>\n<p>B. 5、3、1、2、4</p>\n<p>C. 4、2、1、3、5</p>\n<p>D. 4、1、3、2、5</p>\n<blockquote>\n<p>假设队列左端允许入队和出队，右端允许入队。对于A，依次从右端入队1,2，再从左端入队3,4,5。对于B，从右端入队1,2，然后从左端入队3，再从右端入队4，最后从左端入队5。对于C，从左端入队1,2，然后从右端入队3，再从左端入队4，最后从右端入队5。无法验证D的序列。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-124.png\" style=\"zoom: 67%;\" />\n</blockquote>\n</li>\n<li><p>综合题4【2019】请设计一个队列，要求满足：</p>\n<p>① 初始队列为空；</p>\n<p>② 入队时，允许增加队列占用空间；</p>\n<p>③ 出队后，出队元素所占用的空间可重复使用，即整个队列所占用的空间只增不减；</p>\n<p>④ 入队操作和出队操作的时间复杂度始终保持为O(1</p>\n<p>请回答下列问题</p>\n<p>① 该队列是选择链式存储结构，还是应选择顺序存储结构？</p>\n<p>② 画出队列的初始状态，并给出判断队空和队满的条件</p>\n<p>③ 画出第一个元素入队后的队列状态</p>\n<p>④ 给出入队操作和出队操作的基本过程  </p>\n<blockquote>\n<p>1）顺序存储无法满足要求②的队列占用空间随着入队操作而增加。根据要求来分析：要 求①容易满足；链式存储方便开辟新空间，要求②容易满足；对于要求③，出队后的结点并不 真正释放，用队头指针指向新的队头结点，新元素入队时，有空余结点则无须开辟新空间，赋 值到队尾后的第一个空结点即可，然后用队尾指针指向新的队尾结点，这就需要设计成一个首 尾相接的循环单链表，类似于循环队列的思想。设置队头、队尾指针后，链式队列的入队操作 和出队操作的时间复杂度均为 O(1)，要求④可以满足。 </p>\n<p>因此，采用链式存储结构（两段式单向循环链表），队头指针为 front，队尾指针为 rear。</p>\n<p>2）该循环链式队列的实现，可以参考循环队列，不同之处在于循环链式队列可以方便增 加空间，出队的结点可以循环利用，入队时空间不够也可以动态增加。同样，循环链式队列也 要区分队满和队空的情况，这里参考循环队列牺牲一个单元来判断。初始时，创建只有一个空 闲结点的循环单链表，头指针 front 和尾指针 rear 均指向空闲结点，如下图所示。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-50.png\" style=\"zoom:67%;\" />\n\n<p>队空的判定条件：<code>front == rear</code>。 队满的判定条件：<code>front == rear-&gt;next</code>。</p>\n<p>3）插入第一个元素后的状态如下图所示。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-51.png\" style=\"zoom:67%;\" />\n\n<p>4）操作的基本过程如下:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-52.png\" style=\"zoom: 55%;\" />\n</blockquote>\n</li>\n</ul>\n","categories":["408数据结构"],"tags":["408数据结构"]},{"title":"第四章 串","url":"/p/17647/","content":"<h2 id=\"4-1-串的定义和实现\"><a href=\"#4-1-串的定义和实现\" class=\"headerlink\" title=\"*4.1 串的定义和实现\"></a>*4.1 串的定义和实现</h2><h3 id=\"什么是串\"><a href=\"#什么是串\" class=\"headerlink\" title=\"什么是串\"></a>什么是串</h3><p>字符串，简称串，是由零个或多个字符组成的<font color='orange'>有限序列</font>。一般记为 S = ‘a1a2…an’(n≥0)</p>\n<p>其中，S 是串名，单引号括起来的字符序列是串的值，ai 可以是字母、数字或其他字符；串中字符的个数 n 称为串的长度。n = 0 时的串称为空串。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-42.png\" style=\"zoom:55%;\" />\n\n<p>串是一种<font color='orange'>特殊</font>的<font color='orange'>线性表</font>，数据元素之间呈<font color='orange'>线性关系</font></p>\n<p>它们的区别是:</p>\n<ul>\n<li><p>普通的线性表里面可以存放各种各样的数据类型，是不做限制的。串的数据对象限定为字符集(如中文字符、英文字符、数字字符、标点字符等)</p>\n</li>\n<li><p>普通的线性表，我们在进行增删改查等基本操作时，一般是对线性表中的某<strong>一个数据元素</strong>进行操作。</p>\n<p>而我们对串的基本操作，如增删改查等，<strong>通常以子串为操作对象</strong>。也就是一次是对一堆字符进行操作的。</p>\n</li>\n</ul>\n<h3 id=\"串的存储结构\"><a href=\"#串的存储结构\" class=\"headerlink\" title=\"串的存储结构\"></a>串的存储结构</h3><h4 id=\"串的顺序存储\"><a href=\"#串的顺序存储\" class=\"headerlink\" title=\"串的顺序存储\"></a>串的顺序存储</h4><p>结构类型定义（本质上就是字符数组）</p>\n<p><strong>静态数组实现</strong>:定长顺序存储</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAXLEN 255\t\t\t<span class=\"comment\">// 预定义最大串长为255</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span> ch[MAXLEN];\t\t<span class=\"comment\">// 每个分量存储一个字符</span></span><br><span class=\"line\">    <span class=\"type\">int</span> lenght;\t\t\t\t<span class=\"comment\">// 串的实际长度</span></span><br><span class=\"line\">&#125;SString;\t\t</span><br></pre></td></tr></table></figure>\n\n<p><font color='orange'>静态数组的缺点</font>就是它的<strong>缺点</strong>：长度不可变。</p>\n<p>用静态数组实现串，因此它也叫<strong>串的定长顺序存储</strong>。</p>\n<p>顺序存储在内存中有如下四种方案：</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-43.png\" style=\"zoom:55%;\" />\n\n<ul>\n<li>方案一：会在串的末尾增添一个存储单元，用来存储串的长度变量 Length</li>\n</ul>\n<ul>\n<li>方案二：让 ch[0] 的位置来存储串的长度变量 Length，这样做的优点是字符的位序就和数组下标相同。但缺点是 ch[0] 相当于一个存储单元 1B，这样也只能存储 0~255 的数字范围</li>\n</ul>\n<ul>\n<li>方案三：去掉 Length 变量，在串末尾插入 \\0 表示结尾。缺点是如果经常需要访问串的长度，那么每次都需要对串进行遍历</li>\n</ul>\n<p>由方案一和方案二，我们可以想到一个两者兼备的方案，如下方案四所示。</p>\n<ul>\n<li>方案四：是王道书上的，ch[0] 位置不存储元素，并在串的末尾增添一个存储单元，用来存储串的长度变量 Length。这样既保证了字符的位序就和数组下标相同，也可以记录串的长度</li>\n</ul>\n<p><strong>动态数组实现</strong>:堆分配存储</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span> *ch;\t\t\t\t<span class=\"comment\">// 按串长分配存储区,ch指向串的基地址</span></span><br><span class=\"line\">    <span class=\"type\">int</span> lenght;\t\t\t\t<span class=\"comment\">// 串的长度</span></span><br><span class=\"line\">&#125;HString;</span><br><span class=\"line\"></span><br><span class=\"line\">S.ch = (<span class=\"type\">char</span> *)<span class=\"built_in\">malloc</span>(MAXLEN * <span class=\"keyword\">sizeof</span>(<span class=\"type\">char</span>));\t\t\t<span class=\"comment\">// 用完需要手动 free</span></span><br><span class=\"line\">S.lenght = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<p>malloc方式申请的存储空间，在内存中是在堆区当中的，因此这种方法实现的，叫<strong>堆分配存储</strong>。同时，堆区中分配的内存空间需要手动的free释放。</p>\n<p><font color='orange'>这两种方式的优缺点，和顺序表的不同实现方式的优缺点是一样的。</font></p>\n<h4 id=\"串的链式存储\"><a href=\"#串的链式存储\" class=\"headerlink\" title=\"串的链式存储\"></a>串的链式存储</h4><p>用一个结点存字符，再用一个指针指向下一个结点。</p>\n<ul>\n<li>char 的大小只有 1B，指针大小 4B</li>\n<li>这就意味着我们使用 1 个字节的大小来存储信息，还要使用 4 个字节的大小来存储辅助信息。</li>\n</ul>\n<p>和线性表的链式存储的一样的，只不过我们每个结点保存的数据的类型为<code>char</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StringNode</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span> ch;\t\t\t\t<span class=\"comment\">// 每个结点存1个字符</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StringNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;StringNode,*String;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-3.png\" style=\"zoom: 67%;\" />\n\n<p>这种情况，我们把它称为<strong>存储密度低</strong>。即实际存储的信息比例很小。</p>\n<p>如何解决存储密度低的问题呢？<font color='cornflowerblue'>我们可以让每个结点存多个字符</font></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StringNode</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span> ch[<span class=\"number\">4</span>];\t\t\t\t<span class=\"comment\">// 每个结点存多个字符</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StringNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;StringNode,*String;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-4.png\" style=\"zoom: 55%;\" />\n\n<blockquote>\n<p>此处写的是4个，实际也可以更多。</p>\n<p>那么这样一来，每个结点中，实际存放的信息所占大小就是4B，因此存储密度就会提高。</p>\n<p>因此，若使用链式存储来实现串的话，一般推荐采用这种方式。</p>\n<p>通过这种方式实现，若最后一个结点存不满字符，那么你可以用一些特殊字符（如#，也可以用我们上面提到的’\\0’）将其填充进去。</p>\n</blockquote>\n<h3 id=\"串的基本操作\"><a href=\"#串的基本操作\" class=\"headerlink\" title=\"串的基本操作\"></a>串的基本操作</h3><p>可以看下面两个链接</p>\n<p><a href=\"https://cplusplus.com/reference/cstring/\">c 语言的库：<cstring></a></p>\n<p><a href=\"https://cplusplus.com/reference/string/string/\">c++的库：<string></a></p>\n<p>主要包括构造、销毁、清空、求串长、求字串等</p>\n<p> 基本操作</p>\n<ul>\n<li>StrAssign(&amp;T, chars)：串赋值。把串T赋值为chars</li>\n<li>StrCompare(S, T)：串比较。若S&gt;T，返回值&gt;0;….</li>\n<li>StrLength(S)：求串长。返回串S的元素个数</li>\n<li>Concat(&amp;T, S1, S2)：串连结。用T返回由S1和S2联接而成的新串</li>\n<li>SubString(&amp;Sub, S, pos, len)：求子串。用Sub返回串S的第pos个字符起长度为len的字串。</li>\n<li>StrCopy(&amp;T, S)：串拷贝。由串S复制得到串T。</li>\n<li>StrEmpty(S)：串判空。若S为空串，则返回TRUE，否则返回FALSE。</li>\n<li>ClearString(&amp;S)：清空串</li>\n<li>Index(S,T,pos)：子串的位置。用Sub返回串S的第pos个字符起长度为len的子串。</li>\n<li>Repalce(&amp;S, T, V)：串替换</li>\n<li>StrInsert(&amp;S, pos, T)：子串插入</li>\n<li>StrDelete(&amp;S, pos, len)：子串删除</li>\n<li>DestoryString(&amp;S)：串销毁 </li>\n</ul>\n<h4 id=\"求字串\"><a href=\"#求字串\" class=\"headerlink\" title=\"求字串\"></a>求字串</h4><p><code>SubString(&amp;Sub,S,pos,len)</code> 求子串。用 Sub 返回串 S 的第 pos 个字符起长度为 len 的子串</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-5.png\" style=\"zoom: 60%;\" />\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAXLEN 255\t\t\t<span class=\"comment\">// 预定义最大串长为255</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span> ch[MAXLEN];\t\t<span class=\"comment\">// 每个分量存储一个字符</span></span><br><span class=\"line\">    <span class=\"type\">int</span> length;\t\t\t\t<span class=\"comment\">// 串的实际长度</span></span><br><span class=\"line\">&#125;SString;\t\t</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 求子串</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">SubString</span><span class=\"params\">(SString &amp;Sub,SString S,<span class=\"type\">int</span> pos,<span class=\"type\">int</span> len)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 子串范围越界</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pos+len<span class=\"number\">-1</span> &gt; S.length)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=pos; i&lt;pos+len; i++)&#123;</span><br><span class=\"line\">        Sub.ch[i-pos+<span class=\"number\">1</span>] = S.ch[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Sub.length = len;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"比较操作\"><a href=\"#比较操作\" class=\"headerlink\" title=\"比较操作\"></a>比较操作</h4><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-6.png\" style=\"zoom: 60%;\" />\n\n<p><code>StrCompare(S,T)</code> 比较两个串操作。若 S &gt; T，则返回值 &gt; 0；若 S = T，则返回值 = 0；若 S &lt; T，则返回值 &lt; 0</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-7.png\" style=\"zoom:55%;\" />\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 比较两个串操作。若 S &gt; T，则返回值 &gt; 0；若 S = T，则返回值 = 0；若 S &lt; T，则返回值 &lt; 0</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">StrCompare</span><span class=\"params\">(SString S,SString T)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>; i&lt;=S.length &amp;&amp; i&lt;= T.length; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(S.ch[i] != T.ch[i])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> S.ch[i] - T.ch[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 扫描过的所有字符都相同,则长度更长的串更大</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> S.lenth - T.length;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"定位操作\"><a href=\"#定位操作\" class=\"headerlink\" title=\"定位操作\"></a>定位操作</h4><p><code>Index(S,T)</code>： 定位操作。若主串 S 中存在与串 T 值相同的子串，则返回它在主串 S 中第一次出现的位置，否则函数值为 0</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-8.png\" style=\"zoom:67%;\" />\n\n<p>其实在此处，我们可以通过使用之前实现的求子串操作<code>SubString(&amp;Sub, S, pos, len)</code>来帮助我们完成，将要检查的子串T，和主串S的所有子串依次对比即可，而且，比较两个串是否相等，也可以使用我们之前已经实现的比较操作（StrCompare(S, T)）来完成。</p>\n<p>我们可以在主串 S 中从第一个元素开始取下长度为 3 的子串，然后对比这个子串与串 T 看是否相等，如果不相等，可以再在主串 S 中从第二个元素开始取下长度为 3 的子串，然后对比这个子串与串 T 看是否相等，如果相等，那么我们只需要返回这个子串的第一个字符的位序。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Index</span><span class=\"params\">(SString S,SString T)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i=<span class=\"number\">1</span>; </span><br><span class=\"line\">    <span class=\"type\">int</span> n=StrLength(S);\t\t\t\t<span class=\"comment\">// 求S串长,返回串中元素的个数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> m=StrLength(T);\t\t\t\t<span class=\"comment\">// 求T串长,返回串中元素的个数</span></span><br><span class=\"line\">    SString sub;\t\t\t\t\t<span class=\"comment\">// 用于暂存子串</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt;= n-m+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        SubString(sub,S,i,m);\t\t<span class=\"comment\">// 取子串,用 Sub 返回串 S 的第 i 个字符起长度为 m 的子串。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(StrCompare(sub,T) != <span class=\"number\">0</span>)&#123; <span class=\"comment\">// 对比</span></span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i;\t\t\t\t<span class=\"comment\">// 返回子串在主串中的位置</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\t\t\t\t\t\t<span class=\"comment\">// S中不存在与Tx</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-2-串的匹配模式\"><a href=\"#4-2-串的匹配模式\" class=\"headerlink\" title=\"4.2 串的匹配模式\"></a>4.2 串的匹配模式</h2><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-9.png\" style=\"zoom:60%;\" />\n\n<p>统一一些术语:</p>\n<ul>\n<li><p>从哪个字符串里面进行搜索，那个字符串就叫<strong>主串</strong>。</p>\n</li>\n<li><p>你输入的内容，叫模式串。</p>\n<ul>\n<li>为什么叫模式串，不叫子串？因为子串必定是能够在主串中找到的一个串。而模式串只是我们试图去搜索的一个串，并不一定能够找到，因此叫模式串而不能叫子串。</li>\n</ul>\n</li>\n<li><p><strong>串的模式匹配</strong>：在主串中找到与模式串相同的子串，并返回其所在位置</p>\n</li>\n</ul>\n<h3 id=\"简单的模式匹配算法–BF算法\"><a href=\"#简单的模式匹配算法–BF算法\" class=\"headerlink\" title=\"简单的模式匹配算法–BF算法\"></a>简单的模式匹配算法–BF算法</h3><p>也叫朴素模式匹配算法，其核心思想就是:<font color='red'>暴力求解</font></p>\n<p>之所以叫做朴素模式匹配算法，是因为我们这里不会用其他串的基本操作，而是通过访问数组元素的方式来实现这个过程。</p>\n<p>在主串当中找出所有有可能与模式串相匹配的子串，然后将每个子串与模式串一一进行对比。这样肯定就没有遗漏地进行一遍对比。</p>\n<blockquote>\n<p>因此，如果主串长度为n，模式串长度为m，则</p>\n<p>朴素模式匹配算法：将<strong>主串中所有长度为m的子串</strong>依次与模式串对比，直到找到一个完全匹配的，或直到所有的子串都不匹配为止。</p>\n<p>问题：在长度为n的主串当中，长度为m的子串共有多少个？</p>\n<p>答：共有<code>n-m+1</code>个。</p>\n</blockquote>\n<p>到这里，事实上我们已经发现了，这一系列操作，是和之前我们学过的串的定位操作<code>Index(S, T)</code>是一致的，只是换了个马甲。</p>\n<p>因此，我们所谓的朴素模式匹配算法，就可以使用之前的串定位操作来进行实现，如下。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//和上节写过的那个定位操作是一模一样的内容</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Index</span><span class=\"params\">(SString S, SString T)</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i=<span class=\"number\">1</span>,n = StrLength(S),m = StrLength(T);</span><br><span class=\"line\">\tSString sub;\t<span class=\"comment\">//用于暂存子串</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(i &lt;= n-m+<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\tSubString(sub, S, i, m);<span class=\"comment\">//取出从位置i开始，长度为m的子串</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(StrCompare(sub, T) != <span class=\"number\">0</span>) ++i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> i;\t<span class=\"comment\">//返回子串在主串中的位置 </span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;\t<span class=\"comment\">//没有匹配到 </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来，我们不借助字符串的基本操作，而是<strong>直接通过数组下标来实现朴素模式匹配算法</strong>。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-10.png\" style=\"zoom: 69%;\" />\n\n<p>1.我们会使用 k 来记录当前检查的子串的起始位置，然后比对这个子串与模式串，如果不能匹配，就让 k++（这里在比对时，只要有一个字符不同，就可以停止检查当前子串）</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-11.png\" style=\"zoom: 42%;\" />\n\n<p>2.如果对比的子串和模式串不相等，让 k 的值 ++，也就是对比下一个子串，然后让 i 和 j 分别指向子串和模式串的第一个字符</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-12.png\" style=\"zoom:41%;\" />\n\n<p>3.循环执行操作 2，当被比对的子串和模式串的第一个值相同，这个时候让 i 和 j 的值同时向后移，对比第二个字符，第二个字符也相等，那继续让 i 和 j 的值向后移，对比第三个字符</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-13.png\" style=\"zoom:41%;\" />\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Index</span><span class=\"params\">(SString S,SString T)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> k=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> i=k,j=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&lt;=S.length &amp;&amp; j &lt;= T.length)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(S.ch[i] == T.ch[j])&#123;\t\t\t\t<span class=\"comment\">// 当对比的子串和模式串的第一个字符相等</span></span><br><span class=\"line\">            ++i;\t\t\t\t\t\t\t<span class=\"comment\">// 让 i 和 j 向后移</span></span><br><span class=\"line\">            ++j;\t\t\t\t\t\t\t<span class=\"comment\">// 继续比较后继字符</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            k++;\t\t\t\t\t\t\t<span class=\"comment\">// 检查下一个子串</span></span><br><span class=\"line\">            i=k;\t\t\t\t\t\t\t<span class=\"comment\">// i 指向被对比子串的第一个字符</span></span><br><span class=\"line\">            j=<span class=\"number\">1</span>;\t\t\t\t\t\t\t<span class=\"comment\">// j 指向模式串的第一个字符</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(j&gt;T.length)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> k;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>王道课本代码是这样的:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Index_BF</span><span class=\"params\">(SString S, SString T)</span> &#123;</span><br><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">1</span>, j = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (i &lt;= S.length &amp;&amp; j &lt;= T.length) &#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (S.ch[i] == T.ch[j]) &#123;<span class=\"comment\">// 比较成功则继续匹配下一个字符串</span></span><br><span class=\"line\">    ++i;</span><br><span class=\"line\">    ++j;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 比较不成功则回溯</span></span><br><span class=\"line\">    i = i-j+<span class=\"number\">2</span>;</span><br><span class=\"line\">    j++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (j &gt; T.length)  <span class=\"keyword\">return</span>  i-T.length;  <span class=\"comment\">// 看下文注释</span></span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">j &gt;= T.length 是错误的，举个反例：</span></span><br><span class=\"line\"><span class=\"comment\">S = &#123;&quot;abcdef&quot;&#125;; T = &#123;&quot;fg&quot;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">when i = 6;</span></span><br><span class=\"line\"><span class=\"comment\">S.ch[i] = T.ch[j] = &#x27;f&#x27;;</span></span><br><span class=\"line\"><span class=\"comment\">Then i=7; j=2;</span></span><br><span class=\"line\"><span class=\"comment\">此时不符合循环条件跳出。明显j = 2匹配成功了</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p><font color='purple'>算法性能分析</font>:</p>\n<p>若模式串长度为 m，主串长度为 n，则匹配成功的最好时间复杂度为：O(m)</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-14.png\" style=\"zoom:50%;\" />\n\n<p>若模式串长度为 m，主串长度为 n，则匹配失败的最好时间复杂度为：O(n-m+1) = O(n-m) ≈ O(n)</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-15.png\" style=\"zoom: 36%;\" />\n\n<p>最坏情况：每个子串的前 m-1 个字符都和模式串匹配，只有第 m 个字符不匹配</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-16.png\" style=\"zoom:73%;\" />\n\n<p><font color='orange'>再回顾一下</font>:</p>\n<ul>\n<li>串的模式匹配：在主串中找到与模式串相同的子串，并返回其所在位置。</li>\n<li>朴素模式匹配算法(简单模式匹配算法)思想：将主串中的模式串长度相同的子串搞出来，挨个与模式串对比，当子串与模式串某个对应字符不匹配时，就立即放弃当前子串，转而检索下一个子串</li>\n<li>若模式串长度为 m，主串长度为 n，则直到匹配成功/匹配失败最多需要 (n-m+1)*m 次比较</li>\n</ul>\n<h3 id=\"改进的模式匹配算法——KMP-算法\"><a href=\"#改进的模式匹配算法——KMP-算法\" class=\"headerlink\" title=\"改进的模式匹配算法——KMP 算法\"></a>改进的模式匹配算法——KMP 算法</h3><p>KMP 算法：朴素模式匹配算法的优化</p>\n<p>KMP 算法之所以叫做 KMP 算法，是因为发明它的三个人的名字第一个开头字母组成的。✌️</p>\n<p>朴素模式匹配算法的缺点：<strong>当某些子串与模式串能部分匹配时，主串的扫描指针 i 经常回溯，导致时间开销增加</strong>。这是为什么呢。因为我们在进行匹配之前，并不知道主串里面有什么，我们只能根据下标、模式串串长，进行一个一个的对比。即使是上一轮中对比过的相等的字符，我们也并没有记录。总之每次循环前，主串中有什么内容，都是我们不知道的，我们<strong>只知道开始匹配的下标位置，与要匹配的长度</strong>。</p>\n<p>但是实际上，由于上一轮循环，对于字符的逐个对比，到某个字符匹配失败时结束，这一过程当中，我们必然能够通过一部分“i指向的字符与j指向的字符相等”，来得知主串当中有哪些字符。即，在遇到不匹配的字符之前的字符，一定是和模式串一致的字符。</p>\n<p>因此，对于主串中的信息，虽然刚开始我们一无所知。但是通过模式串的部分匹配，我们可以确定主串里面前边一小部分到底是什么内容。内容就是模式串失配位置前的所有字符。</p>\n<p>那么，根据模式串失配位置前的内容，映射到主串相应位置，之后去执行朴素模式匹配的话，它会寻找到某个位置之后再进行真正的匹配。</p>\n<p>而且从逻辑上来讲，这一操作过程与主串是什么无关，只是与模式串本身的信息内容、失配位置相关。</p>\n<p><font color='red'>改进思路</font>：主串指针不回溯，只有模式串指针回溯</p>\n<hr>\n<p>我们来看一个例子，例如指向模式串的指针 j = 6 时发生了不匹配</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-17.png\" style=\"zoom: 67%;\" />\n\n<p>那么也就是说，前 5 个字符都与模式串匹配上了，这个时候我们让模式串回溯到起始位置，只需要比较子串的最后一个字符与模式串的起始字符是否相同</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-18.png\" style=\"zoom: 67%;\" />\n\n<p>如果子串的最后一个字符与模式串的起始字符相同，我们让指向子串和模式串的指针 i++，j++，从而比较第二个字符是否相同</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-19.png\" style=\"zoom:67%;\" />\n\n<p>如果子串的最后一个字符与模式串的起始字符不相同，我们让指向子串的 i 后移，检查后继元素是否与模式串的起始元素相同，而指向模式串的指针 j 依然是 1</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-20.png\" style=\"zoom:67%;\" />\n\n<p>那如果指向模式串的指针 j = 5 时发生了不匹配，如图:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-21.png\" style=\"zoom:67%;\" />\n\n<p>那么说明我们前4个字符都匹配上了，并且此时子串有第二个 g 开头，我们只需要比对模式串的第二个字符，看子串的 ？号处的字符是否与 o 相同，所以我们让指向模式串的指针 j 回到 2</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-22.png\" style=\"zoom:67%;\" />\n\n<p>如果说指向模式串的指针 j = 3 时不匹配</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-23.png\" style=\"zoom:67%;\" />\n\n<p>让指向模式串的指针 j 回到1</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-24.png\" style=\"zoom:67%;\" />\n\n<p><font color='red'>总结</font>：当我们的指针 j 扫描到某一个字符时，如果发生了不匹配，那么说明前面的字符和我们的主串是能够完全匹配上的，那我们就可以利用模式串前缀的信息，就可以分析出指针 j 接下来应该指向什么位置。</p>\n<hr>\n<p>我们将 j 应该指向什么位置的信息放在一个数组里，数组名字叫 <strong>next</strong></p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-25.png\" style=\"zoom:67%;\" />\n\n<p>这个数组的意思是当指针 j 指向的位置发生不匹配，那么它应该回到某一个位置。这里我们发现当 j = 1时发生不匹配，应该让 j 仍然是1，但是 next 数组里面让 j 回到 0，这是为了写代码的时候考虑。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-26.png\" style=\"zoom: 33%;\" />\n\n<hr>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-44.png\" style=\"zoom:67%;\" />\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Index_KMP</span><span class=\"params\">(SString S,SString T,<span class=\"type\">int</span> next[])</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i=<span class=\"number\">1</span>;j=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&lt;=S.length &amp;&amp; j&lt;= T.length)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j==<span class=\"number\">0</span> || S.ch[i] == T.ch[j])&#123;</span><br><span class=\"line\">            ++i;</span><br><span class=\"line\">            ++j;\t\t\t\t\t\t\t\t<span class=\"comment\">// 继续比较后继字符</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            j=next[j];\t\t\t\t\t\t\t<span class=\"comment\">// j指回相应位置,模式串向右移动</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(j&gt;T.length)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i-T.length;\t\t\t\t\t\t<span class=\"comment\">// 匹配成功</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>KMP算法，最坏时间复杂度O(m+n)；其中，求next数组时间复杂度O(m),模式匹配过程最坏时间复杂度O(n)。</p>\n<h3 id=\"求next数组🔥-王卓\"><a href=\"#求next数组🔥-王卓\" class=\"headerlink\" title=\"求next数组🔥(王卓)\"></a>求next数组🔥(王卓)</h3><p><strong>所以其实 KMP 算法的关键在于我们需要先搞出一个和模式串相对应的数组 next。</strong></p>\n<p>我们先来观察几个例子:</p>\n<p>当 j = 6 时，匹配失败，我们要让模式串向右移动到 j = 3</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-27.png\" style=\"zoom:64%;\" />\n\n<p>当 j = 7 时，匹配失败，我们要让模式串向右移动到 j = 5</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-28.png\" style=\"zoom: 55%;\" />\n\n<p>当 j = 5时匹配失败，我们要让模式串向右移动到 j = 4</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-29.png\" style=\"zoom:59%;\" />\n\n<p>当 j = 5 时匹配失败，我们要让模式串向右移动到 j = 1</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-30.png\" style=\"zoom:58%;\" />\n\n<p>当 j = 1 时就发生匹配失败，我们让 j = 0</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-31.png\" style=\"zoom:60%;\" />\n\n<p>串的前缀：包含第一个字符，且不包含最后一个字符的子串</p>\n<p>串的后缀：包含最后一个字符，且不包含第一个字符的子串</p>\n<p><font color='orange'>当第 j 个字符匹配失败，由前 1 ~ j-1 个字符组成的串记为 S，则： next[j] = S的最大公共前后缀长度 +1</font></p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-32.png\" style=\"zoom:65%;\" />\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Get_next</span><span class=\"params\">(SString T, <span class=\"type\">int</span> next[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">1</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    next[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; <span class=\"built_in\">strlen</span>(T)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j == <span class=\"number\">0</span> || T.ch[i] == T.ch[j]) &#123;</span><br><span class=\"line\">            ++i; ++j;</span><br><span class=\"line\">            next[i] = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> j = next[j]; <span class=\"comment\">// 隐含着非常厉害的递归思想</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度O(m+n) ，其中O(m) 来自于求next数组，O(n) 来自KMP算法的里层循环（普通模式匹配算法的时间复杂度是O(mn)</p>\n<hr>\n<h3 id=\"求next数组-王道\"><a href=\"#求next数组-王道\" class=\"headerlink\" title=\"求next数组(王道)\"></a>求next数组(王道)</h3><p>这个有两种方法：一种是王道讲的这个；一种是王卓上面讲的，根据当前要判断的元素的前面的模式串的子串中公共前后缀的长度加1来确定当前next数组的值（不过要注意模式串下标，有的题目是j从0开始，然后这里需要加1是因为next数组第一个是0，第二个是1）。</p>\n<hr>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-45.png\" style=\"zoom:67%;\" />\n\n<ul>\n<li><p>首先分析next[1]</p>\n<blockquote>\n<p>next[1]的含义是，当模式串的第一个字符发生失配时，模式串指针j应该指向什么位置？</p>\n<p>应该是让j=0，然后执行i++,j++。</p>\n</blockquote>\n<p>对于任何一个模式串都是一样的，第一个字符不匹配时，只能匹配下一个子串。因此，<strong>next[1]均直接写0</strong>即可。</p>\n</li>\n<li><p>分析next[2]</p>\n<blockquote>\n<p>next[2]的含义是，如果第二个字符发生失配，接下来指针j应该指向哪？</p>\n<p>对于这个例子来说，我们应该让j=1。</p>\n</blockquote>\n<p>事实上，对于任何一个模式串都一样，第2个字符不匹配时，应该尝试匹配模式串的第1个字符。因此，<strong>next[2]均直接写1</strong>即可。</p>\n</li>\n<li><p>分析next[3]</p>\n<blockquote>\n<p>在不匹配位置前边，画一个分界线。然后，让模式串一步一步往后退，直到在分界线之前“能对上”，或模式串完全跨过分界线。</p>\n</blockquote>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-46.png\" style=\"zoom:67%;\" />\n\n<p>分界线右边的内容是未知的，模式串一步一步右移，观察分界线左边能不能匹配得上</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-47.png\" style=\"zoom:67%;\" />\n\n<p>即此模式串对应的<code>next[3] = 1</code>。</p>\n</li>\n<li><p>分析next[4]</p>\n<p>同理可知，<code>next[4] = 1</code>。</p>\n</li>\n<li><p>分析next[5]</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-48.png\" style=\"zoom:67%;\" />\n\n<p>同理可知，<code>next[5] = 2</code>。</p>\n</li>\n<li><p>分析next[6]</p>\n<p>同理可知，<code>next[6] = 1</code>。</p>\n</li>\n</ul>\n<h4 id=\"练习1\"><a href=\"#练习1\" class=\"headerlink\" title=\"练习1\"></a>练习1</h4><p><font color='green'>这里直接用算法算</font></p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-33.png\" style=\"zoom:67%;\" />\n\n<p>如题:</p>\n<ol>\n<li>next[1] == 0</li>\n<li>next[2] 的意思是当我们匹配到第二个字符的时候发现匹配失败，那么前 1~(2-1) 个字符组成的串记为S，也就是串S此时只有一个字符为a，<code>&#39;a&#39;</code> 的前缀是空集，后缀也是空集，所以最长相等前后缀长度+1 = 1，所以 next[2] = 1(<strong>其实，无脑写1即可</strong>)</li>\n<li>next[3] 的意思是当我们匹配到第三个字符的时候发现匹配失败，那么前 1~(3-1) 个字符组成的串记为S，也就是串S此时为 <code>&#39;ab&#39;</code> ,前缀为{a}，后缀为{b},所以最长相等前后缀长度+1 = 1,所以 next[3] = 1</li>\n<li>next[4] 的意思是当我们匹配到第四个字符的时候发现匹配失败，那么前 1~(4-1) 个字符组成的串记为S，也就是串S此时为 <code>&#39;aba&#39;</code> ,前缀为{a,ab}，后缀为{a,ba},所以最长相等前后缀长度+1 = 2,所以 next[4] = 2</li>\n<li>next[5] 的意思是当我们匹配到第五个字符的时候发现匹配失败，那么前 1~(5-1) 个字符组成的串记为S，也就是串S此时为 <code>&#39;abab&#39;</code> ,前缀为{a,ab,aba}，后缀为{b,ab,bab},所以最长相等前后缀长度+1 = 3,所以 next[3] = 3</li>\n<li>next[6] 的意思是当我们匹配到第六个字符的时候发现匹配失败，那么前 1~(6-1) 个字符组成的串记为S，也就是串S此时为 <code>&#39;ababa&#39;</code> ,前缀为{a,ab,aba,abab}，后缀为{a,ba,aba,baba},所以最长相等前后缀长度+1 = 4,所以 next[6] = 4</li>\n</ol>\n<p>所以答案为：</p>\n<table>\n<thead>\n<tr>\n<th>序号j</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>模式串</td>\n<td>a</td>\n<td>b</td>\n<td>a</td>\n<td>b</td>\n<td>a</td>\n<td>a</td>\n</tr>\n<tr>\n<td>next[j]</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody></table>\n<h4 id=\"练习2\"><a href=\"#练习2\" class=\"headerlink\" title=\"练习2\"></a>练习2</h4><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-34.png\" style=\"zoom:67%;\" />\n\n<p>如题:</p>\n<ol>\n<li>next[1] == 0</li>\n<li>next[2] 的意思是当我们匹配到第二个字符的时候发现匹配失败，那么前 1~(2-1) 个字符组成的串记为S，也就是串S此时只有一个字符为a，<code>&#39;a&#39;</code> 的前缀是空集，后缀也是空集，所以最长相等前后缀长度+1 = 1，所以 next[2] = 1</li>\n<li>next[3] 的意思是当我们匹配到第三个字符的时候发现匹配失败，那么前 1~(3-1) 个字符组成的串记为S，也就是串S此时为 <code>&#39;aa&#39;</code> ,前缀为{a}，后缀为{a},所以最长相等前后缀长度+1 = 1,所以 next[3] = 2</li>\n<li>next[4] 的意思是当我们匹配到第四个字符的时候发现匹配失败，那么前 1~(4-1) 个字符组成的串记为S，也就是串S此时为 <code>&#39;aaa&#39;</code> ,前缀为{a,aa}，后缀为{a,aa},所以最长相等前后缀长度+1 = 3,所以 next[4] = 3</li>\n<li>next[5] 的意思是当我们匹配到第五个字符的时候发现匹配失败，那么前 1~(5-1) 个字符组成的串记为S，也就是串S此时为 <code>&#39;aaaa&#39;</code> ,前缀为{a,aa,aaa}，后缀为{a,aa,aaa},所以最长相等前后缀长度+1 = 4,所以 next[5] = 4</li>\n</ol>\n<p>答案为:</p>\n<table>\n<thead>\n<tr>\n<th>序号j</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>模式串</td>\n<td>a</td>\n<td>a</td>\n<td>a</td>\n<td>a</td>\n<td>b</td>\n</tr>\n<tr>\n<td>next[j]</td>\n<td>0</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody></table>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>朴素模式匹配算法的缺点：当某些子串与模式串能部分匹配时，主串的扫描指针i经常回溯，导致时间开销增加。最坏的时间复杂度O(nm)</p>\n<p>KMP算法：当子串和模式串不匹配时，主串指针i不回溯，模式串指针 j=next[j] ，算法的平均时间复杂度：<code>O(n+m)</code></p>\n<p>next数组手算方法：当第j个字符匹配失败，由前 <code>1~j-1</code> 个字符组成的串记为S，则：<code>next[j]=S的最长相等前后缀长度+1</code></p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-35.png\" style=\"zoom:67%;\" />\n\n<p><strong>感兴趣看</strong>:</p>\n<p><a href=\"https://blog.csdn.net/ns_code/article/details/19286279\">从BF算法到KMP算法</a></p>\n<p><a href=\"https://www.cnblogs.com/jingmoxukong/p/4343770.html\">字符串 模式匹配</a></p>\n<h3 id=\"KMP-算法优化-nextval数组\"><a href=\"#KMP-算法优化-nextval数组\" class=\"headerlink\" title=\"KMP 算法优化-nextval数组\"></a>KMP 算法优化-nextval数组</h3><h4 id=\"举例说明\"><a href=\"#举例说明\" class=\"headerlink\" title=\"举例说明\"></a>举例说明</h4><p><font color='purple'>举个例子</font></p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-49.png\" style=\"zoom:67%;\" />\n\n<p>当第三个元素不匹配时，让j指针指回next[3]，即从模式串T第一个字符开始匹配</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-50.png\" style=\"zoom:67%;\" />\n\n<p>主串前面两个元素是已经确定的了，第三个元素虽然具体不知道是什么，也可以肯定不是a，但此时查找next[3]为1，而模式串的第一个元素也还是a，根据前一节讲过的KMP算法，是会让模式串的第一个元素跟主串第三个元素比较的，就有点多余了，增加了时间复杂度</p>\n<p>所以改良一下，完全可以让j直接等于0,next[3]=next[1]</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-51.png\" style=\"zoom:80%;\" />\n\n<p>j指向0的时候，i、j再同时++</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-52.png\" style=\"zoom:67%;\" />\n\n<hr>\n<p>==再举个例子==</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-53.png\" style=\"zoom:67%;\" />\n\n<p>根据KMP算法应该让j=2，但同样的问题，匹配到5这个字符时发现匹配失败，虽然不知道主串i指针指向的元素是什么，但确定的是一定不是b，因为模式串中2这个字符和5这个字符是一样的</p>\n<p>这次再匹配失败后，j的值应该改成next[2]。与其多比较一次，不如直接让next[5]=next[2]=1</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-54.png\" style=\"zoom:67%;\" />\n\n<hr>\n<p><font color='cornflowerblue'>那么是不是所有next数组的值都可被优化呢？</font></p>\n<p>==来看这样一个例子==</p>\n<p>假设模式串匹配到第6个字符时才发现匹配失败，那么能确定是主串中i指向的字符一定不是c</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-55.png\" style=\"zoom:67%;\" />\n\n<p>原本next[6]对应的是3，即应将j指向3，从3开始往后匹配。此时只知道主串匹配失败的字符一定不是c，但有可能是a，所以next[6]=3是有必要的。</p>\n<h4 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h4><p>KMP原本是根据模式串T，求出next数组，再利用next数组进行匹配，主串不回溯而模式串回溯。</p>\n<p>对KMP算法的优化本质是只是优化了next数组，将next数组按照上述思想优化成nextval数组，用nextval数组替代next数组</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Get_next</span><span class=\"params\">(SString T, <span class=\"type\">int</span> next[])</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">1</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    nextval[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; <span class=\"built_in\">strlen</span>(T)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j == <span class=\"number\">0</span> || T.ch[i] == T.ch[j]) &#123;</span><br><span class=\"line\">            ++i; ++j;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(T.ch[i]! =T.ch[j]) nextval[i]=j;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> nextval[i] = nextval[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> j = nextval[j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"练习1：求nextval数组\"><a href=\"#练习1：求nextval数组\" class=\"headerlink\" title=\"练习1：求nextval数组\"></a>练习1：求nextval数组</h4><p><a href=\"https://www.cnblogs.com/cherryljr/p/6519748.html\">KMP算法的优化与详解</a></p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-56.png\" style=\"zoom:67%;\" />\n\n<p>首先nextval[1]无脑写0，然后从前往后依次求nextval[]，如果当前的next[j]所指的字符和目前j所指的字符不相等，nextval[j]=next[j]。反之，则nextval[j]=nextval[next[j]]。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-36.png\" style=\"zoom:50%;\" />\n\n<p>例如，对于上述模式串<code>&quot;aaaab&quot;</code>,它的next数组如图，其nextval数组分析如下：</p>\n<ol>\n<li>nextval[1] == 0</li>\n<li>nextval[2] ,第二个字符的next[2] == 1，但是由于第二个字符与第一个字符是相同的，所以将第一个字符的 nextval[1] 赋值给第二个字符的nextval[2] == 0</li>\n<li>nextval[3] ,第三个字符的next[3] == 2，但是由于第三个字符与第二个字符是相同的，所以将第二个字符的 nextval[2] 赋值给第三个字符的 nextval[3] == 0</li>\n<li>nextval[4] ,第四个字符的next[4] == 3，但是由于第四个字符与第三个字符是相同的，所以将第三个字符的 nextval[3] 赋值给第四个字符的 nextval[4] == 0</li>\n<li>nextval[5] ,第五个字符的next[5] == 4，第五个字符b与第四个字符不相同，所以让其保持以前的 next 值不变，则nextval[5] = next[5] =4</li>\n</ol>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-37.png\" style=\"zoom:50%;\" />\n\n<p>获得 nextval 函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Get_next</span><span class=\"params\">(SString T, <span class=\"type\">int</span> nextval[])</span>&#123;</span><br><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">1</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">nextval[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (i &lt; <span class=\"built_in\">strlen</span>(T)) &#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (j == <span class=\"number\">0</span> || T.ch[i] == T.ch[j]) &#123;</span><br><span class=\"line\">    i++;j++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T.ch[i] != T.ch[j]) nextval[i] = j;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> nextval[i] = nextval[j];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> j = nextval[j]; <span class=\"comment\">// 隐含着非常厉害的递归思想</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>总结</strong>:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-38.png\" style=\"zoom:67%;\" />\n\n<p>若题目中需要求 nextval 数组，那我们需要先手算出 next 数组，然后令 nextval[1] = 0,之后从左向右算出 nextval 值</p>\n<h3 id=\"习题\"><a href=\"#习题\" class=\"headerlink\" title=\"习题\"></a>习题</h3><ul>\n<li><p>思考：手算next数组→①next[ 1 ] = 0②next[ 2 ] = 1③next[ i ] = 前缀 和 后缀 最大交集 + 1</p>\n</li>\n<li><p>思考：<code>&#123;aba&#125;</code> 的前缀和后缀分别是什么?→前缀{a, ab}（没有b，必须连续且包含第一个字符），后缀{a, ba}（必须连续且包含最后一个字符）</p>\n</li>\n<li><p>思考：模式串为<code>a b a b a a</code> 求next数组→0 1 1 2 3 4</p>\n</li>\n<li><p>思考：模式串为<code>a a a a b</code>，求next和nextval数组?→0 1 2 3 4；0 0 0 0 4</p>\n</li>\n<li><p>5 和 7，串 <code>a b a b a a a b a b a a</code> 的next数组和nextval值为?→011234223456 ；010104210104</p>\n<blockquote>\n<p>1、前两位：next数组前两位规定是0，1 即前两位ab对应的next数组为01，则：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">模式串</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">下标</td>\n<td align=\"left\">1</td>\n<td align=\"left\">2</td>\n<td align=\"left\">3</td>\n<td align=\"left\">4</td>\n<td align=\"left\">5</td>\n<td align=\"left\">6</td>\n<td align=\"left\">7</td>\n<td align=\"left\">8</td>\n<td align=\"left\">9</td>\n<td align=\"left\">10</td>\n<td align=\"left\">11</td>\n<td align=\"left\">12</td>\n</tr>\n<tr>\n<td align=\"left\">next数组</td>\n<td align=\"left\">0</td>\n<td align=\"left\">1</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>2、接下来看第三位，按照next数组求解方法。第三位a的前一位为第二位的b，b的next值为1对应内容为a，b与a不同，向前继续寻找next值对应的内容来与前一位进行比较。因为找到第一位都没有找到与前一位相等的内容，所以第三位a的next值为1，则：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">模式串</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">下标</td>\n<td align=\"left\">1</td>\n<td align=\"left\">2</td>\n<td align=\"left\">3</td>\n<td align=\"left\">4</td>\n<td align=\"left\">5</td>\n<td align=\"left\">6</td>\n<td align=\"left\">7</td>\n<td align=\"left\">8</td>\n<td align=\"left\">9</td>\n<td align=\"left\">10</td>\n<td align=\"left\">11</td>\n<td align=\"left\">12</td>\n</tr>\n<tr>\n<td align=\"left\">next数组</td>\n<td align=\"left\">0</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>3、接下来看第四位b，b的前一位a的next值1对应内容为a，相同，所以该位b的next值就是前一位a的next值加上1，即为2</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">模式串</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">下标</td>\n<td align=\"left\">1</td>\n<td align=\"left\">2</td>\n<td align=\"left\">3</td>\n<td align=\"left\">4</td>\n<td align=\"left\">5</td>\n<td align=\"left\">6</td>\n<td align=\"left\">7</td>\n<td align=\"left\">8</td>\n<td align=\"left\">9</td>\n<td align=\"left\">10</td>\n<td align=\"left\">11</td>\n<td align=\"left\">12</td>\n</tr>\n<tr>\n<td align=\"left\">next数组</td>\n<td align=\"left\">0</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">2</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>4、接下来看第五位a，a的前一位b的next值2对应内容为b，相等，所以该位a的next值就是前一位b的next值加上1，即为3</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">模式串</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">下标</td>\n<td align=\"left\">1</td>\n<td align=\"left\">2</td>\n<td align=\"left\">3</td>\n<td align=\"left\">4</td>\n<td align=\"left\">5</td>\n<td align=\"left\">6</td>\n<td align=\"left\">7</td>\n<td align=\"left\">8</td>\n<td align=\"left\">9</td>\n<td align=\"left\">10</td>\n<td align=\"left\">11</td>\n<td align=\"left\">12</td>\n</tr>\n<tr>\n<td align=\"left\">next数组</td>\n<td align=\"left\">0</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">2</td>\n<td align=\"left\">3</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>5、接下来看第六位a，a的前一位a的next值3对应内容为a，相等，所以该位a的next值就是前一位a的next值加上1，即为4</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">模式串</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">下标</td>\n<td align=\"left\">1</td>\n<td align=\"left\">2</td>\n<td align=\"left\">3</td>\n<td align=\"left\">4</td>\n<td align=\"left\">5</td>\n<td align=\"left\">6</td>\n<td align=\"left\">7</td>\n<td align=\"left\">8</td>\n<td align=\"left\">9</td>\n<td align=\"left\">10</td>\n<td align=\"left\">11</td>\n<td align=\"left\">12</td>\n</tr>\n<tr>\n<td align=\"left\">next数组</td>\n<td align=\"left\">0</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">2</td>\n<td align=\"left\">3</td>\n<td align=\"left\">4</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>6、接下来看第七位a，a的前一位a的next值4对应内容为b，不相等，向前继续寻找next值对应的内容来与前一位进行比较，b的next值2对应的内容为b，依旧不相等，继续向前寻找，第二位b的next值1对应内容为a，相等。因为是在第二位b处实现的相等，所以第七位a的next值为第二位b的next值上加1，即为2</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">模式串</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">下标</td>\n<td align=\"left\">1</td>\n<td align=\"left\">2</td>\n<td align=\"left\">3</td>\n<td align=\"left\">4</td>\n<td align=\"left\">5</td>\n<td align=\"left\">6</td>\n<td align=\"left\">7</td>\n<td align=\"left\">8</td>\n<td align=\"left\">9</td>\n<td align=\"left\">10</td>\n<td align=\"left\">11</td>\n<td align=\"left\">12</td>\n</tr>\n<tr>\n<td align=\"left\">next数组</td>\n<td align=\"left\">0</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">2</td>\n<td align=\"left\">3</td>\n<td align=\"left\">4</td>\n<td align=\"left\">2</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>7、看第八位b，b的前一位a的next值2对应内容为b，不相等，向前继续寻找next值对应的内容来与前一位进行比较，b的next值1对应的内容为a，相等。因为是在第二位b处实现的相等，所以第八位a的next值为第二位b的next值上加1，即为2：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">模式串</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">下标</td>\n<td align=\"left\">1</td>\n<td align=\"left\">2</td>\n<td align=\"left\">3</td>\n<td align=\"left\">4</td>\n<td align=\"left\">5</td>\n<td align=\"left\">6</td>\n<td align=\"left\">7</td>\n<td align=\"left\">8</td>\n<td align=\"left\">9</td>\n<td align=\"left\">10</td>\n<td align=\"left\">11</td>\n<td align=\"left\">12</td>\n</tr>\n<tr>\n<td align=\"left\">next数组</td>\n<td align=\"left\">0</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">2</td>\n<td align=\"left\">3</td>\n<td align=\"left\">4</td>\n<td align=\"left\">2</td>\n<td align=\"left\">2</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>8.看第九位，前一位b的next值2对应内容为b，相等，所以此处next值为3：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">模式串</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">下标</td>\n<td align=\"left\">1</td>\n<td align=\"left\">2</td>\n<td align=\"left\">3</td>\n<td align=\"left\">4</td>\n<td align=\"left\">5</td>\n<td align=\"left\">6</td>\n<td align=\"left\">7</td>\n<td align=\"left\">8</td>\n<td align=\"left\">9</td>\n<td align=\"left\">10</td>\n<td align=\"left\">11</td>\n<td align=\"left\">12</td>\n</tr>\n<tr>\n<td align=\"left\">next数组</td>\n<td align=\"left\">0</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">2</td>\n<td align=\"left\">3</td>\n<td align=\"left\">4</td>\n<td align=\"left\">2</td>\n<td align=\"left\">2</td>\n<td align=\"left\">3</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>9.第十位同理上面第8可得，为4：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">模式串</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">下标</td>\n<td align=\"left\">1</td>\n<td align=\"left\">2</td>\n<td align=\"left\">3</td>\n<td align=\"left\">4</td>\n<td align=\"left\">5</td>\n<td align=\"left\">6</td>\n<td align=\"left\">7</td>\n<td align=\"left\">8</td>\n<td align=\"left\">9</td>\n<td align=\"left\">10</td>\n<td align=\"left\">11</td>\n<td align=\"left\">12</td>\n</tr>\n<tr>\n<td align=\"left\">next数组</td>\n<td align=\"left\">0</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">2</td>\n<td align=\"left\">3</td>\n<td align=\"left\">4</td>\n<td align=\"left\">2</td>\n<td align=\"left\">2</td>\n<td align=\"left\">3</td>\n<td align=\"left\">4</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>10、第十一位a的前一位b的next值4对应内容为b，相等，所以此处next值为5</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">模式串</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">下标</td>\n<td align=\"left\">1</td>\n<td align=\"left\">2</td>\n<td align=\"left\">3</td>\n<td align=\"left\">4</td>\n<td align=\"left\">5</td>\n<td align=\"left\">6</td>\n<td align=\"left\">7</td>\n<td align=\"left\">8</td>\n<td align=\"left\">9</td>\n<td align=\"left\">10</td>\n<td align=\"left\">11</td>\n<td align=\"left\">12</td>\n</tr>\n<tr>\n<td align=\"left\">next数组</td>\n<td align=\"left\">0</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">2</td>\n<td align=\"left\">3</td>\n<td align=\"left\">4</td>\n<td align=\"left\">2</td>\n<td align=\"left\">2</td>\n<td align=\"left\">3</td>\n<td align=\"left\">4</td>\n<td align=\"left\">5</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>11.最后，第十二位也是同理可以得到next值位6：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">模式串</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">b</th>\n<th align=\"left\">a</th>\n<th align=\"left\">a</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">下标</td>\n<td align=\"left\">1</td>\n<td align=\"left\">2</td>\n<td align=\"left\">3</td>\n<td align=\"left\">4</td>\n<td align=\"left\">5</td>\n<td align=\"left\">6</td>\n<td align=\"left\">7</td>\n<td align=\"left\">8</td>\n<td align=\"left\">9</td>\n<td align=\"left\">10</td>\n<td align=\"left\">11</td>\n<td align=\"left\">12</td>\n</tr>\n<tr>\n<td align=\"left\">next数组</td>\n<td align=\"left\">0</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">2</td>\n<td align=\"left\">3</td>\n<td align=\"left\">4</td>\n<td align=\"left\">2</td>\n<td align=\"left\">2</td>\n<td align=\"left\">3</td>\n<td align=\"left\">4</td>\n<td align=\"left\">5</td>\n<td align=\"left\">6</td>\n</tr>\n</tbody></table>\n<p>另一种解法:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-40.png\"  />\n\n<p>nextval数组</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-39.png\" style=\"zoom: 67%;\" />\n</blockquote>\n</li>\n<li><p>【2015】已知字符串S为’abaabaabacacaabaabcc’，模式串t为’abaabc’。采用KMP算法进行匹配，第一次出现”失配”(S[i]!=t[j])时，i=j=5，则下次开始匹配时，i和j的值分别是–&gt;i=5,j=2</p>\n<blockquote>\n<p>由题中“失配s[i]≠t[j]时，i=j=5”，可知题中的主串和模式串的位序都是从0开始的（要注意灵活应变）。按照next数组生成算法，对于t有：</p>\n<table>\n<thead>\n<tr>\n<th>编号</th>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>t</td>\n<td>a</td>\n<td>b</td>\n<td>a</td>\n<td>a</td>\n<td>b</td>\n<td>c</td>\n</tr>\n<tr>\n<td>next</td>\n<td>-1</td>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>2</td>\n</tr>\n</tbody></table>\n<p>依据KMP算法“当失配时，i不变，j回退到next[j]的位置并重新比较”，当失配s[i]≠t[j]时，i=j=5，由上表不难得出next[j]=next[5]=2（位序从0开始）。从而最后结果应为：i=5（i保持不变），j=2。</p>\n</blockquote>\n</li>\n<li><p>【2019】设主串<code>a b a a b a a b c a b a a b c</code> ，模式串 S = <code>a b a a b c</code>，采用KMP算法进行模式匹配，到匹配成功时为止，在匹配过程中进行的单个字符间的比较次数是?→10次</p>\n<blockquote>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-41.png\" style=\"zoom: 67%;\" />\n</blockquote>\n</li>\n</ul>\n","categories":["408数据结构"],"tags":["408数据结构"]},{"title":"第五章 树与二叉树(上)","url":"/p/63944/","content":"<h2 id=\"5-1-树的基本概念\"><a href=\"#5-1-树的基本概念\" class=\"headerlink\" title=\"5.1 树的基本概念\"></a>5.1 树的基本概念</h2><h3 id=\"树的定义\"><a href=\"#树的定义\" class=\"headerlink\" title=\"树的定义\"></a>树的定义</h3><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-1.png\" style=\"zoom:67%;\" />\n\n<p>空树：结点数为 0 的树</p>\n<p>非空树的特性:</p>\n<ul>\n<li>有且仅有一个根结点</li>\n<li>没有后继的结点称为叶子结点(或者终端结点)</li>\n<li>有后继的结点称为分支结点(或者非终端结点)</li>\n<li>除了根节点外，任何一个结点都有且仅有一个前驱</li>\n<li>每个结点可以有 0 个或多个后继结点。</li>\n</ul>\n<p><strong>除了根结点外，任何一个结点都有且仅有一个前驱</strong></p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-2.png\" style=\"zoom:67%;\" />\n\n<p>树是 n(n≥0) 个结点的有限集合，n = 0 时，称为空树，这是一种特殊情况。在任意一棵非空树中应满足：</p>\n<ol>\n<li>有且仅有一个特定的称为根的结点。</li>\n<li>当 n &gt; 1 时，其余结点可分为 m(m&gt;0) 个互不相交的有限集合T1,T2,…Tm，其中每个集合本身又是一棵树，并且称为根结点的子树。</li>\n</ol>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-3.png\" style=\"zoom:67%;\" />\n\n<h3 id=\"基本术语\"><a href=\"#基本术语\" class=\"headerlink\" title=\"基本术语\"></a>基本术语</h3><ul>\n<li>根结点：非空树种无前驱结点的结点</li>\n<li>结点的度：结点拥有的子树数</li>\n<li>树的度：树内各结点的度的最大值</li>\n<li>叶子（终端结点）：没有后继元素（度 = 0）</li>\n<li>分支结点（非终端结点）：度 != 0；</li>\n<li>内部结点：根结点以外的分支结点</li>\n<li>孩子，双亲：结点的子树的根称为该结点的孩子，该结点称为孩子的双亲</li>\n<li>兄弟结点：有共同的双亲</li>\n<li>堂兄弟：双亲在同一层的结点</li>\n<li>结点的祖先：从根到该结点所经分支上的所有结点</li>\n<li>结点的子孙：以某结点为根的子树中的任一结点</li>\n<li>树的深度：树中结点的最大层次</li>\n<li>有序树：树中结点的各子树从左至右有次序（最左边为第一个孩子）</li>\n<li>无须树：树中结点的各子树无次序</li>\n<li>森林：是m（m≥0）棵互不相交的树的集合，把根结点删除，树就变成了森林，一棵树可以看成是一个特殊的森林，给森林中的各子树加上一个双亲结点，森林就变成了树（树一定是森林，森林不一定是树）</li>\n</ul>\n<h3 id=\"结点之间的关系描述\"><a href=\"#结点之间的关系描述\" class=\"headerlink\" title=\"结点之间的关系描述\"></a>结点之间的关系描述</h3><p>如图就是一棵树的结构：</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-4.png\" style=\"zoom: 50%;\" />\n\n<ul>\n<li>结点：树的结点包含<strong>一个数据元素和若干指向其子树的分支。</strong></li>\n<li>祖先结点：从根结点到该结点<strong>所经过分支上的所有结点</strong>。例如图中 K 的祖先结点有 E、B、A</li>\n<li>子孙结点：以某结点为根的子树中的任一结点都称为该结点的子孙。例如图中 A 的子孙结点是下面所有结点。</li>\n<li>双亲结点：一个结点的直接前驱就是它的双亲结点。例如图中 B、C、D 的双亲结点是 A</li>\n<li>孩子结点：一个结点的直接后继就是孩子结点。例如图中 A 的孩子结点是 B、C、D</li>\n<li>兄弟结点：具有相同<strong>双亲结点</strong> (即同一个前驱)的结点称为兄弟结点。例如图中 B、C、D 为兄弟结点</li>\n<li>两个结点之间的路径：只能<strong>从上往下</strong> 。例如结点 A 和结点 E 之间有路径，结点 E 与 结点 G 之间没有路径。</li>\n<li>两个结点之间的路径长度：一个结点到另一个结点之间经过了几条边。例如 A 到 E 的路径长度为 2</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-5.png\" style=\"zoom:50%;\" />\n\n<p><code>属性</code>：</p>\n<ul>\n<li>结点的层次(深度) ： 从上往下数，默认从 1 开始(有的教材默认从 0 开始，也不要奇怪，见题拆题)<ul>\n<li>深度为 1 是 A 结点</li>\n<li>深度为 2 是 B、C、D结点</li>\n<li>深度为 3 是 E、F、F、H、I、J 结点</li>\n<li>深度为 4 是 K、L、M 结点</li>\n</ul>\n</li>\n<li>结点的高度：从下往上数，默认从 1 开始<ul>\n<li>高度为 1 是 K、L、M 结点</li>\n<li>高度为 2 是 E、F、F、H、I、J 结点</li>\n<li>高度为 3 是 B、C、D结点</li>\n<li>高度为 4 是 A 结点</li>\n</ul>\n</li>\n<li>结点的度：有几个孩子(分支) 就有几个度<ul>\n<li>结点 B 有两个分支，结点 B 的度为 2</li>\n<li>结点 C 有一个分支，结点 C 的度为 1</li>\n<li>结点 D 有三个分支，结点 D 的度为 3</li>\n<li>结点 M 是叶子结点，结点 M 的度为 0</li>\n</ul>\n</li>\n<li>树的度：各结点的度的最大值。也就是树中分支数最多<ul>\n<li>结点 A 、D 的分支最多为 3 ，所以树的度为 3</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"有序树、无序树、森林\"><a href=\"#有序树、无序树、森林\" class=\"headerlink\" title=\"有序树、无序树、森林\"></a>有序树、无序树、森林</h3><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-6.png\" style=\"zoom:67%;\" />\n\n<ul>\n<li>有序树：树中各子树从左到右是有次序的，不能互换，互换会导致含义发生错误。</li>\n<li>无序树：树种各子树从左到右是无次序的，可以更换</li>\n<li>森林：森林是 m(m≥0) 棵互不相交的树的集合</li>\n</ul>\n<h3 id=\"树的性质\"><a href=\"#树的性质\" class=\"headerlink\" title=\"树的性质\"></a>树的性质</h3><ul>\n<li><p>树中的结点数等于所有结点的度数之和加1 </p>\n</li>\n<li><p>度为m的树中第i层上至多有<br>$$<br>m^{i-1}<br>$$<br>个结点（i≥1）</p>\n</li>\n<li><p>高度为h的m叉树至多有<br>$$<br>(m^h-1)/(m-1)<br>$$<br> 个结点</p>\n</li>\n<li><p>具有n个结点的m叉树的最小高度为<br>$$<br>\\lceil  \\log_m{(n(m-1)+1)} \\rceil<br>$$</p>\n</li>\n</ul>\n<h3 id=\"树常考性质\"><a href=\"#树常考性质\" class=\"headerlink\" title=\"树常考性质\"></a>树常考性质</h3><h4 id=\"结点数-总度数-1\"><a href=\"#结点数-总度数-1\" class=\"headerlink\" title=\"结点数 = 总度数 + 1\"></a>结点数 = 总度数 + 1</h4><p>结点的度 = 结点有几个孩子(分支)</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-7.png\" style=\"zoom:50%;\" />\n\n<h4 id=\"度为-m-的树和-m-叉树\"><a href=\"#度为-m-的树和-m-叉树\" class=\"headerlink\" title=\"度为 m 的树和 m 叉树\"></a>度为 m 的树和 m 叉树</h4><ul>\n<li>度为 m 的树：各结点的度的最大值为 m</li>\n<li>m 叉树：每个结点最多只能有 m 个孩子的树</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">度为 m 的树</th>\n<th align=\"left\">m 叉树</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">任意结点的度 ≤ m(最多m个孩子)</td>\n<td align=\"left\">任意结点的度 ≤ m(最多m个孩子)</td>\n</tr>\n<tr>\n<td align=\"left\">至少有一个结点度 = m (有m个孩子)</td>\n<td align=\"left\">允许所有结点的度都 &lt; m</td>\n</tr>\n<tr>\n<td align=\"left\">一定是非空树，至少有 m+1 个结点</td>\n<td align=\"left\">可以是空树</td>\n</tr>\n</tbody></table>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-8.png\" style=\"zoom:67%;\" />\n\n<h4 id=\"度为-m-的树第-i-层至多有-m-i-1-个结点-i-≥-1\"><a href=\"#度为-m-的树第-i-层至多有-m-i-1-个结点-i-≥-1\" class=\"headerlink\" title=\"度为 m 的树第 i 层至多有 m^(i-1) 个结点(i ≥ 1)\"></a>度为 m 的树第 i 层至多有 m^(i-1) 个结点(i ≥ 1)</h4><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-9.png\" style=\"zoom:67%;\" />\n\n<p>所以，第i层：m^(i-1)个结点</p>\n<p>同理，<strong>我们也可以说m叉树的第i层至多有m^(i-1)个结点（i≥1）</strong></p>\n<blockquote>\n<p>因为不管是度为m的树，还是m叉树，本质上都是在说每个节点最多允许有m个孩子。</p>\n</blockquote>\n<h4 id=\"高度为-h-的-m-叉树至多有-m-h-1-m-1-个结点\"><a href=\"#高度为-h-的-m-叉树至多有-m-h-1-m-1-个结点\" class=\"headerlink\" title=\"高度为 h 的 m 叉树至多有 (m^h -1)/(m-1) 个结点\"></a>高度为 h 的 m 叉树至多有 (m^h -1)/(m-1) 个结点</h4><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-10.png\" style=\"zoom:67%;\" />\n\n<h4 id=\"高度为-h-的-m-叉树至少有-h-个结点\"><a href=\"#高度为-h-的-m-叉树至少有-h-个结点\" class=\"headerlink\" title=\"高度为 h 的 m 叉树至少有 h 个结点\"></a>高度为 h 的 m 叉树至少有 h 个结点</h4><blockquote>\n<p>对于<strong>m叉树</strong>，我们只是规定了每个结点的孩子结点的上限是多少个，没有规定它的下限。</p>\n</blockquote>\n<p>所以高度为h的m叉树，结点最少的情况，就是从根结点一直往下，每一个结点都只有一个孩子的情况。所以至少有h个结点。</p>\n<p><strong>对于高度为h、度为m的树，至少有h+m-1个结点。</strong></p>\n<p>这是因为，首先我们让它从根结点一路向下，每一个结点都只有一个孩子。但是由于度为m的树，要保证至少有一个结点有m个孩子，所以还要加上m-1。即h+m-1。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-11.png\" style=\"zoom: 67%;\" />\n\n<h4 id=\"具有n个结点的m叉树的最小高度\"><a href=\"#具有n个结点的m叉树的最小高度\" class=\"headerlink\" title=\"具有n个结点的m叉树的最小高度\"></a>具有n个结点的m叉树的最小高度</h4><p>对于n个结点的m叉树，想让它的高度最小，那么就想尽可能的让每一个结点都有尽可能多的孩子，也就是会有m个孩子。这样一来，这个树就会往宽处达到最宽，高度从而就最小了。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-12.png\" style=\"zoom:67%;\" />\n\n<p><strong>总结</strong></p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-13.png\" style=\"zoom:67%;\" />\n\n<h3 id=\"习题\"><a href=\"#习题\" class=\"headerlink\" title=\"习题\"></a>习题</h3><ul>\n<li><p>思考：树中的结点数等于→所有结点的度数之和+1</p>\n</li>\n<li><p>树的路径长度是从树根到每个结点的路径长度的什么→总和，注意与哈夫曼树的带权路径长度的区别</p>\n</li>\n<li><p>【2010】在一棵度为4的树T中，若有20个度为4的结点，10个度为3的结点，1个度为2的结点，10个度为1的结点，则树T的叶节点个数为多少 ?→82</p>\n<blockquote>\n<p>任何一棵树中，结点个数比分支个数多一 </p>\n<p>分支个数等于20x4+10x3+1x2+10x1=122 </p>\n<p>所以这棵树一共有123个结点 </p>\n<p>度不为零的结点数目为20+10+1+10=41 </p>\n<p>所以叶子结点也就是度为零的结点个数为123-41=82</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"5-2-二叉树的概念\"><a href=\"#5-2-二叉树的概念\" class=\"headerlink\" title=\"5.2 二叉树的概念\"></a>5.2 二叉树的概念</h2><h3 id=\"二叉树的定义\"><a href=\"#二叉树的定义\" class=\"headerlink\" title=\"二叉树的定义\"></a>二叉树的定义</h3><p>每个结点至多只有两棵子树，且子树有左右之分</p>\n<p>二叉树是 n (n≥0) 个结点的有限集合。</p>\n<ul>\n<li>或者为空二叉树，即 n = 0</li>\n<li>或者由一个根节点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-14.png\" style=\"zoom:67%;\" />\n\n<p>特点：</p>\n<ol>\n<li>每个结点至多只有两棵子树</li>\n<li>左右子树不能颠倒(二叉树是有序树)</li>\n</ol>\n<h3 id=\"几个特殊的二叉树\"><a href=\"#几个特殊的二叉树\" class=\"headerlink\" title=\"几个特殊的二叉树\"></a>几个特殊的二叉树</h3><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-15.png\" style=\"zoom:67%;\" />\n\n<h4 id=\"满二叉树\"><a href=\"#满二叉树\" class=\"headerlink\" title=\"满二叉树\"></a>满二叉树</h4><p>满二叉树：<strong>一棵高度为 h，且含有 2^h -1 个结点的二叉树</strong>，即树中的每层都含有最多的结点。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-16.png\" style=\"zoom: 50%;\" />\n\n<p>特点：</p>\n<ol>\n<li>只有最后一层有叶子结点</li>\n<li>不存在度为 1 的结点</li>\n<li>按层序从 1 开始编号，结点 i 的左孩子为 2i，右孩子为 2i+1，结点 i 的父节点为 [ i / 2] (如果有的话) <strong>[ i / 2 ]向下取整</strong>。<font color='orange'>这个特性是很重要的，可以通过这个特性，使得我们能够用顺序存储的方式来存储这些结点。</font></li>\n</ol>\n<h4 id=\"完全二叉树\"><a href=\"#完全二叉树\" class=\"headerlink\" title=\"完全二叉树\"></a>完全二叉树</h4><p>完全二叉树：当且仅当其每个结点都与高度为 h 的满二叉树中编号为 1~n 的结点一一对应时，称为完全二叉树。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-17.png\" style=\"zoom: 50%;\" />\n\n<blockquote>\n<p>可以这么理解：满二叉树已经满了，不可能再有更多的结点。</p>\n<p>而完全二叉树是什么呢？就是在满二叉树的基础上，可以把一些编号更大的结点，依次给去掉。（如此处将13、14、15去掉）</p>\n<p>若只把结点13去掉，则其后面的14、15的编号，要改为13、14。这样一来，其每个结点的编号就不与满二叉树一一对应了，就不是完全二叉树了。</p>\n</blockquote>\n<p>可见，<strong>满二叉树是一种特殊的完全二叉树</strong>。<strong>而完全二叉树不一定是满二叉树</strong>。</p>\n<p>那么，由于我们将最后一层编号更大的结点去除了，那么就会在倒数第二层，出现叶子结点。而且不难理解，完全二叉树只有最后两层可能有叶子结点。且最多只有一个度为1的结点。</p>\n<p>特点：</p>\n<ol>\n<li><p>只有最后两层可能有叶子结点。</p>\n</li>\n<li><p>同时只有一个度为 1 的结点</p>\n</li>\n<li><p>按层序从 1 开始编号，结点 i 的左孩子为 2i，右孩子为 2i+1，结点 i的父节点为 ⌊i/2⌋ (如果有的话) </p>\n</li>\n<li><p>i ≤ ⌊n/2⌋ 为分支结点, i &gt; ⌊n/2⌋为叶子结点</p>\n</li>\n<li><p>在完全二叉树中,如果某结点只有一个孩子,那么一定是左孩子</p>\n</li>\n</ol>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-18.png\" style=\"zoom:67%;\" />\n\n<p><font color='red'>上图右下角纠正:如果结点是右孩子，那么就不是完全二叉树</font></p>\n<h4 id=\"二叉排序树\"><a href=\"#二叉排序树\" class=\"headerlink\" title=\"二叉排序树\"></a>二叉排序树</h4><p><strong>二叉排序树</strong>：一棵二叉树或者空二叉树，或者具有如下性质的二叉树:</p>\n<ul>\n<li>左子树上所有结点的关键字均<strong>小于根结点</strong>的关键字</li>\n<li>右子树上所有结点的关键字均<strong>大于根节点</strong>的关键字</li>\n<li>左子树和右子树又各是一棵二叉排序树</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-19.png\" style=\"zoom:67%;\" />\n\n<p><strong>二叉排序树用于元素的排序、搜索</strong></p>\n<h4 id=\"平衡二叉树\"><a href=\"#平衡二叉树\" class=\"headerlink\" title=\"平衡二叉树\"></a>平衡二叉树</h4><p>平衡二叉树：树上任一结点的<strong>左子树</strong>和<strong>右子树</strong>的<strong>深度之差不超过 1</strong></p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-20.png\" style=\"zoom:67%;\" />\n\n<p>可以看出，<strong>平衡二叉树能有更高的搜索效率</strong>。</p>\n<p>其实平衡二叉树，就是希望一棵树在生长的时候，尽可能的往宽处长，而高度是在当前状态下的最小高度。这样一来，我们在向下搜索的过程中，搜索的次数也便是最少的了。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-21.png\" style=\"zoom: 80%;\" />\n\n<h3 id=\"二叉树的性质\"><a href=\"#二叉树的性质\" class=\"headerlink\" title=\"二叉树的性质\"></a>二叉树的性质</h3><ul>\n<li><p>非空二叉树上的叶子结点数等于?→ 度为 2 的结点数加 1，即<br>$$<br>n_0=n_2+1<br>$$</p>\n</li>\n<li><p>非空二叉树上第 k 层上至多有多少个结点，总共至多有多少个结点<br>$$<br>2^{k-1}<br>$$<br> 个结点</p>\n</li>\n<li><p>高度为 h 的二叉树至多有多少个结点?→<br>$$<br>2^h-1<br>$$<br> 个结点</p>\n</li>\n<li><p>对完全二叉树按从上到下、从左到右的顺序依次编号 1，2，…，n，则有以下关系</p>\n<ul>\n<li><p>① 当 i &gt;1 时，结点 i 的双亲的编号为 ⌊i/2⌋，即当 i 为偶数时，其双亲编号为 i/2，它是双亲的左孩子；当 i 为奇数时，其双亲的编号为 (i-1) / 2，它是双亲的右孩子</p>\n</li>\n<li><p>② 当 2i ≤ n 时，结点 i 的左孩子编号为 2i，否则无左孩子</p>\n</li>\n<li><p>③ 当 2i + 1 ≤ n 时，结点 i 的右孩子编号为 2i，否则无右孩子</p>\n</li>\n<li><p>④ 结点 i 所在的层次（深度）为<br>$$<br>\\lfloor \\log_2 i\\rfloor+1<br>$$</p>\n</li>\n</ul>\n</li>\n<li><p>具有 n 个（n &gt; 0）结点的完全二叉树的高度为<br>$$<br>\\lceil\\log_2(n+1)\\rceil或\\lfloor\\log_2n\\rfloor+1<br>$$</p>\n</li>\n</ul>\n<h3 id=\"二叉树常考性质\"><a href=\"#二叉树常考性质\" class=\"headerlink\" title=\"二叉树常考性质\"></a>二叉树常考性质</h3><h4 id=\"叶子结点比二分支结点多一个\"><a href=\"#叶子结点比二分支结点多一个\" class=\"headerlink\" title=\"叶子结点比二分支结点多一个\"></a>叶子结点比二分支结点多一个</h4><p>设非空二叉树中度为 0、1 和 2 的结点个数分别为 n0 、n1 、n2 ，则 n0 = n2 + 1</p>\n<p>(叶子结点比二分支结点多一个)</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-22.png\" style=\"zoom: 80%;\" />\n\n<h4 id=\"二叉树第-i-层至多有-2-i-1-个结点-i≥1\"><a href=\"#二叉树第-i-层至多有-2-i-1-个结点-i≥1\" class=\"headerlink\" title=\"二叉树第 i 层至多有 2^(i-1) 个结点(i≥1)\"></a>二叉树第 i 层至多有 2^(i-1) 个结点(i≥1)</h4><p>之前讨论过的 m叉树 第 i 层至多有 m^(i-1) 个结点(i≥1)</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-23.png\" style=\"zoom: 67%;\" />\n\n<h4 id=\"高度为-h-的二叉树至多有-2-h-1-个结点-满二叉树\"><a href=\"#高度为-h-的二叉树至多有-2-h-1-个结点-满二叉树\" class=\"headerlink\" title=\"高度为 h 的二叉树至多有 2^h -1 个结点(满二叉树)\"></a>高度为 h 的二叉树至多有 2^h -1 个结点(满二叉树)</h4><p>之前讨论过的 高度为 h 的 m 叉树至多有 (m^h -1) / (m-1) 个结点</p>\n<h3 id=\"完全二叉树常考性质\"><a href=\"#完全二叉树常考性质\" class=\"headerlink\" title=\"完全二叉树常考性质\"></a>完全二叉树常考性质</h3><h4 id=\"具有n个-n-gt-0-结点的完全二叉树的高度\"><a href=\"#具有n个-n-gt-0-结点的完全二叉树的高度\" class=\"headerlink\" title=\"具有n个(n&gt;0)结点的完全二叉树的高度\"></a>具有n个(n&gt;0)结点的完全二叉树的高度</h4><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-24.png\" style=\"zoom: 80%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-25.png\" style=\"zoom: 80%;\" />\n\n<h4 id=\"对于完全二叉树，可以由结点数n推出度为-0、1和2的结点个数\"><a href=\"#对于完全二叉树，可以由结点数n推出度为-0、1和2的结点个数\" class=\"headerlink\" title=\"对于完全二叉树，可以由结点数n推出度为 0、1和2的结点个数\"></a>对于完全二叉树，可以由结点数n推出度为 0、1和2的结点个数</h4><p>对于完全二叉树，可以由结点数n推出度为 0、1和2的结点个数，n0、n1和n2</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-26.png\" style=\"zoom: 80%;\" />\n\n<h3 id=\"二叉树的存储结构\"><a href=\"#二叉树的存储结构\" class=\"headerlink\" title=\"二叉树的存储结构\"></a>二叉树的存储结构</h3><h4 id=\"顺序存储结构\"><a href=\"#顺序存储结构\" class=\"headerlink\" title=\"顺序存储结构\"></a>顺序存储结构</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 100</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> &#123;</span></span><br><span class=\"line\">    ElemType value;\t\t\t<span class=\"comment\">// 结点中的数据元素</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> isEmpty;\t\t\t<span class=\"comment\">// 结点是否为空</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">TreeNode t[MaxSize];</span><br><span class=\"line\"><span class=\"comment\">//定义一个长度为MaxSize的数组t，按照从上至下、从左至右的顺序依次存储完全二叉树中的各个结点 </span></span><br><span class=\"line\"><span class=\"comment\">//在初始化这个数组的时候，我们要把所有的元素的结点先初始化为空。</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;MaxSize;i++)&#123;</span><br><span class=\"line\">    t[i].isEmpty = <span class=\"literal\">true</span>;\t\t<span class=\"comment\">// 初始化时所有结点标记为空</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-27.png\" style=\"zoom: 80%;\" />\n\n<p><strong>几个重要常考的基本操作</strong>:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-28.png\" style=\"zoom:80%;\" />\n\n<p>上述是完全二叉树的存储，那么对于一棵不是完全二叉树而言又如何存储呢？<strong>如果不是完全二叉树，依然按层序将各结点顺序存储，那么无法从结点编号反映出结点点的逻辑关系</strong>。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-29.png\" style=\"zoom:80%;\" />\n\n<p>所以对于二叉树的顺序存储中，<strong>一定要把树的结点编号与完全二叉树对应起来</strong>。这样我们就可以通过结点编号来算出左孩子、右孩子、父节点，但是无法通过结点编号 i 与结点总数 n 作比较，来进行判断。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-30.png\" style=\"zoom:80%;\" />\n\n<p>我们可以看到，这样存储的话会浪费很多存储单元，<strong>所以对于二叉树的顺序存储结构，只适合存储完全二叉树。</strong></p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-31.png\" style=\"zoom:67%;\" />\n\n<h4 id=\"链式存储结构\"><a href=\"#链式存储结构\" class=\"headerlink\" title=\"链式存储结构\"></a>链式存储结构</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 二叉树的结点(链式存储)</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span>&#123;</span></span><br><span class=\"line\">    ElemType data;\t\t\t\t\t<span class=\"comment\">// 数据域</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span> *<span class=\"title\">lchild</span>,*<span class=\"title\">rchild</span>;</span> <span class=\"comment\">// 左、右孩子指针</span></span><br><span class=\"line\">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-32.png\" style=\"zoom:80%;\" />\n\n<p>如果一个结点没有左孩子，我们可以将对应的指针设为 null。</p>\n<p>思考：<font color='cornflowerblue'>在含有 n 个结点的二叉链表中，含有多少个空链域？</font>→n+1个空链域</p>\n<p>若共有n个结点，会有2n个指针，除了根结点之外，其他结点头上都会连一个指针，也就是说有n-1结点的头上也会连接有一个指针(除了头结点外，每个结点被指1次)，所以这2n个指针中会有(2n-(n-1))= n+1个指向 null。即<strong>n个结点的二叉链表共有n+1个空链域</strong>。<br>$$<br>1n_0+1n_1+1n_2=n \\quad结点数之和<br>$$</p>\n<p>$$<br>0n_0+1n_1+2n_2=n-1 \\quad度和结点关系<br>$$</p>\n<p>$$<br>2n_0+1n_1+0n_2=? \\quad求空链域<br>$$</p>\n<blockquote>\n<p>实际上，这些空链域可以被利用起来，<strong>用于构造线索二叉树</strong>（这是之后会学到的内容）</p>\n</blockquote>\n<p><strong>初始化一个二叉树</strong></p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-33.png\" style=\"zoom: 50%;\" />\n\n<p>由于每个节点都有两个指针，我们也把这种实现叫做二叉链表。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ElemType</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 二叉树的结点(链式存储)</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span>&#123;</span></span><br><span class=\"line\">    ElemType data;\t\t\t\t\t<span class=\"comment\">// 数据域</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span> *<span class=\"title\">lchild</span>,*<span class=\"title\">rchild</span>;</span> <span class=\"comment\">// 左、右孩子指针</span></span><br><span class=\"line\">&#125;BiTNode,*BiTree;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一棵空树</span></span><br><span class=\"line\">BiTree root = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 插入根节点</span></span><br><span class=\"line\">root = (BiTree) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(BiTNode));</span><br><span class=\"line\">root-&gt;data = &#123;<span class=\"number\">1</span>&#125;;\t\t\t\t\t\t\t<span class=\"comment\">// 根节点数据域为 1</span></span><br><span class=\"line\">root-&gt;lchild = <span class=\"literal\">NULL</span>;\t\t\t\t\t\t<span class=\"comment\">// 根节点左孩子指向NULL</span></span><br><span class=\"line\">root-&gt;rchild = <span class=\"literal\">NULL</span>;\t\t\t\t\t\t<span class=\"comment\">// 根节点右孩子指向NULL</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 插入新结点</span></span><br><span class=\"line\">BiTNode *p = (BiTNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(BiTNode));</span><br><span class=\"line\">p-&gt;data = &#123;<span class=\"number\">2</span>&#125;;\t\t\t\t\t\t\t\t<span class=\"comment\">// 新节点数据域为 2</span></span><br><span class=\"line\">p-&gt;lchild = <span class=\"literal\">NULL</span>;\t\t\t\t\t\t\t<span class=\"comment\">// 新节点左孩子为NULL</span></span><br><span class=\"line\">p-&gt;rchild = <span class=\"literal\">NULL</span>;\t\t\t\t\t\t\t<span class=\"comment\">// 新节点右孩子为NULL</span></span><br><span class=\"line\">root-&gt;lchild = p;\t\t\t\t<span class=\"comment\">//新节点作为根结点的左孩子</span></span><br></pre></td></tr></table></figure>\n\n<p>根据链式存储我们要找到指定结点 p 的左/右孩子，只需要查看结点 p 的左右孩子指针指向的结点即可。</p>\n<p><font color='cornflowerblue'>可是如何找到指定结点 p 的父结点呢？</font>就只能从根节点开始遍历寻找，看看哪一个结点的左孩子或者右孩子是指向p结点的。显然，若整个树很大，那么这一操作还是很耗时的。因此，若你的应用场景当中，经常需要找某结点的父节点的话，你可以再给结点添加一个指针域，用来存放该结点的父节点指针。(考研一般不喜欢这么考)</p>\n<p>再来看看三叉链表，它的结点类型定义如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 二叉树的结点(链式存储)</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span>&#123;</span></span><br><span class=\"line\">    ElemType data;\t\t\t\t\t<span class=\"comment\">// 数据域</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span> *<span class=\"title\">lchild</span>,*<span class=\"title\">rchild</span>;</span> <span class=\"comment\">// 左、右孩子指针</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span> *<span class=\"title\">parent</span>;</span>\t\t\t<span class=\"comment\">// 父结点指针</span></span><br><span class=\"line\">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"习题-1\"><a href=\"#习题-1\" class=\"headerlink\" title=\"习题\"></a>习题</h3><ul>\n<li><p>设二叉树有2n个结点，且m&lt;n，则不可能存在（）的结点→C</p>\n<p>A n个度为0<br>B 2m个度为0<br>C 2m个度为1<br>D 2m个度为2</p>\n</li>\n<li><p>【2009】已知一棵完全二叉树的第6层（设根为第1层）有8个叶结点，则完全二叉树的结点个数最多是?→111</p>\n<blockquote>\n<p>完全二叉树比满二叉树只是在最下面一层的右边缺少了部分叶结点，而最后一层之上是个满二叉树，并且只有最后两层有叶结点。第6层有叶结点则完全二叉树的高度可能为6或7，显然树高为7时结点更多。若第6层上有8个叶结点，则前六层为满二叉树，而第7层缺失了8×2=16个叶结点，故完全二叉树的结点个数最多为(27-1)-16=111个结点。</p>\n<p>若问最少那么就六层树，树才只有六层并且叶子节点在第六层的前面。最少就是前五层满2＾5－1＋8＝39个。</p>\n</blockquote>\n</li>\n<li><p>【2011】若一棵完全二叉树有768个结点，则该二叉树中叶结点的个数为→384</p>\n<blockquote>\n<p>完全二叉树，只有在第一层和叶节点层上节点个数可能是奇数个，根节点本来就是奇数的，所以总数为偶数时应该先减一得到叶节点是否包含无兄弟的叶子。显然此题包含一个只有左子节点的节点，既n1等于1。n=n0+n1+n2。768-1-1=2n2。n2=383所以n0=n2+1=384</p>\n</blockquote>\n</li>\n<li><p>【2018】设一棵非空完全二叉树T的所有叶结点均位于同一层，且每个非叶结点都有2个子节点。若T有k个叶结点，则T的结点总数是→2k-1</p>\n<blockquote>\n<p>一棵非空完全二叉树T的所有叶结点均位于同一层，且每个非叶结点都有2个子结点就是满二叉树。</p>\n<p>则有 k = 2^(h-1)， T的结点总数n=2^(h-1)-1+k = 2k-1</p>\n</blockquote>\n</li>\n<li><p>【2020】对于任意一棵高度为5且有10个结点的二叉树，若采用顺序存储结构保存，每个结点占1个存储单元（仅存放结点的数据信息），则存放该二叉树需要的存储单元数量至少是→31</p>\n<blockquote>\n<p>因为是顺序存储结构保存，所以需要的存储单元是给定高度的全部结点都要考虑。<br>高度为5的满二叉树共有：<br>25-1=31个结点<br>31*1个存储单元=31；</p>\n</blockquote>\n</li>\n</ul>\n","categories":["408数据结构"],"tags":["408数据结构"]},{"title":"第五章 树与二叉树(中)","url":"/p/48066/","content":"<h2 id=\"5-3-二叉树的遍历和线索二叉树\"><a href=\"#5-3-二叉树的遍历和线索二叉树\" class=\"headerlink\" title=\"5.3 二叉树的遍历和线索二叉树\"></a>5.3 二叉树的遍历和线索二叉树</h2><h3 id=\"二叉树的遍历\"><a href=\"#二叉树的遍历\" class=\"headerlink\" title=\"二叉树的遍历\"></a>二叉树的遍历</h3><p><strong>遍历</strong>：按照某种次序把所有结点都访问一遍</p>\n<p>对于一个线性结构，如a1 a2 a3 a4 a5</p>\n<p>对其进行遍历，是很简单的，我们可以从前往后依次遍历，也可以从后往前。</p>\n<p>但是对于树形结构，我们的遍历规则就会更复杂一些。</p>\n<p>由于树这种结构呈现出了一层一层的效果，因此不难想到我们可以一层一层地访问这些结点。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-34.png\" style=\"zoom:80%;\" />\n\n<p>这种方法叫做<strong>层次遍历</strong>，即基于树的层次特性确定的次序规则。</p>\n<p>而我们此节主要说的<strong>先/中/后序遍历</strong>是基于树的递归特性确定的次序规则。</p>\n<p><strong>二叉树的递归特性</strong>：</p>\n<ol>\n<li>要么是个空二叉树</li>\n<li>要么就是由 “根节点 + 左子树 + 右子树” 组成的二叉树</li>\n<li><strong>先序遍历：根左右</strong></li>\n<li><strong>中序遍历：左根右</strong></li>\n<li><strong>后序遍历：左右根</strong></li>\n</ol>\n<hr>\n<p>我们先来看一个简单的例子：</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-35.png\" style=\"zoom:80%;\" />\n\n<p>上述是最简单的二叉树遍历，我们再来看一个:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-36.png\" style=\"zoom: 80%;\" />\n\n<h4 id=\"先序遍历-PreOrder\"><a href=\"#先序遍历-PreOrder\" class=\"headerlink\" title=\"先序遍历 PreOrder\"></a>先序遍历 PreOrder</h4><p>先序遍历的操作过程如下：</p>\n<ol>\n<li>若二叉树为空，则什么也不做</li>\n<li>若二叉树非空<ol>\n<li>访问根节点</li>\n<li>先序遍历左子树</li>\n<li>先序遍历右子树</li>\n</ol>\n</li>\n</ol>\n<p><font color='orange'>先序遍历——第一次路过时访问结点</font></p>\n<p>先序遍历的算法实现（递归）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">PreOrder</span><span class=\"params\">(BiTree T)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (T != <span class=\"literal\">NULL</span>)&#123;         <span class=\"comment\">// 如果二叉树非空，则继续</span></span><br><span class=\"line\">    visit(T);             <span class=\"comment\">// 访问根结点内容</span></span><br><span class=\"line\">    PreOrder(T-&gt;lchild);  <span class=\"comment\">// 访问左子树内容</span></span><br><span class=\"line\">    PreOrder(T-&gt;rchild);  <span class=\"comment\">// 访问右子树内容</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"中序遍历-InOrder\"><a href=\"#中序遍历-InOrder\" class=\"headerlink\" title=\"中序遍历 InOrder\"></a>中序遍历 InOrder</h4><p>中序遍历的操作过程如下：</p>\n<ol>\n<li>若二叉树为空，则什么也不做</li>\n<li>若二叉树非空<ol>\n<li>中序遍历左子树</li>\n<li>访问根节点</li>\n<li>中序遍历右子树</li>\n</ol>\n</li>\n</ol>\n<p><font color='orange'>中序遍历——第二次路过时访问结点</font></p>\n<blockquote>\n<p>这里要提两个术语:前驱节点和后继节点</p>\n<p>前驱节点：对一棵二叉树进行中序遍历，遍历后的顺序，当前节点的前一个节点为该节点的前驱节点；</p>\n<p>后继节点：对一棵二叉树进行中序遍历，遍历后的顺序，当前节点的后一个节点为该节点的后继节点；</p>\n</blockquote>\n<p>中序遍历的算法实现（递归）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 中序遍历</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InOrder</span><span class=\"params\">(BiTree T)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        InOrder(T -&gt; lchild);\t\t<span class=\"comment\">// 递归遍历左子树</span></span><br><span class=\"line\">        visit(T);\t\t\t\t\t<span class=\"comment\">// 访问根节点</span></span><br><span class=\"line\">        InOrder(T -&gt; rchild);\t\t<span class=\"comment\">// 递归遍历右子树</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"后续遍历-PostOrder\"><a href=\"#后续遍历-PostOrder\" class=\"headerlink\" title=\"后续遍历 PostOrder\"></a>后续遍历 PostOrder</h4><p>后序遍历的操作过程如下：</p>\n<ol>\n<li>若二叉树为空，则什么也不做</li>\n<li>若二叉树非空:<ol>\n<li>后序遍历左子树</li>\n<li>后序遍历右子树</li>\n<li>访问根节点</li>\n</ol>\n</li>\n</ol>\n<p><font color='orange'>后序遍历——第三次路过时访问结点</font></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 后序遍历</span></span><br><span class=\"line\">Void <span class=\"title function_\">PostOrder</span><span class=\"params\">(BiTree T)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        PostOrder(T-&gt;lchild);\t\t\t<span class=\"comment\">// 递归遍历左子树</span></span><br><span class=\"line\">        PostOrder(T-&gt;rchild);\t\t\t<span class=\"comment\">// 递归遍历右子树</span></span><br><span class=\"line\">        visit(T);\t\t\t\t\t\t<span class=\"comment\">// 访问根节点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"手算练习\"><a href=\"#手算练习\" class=\"headerlink\" title=\"手算练习\"></a>手算练习</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 访问一个结点:打印字符</span></span><br><span class=\"line\">Void <span class=\"title function_\">visit</span><span class=\"params\">(BiTNode *p)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>,p-&gt;data);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-37.png\" style=\"zoom:80%;\" />\n\n<p><font color='orange'>这里的遍历和我们学习栈的表达式时很有关联，我们将这里的先序遍历的表达式转换为中缀表达式和后缀表达式，分别对应的就是中序遍历和后序遍历，只是中序遍历没有添加界限符</font></p>\n<hr>\n<blockquote>\n<p>三种遍历算法中，递归遍历左、右子树的顺序都是固定的，只是访问根结点的顺序不同。不管采用哪种遍历算法，每个结点都访问一次且仅访问一次，故时间复杂度都是O(n)。在递归遍历中，递归工作栈的栈深恰好为树的深度，所以在最坏情况下，二叉树是有n个结点且深度为n的单支树，遍历算法的空间复杂度为O(n)。</p>\n</blockquote>\n<h4 id=\"求树的深度-应用\"><a href=\"#求树的深度-应用\" class=\"headerlink\" title=\"求树的深度(应用)\"></a>求树的深度(应用)</h4><p>对于求树的深度，我们只需要选择左子树和右子树中深度最大的子树 + 1 就是树的深度</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 求树的深度</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">treeDepth</span><span class=\"params\">(BiTree T)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T == <span class=\"literal\">NULL</span>)&#123;\t\t\t\t\t\t\t\t<span class=\"comment\">// 树是空树</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\t\t\t\t\t\t\t\t<span class=\"comment\">// 深度为0</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = treeDepth(T-&gt;lchild);\t\t\t<span class=\"comment\">// 求左子树的深度</span></span><br><span class=\"line\">        <span class=\"type\">int</span> r = treeDepth(T-&gt;rchild);\t\t\t<span class=\"comment\">// 求右子树的深度</span></span><br><span class=\"line\">        <span class=\"comment\">// 树的深度 = Max(左子树深度,右子树深度)+1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> l&gt;r ? l+<span class=\"number\">1</span> : r+<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"递归算法和非递归算法的转换\"><a href=\"#递归算法和非递归算法的转换\" class=\"headerlink\" title=\"递归算法和非递归算法的转换\"></a>递归算法和非递归算法的转换</h4><p><a href=\"https://blog.csdn.net/qq_53144843/article/details/121127971\">https://blog.csdn.net/qq_53144843/article/details/121127971</a></p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-1.jpg\" style=\"zoom: 25%;\" />\n\n<p>上图中，用带箭头的虚线表示了这3种遍历算法的递归执行过程。其中，向下的箭头表示更深一层的递归调用，向上的箭头表示从递归调用退出返回；虚线旁的三角形、圆形和方形内的字符分别表示在先序、中序、后序遍历的过程中访问结点时输出的信息。如图，先序序列为A B D E C、中序序列为D B E A C、后序序列为D E B C A。</p>\n<h5 id=\"中序遍历的非递归算法\"><a href=\"#中序遍历的非递归算法\" class=\"headerlink\" title=\"中序遍历的非递归算法\"></a>中序遍历的非递归算法</h5><p>借助栈，分析中序遍历的访问过程:</p>\n<p>①<strong>沿着根的左孩子，依次入栈，直到左孩子为空</strong>，说明已找到可以输出的结点，此时栈内元素依次为A B D。②<strong>栈顶元素出栈并访问:若其右孩子为空，继续执行</strong>②；<strong>若其右孩子不空，将右子树转执行</strong>①。栈顶D出栈并访问，它是中序序列的第一个结点:D右孩子为空，栈顶B出栈并访问；B右孩子不空，将其右孩子E入栈，E左孩子为空，栈顶E出栈并访问；E右孩子为空，栈顶A出栈并访问；A右孩子不空，将其右孩子C入栈，C左孩子为空，栈顶C出栈并访问。由此得到中序序列D B E A C。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InOrder2</span><span class=\"params\">(BiTree T, SqStack S)</span> &#123;</span><br><span class=\"line\">  InitStack(S); BiTree p = T;<span class=\"comment\">//初始化栈S；p是遍历指针</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (p||!IsEmpty(S)) &#123;   <span class=\"comment\">//栈不空或p不空时循环</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p) &#123;                 <span class=\"comment\">//一路向左</span></span><br><span class=\"line\">        Push(S, p);          <span class=\"comment\">//当前结点入栈</span></span><br><span class=\"line\">        p = p-&gt;lchild;       <span class=\"comment\">//左孩子不空，一直向左走</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;                   <span class=\"comment\">//出栈，并转向出栈结点的右子树</span></span><br><span class=\"line\">        Pop(S,p); visit(p);  <span class=\"comment\">//栈顶元素出栈，访问出栈结点</span></span><br><span class=\"line\">        p = p-&gt;rchild;       <span class=\"comment\">//向右子树走，p赋值为当前结点的右孩子</span></span><br><span class=\"line\">    &#125;                        <span class=\"comment\">//返回while循环继续进入if-else语句</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"先序遍历的非递归算法\"><a href=\"#先序遍历的非递归算法\" class=\"headerlink\" title=\"先序遍历的非递归算法\"></a>先序遍历的非递归算法</h5><p>先序遍历和中序遍历的基本思想是类似的，只需把访问结点操作放在入栈操作的前面。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InOrder2</span><span class=\"params\">(BiTree T, SqStack S)</span> &#123;</span><br><span class=\"line\">  InitStack(S); BiTree p = T;<span class=\"comment\">//初始化栈S；p是遍历指针</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (p||!IsEmpty(S)) &#123;   <span class=\"comment\">//栈不空或p不空时循环</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p) &#123;                 <span class=\"comment\">//一路向左</span></span><br><span class=\"line\">        visit(p);Push(S,p);  <span class=\"comment\">//访问当前结点，并入栈</span></span><br><span class=\"line\">        p = p-&gt;lchild;       <span class=\"comment\">//左孩子不空，一直向左走</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;                   <span class=\"comment\">//出栈，并转向出栈结点的右子树</span></span><br><span class=\"line\">        Pop(S,p);            <span class=\"comment\">//栈顶元素出栈</span></span><br><span class=\"line\">        p = p-&gt;rchild;       <span class=\"comment\">//向右子树走，p赋值为当前结点的右孩子</span></span><br><span class=\"line\">    &#125;                        <span class=\"comment\">//返回while循环继续进入if-else语句</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"后序遍历的非递归算法\"><a href=\"#后序遍历的非递归算法\" class=\"headerlink\" title=\"后序遍历的非递归算法\"></a>后序遍历的非递归算法</h5><blockquote>\n<p>后序遍历的非递归实现是三种遍历算法中最难的。因为后序遍历中，要保证左孩子和右孩子都已被访问并且左孩子在右孩子前访问才能访问根结点，这就为流程的控制带来了难题。</p>\n</blockquote>\n<p>后序非递归遍历算法思想:后序非递归遍历二叉树是先访问左子树，再访问右子树，最后访问根结点。结合图来分析:①<strong>沿着根的左孩子，依次入栈，直到左孩子为空</strong>。此时栈内元素依次为A B D。②<strong>读栈顶元素:若其右孩子不空且未被访问过，将右子树转执行</strong>①；<strong>否则，栈顶元素出栈并访问</strong>。栈顶D的右孩子为空，出栈并访问，它是后序序列的第一个结点；栈顶B的右孩子不空且未被访问过，E入栈，栈顶E的左右孩子均为空，出栈并访问；栈顶B的右孩子不空但已被访问，B出栈并访问；栈顶A的右孩子不空且未被访问，C入栈，栈顶C的左右孩子均为空，出栈并访问；栈顶A的右孩子不空但已被访问，A出栈并访问。由此得到后序序列D E B C A。</p>\n<p>在上述思想中的第②步，<strong>必须分清返回时是从左子树返回的还是从右子树返回的</strong>，因此设定<font color='red'>一个辅助指针r</font>，指向最近访问过的结点。<font color='orange'>也可在结点中增加一个标志域</font>，记录是否已被访问。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">PostOrder</span><span class=\"params\">(BiTree T)</span>&#123;</span><br><span class=\"line\">    InitStack(S);</span><br><span class=\"line\">    p=T;</span><br><span class=\"line\">    r=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p||!IsEmpty(s))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(P)&#123;   <span class=\"comment\">//走到最左边</span></span><br><span class=\"line\">            push(S,p);</span><br><span class=\"line\">            p=p——&gt;lchild；</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;   <span class=\"comment\">//向右</span></span><br><span class=\"line\">            GetTop(S,p); <span class=\"comment\">//读栈顶结点(非出栈)</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p-&gt;rchild&amp;&amp;p-&gt;rchild! =r)<span class=\"comment\">//若右子树存在，且未被访问过</span></span><br><span class=\"line\">                p=p-&gt;rchild; <span class=\"comment\">//转向右</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;    <span class=\"comment\">//否则，弹出结点并访问</span></span><br><span class=\"line\">                pop(S,p); <span class=\"comment\">//弹出结点</span></span><br><span class=\"line\">                visit(p-&gt;data); <span class=\"comment\">//访问该结点</span></span><br><span class=\"line\">                r=p;  <span class=\"comment\">//记录最近访问过的结点</span></span><br><span class=\"line\">                p=<span class=\"literal\">NULL</span>;  <span class=\"comment\">//结点访问完后，重置p指针</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"comment\">//else</span></span><br><span class=\"line\">    &#125;<span class=\"comment\">//while</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意:每次出栈访问完一个结点就相当于遍历完以该结点为根的子树，需将p置NULL。</p>\n</blockquote>\n<h4 id=\"层序遍历\"><a href=\"#层序遍历\" class=\"headerlink\" title=\"层序遍历\"></a>层序遍历</h4><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-38.png\" style=\"zoom: 80%;\" />\n\n<p>算法思想：</p>\n<ol>\n<li><p>初始化一个辅助队列</p>\n</li>\n<li><p>让根结点入队</p>\n</li>\n<li><p>若队列非空，则队头结点出队，访问该结点，并将其左、右孩子插入队尾(如果有的话)</p>\n<ul>\n<li>例如 A 结点在队头，让 A 出队，并将其左、右孩子 B、C 插入队</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-39.png\" style=\"zoom:80%;\" />\n</li>\n<li><p>重复 3 直至队列为空</p>\n<ul>\n<li>B 此时为队头元素，B 出队，将 B 的左右孩子 D、E 插入队尾</li>\n<li>C 此时为队头元素，C 出队，将 C 的左右孩子 F、G 插入队尾</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-40.png\" style=\"zoom:80%;\" />\n\n</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 层序遍历</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">LevelOrder</span><span class=\"params\">(BiTree T)</span>&#123;</span><br><span class=\"line\">    LinkQueue Q;\t\t\t\t<span class=\"comment\">// 链队列</span></span><br><span class=\"line\">    InitQueue(Q);\t\t\t\t<span class=\"comment\">// 初始化辅助队列</span></span><br><span class=\"line\">    BiTree p;\t\t\t\t\t</span><br><span class=\"line\">    EnQueue(Q,T);\t\t\t\t<span class=\"comment\">// 将根结点入队</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!IsEmpty(Q))&#123;\t\t\t<span class=\"comment\">// 队列不为空则循环</span></span><br><span class=\"line\">        DeQueue(Q,p);\t\t\t<span class=\"comment\">// 队头结点出队</span></span><br><span class=\"line\">        visit(p);\t\t\t\t<span class=\"comment\">// 访问出队结点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p-&gt;lchild != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            EnQueue(Q,p-&gt;lchild);<span class=\"comment\">// 左孩子入队</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p-&gt;rchild != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            EnQueue(Q,p-&gt;rchild);<span class=\"comment\">// 右孩子入队</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里使用的是链队列，因为我们无法估计一棵树到底有多少个结点，使用链队列方便我们对空间进行扩展。</p>\n<p>对于链队列的初始化、入队出队等操作，之前讲过就不再重复了。</p>\n</blockquote>\n<h3 id=\"由遍历序列构造二叉树\"><a href=\"#由遍历序列构造二叉树\" class=\"headerlink\" title=\"由遍历序列构造二叉树\"></a>由遍历序列构造二叉树</h3><blockquote>\n<p>给定一棵二叉树，它的中序遍历序列是唯一的。</p>\n<p>但是给定一个中序遍历序列，我们不能确切的说，它对应的是哪棵树。同一个中序遍历序列可能对应多种二叉树形态。</p>\n<p>前序遍历、后序遍历、层序遍历同理。</p>\n<p>因此，若只给出某一种遍历序列，就让逆推出二叉树，是不可能的。</p>\n</blockquote>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-41.png\" style=\"zoom:67%;\" />\n\n<p><font color='cornflowerblue'>结论：一个中序/前序/后序/层次遍历序列可能对应多种二叉树形态，若只给出一棵二叉树的 前/中/后/层 序遍历序列中的一种，不能唯一确定一棵二叉树</font></p>\n<p><font color='orange'>怎样可以唯一确定一棵二叉树呢？</font></p>\n<p>若要由二叉树的遍历序列构造二叉树，则</p>\n<ul>\n<li>前序 + 中序 遍历序列</li>\n<li>后序 + 中序 遍历序列</li>\n<li>层序 + 中序 遍历序列</li>\n</ul>\n<p><font color=\"red\">注意：前序、后序、层序序列的两两组合无法唯一确定一棵二叉树，一定要有中序遍历序列，才能推出二叉树</font></p>\n<h4 id=\"前序-中序遍历序列\"><a href=\"#前序-中序遍历序列\" class=\"headerlink\" title=\"前序+中序遍历序列\"></a>前序+中序遍历序列</h4><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-42.png\" style=\"zoom:80%;\" />\n\n<p>我们来看一个例子：</p>\n<ul>\n<li>已知前序遍历序列为：A D B C E</li>\n<li>已知中序遍历序列为：B D C A E</li>\n</ul>\n<p>由中序遍历序列首先推出根节点为 A ，(B D C) 均为左子树，E 为右子树。如下图</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-43.png\" style=\"zoom:50%;\" />\n\n<p>由前序遍历序列推出左子树的根节点为 D，则由中序序列推出结点 D 的左子树为 B，右子树为 C</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-176.png\"  />\n\n<hr>\n<p>再来看一个复杂一点的例子</p>\n<ul>\n<li>已知前序遍历序列为：D A E F B C H G I</li>\n<li>已知中序遍历序列为：E A F D H C B G I</li>\n</ul>\n<p>由前序遍历序列推出 D 为根结点，则由中序遍历序列可知 D 的左子树为 (D A F)，右子树为(H C B G I)</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-45.png\" style=\"zoom:50%;\" />\n\n<p>根据前序遍历序列 A 为左子树的根节点，根据中序遍历序列 A 的左子树为 E，右子树则为 F</p>\n<p>根据前序遍历序列 B 为右子树的根节点，根据中序遍历序列 B 的左子树为(H C)，右子树为(GI)</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-46.png\" style=\"zoom:50%;\" />\n\n<p>根据前序遍历序列 C 为 根，根据中序遍历序列 C 的左子树为 H</p>\n<p>根据前序遍历序列 G 为根，根据中序遍历序列 G 的右子树为 I</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-47.png\" style=\"zoom:50%;\" />\n\n<h4 id=\"后续-中序遍历序列\"><a href=\"#后续-中序遍历序列\" class=\"headerlink\" title=\"后续+中序遍历序列\"></a>后续+中序遍历序列</h4><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-48.png\" style=\"zoom: 80%;\" />\n\n<p>我们来看一个例子：</p>\n<ul>\n<li>已知后序遍历序列：E F A H C I G B D (左 右 根)</li>\n<li>已知中序遍历序列：E A F D H C B G I (左 根 右)</li>\n</ul>\n<p>根据后序遍历序列 D 为根节点，根据中序遍历序列 ，(E A F) 为左子树，(H C B G I) 为右子树</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-49.png\" style=\"zoom: 50%;\" />\n\n<p>根据后序遍历序列 A 为左子树的根节点，根据中序遍历序列 E 为 A 结点的左子树，F为右子树</p>\n<p>根据后序遍历序列 B 为右子树的根节点，根据中序遍历序列 (H C) 为左子树，(G I)为右子树</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-50.png\" style=\"zoom:50%;\" />\n\n<p>根据后序遍历序列 C 为根，G 为根。根据中序遍历序列 H 为左子树，I 为右子树</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-51.png\" style=\"zoom:50%;\" />\n\n<h4 id=\"层序-中序遍历序列\"><a href=\"#层序-中序遍历序列\" class=\"headerlink\" title=\"层序+中序遍历序列\"></a>层序+中序遍历序列</h4><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-52.png\" style=\"zoom: 80%;\" />\n\n<p>我们来看一个简单的例子：</p>\n<ul>\n<li>已知层序遍历序列：A B C D E (根 左子树的根 右子树的根)</li>\n<li>已知中序遍历序列：A C B E D (左 根 右)</li>\n</ul>\n<p>根据层序遍历序列，首先访问第一层，根为 A。格局中序遍历序列，A 的左边没有元素，则 A 的左子树为空1</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-53.png\" style=\"zoom: 50%;\" />\n\n<p>根据层序遍历序列，访问第二层，首先出现的是 B，则 B 是右子树的根节点。根据中序遍历序列，C 为 B 的左子树，(E D) 为 B 的右子树</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-54.png\" style=\"zoom:50%;\" />\n\n<p>根据层序遍历，访问第三层，首先出现的是 C、D，则 D 为根，根据中序遍历，E 为 D 的左子树</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-55.png\" style=\"zoom:50%;\" />\n\n<hr>\n<p>我们来看一个例子：</p>\n<ul>\n<li>已知层序遍历序列：D A B E F C G H I (根 左子树的根 右子树的根)</li>\n<li>已知中序遍历序列：E A F D H C B G I (左 根 右)</li>\n</ul>\n<p>根据层序遍历序列，访问第一层，D 为根结点，根据中序遍历序列，(E A F)为左子树，(H C B G I)为右子树</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-56.png\" style=\"zoom:50%;\" />\n\n<p>根据层序遍历序列，访问第二层，首先出现的是A、B，则A 为左子树的根节点，B 为右子树的根节点。根据中序遍历，E 为 A 的左子树，F为 A 的右子树。 (H C )为 B 的左子树，(G I) 为 B 的右子树</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-57.png\" style=\"zoom:50%;\" />\n\n<p>根据层序遍历序列，访问第三层，首先出现的是 E、F、C、G，则 根节点分别为 C、G</p>\n<p>根据中序遍历，C 的左子树为 H，G 的右子树为 </p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-58.png\" style=\"zoom:50%;\" />\n\n<h3 id=\"线索二叉树\"><a href=\"#线索二叉树\" class=\"headerlink\" title=\"线索二叉树\"></a>线索二叉树</h3><h4 id=\"线索二叉树的作用\"><a href=\"#线索二叉树的作用\" class=\"headerlink\" title=\"线索二叉树的作用\"></a>线索二叉树的作用</h4><p>普通二叉树有如下两个<strong>问题</strong>：</p>\n<ul>\n<li>普通二叉树遍历只能从根节点开始遍历，不能从一个指定结点开始中序遍历。</li>\n<li>普通二叉树中如果只知道指向当前结点的指针，没法找到当前结点在中序遍历序列的前驱。(例如下图中只知道指向 F 结点的指针 p，如何找到结点在中序遍历序列的前驱呢？)</li>\n</ul>\n<p>那么我们如何解决上述问题呢？</p>\n<p><font color='red'>思路</font>：</p>\n<ul>\n<li>从根结点出发，重新进行一次中序遍历，指针 q 记录当前访问的结点，指针 pre 记录上一个被访问的结点(前驱)</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-59.png\" style=\"zoom: 80%;\" />\n\n<ul>\n<li>下一个结点被访问(visit)之前，我们需要将 pre 前驱指针指向 q 所指向的结点，然后 q 指针指向下一个要访问的结点</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-60.png\" style=\"zoom: 33%;\" />\n\n<ul>\n<li>所以现在 pre 指针所指向的结点就是 q 指针所指向结点的中序遍历的前驱。用这样的思路我们可以让 q 不断的指向后一个被访问的结点，然后 pre 也跟着依次的向后移动。</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-61.png\" style=\"zoom: 33%;\" />\n\n<ul>\n<li>当 q 和 p 指向了同一个结点，也就是 q == p，那么就说明 pre 所指向的结点就是 p 所指向结点的前驱</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-62.png\" style=\"zoom: 33%;\" />\n\n<ul>\n<li>继续 pre 向后移， q 也向后移。此时 pre == p，则 q 所指向的结点就是 p 所指向结点的后继</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-63.png\" style=\"zoom: 33%;\" />\n\n<p><font color='orange'>上述的操作是非常不方便的，线索二叉树就是为了解决上述问题的。</font></p>\n<p><strong>n 个结点的二叉树，有 n + 1 个空链域。我们可以利用这些空链域来记录前驱、后继的信息。</strong></p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-215.png\" style=\"zoom:55%;\" />\n\n<ul>\n<li>如上图，D 的左子树是空链域，因为 D 没有前驱结点，是第一个结点，所以让其左子树指向NULL</li>\n<li>G 的左右子树都是空链域，让左子树指向其前驱结点 D，让右子树指向其后继结点 B</li>\n<li>E 的左右子树都是空链域，让左子树指向其前驱结点 B，让右子树指向其后继结点 A</li>\n<li>F 的左右子树都是空链域，让左子树指向其前驱结点 A，让右子树指向其后继结点 C</li>\n<li>C 的右子树是空链域，因为 C 没有后继结点，是最后一个结点，所以让其右子树指向 NULL</li>\n</ul>\n<p><strong>定义</strong>：一个结点的左孩子指针和右孩子指针指向的是前驱和后继而不是其左右孩子的话，我们把这种类型的指针称为线索，指向前驱的是前驱线索，指向后继的是后继线索。</p>\n<p><font color='cornflowerblue'>那么还存在一个问题，如果我们的右孩子指针指向的就是右孩子而不是后继，那么如何找后继呢？</font></p>\n<h4 id=\"线索二叉树的存储结构\"><a href=\"#线索二叉树的存储结构\" class=\"headerlink\" title=\"线索二叉树的存储结构\"></a>线索二叉树的存储结构</h4><p><strong>普通二叉树</strong>的链式存储结点:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-65.png\" style=\"zoom: 67%;\" />\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 二叉树的结点(链式存储)</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span> &#123;</span></span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span> *<span class=\"title\">lchild</span>,*<span class=\"title\">rchild</span>;</span></span><br><span class=\"line\">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>\n\n<p><strong>线索二叉树</strong>的链式存储结点:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-66.png\" style=\"zoom: 67%;\" />\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 线索二叉树的结点</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ThreadNode</span>&#123;</span></span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ThreadNode</span> *<span class=\"title\">lchild</span>,*<span class=\"title\">rchild</span>;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> ltag,rtag;\t\t\t\t\t\t<span class=\"comment\">// 左、右线索标志</span></span><br><span class=\"line\">&#125;ThreadNode,*ThreadTree;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"中序线索二叉树的存储\"><a href=\"#中序线索二叉树的存储\" class=\"headerlink\" title=\"中序线索二叉树的存储\"></a>中序线索二叉树的存储</h5><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-216.png\" style=\"zoom: 55%;\" />\n\n<p>以上是中序线索二叉树。而对于先序、后序线索二叉树来说，只不过是遍历序列的顺序变了，<strong>利用左孩子指针充当前驱线索、右孩子指针充当后继线索</strong>的思想是一样的。</p>\n<blockquote>\n<p>总之，线索二叉树的思想就是利用n个结点的二叉树的n+1个空链域，把这些空链域变成<strong>线索</strong>，指向前驱、后继。</p>\n<p>而先序/中序/后续线索二叉树的区别，仅仅是遍历出来的序列是什么的区别。</p>\n<p>一些术语：</p>\n<p>先/中/后序前驱、先/中/后序后继——先/中/后序线索二叉树中的<strong>线索</strong></p>\n</blockquote>\n<h4 id=\"先序线索二叉树\"><a href=\"#先序线索二叉树\" class=\"headerlink\" title=\"先序线索二叉树\"></a>先序线索二叉树</h4><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-68.png\" style=\"zoom:80%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-69.png\" style=\"zoom: 67%;\" />\n\n<h4 id=\"后序线索二叉树\"><a href=\"#后序线索二叉树\" class=\"headerlink\" title=\"后序线索二叉树\"></a>后序线索二叉树</h4><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-217.png\" style=\"zoom:55%;\" />\n\n<h4 id=\"三种线索二叉树的对比\"><a href=\"#三种线索二叉树的对比\" class=\"headerlink\" title=\"三种线索二叉树的对比\"></a>三种线索二叉树的对比</h4><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-218.png\" style=\"zoom:55%;\" />\n\n<ul>\n<li>中序线索二叉树 ➡ 线索指向中序前驱、中序后继</li>\n<li>先序线索二叉树 ➡ 线索指向先序前驱、先序后继</li>\n<li>后序线索二叉树 ➡ 线索指向后序前驱、后序后继</li>\n</ul>\n<h3 id=\"二叉树的线索化\"><a href=\"#二叉树的线索化\" class=\"headerlink\" title=\"二叉树的线索化\"></a>二叉树的线索化</h3><h4 id=\"中序线索化\"><a href=\"#中序线索化\" class=\"headerlink\" title=\"中序线索化\"></a>中序线索化</h4><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-72.png\" style=\"zoom: 50%;\" />\n\n<p>中序遍历二叉树，<font color='orange'>一边遍历一边线索化</font></p>\n<ul>\n<li><p>首先中序遍历左子树，首先访问到的是 D 结点，D 结点没有前驱，所以将 pre 指针指向NULL，并将标志修改为 1 (代表这个孩子指针是线索)</p>\n</li>\n<li><p>之后访问下一个结点，pre 指向 q 指向的结点，q 指向下一个结点</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-73.png\" style=\"zoom:50%;\" />\n</li>\n<li><p>此时 q 指向的结点为 G，判断左子树，如果为空，则建立前驱线索并修改标志为 1 ，判断其右子树，如果为空，则建立后继线索并修改标志为 1</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-74.png\" style=\"zoom:50%;\" />\n</li>\n<li><p>当访问最后一个结点时，pre 和 q 均指向最后一个结点，要检查 pre-&gt; rchild 是否为 NULL，如果是，则令标志为 1</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-75.png\" style=\"zoom:50%;\" />\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 线索二叉树的结点</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ThreadNode</span>&#123;</span></span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ThreadNode</span> *<span class=\"title\">lchild</span>,*<span class=\"title\">rchild</span>;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> ltag,rtag;\t\t\t\t\t\t<span class=\"comment\">// 左、右线索标志</span></span><br><span class=\"line\">&#125;ThreadNode,*ThreadTree;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 中序遍历二叉树,一边遍历一边线索化</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InThread</span><span class=\"params\">(ThreadTree T)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        InThread(T-&gt;lchild);\t\t<span class=\"comment\">// 中序遍历左子树</span></span><br><span class=\"line\">        visit(T);\t\t\t\t\t<span class=\"comment\">// 访问根节点</span></span><br><span class=\"line\">        InThread(T-&gt;rchild);\t\t<span class=\"comment\">// 中序遍历右子树</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 全局变量 pre,指向当前访问结点的前驱(开始访问第一个结点,无前驱,所以指向NULL)</span></span><br><span class=\"line\">ThreadNode *pre = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">visit</span><span class=\"params\">(ThreadNode *q)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(q-&gt;lchild == <span class=\"literal\">NULL</span>)&#123;\t\t\t<span class=\"comment\">// 如果左子树为空,则建立前驱线索</span></span><br><span class=\"line\">        q-&gt;lchild = pre;</span><br><span class=\"line\">        q-&gt;ltag = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pre != <span class=\"literal\">NULL</span> &amp;&amp; pre-&gt;rchild == <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        pre-&gt;rchild = q;\t\t\t<span class=\"comment\">// 建立前驱结点的后继线索</span></span><br><span class=\"line\">        pre-&gt;rtag = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pre = q;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 中序线索化二叉树T</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">CreateInThread</span><span class=\"params\">(ThreadTree T)</span>&#123;</span><br><span class=\"line\">    pre=<span class=\"literal\">NULL</span>;\t\t\t\t\t\t<span class=\"comment\">// pre初始为NULL</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T != <span class=\"literal\">NULL</span>)&#123;\t\t\t\t\t<span class=\"comment\">// 非空二叉树才能线索化</span></span><br><span class=\"line\">        InThread(T);\t\t\t\t<span class=\"comment\">// 中序线索化二叉树</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pre-&gt;rchild == <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            pre-&gt;rtag=<span class=\"number\">1</span>;\t\t\t<span class=\"comment\">// 处理遍历的最后一个结点</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"先序线索化\"><a href=\"#先序线索化\" class=\"headerlink\" title=\"先序线索化\"></a>先序线索化</h4><p>先序遍历二叉树，<font color='orange'>一边遍历一边线索化</font></p>\n<ul>\n<li><p>首先访问根结点，判断左右子树，发现左右子树都非空，则不操作，让 pre 指向 q所指向的结点，q指向下一结点</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-76.png\" style=\"zoom:50%;\" />\n</li>\n<li><p>访问结点 B，发现 B 的左右子树都非空，则不操作，让 pre 指向 q所指向的结点，q指向下一结点</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-77.png\" style=\"zoom:50%;\" />\n</li>\n<li><p>之后访问 D 结点，发现其左子树为空，则建立前驱线索(将其左子树指向前驱结点B)，之后我们就要先序遍历 D结点的左子树，但是发现此时左子树为 B，这样下去就会造成循环。所以我们在先序遍历二叉树时，要让左子树不是前驱线索时再进行</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 先序遍历二叉树,一边遍历一边线索化</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">PreThread</span><span class=\"params\">(ThreadTree T)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        visit(T);\t\t\t\t<span class=\"comment\">// 先处理根结点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(T-&gt;ltag == <span class=\"number\">0</span>)&#123;\t\t<span class=\"comment\">// lchild不是前驱线索</span></span><br><span class=\"line\">            PreThread(T-&gt;lchild);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        PreThread(T-&gt;rchild);\t<span class=\"comment\">// 先序遍历右子树</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 全局变量 pre,指向当前访问结点的前驱</span></span><br><span class=\"line\">ThreadNode *pre = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">visit</span><span class=\"params\">(ThreadNode *q)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(q-&gt;lchild == <span class=\"literal\">NULL</span>)&#123;\t\t\t<span class=\"comment\">// 如果左子树为空,则建立前驱线索</span></span><br><span class=\"line\">        q-&gt;lchild = pre;</span><br><span class=\"line\">        q-&gt;ltag = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pre != <span class=\"literal\">NULL</span> &amp;&amp; pre-&gt;rchild == <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        pre-&gt;rchild = q;\t\t\t<span class=\"comment\">// 建立前驱结点的后继线索</span></span><br><span class=\"line\">        pre-&gt;rtag = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pre = q;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 先序线索化二叉树T</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">CreateInThread</span><span class=\"params\">(ThreadTree T)</span>&#123;</span><br><span class=\"line\">    pre=<span class=\"literal\">NULL</span>;\t\t\t\t\t\t<span class=\"comment\">// pre初始为NULL</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T != <span class=\"literal\">NULL</span>)&#123;\t\t\t\t\t<span class=\"comment\">// 非空二叉树才能线索化</span></span><br><span class=\"line\">        InThread(T);\t\t\t\t<span class=\"comment\">// 中序线索化二叉树</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pre-&gt;rchild == <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            pre-&gt;rtag=<span class=\"number\">1</span>;\t\t\t<span class=\"comment\">// 处理遍历的最后一个结点</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"后序线索化\"><a href=\"#后序线索化\" class=\"headerlink\" title=\"后序线索化\"></a>后序线索化</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 线索二叉树的结点</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ThreadNode</span>&#123;</span></span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ThreadNode</span> *<span class=\"title\">lchild</span>,*<span class=\"title\">rchild</span>;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> ltag,rtag;\t\t\t\t\t\t<span class=\"comment\">// 左、右线索标志</span></span><br><span class=\"line\">&#125;ThreadNode,*ThreadTree;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 后序遍历二叉树,一边遍历一边线索化</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">PostThread</span><span class=\"params\">(ThreadTree T)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        PostThread(T-&gt;lchild);\t\t<span class=\"comment\">// 中序遍历左子树</span></span><br><span class=\"line\">        PostThread(T-&gt;rchild);\t\t<span class=\"comment\">// 中序遍历右子树</span></span><br><span class=\"line\">        visit(T);\t\t\t\t\t<span class=\"comment\">// 访问根节点</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 全局变量 pre,指向当前访问结点的前驱(开始访问第一个结点,无前驱,所以指向NULL)</span></span><br><span class=\"line\">ThreadNode *pre = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">visit</span><span class=\"params\">(ThreadNode *q)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(q-&gt;lchild == <span class=\"literal\">NULL</span>)&#123;\t\t\t<span class=\"comment\">// 如果左子树为空,则建立前驱线索</span></span><br><span class=\"line\">        q-&gt;lchild = pre;</span><br><span class=\"line\">        q-&gt;ltag = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pre != <span class=\"literal\">NULL</span> &amp;&amp; pre-&gt;rchild == <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        pre-&gt;rchild = q;\t\t\t<span class=\"comment\">// 建立前驱结点的后继线索</span></span><br><span class=\"line\">        pre-&gt;rtag = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pre = q;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 后序线索化二叉树T</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">CreateInThread</span><span class=\"params\">(ThreadTree T)</span>&#123;</span><br><span class=\"line\">    pre=<span class=\"literal\">NULL</span>;\t\t\t\t\t\t<span class=\"comment\">// pre初始为NULL</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T != <span class=\"literal\">NULL</span>)&#123;\t\t\t\t\t<span class=\"comment\">// 非空二叉树才能线索化</span></span><br><span class=\"line\">        InThread(T);\t\t\t\t<span class=\"comment\">// 中序线索化二叉树</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pre-&gt;rchild == <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            pre-&gt;rtag=<span class=\"number\">1</span>;\t\t\t<span class=\"comment\">// 处理遍历的最后一个结点</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-78.png\" alt=\"\"></p>\n<h3 id=\"线索二叉树找前驱-后继\"><a href=\"#线索二叉树找前驱-后继\" class=\"headerlink\" title=\"线索二叉树找前驱/后继\"></a>线索二叉树找前驱/后继</h3><h4 id=\"中序线索二叉树找中序后继\"><a href=\"#中序线索二叉树找中序后继\" class=\"headerlink\" title=\"中序线索二叉树找中序后继\"></a>中序线索二叉树找中序后继</h4><p>例如：我们要在中序线索二叉树中找到指定结点 *p 的中序后继 next，next = p的右子树中最左下结点</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-219.png\" style=\"zoom:55%;\" />\n\n<ul>\n<li>若 p -&gt; rtag == 1, 说明右子树被线索化，那么右子树就是其中序后继，则 next = p -&gt; rchild</li>\n<li>若 p-&gt; rtag == 0,说明右子树未被线索化，右子树肯定是非空，则 p 必然有右孩子。</li>\n</ul>\n<blockquote>\n<p>由于我们是找中序后继，也就是从中序遍历来看，在访问这个结点后，访问的下一个结点是什么。而中序遍历的访问顺序是：左、根、右。所以按照中序遍历的规则，访问p结点这个根结点之后，需要再中序遍历p的右子树。那么，在p的右子树中第一个被访问的结点，就应该是p的后继。</p>\n<p>假设p的右子树只有一个右孩子，也就是只有一个叶子结点，那么显然这个右孩子就是p的后继。</p>\n<p>但是如果这个结点是一个分支节点，也就是再往下还有更深层的结点的话，那么要对这个右子树继续进行中序遍历（左、根、右）这样来看的话，那么这个右子树的最左下角的那个结点就应该是p的中序后继结点。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 找到以 P 为根的子树中,第一个被中序遍历的结点</span></span><br><span class=\"line\">ThreadNode *<span class=\"title function_\">Firstnode</span><span class=\"params\">(ThreadNode *p)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 循环找到最左下结点(不一定是叶结点)</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p-&gt;ltag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        p = p-&gt;lchild;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在中序线索二叉树中找到结点 p 的后继结点</span></span><br><span class=\"line\">ThreadNode *<span class=\"title function_\">Nextnode</span><span class=\"params\">(ThreadNode *p)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 右子树最左下结点(右子树当中第一个被遍历到的结点)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p-&gt;rtag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Firstnode(p-&gt;rchild);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p-&gt;rchild;\t\t<span class=\"comment\">// rtag == 1 直接返回后继线索</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>既然我们能遍历到结点的后继结点，那么我们就可以对中序线索二叉树进行遍历</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对中序线索二叉树进行中序遍历(利用线索实现的非递归算法) </span></span><br><span class=\"line\"><span class=\"comment\">// 传入我们要遍历的树的根节点的指针T</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Inorder</span><span class=\"params\">(ThreadNode *T)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(ThreadNode *p = Firstnode(T);p != <span class=\"literal\">NULL</span>;p=Nextnode(p))&#123;</span><br><span class=\"line\">        visit(p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"中序线索二叉树找中序前驱\"><a href=\"#中序线索二叉树找中序前驱\" class=\"headerlink\" title=\"中序线索二叉树找中序前驱\"></a>中序线索二叉树找中序前驱</h4><p>例如：我们要在中序线索二叉树中找到指定结点 *p 的中序前驱pre，pre= p的左子树中最右下结点</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-220.png\" style=\"zoom:55%;\" />\n\n<ul>\n<li>若 p -&gt; ltag == 1, 说明左子树被线索化，那么左子树就是其中序后继，则 pre = p -&gt; lchild</li>\n<li>若 p-&gt; ltag == 0,说明左子树未被线索化，那么左子树肯定非空，则 p 必然有左孩子。</li>\n</ul>\n<blockquote>\n<p>按照中序遍历的规则，（左、根、右），它的这个结点的前驱一定是它的左子树当中，按照中序遍历最后一个被访问的结点。</p>\n<p>如果左子树只有一个叶子结点，那么显然它的这个左孩子就是它的中序前驱。</p>\n<p>而如果左子树还有多层分级的话，总之，其左子树最右下的结点就是左子树当中最后一个被访问的结点。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 找到以p为根的子树中,最后一个被中序遍历的结点</span></span><br><span class=\"line\">ThreadNode *<span class=\"title function_\">Lastnode</span><span class=\"params\">(ThreadNode *p)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 循环找到最右下结点(不一定是叶节点)</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p-&gt;rtag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        p = p-&gt;rchild;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在中序线索二叉树中找到结点p的前驱结点</span></span><br><span class=\"line\">ThreadNode *<span class=\"title function_\">Prenode</span><span class=\"params\">(ThreadNode *p)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 左子树中最右下结点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p-&gt;ltag == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Lastnode(p-&gt;lchild);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p-&gt;lchild;\t\t\t<span class=\"comment\">//ltag==1 直接返回前驱结点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>既然我们能遍历到结点的前驱结点，那么我们就可以对中序线索二叉树进行逆向中序遍历</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对中序线索二叉树进行逆向中序遍历</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">RevInorder</span><span class=\"params\">(ThreadNode *T)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(ThreadNode *p = Lstnode(T);p != <span class=\"literal\">NULL</span>;p = Prenode(p)&#123;</span><br><span class=\"line\">        visit(p);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"先序线索二叉树找先序后继\"><a href=\"#先序线索二叉树找先序后继\" class=\"headerlink\" title=\"先序线索二叉树找先序后继\"></a>先序线索二叉树找先序后继</h4><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-221.png\" style=\"zoom:55%;\" />\n\n<ul>\n<li>若 p -&gt; rtag == 1, 说明右子树被线索化，那么右子树就是其先序后继，则 next= p -&gt; rchild</li>\n<li>若 p-&gt; rtag == 0,说明右子树未被线索化，那么右子树肯定非空，则 p 必然有右孩子。</li>\n</ul>\n<blockquote>\n<p>我们先假设它有左孩子。</p>\n<p>然后按照先序遍历（根、左、右）的规则来看，p结点的后继结点肯定是它左子树当中第一个被访问的结点。也就是不论其左子树有多少层级，都是p的那一个左孩子结点。</p>\n<p>再说，如果没有左孩子。</p>\n<p>如果没有左孩子的话，根据根、左、右的原则，由于左为空，那么就是根、右。那么也就是它的右子树当中第一个被先序遍历的结点。也就是，无论它的右子树是叶子结点，还是多个层级的分支节点，都是p的右孩子结点。</p>\n</blockquote>\n<h4 id=\"先序线索二叉树找先序前驱\"><a href=\"#先序线索二叉树找先序前驱\" class=\"headerlink\" title=\"先序线索二叉树找先序前驱\"></a>先序线索二叉树找先序前驱</h4><p>在先序线索二叉树中找到指定结点p的<strong>先序前驱</strong>pre。</p>\n<ul>\n<li>若p-&gt;ltag == 1，则next = p-&gt;lchild。</li>\n<li>若p-&gt;ltag == 0，（说明p一定有左孩子）。</li>\n</ul>\n<blockquote>\n<p>按照先序遍历的规则（根、左、右）可知，p的左子树、右子树，都只可能是p的后继，而不可能是p的前驱。因此，我们不可能在它的左右子树当中，找到它的前驱。</p>\n<p>而我们的线索二叉树，它只有指向它的孩子结点的指针，不可能往上找。</p>\n<p>所以在这种情况下，我们是找不到p的先序前驱的。</p>\n<p>除非，用从头遍历的土办法，来重新进行一次完整的先序遍历来找到p的前驱。</p>\n</blockquote>\n<blockquote>\n<p>但是我们说过，二叉链表其实我们可以在某些应用场景下，根据需要，把它改为三叉链表，即增加一个指向其父节点的指针。</p>\n<p>那么在这种能找到它的父节点的情况下，我们再看，能不能找到它的先序前驱。</p>\n<p>第一种情况：<strong>能找到p的父节点，且p是左孩子</strong></p>\n<p>按照先序遍历的规则（根、左、右）来看，p结点一定是在它的父节点被访问过之后，第一个被访问到的。因此<strong>p的父节点一定是p的先序前驱</strong>。</p>\n<p>第二种情况：<strong>能找到p的父节点，且p是右孩子，其左兄弟为空</strong></p>\n<p>也就是p的父节点的左孩子为空。那么按照先序遍历的规则就应该是：根、右。因此，<strong>p的父节点一定是它的先序前驱</strong>。</p>\n<p>第三种情况：<strong>能找到p的父节点，且p是右孩子，其左兄弟非空</strong></p>\n<p>按照先序遍历的规则（根、左、右），p这个结点的先序前驱，一定是它的左兄弟子树，按照先序遍历的顺序<strong>最后一个被访问到的结点，也就是最右下的结点</strong>。即<strong>p的先序前驱为其左兄弟子树中最后一个被先序遍历访问的结点</strong>。</p>\n<p>第四种情况：<strong>如果p没有父节点，也就是p是根结点，则p没有先序前驱</strong>。</p>\n</blockquote>\n<h4 id=\"后序线索二叉树找后序前驱\"><a href=\"#后序线索二叉树找后序前驱\" class=\"headerlink\" title=\"后序线索二叉树找后序前驱\"></a>后序线索二叉树找后序前驱</h4><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-163.png\" style=\"zoom: 50%;\" />\n\n<p>在后序线索二叉树中找到指定结点p的<strong>后续前驱</strong>pre。</p>\n<ul>\n<li>若p-&gt;ltag == 1，则pre = p-&gt;lchild。</li>\n<li>若p-&gt;ltag == 0（说明它一定有左孩子，但是不一定有没有右孩子）</li>\n</ul>\n<blockquote>\n<p>先讨论假设它有右孩子的情况：</p>\n<p>按照后序遍历的规则（左、右、根），可以看到，p的后序前驱，是p的右子树中，按照后序遍历的规则被访问到的最后一个结点，也就是右孩子结点本身。因此，<strong>若p有右孩子，则后序前驱为其右孩子</strong>。</p>\n<p>假设它没有右孩子：</p>\n<p>按照后序遍历的规则（左、根），可以看到，p的后序前驱，是p的左子树中，按照后序遍历的规则被访问到的最后一个结点，也就是左孩子本身。因此，<strong>若p没有右孩子，则后序前驱为其左孩子</strong>。</p>\n</blockquote>\n<h4 id=\"后序线索二叉树找后序后继\"><a href=\"#后序线索二叉树找后序后继\" class=\"headerlink\" title=\"后序线索二叉树找后序后继\"></a>后序线索二叉树找后序后继</h4><p>在后序线索二叉树中找指定结点p的<strong>后序后继</strong>next。</p>\n<ul>\n<li>若p-&gt;rtag == 1，则next = p-&gt;rchild。</li>\n<li>若p-&gt;rtag == 0，（说明其一定有右孩子）</li>\n</ul>\n<blockquote>\n<p>按照后序遍历的规则（左、右、根）来看，p的左右子树均只有可能是它的前驱，而不可能是它的后继。</p>\n<p>因此，后序遍历中，左右子树中的结点只可能是p的前驱，不可能是后继。</p>\n<p>因此我们只能利用土办法，即从头到尾重新进行一次完整的后序遍历，才有可能找到它的后序后继。</p>\n</blockquote>\n<blockquote>\n<p>但是，还可以改用三叉链表找到父节点的方式来完成。</p>\n<p>第一种情况，<strong>能找到p的父节点，且p是右孩子</strong>：</p>\n<p>按照后序遍历的规则（左、右、根），无论p结点下面还有没有孩子，p结点一定是最后一个被访问的结点。而在访问过p结点之后，下一个一定紧接着是访问它的父节点。因此，<strong>p的后序后继为p的父节点</strong>。</p>\n<p>第二种情况，<strong>能找到p的父节点，且p是左孩子，其右兄弟为空</strong>：</p>\n<p>按照后序遍历的规则（左、根）。显然，无论如何，在访问完p结点之后，一定会紧接着访问它的父节点。因此，<strong>p的后序后继为p的父节点</strong>。</p>\n<p>第三种情况，<strong>能找到p的父节点，且p是左孩子，其右兄弟非空</strong>：</p>\n<p>按照后序遍历的规则（左、右、根）来看，p的后继，就应该是它的右兄弟子树当中，按照后序遍历第一个被访问的结点，也就是右兄弟子树最左下的结点。因此，<strong>p的后序后继为右兄弟子树中第一个被后序遍历到的结点</strong>。</p>\n<p>第四种情况，<strong>如果p是根结点，则p没有后序后继</strong>。</p>\n</blockquote>\n<h4 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>对以上所有情况的讨论，我们只需要理解其逻辑过程，而不要去背结论</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>中序线索二叉树</th>\n<th>先序线索二叉树</th>\n<th>后序线索二叉树</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>找前驱</td>\n<td>✔</td>\n<td>×</td>\n<td>✔</td>\n</tr>\n<tr>\n<td>找后继</td>\n<td>✔</td>\n<td>✔</td>\n<td>×</td>\n</tr>\n</tbody></table>\n<p>对先序线索二叉树来说，找先序前驱是不可以的；同样地，对于后续线索二叉树来说，找后序后继是不可以的。除非采用<strong>三叉链表</strong>，或者用<strong>土办法</strong>从整棵树的根结点重新进行完整的遍历来寻找其<strong>父节点</strong>。</p>\n<p>也就是，对于先序线索二叉树来说，给你一个结点，你只能从这个结点开始向后进行先序遍历。</p>\n<p>对于后续线索二叉树来说，给你一个结点，你只能从这个结点开始进行逆向的后序遍历。</p>\n<h3 id=\"习题\"><a href=\"#习题\" class=\"headerlink\" title=\"习题\"></a>习题</h3><ul>\n<li><p>在二叉树中有两个结点 m 和 n，若 m 是 n 的祖先，则使用什么遍历方法可以找到 m 到 n 的路径 → 后序遍历</p>\n</li>\n<li><p>在二叉树的前序序列、中序序列和后序序列中，所有叶子结点的先后顺序相同吗？若不全相同，则哪几种遍历方式的先后顺序相同 → 完全相同</p>\n</li>\n<li><p>【2009】给定二叉树如右图所示。设N代表二叉树的根，L代表根结点的左子树，R代表根结点的右子树。若遍历后的结点序列是(3, 1, 7, 5, 6, 2, 4)，则其遍历方式是–&gt;RNL</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-82.png\" style=\"zoom:85%;\" />\n\n<blockquote>\n<p>分析遍历后的结点序列，可以看出根结点是在中间访问，而右子树结点在左子树之前，即遍历的方式是 RNL 。本题考查的遍历方法并不是二叉树的 3 种基本遍历方法，对于考生而言，重要的是要掌握遍历的思想。</p>\n<ul>\n<li>前序遍历：根结点 -&gt; 左子树 -&gt; 右子树</li>\n<li>中序遍历：左子树 -&gt; 根结点 -&gt; 右子树</li>\n<li>后序遍历：左子树 -&gt; 右子树 -&gt; 根结点</li>\n</ul>\n</blockquote>\n</li>\n<li><p>【2011】若一棵二叉树的前序遍历序列和后序遍历序列分别为{ 1, 2, 3, 4}和{4, 3, 2, 1}，则该二叉树的中序遍历序列不会是→C</p>\n<p>A. 1234   B. 2341<br>C. 3241   D. 4321</p>\n<blockquote>\n<p>前序序列为NLR，后序序列的逆序为LRN，要使NLR=NRL（后序序列的反序），则L或R为空，这样的二叉树每层就只有一个结点，高度为4。1为根结点，由于根结点只有左孩子或右孩子，因此在中序序列中，1或在序列首或在序列尾，ABCD皆满足。仅考虑以1的孩子结点2为根的子树，同理在中序序列中，2或在序列首或在序列尾，ABD皆满足，C不满足。</p>\n</blockquote>\n</li>\n<li><p>【2012】若一棵二叉树的前序遍历序列为{ a, e, b, d, c}，后序遍历序列为{ b, c, d, e, a}，则根结点的孩子结点 → 只有 e</p>\n<blockquote>\n<p>由先序遍历第一个结点为a,则可知道树的根节点为a。后序遍历序列中根节点会把序列分为左右两段，左段为左子树上结点，右段为右子树上结点，所以由后序遍历序列可知b,c,d,e均为a结点的左子树上的点，a不存在右子树。再由先序遍历序列知道e为根结点a的左孩子结点。即根节点的孩子结点只有e，且为左孩子。</p>\n</blockquote>\n</li>\n<li><p>【2013】若X是后序线索二叉树中的叶结点，且X存在左兄弟结点Y，则X的右线索指向的是–&gt;A</p>\n<p>A. X的父结点<br>B. 以Y为根的子树的最左下结点<br>C. X的左兄弟结点Y<br>D. 以Y为根的子树的最右下结点</p>\n<blockquote>\n<p>根据题意，x存在左兄弟结点y,说明x是右边的那个结点</p>\n<p>由于是后序线索二叉树，后序遍历的规则是DLR，X的后继就是其双亲结点</p>\n<p>因此右线索指向的是：X的父结点</p>\n</blockquote>\n</li>\n<li><p>【2014】若对下图所示的二叉树进行中序线索化，则结点X的左、右线索指向的结点分别是–&gt;b，a</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-84.png\" style=\"zoom: 80%;\" />\n\n<blockquote>\n<p>中序线索化即根据中序遍历的顺序，找出该字母的前驱和后继。中序遍历结果为debxac。x的前驱是b，后继是a。所以结点x的左、右线索指向的结点分别是b，a。</p>\n</blockquote>\n</li>\n<li><p>【2015】先序序列为a,b,c,d的不同二叉树的个数是–&gt;14</p>\n<blockquote>\n<p>根据二叉树前序遍历和中序遍历的递归算法中递归工作栈的状态变化得出：前序序列和中序序列的关系相当于以前序序列为入栈次序，以中序序列为出栈次序。因为前序序列和中序序列可以唯一地确定一棵二叉树，所以题意相当于“以序列 a,b,c,d 为入栈次序，则出栈序列的个数为？”，对于 n 个不同元素进栈，出栈序列的个数为14</p>\n</blockquote>\n</li>\n<li><p>【2017】某二叉树的树形如图所示，其后序序列为e,a,c,b,d,g,f，树中与结点a同层的结点是–&gt;d</p>\n<p><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-85.png\" alt=\"\"></p>\n<blockquote>\n<p>后序序列是先左子树，接着右子树，最后父结点，递归进行。根结点左子树的叶结点首先被访问，它是e。接下来是它的父结点a,然后是a的父结点c。接着访问根结点的右子树。它的叶结点b首先被访问，然后是b的父结点d，再后是d的父结点g,最后是根结点f,如右图所示。因此d与a同层。</p>\n</blockquote>\n</li>\n<li><p>【2017】要使一棵非空二叉树的先序序列与中序序列相同，其所有非叶结点须满足的条件是–&gt;B</p>\n<p>A. 只有左子树<br>B. 只有右子树<br>C. 结点的度均为1<br>D. 结点的度均为2</p>\n<blockquote>\n<p>先序序列是先父结点，接着左子树，然后右子树。中序序列是先左子树，接着父结点，然后右子树，递归进行。如果所有非叶结点只有右子树，先序序列和中序序列都是先父结点，然后右子树，递归进行，因此B正确。</p>\n</blockquote>\n</li>\n<li><p>线索二叉树是一种什么结构？「逻辑、逻辑和存储、物理、线性」?→ 物理</p>\n</li>\n<li><p>一棵左子树为空的二叉树在先序线索化后，其中空的链域的个数是 →2 个</p>\n</li>\n<li><p>【2010】下列线索二叉树中(用虚线表示线索)，符合后序线索树定义的是–&gt;D</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-83.png\" style=\"zoom:67%;\" />\n\n<blockquote>\n<p>题中所给二叉树的后序序列为dbca。结点d无前驱和左子树，左链域空，无右子树，右链域指向其后继结点b；结点b无左子树，左链域指向其前驱结点d；结点c无左子树，左链域指向其前驱结点b，无右子树，右链域指向其后继结点a。</p>\n</blockquote>\n</li>\n<li><p>二叉树在线索化后，仍不能有效求解的问题是？→D</p>\n<p>A 先序线索二叉树中求先序后继<br>B 中序线索二叉树中求中序后继<br>C 中序线索二叉树中求中序前驱<br>D 后序线索二叉树中求后序后继 </p>\n</li>\n<li><p>（ ）的遍历仍需要栈的支持→C</p>\n<p>A 前序线索树<br>B 中序线索树<br>C 后序线索树<br>D 所有线索树 </p>\n</li>\n<li><p>综合【2014】二叉树的带权路径长度(WPL)是二叉树中所有叶结点的带权路径长度之和。给定一棵二叉树T，采用二叉链表存储，结点结构为</p>\n<table>\n<thead>\n<tr>\n<th>left</th>\n<th>weight</th>\n<th>right</th>\n</tr>\n</thead>\n</table>\n<p>其中叶节点的weight域保存该结点的非负权值。设root为指向T的根节点的指针，设计求T的WPL的算法。要求：</p>\n<p>（1）给出算法的基本设计思想；</p>\n<p>（2）使用C或C++语言，给出二叉树结点的数据类型定义；</p>\n<p>（3）根据设计思想，采用C或C++语言描述算法，关键之处给出注释。</p>\n<blockquote>\n<p>(1)算法的基本设计思想： </p>\n<p>① 基于先序递归遍历的算法思想是用一个static变量记录wpl，把每个结点的深度作为递归函数的一个参数传递，算法步骤如下： </p>\n<p>若该结点是叶子结点，那么变量wpl加上该结点的深度与权值之积； </p>\n<p>若该结点非叶子结点，那么若左子树不为空，对左子树调用递归算法，若右子树不为空，对右子树调用递归算法，深度参数均为本结点的深度参数加1；</p>\n<p>最后返回计算出的wpl即可。 </p>\n<p>② 基于层次遍历的算法思想是使用队列进行层次遍历，并记录当前的层数， </p>\n<p>当遍历到叶子结点时，累计wpl； </p>\n<p>当遍历到非叶子结点时对该结点的把该结点的子树加入队列； </p>\n<p>当某结点为该层的最后一个结点时，层数自增1； </p>\n<p>队列空时遍历结束，返回wpl。</p>\n<p>(2)算法中使用的二叉树结点的数据类型定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span>&#123;</span></span><br><span class=\"line\"><span class=\"type\">int</span> weight;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span> *<span class=\"title\">lchild</span>,*<span class=\"title\">rchild</span>;</span></span><br><span class=\"line\">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>\n\n<p>(3)代码实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">WPL</span><span class=\"params\">(BitNode root)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> wplPreOrder(root,<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">wplPreOrder</span><span class=\"params\">(BitNode root,<span class=\"type\">int</span> deep)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> wpl=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(root-&gt;left= =<span class=\"literal\">NULL</span> &amp;&amp; root-&gt;right= =<span class=\"literal\">NULL</span>)<span class=\"comment\">//若为叶结点，则累积WPL</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  wpl+=deep*root-&gt;weight;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(root-&gt;left! =<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  wplPreOrder(root-&gt;left,deep+<span class=\"number\">1</span>);<span class=\"comment\">//如果左子树不为空，则对左子树进行递归遍历</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(root-&gt;right! =<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  wplPreOrder(root-&gt;right,deep+<span class=\"number\">1</span>);<span class=\"comment\">//如果右子树不为空，则对右子树进行递归遍历</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> wpl;<span class=\"comment\">//返回WPL值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n","categories":["408数据结构"],"tags":["408数据结构"]}]