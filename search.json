[{"title":"第八章 排序(四)","url":"/p/44803/","content":"\n## 8.7 外部排序\n\n### 外部排序\n\n#### 外存、内存之间的数据交换\n\n此处的外存特指“磁盘”。而磁盘是以所谓的“磁盘块”为单位的。\n\n操作系统也是以这些“磁盘块”，对磁盘的存储空间进行管理。\n\n每个磁盘块的大小，比如1KB，比如4KB。此处以1KB为例。\n\n数据信息可以存放在各个磁盘块上。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-183.png\" style=\"zoom: 67%;\" />\n\n现在，比如磁盘块4、磁盘块11，里面存放了一些数据。\n\n问题：如果要修改磁盘里面存储的数据，应该怎么办？\n\n我们要修改磁盘里的数据，需要做的事，就是把对应磁盘块里的数据，读到内存里。\n\n比如说，我们要在内存里申请开辟一块1KB的缓冲区。这样一个缓冲区的大小，是可以和一个磁盘块的大小保持一致的。\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-184.png\" style=\"zoom: 67%;\" />\n\n接下来，我们就可以把磁盘块4当中的数据，读到内存当中。\n\n磁盘的读/写，都是以”块“为单位进行的。也就是说每次都读一块、写一块。\n\n数据已经读入内存了，接下来我们就可以用程序代码，对内存里的数据进行修改。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-185.png\" style=\"zoom: 67%;\" />\n\n现在，我们只是把内存里面的数据修改了，如果要更改磁盘块的数据，那么还需要把这些数据写回磁盘。同样地，还是以“块”为单位，进行“写”操作的。\n\n所以我们可以把这1KB内存缓冲区中的内容，写回磁盘块4。当然，也可以把它写到其他的磁盘块，比如同时也写到磁盘块11中。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-186.png\" style=\"zoom: 67%;\" />\n\n这就是外存和内存之间数据交换的原理。每次是以“块”为单位进行读写的。\n\n#### 外部排序原理\n\n外部排序是指，我们的这些数据元素是存放在外存，即存放在磁盘的。\n\n由于磁盘的容量很大，而内存的容量很小。\n\n所以很多时候我们没有办法，把磁盘当中的所有数据元素都给读入内存，内存存不下这么多。\n\n所以我们要对存在外存中的这些数据进行排序，这就是所谓的外部排序。\n\n接下来看如何实现外部排序。\n\n外部排序实现的思想，其实还是来源于之前的“归并排序”。采用这种方式，我们最少只需要在内存中分配3块大小的缓冲区，就可以完成对任意大小的文件进行排序。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-187.png\" style=\"zoom: 67%;\" />\n\n> 其中，这几个缓冲区的大小，是和磁盘块的大小保持一致的。\n>\n> 此处，我们为了演示方便，磁盘中这个文件大小总共包括了16块数据块，而每个数据块中包括了3个记录。\n\n现在，我们要对整个文件中的所有记录中的关键字，用归并排序的方式，把它变成一个递增的序列。\n\n回顾一下归并排序，在进行每一趟归并时，需要把两个已经有序的子序列，合并成一个更长的子序列。\n\n所以在归并排序开始之前，我们需要构造一些已经有序的子序列。\n\n##### 构造初始\"归并段\"\n\n可以这么做：\n\n由于我们内存当中已经有两块输入缓冲区。我们可以把文件中的第1、2块数据，分别读入内存。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-188.png\" style=\"zoom: 67%;\" />\n\n那么，这些数据一旦被我们读入内存之后，想怎么处理它，都可以。所以我们对于读入内存中的这些数据，进行一个内部排序。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-189.png\" style=\"zoom: 80%;\" />\n\n就将这两块的内容各自都变成了一个递增的状态。\n\n接下来，先把输入缓冲区1的内容，先放到输出缓冲区当中。\n\n通过输出缓冲区，再把这些数据写回磁盘。由于缓冲区的大小和磁盘块的大小是一致的，所以可以写回。\n\n我们把`8 9 26`写回第一个磁盘块。\n\n接下来，再把输入缓冲区2的内容，放到输出缓冲区，写到第二个磁盘块当中。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-190.png\" style=\"zoom: 33%;\" />\n\n那么现在，第一个磁盘块和第二个磁盘块里面的这些记录，就变成了一个递增的有序状态。\n\n之后我们就可以将这两块的整体内容，作为一个有序的子序列，进行归并排序。这就叫一个有序的“归并段”。\n\n之后同样地，我们再把磁盘块3、磁盘块4中的内容，读入内存。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-191.png\" style=\"zoom:67%;\" />\n\n在内存里，对它们进行一个内部排序。然后再将它们写回磁盘。\n\n于是我们就得到了第二个归并段。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-192.png\" style=\"zoom: 50%;\" />\n\n之后同理，过程略。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-193.png\" style=\"zoom: 67%;\" />\n\n最终，我们将16个磁盘块，构造成了8个初始归并段。\n\n其中，经过了16次“读”和16次“写”。\n\n##### 第一趟归并\n\n> 接下来，我们可以用刚刚构造的初始归并段，进行接下来的排序。\n>\n> 把8个有序子序列（归并段）两两归并。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-194.png\" style=\"zoom:67%;\" />\n\n接下来，我们会对每两个归并段，进行2路归并。\n\n我们先把归并段1、归并段2中更小的那两块，分别读入内存，放到输入缓冲区1、缓冲区2。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-195.png\" style=\"zoom:67%;\" />\n\n接下来，对这两个缓冲区中的数据进行归并。即利用三个指针i、j、k，将更小的元素依次放入输出缓冲区。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-196.png\" style=\"zoom:67%;\" />\n\n不要忘了，我们的输出缓冲区和磁盘块的大小是相等的，都是1KB，并且每次读和写都只能读写1KB。\n\n那当我们在输出缓冲区当中凑足1KB之后，就可以写回外存了。\n\n所以现在我们可以把这一块的内容，给写回外存。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-197.png\" style=\"zoom:67%;\" />\n\n此时输出缓冲区已经清空了，我们对剩下的元素同样进行归并排序。\n\n注意，当缓冲区1空了的时候，就要立即用归并段1的后一块内容补上。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-198.png\" style=\"zoom:67%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-199.png\" style=\"zoom: 67%;\" />\n\n这么做可以保证，我们的输入缓冲区1当中，永远是包含着归并段1里面，此时暂时还没有被归并，但是是数值最小的一个记录。\n\n下面继续让两个缓冲区进行归并。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-200.png\" style=\"zoom:33%;\" />\n\n现在，输出缓冲区又满了，于是又可以写回外存。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-201.png\" style=\"zoom: 33%;\" />\n\n同时，现在输入缓冲区2里面已经空了，我们需要立即用归并段2里面的下一块内容补上。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-202.png\" style=\"zoom:67%;\" />\n\n之后，经过归并。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-203.png\" style=\"zoom: 80%;\" />\n\n再写回外存。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-204.png\" style=\"zoom:67%;\" />\n\n到此为止，我们的两个归并段，就归并成为了一个更长、更大的段。\n\n为了美观一些，我们把其中的数据，在图上放回原来的位置，进行展示。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-205.png\" style=\"zoom:67%;\" />\n\n之后，我们会把后续的每两个初始归并段，均归并为一个更长的有序序列。方法是一样的。不再赘述。\n\n最终结果如下：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-206.png\" style=\"zoom: 33%;\" />\n\n经过第一趟归并之后，我们把8个初始归并段，归并成了4个。\n\n接下来我们可以进行第二趟的归并。\n\n##### 第二趟归并\n\n> 把4个有序子序列（归并段）两两归并。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-207.png\" style=\"zoom:67%;\" />\n\n先来归并前两个归并段。归并之后，我们会把它写到外存的另外一片空间当中。\n\n归并的方法和之前是一样的。\n\n我们先把归并段1、归并段2当中更小的两个块，读入内存。分别放入缓冲区1、缓冲区2中。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-208.png\" style=\"zoom: 67%;\" />\n\n接下来用归并排序的方法，挑选出三个最小的元素。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-209.png\" style=\"zoom:67%;\" />\n\n这样，凑足一整块之后，把它写回外存。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-210.png\" style=\"zoom:67%;\" />\n\n接下来继续归并。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-211.png\" style=\"zoom:67%;\" />\n\n此时，输入缓冲区已经空了。那么，我们需要把归并段1当中的下一块内容，读入输入缓冲区1当中。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-212.png\" style=\"zoom:67%;\" />\n\n> 有人会比较疑惑：\n>\n> 你把归并段1中的下一块内容读入缓冲区1之后，下一步进行归并操作，不也是读入缓冲区2当中的`12`吗？\n>\n> 那你先把`13`放进去，然后两块缓冲区都空了，一起再读入，是不是也可以呢？\n>\n> 这种想法是不对的。\n>\n> 刚才我们读入的三个元素是`25 26 27`，都比缓冲区2的`13`要大，所以可能会有这种错觉。\n>\n> 但是如果我们读入的元素是`10 26 27`呢？\n>\n> 所以，如果没有在缓冲区1变空之后，立马将下一个磁盘块记录读入内存，而是先归并的话，就会出错！！\n\n**所以再次强调，每当一个输入缓冲区空了的时候，我们都需要立即把与之对应的那个归并段的下一个磁盘块中的内容读入内存，然后才可以接着往下归并。**\n\n那么接下来，将`13`放入输入缓冲区。那么此时，缓冲区2空了，同样地，我们也要立即把缓冲区2当中的下一块内容读入内存。\n\n再继续进行归并，写入外存……\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-213.png\" style=\"zoom:67%;\" />\n\n到此为止，我们把两个归并段，归并成了一个更长更长的归并段。\n\n同样地，为了美观，我们把这部分的图像，挪到下面。\n\n不过，需要知道的是，**我们归并之后得到的这个更长的子序列，其实是放在磁盘的另一片空间当中的，以前的那些空间我们会归还给系统**。\n\n图像上为了美观，我们把它挪下来，导致看上去像是同一片空间，但是实际的逻辑上并不是同一片空间。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-214.png\" style=\"zoom:67%;\" />\n\n现在，我们需要把归并段3、归并段4进行归并。用同样的方法。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-215.png\" style=\"zoom:67%;\" />\n\n此时，第二趟归并完成。\n\n第二趟归并完成之后，我们得到了两个更长的有序的归并段。\n\n##### 第三趟归并\n\n> 把2个有序子序列（归并段）归并。\n\n归并的过程和之前的，是一模一样的。只不过是这里的归并段的长度变长了而已。\n\n此处不再赘述。\n\n总之，经过这一趟归并之后，整个文件，就变成了一个整体有序的序列了。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-216.png\" style=\"zoom:67%;\" />\n\n#### 时间开销分析\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-217.png\" style=\"zoom: 67%;\" />\n\n回顾一下刚才那个例子。\n\n在最开始的时候，我们需要把一个磁盘块均完全乱序的文件，两两归并，生成初始归并段。\n\n进行了读、写操作各16次，而且在数据读入内存之后，还要进行内部排序。\n\n经过这样的处理之后，我们才得到了8个初始归并段，每个段占两块磁盘块。\n\n> 这是因为，在我们这个例子当中，只使用了两块的输入缓冲区（输入缓冲区1、输入缓冲区2），所以我们每次只能读入两块的内容，对它们进行内部排序。\n>\n> 如果分配的内存缓冲区更大，那我们得到的这个初始归并段的长度，相应的也会变得更长。\n>\n> 但总之，在我们的例子当中，我们会生成8个初始的归并段，每段占两块。\n\n接下来，我们会进行三趟的归并，把有序的归并段归并成一个更长的整体。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-218.png\" style=\"zoom: 67%;\" />\n\n每一趟归并，会基于上一趟归并的结果，再次把两个有序的归并段合并成更长的一个归并段。\n\n这样经过三趟归并之后，就可以得到一个整体有序的文件。\n\n通过刚才我们对归并过程的演示，不难发现，我们每一趟归并，其实都需要把16个磁盘块的数据，都需要读入内存，并写回外存。所以每一趟归并，读、写磁盘块的次数，都是16次。当然了，在每一趟读入内存之后，还需要在内存处进行内部的归并排序。\n\n所以我们外部排序的时间开销如下：\n\n外部排序时间开销 = 读写外存的时间 + 内部排序所需时间 + 内部归并所需时间\n\n其实读写外存的时间，基本上和读写磁盘的次数，是成正比的。\n\n刚才的例子中，我们需要读写磁盘的次数共有`32*4 = 128`次。\n\n那么，如果每次读或写磁盘都需要10ms的时间的话，整体来看，读写磁盘的时间就需要1280ms，也就是1.28s。\n\n对于计算机来说，内部排序、内部归并，由于是在内存里面进行的，这个速度是很快的，肯定达不到“秒”这样的级别。\n\n![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-219.png)\n\n然，文件的总块数是多少，我们没法改变。但是，归并的趟数，其实我们可以想办法，让它缩小。\n\n只要归并的趟数缩小了，那么我们读写磁盘的次数就会减少，相应的，外部排序的时间开销就会下降。\n\n所以，这是我们接下来进行优化的一个思路：怎么减少归并的趟数。\n\n#### 优化:多路归并\n\n> 刚才我们说了，如果能够减少归并的趟数，相应的就会减少读写磁盘的次数。\n\n那么怎么做呢？\n\n我们可以用多路归并。之前我们是用了2路归并。现在我们来看一下，如果采用4路归并。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-220.png\" style=\"zoom:67%;\" />\n\n相应的，如果要进行4路归并，我们就需要在内存中分配四个输入缓冲区。\n\n然后把4个归并段中的内容，分别读入这四个缓冲区当中。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-221.png\" style=\"zoom:67%;\" />\n\n接下来归并的原理，其实和刚才是一样的。\n\n每一次从这4个缓冲区当中挑选一个最小的元素，把它放到输出缓冲区。\n\n凑足一整块之后，把它写回外存。\n\n同样需要注意的是，每当一个缓冲区空了的时候，我们就需要把这个缓冲区所对应的归并段的下一块的内容，立即读入内存。\n\n总之，我们进行4路归并之后，可以把这4个归并段，归并为一个更长的有序序列。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-222.png\" style=\"zoom:67%;\" />\n\n下面那4个归并段也是一样的。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-223.png\" style=\"zoom:67%;\" />\n\n所以，在第一趟归并之后，我们整个文件就只剩下两个归并段了。\n\n那么，接下来我们再对这两个归并段进行一个2路归并，就可以得到一个整体的有序文件了。\n\n所以，如果我们采用4路归并的话，整体归并的趟数就只有两趟。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-224.png\" style=\"zoom: 50%;\" />\n\n采用4路归并，只需进行两趟归并即可。\n\n读、写磁盘的次数 = `32 + 32*2 = 96`次。\n\n**重要结论**：采用**多路归并**可以**减少归并趟数**，从而**减少磁盘I/O（读写）次数**。\n$$\n对r个初始归并段，做k路归并，则归并树可用k叉树表示。\\\\若树高为h,则归并趟数=h-1=\\lceil log_kr \\rceil\n$$\n\n> 推导过程:\n> $$\n> k叉树第h层最多有k^{h-1}结点\\\\则r<=k^{h-1},(h-1)_{最小}=\\lceil log_kr \\rceil\n> $$\n\n从这个式子，很明显的可以看到，k越大，r越小，则归并趟数越少，读写磁盘次数越少。\n\n所以我们的优化策略就是，令归并的路数变多一些（k变大），或者令初试归并段的数量少一些（r变小）。\n\n但是值得一提的是，归并路数并不是越多越好，因为归并路数变多，也会带来一些负面影响：\n\n①k路归并时，需要开辟k个输入缓冲区，内存开销增加。\n\n②每挑选一个关键字需要对比关键字(k-1)次，内部归并所需时间增加。\n\n> 当然，这个问题，我们接下来要讲的败者树，可以解决在k路归并的时候，每挑选一次关键字都需要对比关键字k-1次的问题。\n\n接下来我们看怎么减少r，也就是怎么减少初始归并段的数量。\n\n<font color='cornflowerblue'>刚才我们进行4路归并的时候，不是开辟了4个输入缓冲区吗？</font>\n\n那既然我们有4个输入缓冲区，那么对于最开始的一个无序的文件，我们完全可以读入4块的内容，然后把这些内容在内存里面进行一个内部排序。再分别写回外存。这样的话，我们得到的初始归并段就包含了4块的内容。用这种方式构造初始归并段，就只会有4个（对上面的例子来讲）。\n\n> 所以，生成初始归并段的“内存工作区”（也就是输入缓冲区）越大，初始归并段越长。也就意味着r越小。\n\n**结论**：若能增加初始归并段的长度，则可减少初始归并段数量r。\n\n#### 总结\n\n**外部排序**\n\n- 若要进行k路归并排序，则需要在内存中分配k个输入缓冲区和1个输出缓冲区\n- 步骤\n  - ①生成r个初始归并段（对L个记录进行内部排序，组成一个有序的初始归并段）\n  - ②进行S趟k路归并，`S = ⌈logk(r)⌉`\n- 如何进行k路归并\n  - 把k个归并段的块读入k个输入缓冲区\n  - 用“归并排序”的方法从k个归并段中选出几个最小记录暂存到输出缓冲区中\n  - 当输出缓冲区满时，写出外存\n- 外部排序时间开销：读写外存的时间 + 内部排序所需时间 + 内部归并所需时间\n- 优化\n  - 增加归并路数k，进行多路平衡归并\n    - 代价1：需要增加相应的输入缓冲区\n    - 代价2：每次从k个归并段中选一个最小元素需要（k-1）次关键字对比\n  - 减少初始归并段数量r\n\n> 对于“代价2”，在下一小节中，我们将介绍“败者树”，来减少关键字对比次数。\n\n<font color='red'>注</font>：按照本节介绍的方法生成的初始归并段，若共N个记录，内存工作区可容纳L个记录，则初始归并段数量 `r = ⌈ N/L ⌉`。\n\n> 对于此处，我们在之后的小节当中，会介绍一种“置换—选择排序”的方法，进一步减少初始归并段数量。\n\n> 那么此处提到的“败者树”，和“归并—选择排序”，就是我们接下来要学习的内容。\n\n#### 纠正:多路平衡归并是什么\n\n课本上写的是：对r个初始归并段，做k路平衡归并，归并树可用严格k叉树（即只有度为k与度为0的结点的k叉树）来表示。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-225.png\" style=\"zoom:50%;\" />\n\n<font color='red'>上面这种说法是有疏漏的</font>（但是图确实是一个4路平衡归并）。因为，这是4路归并，但是对于根结点来说，根结点是2叉的，并不是4叉的，与它的文字描述相矛盾。\n\n<font color='orange'>我们把这种说法纠正一下，如下</font>：\n\n**k路平衡归并**：\n\n①最多只能有k个段归并为一个；\n\n②每一趟归并中，若有m个归并段参与归并，则经过这一趟处理得到`⌈ m/k ⌉`个新的归并段。\n\n如果不满足这两个条件，就不能称之为“k路**平衡**归并”。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-226.png\" style=\"zoom:50%;\" />\n\n因此，对于上图：\n\n这个例子是不是4路归并排序？——是。\n\n这个例子是不是4路平衡归并排序？——不是。\n\n> 因为，最初有8个归并段`R1~R8`，对于第一趟归并，其将8个归并段归并为了3个新的归并段，`R1' R2' R3'`。\n>\n> 对于4路归并来说，如果当前这一趟有8个归并段参与归并的话，最后应当得到`⌈ 8/4 ⌉ = 2 `个新的归并段，而不是3个。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-225.png\" style=\"zoom:50%;\" />\n\n再来看书上的这个图。\n\n第一趟归并，把8个归并段归并成了2个新的归并段，OK。\n\n第二趟归并，把2个归并段归并成了`⌈ 2/4 ⌉ = 1`个新的归并段，也没问题。\n\n所以这个图，的确是一个4路平衡归并的排序过程。\n\n### 败者树\n\n> 上面外部排序中，我们说过，对于外部排序，若使得归并路数k增加，则归并趟数会减小，从而读写磁盘总次数减少。\n>\n> 但是问题是，归并路数k如果过大，由于k路归并的过程需要对比关键字k-1次才能选出一个最小元素，从而导致内部归并所需时间增加。\n>\n> 这样一来，多路归并虽然减少了读写磁盘次数，但是又会使得内部归并所需时间增加。\n\n> 对于这个，增加归并路数所带来的负面影响，可以用败者树来进行优化。\n>\n> 可以让我们从k个归并段中选出最小元素，需要对比关键字的次数更少。\n\n#### 什么是败者树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-227.png\" style=\"zoom:67%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-228.png\" style=\"zoom:67%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-229.png\" style=\"zoom:67%;\" />\n\n可以看到，若有8位参赛者，则构造败者树需要7次比拼。\n\n这就是败者树，所有选手进行一回合一回合的晋级，最终选出获胜者。\n\n我们把它简化一下，如下，就成为了一棵二叉树。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-230.png\" style=\"zoom:67%;\" />\n\n**败者树**——可视为一棵完全二叉树（多了一个头）。k个叶结点分别是当前参加比较的元素，非叶子结点用来记忆左右子树中的“失败者”，而让胜者往上继续进行比较，一直到根结点为止。\n\n> 上图，最下面一层8个叶子结点就是参加比较的元素，上面的若干非叶子结点用来记忆中间的失败者。\n\n那么，最终“天津饭”就是冠军。\n\n但是，此时，如果“天津饭”退出比赛，并且由“派大星”顶替。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-231.png\" style=\"zoom:67%;\" />\n\n> 现在冠军走了，那么是不是意味着，我们需要重新进行7个回合的比赛？\n\n其实是不需要这样的。\n\n我们完全可以基于之前构造好的这棵败者树，来对比赛的流程进行优化，可以进行更少的比赛就可以找出谁最强。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-232.png\" style=\"zoom:50%;\" />\n\n此时，若要让这8个人重新选出一个冠军。其实右半边的那几场比赛完全没有必要再进行一次（上图圈住的部分）。因为那几个人，谁更厉害，在之前就已经得知了。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-233.png\" style=\"zoom:67%;\" />\n\n此时，我们可以让“派大星”和“阿乐”打一场。因为阿乐只是输给了之前的那个人，但是不能确定阿乐和派大星谁更厉害。所以必须让派大星和阿乐打一场。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-234.png\" style=\"zoom:67%;\" />\n\n此时，如果派大星赢了，那么接下来再让派大星和程龙打一场。\n\n如果派大星又打赢了，那么接下来可以让派大星和孙悟空打一场。它们俩对打之后，就得出了冠军是谁。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-235.png\" style=\"zoom: 67%;\" />\n\n此时，原来的冠军走了，派大星加入之后，新的冠军，就求了出来。\n\n可见，对于这个例子，基于已经构建好的败者树，选出新的胜者只需进行3场比赛。（并不需要重新打7场）\n\n> 例子中的“对打”，其实就是我们关键字的对比。\n\n#### 败者树在多路平衡归并中的应用\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-236.png\" style=\"zoom: 67%;\" />\n\n这里有8个归并段，我们要在这8个归并段当中选出一个最小的元素。之前，每选出一个最小的元素，我们都需要进行7次的对比。\n\n但是现在，我们可以这么做。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-237.png\" style=\"zoom:67%;\" />\n\n先来构造一棵败者树。败者树中的每一个叶子结点，会对应我们的每一个归并段。\n\n接下来我们会继续构建这棵败者树，从中找出最小的一个元素。\n\n> 对于败者树来说，在中间的分支节点上（记录失败者信息），我们本应该记录的是失败者的元素。但是在此处，我们对于每个分支节点，要记录失败者是来自哪一个归并段。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-238.png\" style=\"zoom:67%;\" />\n\n对于失败者结点，我们只需要记录其来自于归并段的编号，并不需要把其数据元素值记录其中。\n\n现在我们构建好了一棵败者树，其中，根结点（最顶上的那个结点）记录了冠军，即最小的元素是来自于哪一个归并段当中。\n\n这里记录的是3，所以，最小的元素是来自于归并段3当中。\n\n所以，第一轮，我们经过了7次关键字对比，找到了最小的元素。\n\n> 对于k路归并，第一次构造败者树需要对比关键字k-1次。\n\n接下来，按照归并排序的规则，我们还需要再从这8个归并段中，再选出一个最小的元素。\n\n因此，我们需要将归并段3中的下一个元素，替代1这个元素原有的位置。（因为1是冠军，已经走了）\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-239.png\" style=\"zoom:67%;\" />\n\n接下来，我们只需要用这个新来的元素，和第4个归并段中此时最小的元素进行对比（因为它的父节点是4，表示来自于归并段4的那个失败者，也就是刚刚由归并段4进入败者树的结点，也就是归并段4的第一个结点，而由于归并段是有序的，也就是归并段4的最小的元素）。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-240.png\" style=\"zoom: 33%;\" />\n\n这个元素6是更小的，那么它胜出。\n\n然后就可以进行下一轮的对比，即与归并段2中的最小元素进行对比。对比之后，同样是来自归并段3的胜出。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-241.png\" style=\"zoom:33%;\" />\n\n因此，来自归并段3的元素又可以进入下一轮的对比。接下来这一轮，是要和归并段5的最小元素进行对比。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-242.png\" style=\"zoom:33%;\" />\n\n归并段5的最小元素是2，显然比6更小，因此5号选手胜出。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-243.png\" style=\"zoom: 50%;\" />\n\n那么最终，我们选出了一个新的冠军，即8个归并段中的下一个最小的元素。\n\n目前来看，最小的元素是来自于5号段中的最小元素，也就是数据元素2。\n\n所以在这个例子当中，我们可以看到。\n\n只要我们构建好了败者树，接下来每一次要选出一个最小的元素，只需要进行3次的关键字对比（即灰色结点的层数）。\n\n**结论**：\n\n- 对于k路归并，第一次构造败者树需要对比关键字`k-1`次\n- 有了败者树，选出最小元素，只需对比关键字`⌈ log₂k ⌉`次。\n\n> 此时，如果要进行1024路归并。\n>\n> 在以前，我们每次要选出最小的关键字，都需要进行1023次对比。\n>\n> 但如果我们有了败者树，我们每次选出最小关键字就只需要10次对比。\n\n#### 败者树的实现思路\n\n> 在考研当中，对败者树的考察一般是手算。\n>\n> 此处讲一下代码的实现思路，作为了解。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-244.png\" style=\"zoom: 50%;\" />\n\n如果我们要进行8路归并。\n\n我们要定义一个长度为8的int型数组，用这个数组就可以存储8路归并的败者树。\n\n其中，数组下标为1的，就可以表示传统意义上的树的根结点，数组下标为0的，就是败者树中新增加的那个头。其他的位置结点，以及一些性质，和一棵完全二叉树是对应的。\n\n此处会发现，我们最底层的叶子结点，在存储败者树的数组当中是不对应任何数据的。\n\n也就是说叶子结点是虚拟的。但是从逻辑上看，这些叶子结点是“存在的”，每个叶子结点会对应一个归并段，但实际上，这些叶子结点只是我们脑补上去的。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-245.png\" style=\"zoom: 33%;\" />\n\n到此，我们应该就能看懂，课本中给的这个图示是什么意思。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-246.png\" style=\"zoom: 50%;\" />\n\n5路归并的败者树，其背后实际上对应的是一个长度为5的int型数组。\n\n数组中，下标为1到4的这几个结点，其实对应的就是失败者的结点，而0号结点就是冠军结点。\n\n> 并且，对于这个5路归并，根据⌈log₂5⌉ = 3，可知其失败结点总共有三层。因此每次只需3次对比。\n>\n> 当然，也有可能只需要2次对比。因为，如果我们填补的新元素，在它上方只有2层失败结点，那么就只需两次对比了。（如上图的b0、b1、b2处）\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-247.png\" style=\"zoom: 33%;\" />\n\n#### 总结\n\n- 败者树解决的问题：使用多路平衡归并可减少归并趟数，但是用传统方法，从k个归并段中选出一个最小/最大元素需要对比关键字k-1次，构造败者树可以使关键字对比次数减少到⌈log₂k⌉。\n- 败者树可视为一棵完全二叉树（多了一个头）。k个叶结点分别对应k个归并段中当前参加比较的元素，非叶子结点用来记忆左右子树的“失败者”，而让胜者往上继续进行比较，一直到根结点。\n- 如何构造和使用败者树？结合图示进行理解。\n\n### 置换-选择排序\n\n> 在外部排序的时候，生成r个初始归并段，进行S趟k路归并。\n> $$\n> S=\\lceil log_kr \\rceil\n> $$\n> 我们说了，如果让初始归并段r减少，则可以使外部排序的效率提升。\n\n置换-选择排序，就能够用于制造更长的归并段，也就是让初始归并段的数量尽可能的少。\n\n#### 传统方法制造初始归并段\n\n> 我们用传统方法制造的初始归并段，就是在内存中开辟两块输入缓冲区与一块输出缓冲区，然后将文件中的2个磁盘块中的乱序内容读入内存中，进行内部排序，再将排好序的两块写回磁盘。\n>\n> 而由于我们的内存只开辟了两块缓冲区，因此只能对这两块的内容进行内部排序，得到两块整体有序的序列。\n\n如何让这个序列更长呢？\n\n不难想到，我们可以用一片更大的内存区域来进行内部排序。\n\n比如我们有六块缓冲区，那么一次可以将6个磁盘块中的数据读入，并且对它们进行内部排序并写回磁盘，最终得到一个长度为六块的有序序列，即长度是6块的初始归并段。\n\n这样一来，就使得初始归并段的个数降低了。\n\n> 用于内部排序的内存工作区WA可容纳`l`个记录，则每个初始归并段也只能包含`l`个记录。（这个`l`，就是我上面说的块数乘每块中的记录数）\n\n若文件共有n个记录，则初始归并段的数量`r = n / l`。\n\n#### 置换-选择排序\n\n> 上面的扩大初始归并段长度的方法，仍然是一种传统思想。其初始归并段的长度，是和内存工作区的大小相等的。\n\n怎样能制造一个比内存工作区更大的初始归并段呢？可以用置换-选择排序来解决。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-248.png\" style=\"zoom: 67%;\" />\n\n假设用于内部排序的这个内存工作区，只能容纳3个记录（即，对于传统思路来讲，当存入3个数据元素时，就够一块了，就要写回，并组成一个初始归并段了，因此初始归并段每段的记录也为3，由于总共有24个记录，所以传统方法只能生成8个初始归并段）。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-249.png\" style=\"zoom: 67%;\" />\n\n> 我们最终要实现递增的序列。\n\n我们先把文件中的前三个记录读入进来。此时，内存工作区已经填满，我们要把最小的元素置换出去。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-250.png\" style=\"zoom:67%;\" />\n\n置换出去，放到归并段1当中。并且，同时，用MINIMAX，把刚才这个变量的值`4`给记下来。\n\n接下来，我们会从待排序文件当中读入下一个记录。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-251.png\" style=\"zoom:67%;\" />\n\n经过对比发现，此时最小的一个元素是`6`，并且它的值要比刚才输出的值`4`更大（即比MINIMAX=4更大）。所以我们要把`6`放到归并段1的后面，并且令MINIMAX为6。\n\n此时，6拿出去了，就空出了一个位置。此时，我们要把下一个记录读入进来。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-252.png\" style=\"zoom:67%;\" />\n\n在这几个记录当中，最小的是`7`，同时，`7`要比刚刚输出的值`6`更大（即比MINIMAX=6更大）。所以我们要把`7`这个记录，放到`6`的后面。同时令MINIMAX为7。\n\n接下来读入下一个记录。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-253.png\" style=\"zoom: 67%;\" />\n\n此时最小的是9，把9放在刚才的7的后面。读入下一个记录。\n\n…………中间略去若干步骤。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-254.png\" style=\"zoom:67%;\" />\n\n此时，最小的记录是`10`，但是，通过MINIMAX这个变量我们知道，上一个输出到归并段1当中的记录应该是`13`，所以现在`10`这个记录，我们不可能把它放到归并段1的末尾。（因为我们的归并段1肯定是要内部递增的）\n\n因此，虽然10这个记录是最小的，但是我们不能把它置换出去。\n\n而，除了10之外，最小的是`14`，而且14要比刚才输出的13更大。所以，我们可以把14放到归并段1的末尾，并令MINIMAX=14。\n\n…………中间略去若干步骤。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-255.png\" style=\"zoom:67%;\" />\n\n此时，最小的是`2`，并且由于刚才输出的记录是`22`，因此我们不可能把2放到归并段1的末尾。\n\n此时，其他的关键字中最小的为`30`。（10已经不被考虑了）`30`比22更大，所以将其放到归并段1的末尾，并令MINIMAX=30。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-256.png\" style=\"zoom:67%;\" />\n\n接下来，读入记录`3`。\n\n现在，`3`这个元素，要比MINIMAX=30更小，因此不可能把它放到归并段1的末尾。\n\n而此时，内存工作区内的三个关键字都比MINIMAX更小，则次归并段在此截止。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-257.png\" style=\"zoom:67%;\" />\n\n第一个归并段就到此为止，构造完成。\n\n接下来我们构造第二个归并段，归并段2。\n\n我们先将刚刚“标红”的三个关键字给解除一下，重新纳入考虑。\n\n则，首先输出`2`，并将MINIMAX设为2。\n\n…………之后步骤和上面同理，略。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-258.png\" style=\"zoom:67%;\" />\n\n至此，当前工作区中的关键字都比MINIMAX更小，则归并段2生成完毕。\n\n接下来构造归并段3的方法是一样的，略。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-259.png\" style=\"zoom:67%;\" />\n\n到这一步时，初始的待排序文件已经全部读入完毕了。那么接下来把工作区中的三个记录依次有序输出即可。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-260.png\" style=\"zoom:67%;\" />\n\n这样一来，我们就得到了三个初始归并段。\n\n这些初始归并段的长度，可以超过内存工作区的限制。\n\n原本内存工作区只能容纳3个记录，而我们生成的归并段中的记录都能够大于3。由于归并段中记录数越多，则归并段个数越少，即r越小，即读写磁盘的次数越少。\n\n> **注**：\n>\n> 其实输出文件FO，是在磁盘当中的。\n>\n> 在刚刚我们演示的例子过程当中，是每次从内存工作区中直接找到最小元素，输出到FO中。\n>\n> 但是实际上，我们的内存当中是要有一个输出缓冲区的，内存工作区中每次找到的最小元素，要先排列在输出缓冲区当中，当输出缓冲区满了（即达到一个磁盘块的大小了），才一并写入磁盘，存入FO当中。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-261.png\" style=\"zoom:67%;\" />\n>\n> 同样地，在从FI文件读入记录至内存工作区时，也不是一个记录一个记录读入的，而是一次读入一块的内容（输入缓冲区）。只不过每次会把一个记录放进内存工作区WA。\n\n#### 总结\n\n设初始待排文件为FI，初始归并段输出文件为FO，内存工作区为WA，FO和WA的初始状态为空，WA可容纳w个记录。\n\n置换-选择排序算法的步骤如下：\n\n①从FI输入w个记录到工作区WA。\n\n②从WA中选出其中关键字取最小值的记录，记为MINIMAX记录。\n\n③将MINIMAX记录输出到FO中去。\n\n④若FI不空，则从FI输入下一个记录到WA中。\n\n⑤从WA中所有关键字比MINIMAX记录的关键字大的记录中选出最小关键字记录，作为新的MINIMAX记录。\n\n⑥重复③-⑤，直至在WA中选不出新的MINIMAX记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到FO中去。\n\n⑦重复②-⑥，直至WA为空。由此得到全部初始归并段。\n\n### 最佳归并树\n\n> 之前我们学习的归并树，它有一个性质。\n\n#### 归并树的神秘性质\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-262.png\" style=\"zoom: 50%;\" />\n\n通过上一小节的`置换-选择排序`，我们了解到，通过那种方法得到的初始归并段，长度是各不相同的。\n\n我们对于通过置换-选择排序得到的长度不一的初始归并段，对于这些初始归并段，我们来进行二路归并。\n\n> 上图中，每个数字代表该归并段所占磁盘块的块数。\n\n我们对这5个初始归并段，进行二路归并，即两两归并。\n\n那么首先我们可以归并R2、R3两个归并段，得到一个长度为6块的归并段。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-263.png\" style=\"zoom:33%;\" />\n\n我们要把R2、R3这两个，一个长度为5个磁盘块、一个长度为1个磁盘块，的归并段，来读入内存当中去进行二路归并。而由于我们的读写操作，是以磁盘块为单位的。\n\n因此，对于R2、R3的二路归并，我们需要进行`5+1`，即读、写操作各6次。之后，经过我们内存的处理，最终会将R2、R3两个归并段合二为一，得到一个总共占有6个磁盘块的新的归并段。\n\n然后，我们将R4、R5进行二路归并，同理，总共需要进行读、写操作各8次。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-264.png\" style=\"zoom: 50%;\" />\n\n之后，我们再把这个占6块、占8块的两个归并段再次进行归并，得到一个占14块的归并段。并且总共需要进行读、写操作各14次。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-265.png\" style=\"zoom: 33%;\" />\n\n最后，我们再把R1这个归并段，和这个14块的归并段进行归并。并且总共需要进行读、写操作各16次。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-266.png\" style=\"zoom: 33%;\" />\n\n最终将所有初始归并段，归并为了一个整体，归并完毕。\n\n最终，我们可以看到，整个过程进行的读、写操作各为`6+8+14+16`，即44次。\n\n现在我们把上图中的4个绿色结点看作二叉树的5个叶子结点。\n\n现在来计算这棵二叉树（归并树）的带权路径长度，**WPL** = 2×1 + (5+1+6+2)×3 = 44 = 读磁盘的次数 = 写磁盘的次数。即读写磁盘的总共操作次数为88次。\n\n> 如果忘了带权路径长度是什么，可以回去看一下哈夫曼树那一小节。\n\n**重要结论**：归并过程中的**磁盘I/O次数 = 归并树的WPL×2**。\n\n<font color='cornflowerblue'>基于此，我们不难想到，如果我们想让归并的过程中磁盘读写的次数最少，那么只需要使归并树的WPL最小，这不就是哈夫曼树吗？</font>\n\n所以接下来我们会构造一棵哈夫曼树，来优化这个二路归并的策略。\n\n#### 构造2路归并的最佳归并树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-267.png\" style=\"zoom:33%;\" />\n\n就是将初始归并段对应的结点，构造成一棵哈夫曼树。\n\n> 简单描述一下构造哈夫曼树的过程：\n>\n> 先从5个结点中选出两个权值最小的结点1、2，令他们两个构成兄弟，进行归并，产生一个权值为3的结点；\n>\n> 此时所有结点中权值最小的两个结点为3和2，令他们两个构成兄弟，进行归并，产生一个权值为5的结点；\n>\n> 此时所有结点中权值最小的两个结点为5和5，构成兄弟并归并，产生一个10的结点；\n>\n> 此时最小的两个，10和6，构成兄弟，归并，产生最终的一个结点16。\n\n这个哈夫曼树的含义，或者说按照这棵归并树的操作过程，就是。刚开始我们先把1和2两个归并段进行归并，然后再与长度2的归并段归并，再与长度5的归并段归并，再与长度6的归并段归并。\n\n最佳归并树，WPL_min = (1+2)×4 + 2×3 + 5×2 + 6×1 = 34。\n\n也就是用我们这种归并方案，总共需要读、写磁盘各34次，即总的磁盘I/O次数68次。\n\n这就是一棵最佳归并树，我们按照它来进行归并，能够得到最少的磁盘I/O次数。\n\n#### 多路并归的情况\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-268.png\" style=\"zoom: 50%;\" />\n\n有这些初始归并段，同样地，每个小圆圈里面的数字，代表该归并段长度占了多少个磁盘块。\n\n##### 三路归并\n\n现在，我们若要进行**3路归并**。\n\n按照我们之前的传统方法，我们的三路归并应该是如下结果：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-269.png\" style=\"zoom:50%;\" />\n\n那可以计算一下这棵树的带权路径长度，`WPL = (9+30+12+18+3+17+2+6+24)*2 = 242`，即整个归并过程的磁盘I/O总次数为484次。\n\n这是我们之前学习的，三路归并的方法。显然这并不是一棵最佳的归并树。\n\n<font color='cornflowerblue'>那三路归并的最佳归并树应该怎么构造呢？</font>\n\n其实原理和二路归并是非常类似的。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-270.png\" style=\"zoom:33%;\" />\n\n> 和二路归并构造哈夫曼树的操作非常类似，它只不过是每次拿来权值最小的三个结点。\n>\n> 首先拿来所有结点中权值最小的三个结点2、3、6，使他们构成兄弟，进行归并，得到一个11的新的结点；\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-271.png\" style=\"zoom: 33%;\" />\n>\n> 接下来，权值最小的三个结点就是9、12、11，让他们构成兄弟，进行归并，得到一个32的新结点。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-272.png\" style=\"zoom:33%;\" />\n>\n> 此时，权值最小的三个为17、18、24，让他们构成兄弟，进行归并。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-273.png\" style=\"zoom: 33%;\" />\n>\n> 最后，只剩下了三个结点30、32、59，我们再把它们三个进行归并。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-274.png\" style=\"zoom:33%;\" />\n\n用这样的方法得到的一棵三路归并的归并树，它就是一棵最佳归并树。\n\nWPL_min = (2+3+6)×3 + (9+12+17+24+18)×2 + 30×1 = 223\n\n那么按照这种归并过程进行的三路归并，总共需要的磁盘I/O次数为446次。\n\n##### 如果减少一个归并段\n\n接下来，问题来了，如果我们去掉一个归并段。比如把`30`这个归并段给去掉。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-275.png\" style=\"zoom:33%;\" />\n\n也就是说我们总共只有8个归并段，来参与三路归并。\n\n那按照三路归并构造哈夫曼树的规则，过程如下：\n\n> 首先选择最小的三个2、3、6，归并。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-276.png\" style=\"zoom:33%;\" />\n>\n> 此时，最小的三个是9、12、11，归并。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-277.png\" style=\"zoom:33%;\" />\n>\n> 接下来，最小的三个是17、24、18，归并。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-278.png\" style=\"zoom:33%;\" />\n>\n> 现在我们只剩下了这两棵树，而如果我们要把这两棵树进行归并，就只能进行二路归并。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-279.png\" style=\"zoom:33%;\" />\n\n> 这棵树的带权路径长度是：\n>\n> WPL = (2+3+6)×3 + (9+12+17+24+18)×2 = 193。\n>\n> 归并过程中，总共的磁盘I/O次数是386次。\n\n此处，要说的是，上述这中构造最佳归并树的方法是不对的。这个并不是最佳归并树。\n\n最后的一次归并，是进行的二路归并，而不是三路归并。\n\n而，如果初始归并段能够再多一个，就能够保证刚好都是三路归并了。\n\n所以，正确的做法应该是这样的，如下。\n\n##### 正确的做法\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-280.png\" style=\"zoom:33%;\" />\n\n<font color='red'>注意</font>：对于k路归并，若**初始归并段的数量无法构成严格的k叉归并树**，则**需要补充几个长度为0的“虚段”**，再进行k叉哈夫曼树的构造。\n\n那么像刚才那个例子当中，我们需要补充1个虚段。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-281.png\" style=\"zoom:33%;\" />\n\n长度为0的这个结点实际上是不存在的，但是我们把它加上，是为了总共的结点能够刚好凑成k叉归并树。\n\n我们加入了虚段的结点后，就可以构造出正确的三叉归并树，过程省略，结果如下。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-282.png\" style=\"zoom: 33%;\" />\n\nWPL_min = (2+3+0)×3 + (6+9+12+17+18)×2 + 24×1 = 163。\n\n即，归并过程中，总的磁盘I/O次数为326次。\n\n上面这个，就是三路归并的最佳归并树。\n\n> 对于0这个虚段的设置，现实含义为：\n>\n> 我们在进行三路归并的时候，是在内存中开辟了三个缓冲区。当我们对`2 3 0`这三个归并段进行归并的时候，我们把`2`放到缓冲区1当中，把`3`放到缓冲区2，而缓冲区3中什么都不用放。对于`0`这个归并段，在参与归并的时候，只需看作已经被归并完毕了的归并段，不用再进行任何操作，就可以了。\n\n总之，当我们进行k路归并的时候，若k>2，则我们就会遇到，初始归并段的数量无法构成严格的k叉归并树的情况。此时我们就要补充若干个长度为0的虚段，再进行处理。\n\n<font color='cornflowerblue'>那么到底要补充几个呢？</font>\n\n我们现在是要进行k路归并，而k路归并的最佳归并树一定是一棵严格的k叉树，即树中只包含度为k、度为0的结点。\n\n设度为k的结点有`n_k`个，度为0的结点有`n_0`个，归并树总结点数位`n`，则：\n\n对于初始时给的归并段，以及我们补充上去的虚段，它们最终肯定都是叶子结点，即度为0的结点。即，初始归并段数量 + 虚段数量 = n_0。\n\n另外，根据k叉树本身的性质，应该有如下两个等式：\n\n- n = n_0 + n_k\n\n> 这个式子不需要解释。\n\n- k × n_k = n-1\n\n> 对于严格的k叉树，除了根结点外，每个节点头上都会连着一个分叉。\n>\n> 对于k叉树，每个度为k的结点，共发出k×n_k个分叉，也就是说有k×n_k个结点，但由于这样计算是不会将根结点包含在内的，因此其等于n-1。\n\n由上面这两个式子，可以得出：\n\nn_0 = (k-1)×n_k + 1\n\n进而得出：\n$$\nn_k=\\frac{n_0-1}{k-1}\n$$\n由于n_k表示的是，度为k的结点的数量，因此它必须是一个整数。\n\n也就是说，如果是严格k叉树，则上面这个分式，一定得到的是一个整数的结果，或者说一定能除得尽。\n\n又因为`初始归并段数量 + 虚段数量 = n_0`。\n\n因此，用人话来说一遍就是，初始归并段数量，再加上我们补充的虚段数量，再减1，应该是刚好能除尽（k-1）的。\n\n即：\n\n- 若（初始归并段数量 - 1）% (k - 1) = 0，说明刚好可以构成严格k叉树，此时不需要添加虚段。\n- 若（初始归并段数量 - 1）% (k - 1) = u ≠ 0，则需要补充（k - 1）- u个虚段。\n\n> 例子：\n>\n> 假设我们要进行8路归并，初始归并段数量为19。\n>\n> 由(19-1)%(8-1) = 4，因此不能直接构成严格8叉树，需要补充虚段。\n>\n> 再补3个虚段就行了。\n\n#### 总结\n\n**最佳归并树**\n\n- 理论基础\n  - 每个初始归并段对应一个叶子结点，把归并段的块数作为叶子的权值\n  - 归并树的WPL = 树中所有叶子结点的带权路径长度之和\n  - 归并过程中的磁盘I/O次数 = 归并树的WPL × 2\n- 注意：k叉归并的最佳归并树一定是严格k叉树，即树中只有度为k、度为0的结点\n- 如何构造\n  - 补充虚段：（初始归并段数量 - 1）% (k - 1)\n    - 若能除尽，则不用补虚段\n    - 若不能除尽，则补一些虚段让它能除尽\n  - 构造k叉哈夫曼树：每次选择k个根结点权值最小的树合并，并将k个根结点的权值之和作为新的根结点的权值\n\n![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-283.png)\n\n告一段落了~\n\n### 习题\n\n- 【2013】已知三叉树 T 中 6 个叶结点的权分别是`2 3 4 5 6 7` ，T 的带权（外部）路径长度最小是多少-->46\n\n  > m表示节点个数 k表示K叉树 \n  >\n  > 若（m-1）%(k-1) = 0说明不需要虚段，否则需要（K-1）-（m-1）%(k-1)个虚段。 \n  >\n  > 本题m=6,k=3。 则（6-1）%（3-1）=1 \n  >\n  > 需要虚段 2 - 1 = 1添加的虚段可视为0。然后按照优先取最小的三个的原则，构造三叉树。\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-284.png\" style=\"zoom: 67%;\" />\n\n- 【2019】设外存上有 120 个初始归并段，进行 12 路归并时，为实现最佳归并，需要补充的虚段个数是多少-->2\n\n  > 设n0,n12,n补,分别为度为零，十二和要补充的结点，则有： \n  >\n  > n0=120+n补(根据哈夫曼树构成，度为零的结点全是初始提供的结点）； \n  >\n  > n0=12*(n12)-(n12)+1;（根据完全十二叉树构成）； \n  >\n  > 即n12=（119+n补）/11，且n12为整数，则n补最小为2。\n\n  \n","tags":["408数据结构"],"categories":["408数据结构"]},{"title":"第八章 排序(三)","url":"/p/14847/","content":"\n## 8.5 归并排序和基数排序\n\n### 归并排序 Merge Sort\n\n#### 什么是归并/合并\n\n> 归并：把**两个**或**多个**已经有序的序列合并成一个。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-140.png\" style=\"zoom:80%;\" />\n\n现在，左边这个数组和右边这个数组，都是有序的，现在我们要把它合并成一个。\n\n首先我们肯定得定义一个更大的数组，才能把所有的这些元素都存放在一起。\n\n接下来要做的事情是，我们可以设置这样的三个指针。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-141.png\" style=\"zoom:80%;\" />\n\n接下来，我们每一次会**对比 i、j 所指元素，选择一个更小的放入 k 所指位置**。\n\n此时，i、j 所指元素较小的是`7`，于是将j 所指元素7放入 k 所指位置。之后，将j、k向后移动一位。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-142.png\" style=\"zoom:80%;\" />\n\n此时，i、j 所指元素较小的是`10`，所以把10放入，之后将j、k向后移。\n\n之后，12更小，所以将12放入，之后将i、k向后移。\n\n…………\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-143.png\" style=\"zoom:80%;\" />\n\n此时，i、j 所指的元素，都是`24`。\n\n如果是我们自己写代码的话，可以在代码里设计，让 i 所指的元素优先放入，也可以设计让 j 所指的元素优先放入。\n\n这个地方，我们让 i 所指的优先。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-145.png\" style=\"zoom:80%;\" />\n\n所以会把 i 所指的`24`先放进来。\n\n下一步，对比，把 j 所指的24放进来。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-144.png\" style=\"zoom:80%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-146.png\" style=\"zoom: 67%;\" />\n\n到了这一步，j 指针已经超出了它所对应的数组的范围了。也就是说明右边这个数组中所有的元素，我们都已经进行了合并。\n\n那现在，只有左边这个数组，是还没有合并完毕所有元素的。所以接下来我们就不再需要进行关键字的对比，我们可以直接把其中剩余元素全部加入总表。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-147.png\" style=\"zoom:67%;\" />\n\n到此为止，我们就完成了两个有序序列的归并。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-148.png\" style=\"zoom:67%;\" />\n\n#### ”2路“归并\n\n> 什么叫2路归并呢？\n>\n> 就是我们刚刚所做的这个过程。\n>\n> 我们把**两个**有序的序列合二为一，这就是2路归并。\n>\n> “2路” —— 二合一。\n\n“2路”归并 —— 每选出一个小元素需对比关键字1次。\n\n#### “4路”归并\n\n> 既然有2路归并，当然也可以有**多路归并**。\n>\n> 比如说“4路”归并。\n>\n> “4路” —— 四合一。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-149.png\" style=\"zoom:80%;\" />\n\n我们给出了4个有序的数组，我们将它们四合一。\n\n“4路”归并 —— 每选出一个小元素需对比关键字3次。\n\n**结论**：**m路归并，每选出一个元素需要对比关键字m-1次**。\n\n#### 归并排序(手算)\n\n> 在内部排序中，我们对于归并排序算法，一般采用的是2路归并。\n>\n> 每相邻的两两进行归并。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-150.png\" style=\"zoom: 50%;\" />\n\n给定一个初始序列。我们会把它看作一个、一个的，独立的，排好序的部分，每部分含有1个元素。\n\n接下来，我们会对相邻的两个部分进行2路归并。\n\n比如说，0和1两处的元素，进行2路归并。接下来，2和3进行归并；4和5进行归并。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-151.png\" style=\"zoom: 50%;\" />\n\n而6处的这个元素，它是单个的，所以对它的处理相当于什么也没做。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-152.png\" style=\"zoom:50%;\" />\n\n这是**第一趟归并**排序。\n\n之后，第二趟归并排序，会基于第一趟归并的结果，再次地对它们归并。\n\n可见第一部分（0、1）已经有序，第二部分（2、3）也已经有序。把这两个有序的子序列归并成一个。第三、四部分同理。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-153.png\" style=\"zoom:50%;\" />\n\n这是**第二趟归并**排序。\n\n此时，我们得到了2个已经有序的子序列。最后再进行一次归并就可以了，就能得到整体有序的一个序列。\n\n整个过程如下所示。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-154.png\" style=\"zoom: 80%;\" />\n\n> 核心操作：\n>\n> 把数组内的两个有序序列归并成一个。\n\n#### 代码实现\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-155.png\" style=\"zoom: 50%;\" />\n\n```C\nint *B = (int *)malloc(n * sizeof(int));\t//辅助数组B\n\n//A[low...mid]和A[mid+1...high]各自有序，将两个部分归并\nvoid Merge(int A[], int low, int mid, int high){\n\tint i,j,k;\n\tfor(k=low; k<=high; k++)\n\t\tB[k] = A[k];\t//将A中所有元素都复制到B中 \n\tfor(i=low,j=mid+1,k=i; i<=mid && j<=high; k++){\n\t\tif(B[i] <= B[j])\n\t\t\tA[k] = B[i++];\t//将较小值复制到A中 \n\t\telse\n\t\t\tA[k] = B[j++];\n\t}\n\twhile(i<=mid)\tA[k++] = B[i++];\n\twhile(j<=high)  A[k++] = B[j++];\n} \n```\n\n对于两个有序子序列来说（如上图3-6已经是有序的、7-9已经是有序的），我们会将low指针指向最前面的元素，然后让mid指向第一个有序子序列的最后一个元素，让high指针指向第二个子序列的最后一个元素。\n\n这样，我们就可以用low、mid、high，区分出两个要归并的有序子序列的范围。\n\n而且这两个子序列是相邻的。\n\n那么，这就契合了我们之前对于归并排序手算过程中，提出的需求（核心操作），即每次归并，都是要归并两两相邻的子序列。\n\n> 此代码当中，我们\n>\n> ```C\n> if(B[i] <= B[j])\n>  A[k] = B[i++];\t//将较小值复制到A中 \n> else\n>  A[k] = B[j++];\n> ```\n>\n> 即两数相等时，我们也将 i 所指的元素优先放入，而 i 是靠前的那个元素。保证了**稳定性**。\n\n以上是归并排序的核心操作。\n\n接下来看归并排序的完整代码：\n\n```C\nint *B = (int *)malloc(n * sizeof(int));\t//辅助数组B\n\n//A[low...mid]和A[mid+1...high]各自有序，将两个部分归并\nvoid Merge(int A[], int low, int mid, int high){\n\tint i,j,k;\n\tfor(k=low; k<=high; k++)\n\t\tB[k] = A[k];\t//将A中所有元素都复制到B中 \t\n\tfor(i=low,j=mid+1,k=i; i<=mid && j<=high; k++){\n\t\tif(B[i] <= B[j])\n\t\t\tA[k] = B[i++];\t//将较小值复制到A中 \n\t\telse\n\t\t\tA[k] = B[j++];\n\t}\n\twhile(i<=mid)\t\tA[k++] = B[i++];\t \n\twhile(j<=high)\t\tA[k++] = B[j++];\n} \n//用递归\nvoid MergeSort(int A[], int low, int high){\n\tif(low < high){\n\t\tint mid = (low+high)/2;\t//从中间划分\n\t\tMergeSort(A, low, mid);\t//对左半部分归并排序\n\t\tMergeSort(A, mid+1, high);\t//对右半部分归并排序\n\t\tMerge(A, low, mid, high);\t//归并 \n\t}\n}\n```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-156.png\" style=\"zoom: 33%;\" />\n\n对于一个待排序序列，我们首先将low和high指向其头尾，然后让mid指向它中间部分。\n\n然后对其左半部分、右半部分，递归地进行归并排序。\n\n> 递归地进行，就是说。\n>\n> 对于其左半部分、右半部分，又分别要进行它们各自的左右两部分。\n>\n> 一层套一层。直到不满足`low<high`的条件，即达到递归的最深层。即每部分只有1个元素的时候。\n\n当其左半部分、右半部分变得有序后，\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-157.png\" style=\"zoom: 80%;\" />\n\n我们再对左右这两个子序列进行归并即可。\n\n#### 算法效率分析\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-158.png\" style=\"zoom:80%;\" />\n\n刚才我们2路归并的这个过程，从形态上来看，就像一棵倒立的二叉树。因此也叫**归并树**。\n\n把它看作一棵二叉树，接下来我们就可以用二叉树的相关知识进行分析。\n\n树高h，则进行归并的趟数就是h-1趟。\n\n而二叉树的第h层最多有2^(h-1)个结点，所以，若树高h，则应满足`n ≤ 2^(h-1) `。因为我们整个序列中的n个结点，都只会出现在二叉树的`第h层`。（即“初始序列”那一层）即`h-1 = ⌈log₂n⌉`。\n\n而刚刚我们说了，对于树高为h的2路归并排序，需要归并的趟数是h-1，也就是需要归并的趟数是⌈log₂n⌉。\n\n而每一趟的归并，时间复杂度都是O(n)。\n\n> 每对比关键字一次，都会挑出一个当前剩余的最小的关键字，所以对比的次数 ≤ n-1。\n\n因此，算法的<font color='orange'>时间复杂度</font>为`O(nlog₂n)`。\n\n<font color='orange'>空间复杂度</font>为`O(n)`。其空间复杂度主要来源于辅助数组B。而辅助数组B的大小，和原本数组A的大小是一样的，因此是O(n)。\n\n> **问题**：既然归并排序是用递归算法实现的。\n>\n> 那么对于空间复杂度来说，是不是还要考虑递归工作栈所使用的空间呢？\n>\n> 的确。但是，我们递归调用的深度，是不会超过log₂n的（归并的趟数），因此递归工作栈所带来的空间复杂度为O(log₂n)，它与辅助数组带来的空间复杂度相比，我们只需要保留O(n)。\n\n<font color='orange'>稳定性</font>:由于Merge()操作不好改变相同关键字记录的相对次序，所以2路归并排序算法是一种稳定的排序方法\n\n#### 总结\n\n**归并排序**\n\n- Merge（归并）\n  - 把两个或多个有序的子序列合并为一个\n  - 2路归并 —— 二合一\n  - k路归并 —— k合一\n- 归并排序算法\n  - ①若low<high，则将序列从中间`mid=(low+high)/2`分开\n  - ②对左半部分`[low, mid]`递归地进行归并排序\n  - ③对右半部分`[mid+1, high]`递归地进行归并排序\n  - ④将左右两个有序子序列Merge为一个\n- 性能\n  - 空间复杂度：O(n)\n  - 时间复杂度：O(nlog₂n)\n  - 稳定性：稳定\n\n> 对于内部排序，我们的归并排序一般使用的是2路排序。\n>\n> 对于外部排序，我们的归并排序可能还会用到多路排序，这个我们到外部排序的地方再说。\n\n### 基数排序 Radix Sort\n\n> 比较神奇的排序算法。\n>\n> 之所以说它比较神奇，是因为之前的排序算法都比较了关键字的大小，而基数排序并没有比较关键字的大小。\n\n来看一下基数排序是怎么做的。\n\n#### 算法思想\n\n假设有这么一个序列，我们要用基数排序将它排成一个递减的序列。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-159.png\" style=\"zoom: 67%;\" />\n\n对于其中的所有元素，我们会发现，都可以分为三个部分：“个位”、“十位”、“百位”。而且，这三个部分，每个部分有可能的取值只有`0~9`。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-160.png\" style=\"zoom: 67%;\" />\n\n所以我们就建立一个辅助队列，分别对应`0~9`。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-161.png\" style=\"zoom: 60%;\" />\n\n接下来，进行我们的**第一趟处理**：\n\n**第一趟”分配“**：\n\n我们会以“个位”进行分配。\n\n由于第一个元素`520`，它的个位是0，因此会被我们放在`Q0`当中。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-162.png\" style=\"zoom:80%;\" />\n\n下一个元素是`211`，个位是1，因此放到`Q1`这个队列当中。\n\n如果两个数字的个位一样，由于每次放入，都是放到队列的队尾，因此先后次序不难区分。\n\n中间过程省略，最后，第一趟分配结束，结果如下\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-163.png\" style=\"zoom:80%;\" />\n\n接下来，我们需要进行一个操作，就是“收集”。我们要把各个队列中的元素收集起来，把它们连成一个统一的链表。\n\n**第一趟“收集”**：\n\n由于我们最后想要得到一个“递减”的序列，所以我们要从个位数最大的地方开始收集。也就是从`Q9`到`Q0`依次进行收集。\n\n依次将每个队列中的元素拆下来，并且让靠近队头的元素放在前面，靠近队尾的元素放在后面。\n\n中间过程省略，最后，第一趟收集结束，结果如下：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-164.png\" style=\"zoom: 80%;\" />\n\n由于我们刚才是按照“个位”进行“分配”的，所以按照这种方式，我们“收集”到的是**按“个位”递减**的序列。\n\n以上总共是第一趟的处理。接下来我们进行第二趟的处理。\n\n**第二趟“分配”**：以“十位”进行“分配”。\n\n第一个数`438`的十位是3，所以放到`Q3`队列中，…………\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-165.png\" style=\"zoom: 67%;\" />\n\n> 在分配的过程中，我们会发现。\n>\n> 由于此处对于“十位”的分配，是基于个位已经分配并收集好之后进行的。\n>\n> 所以对于十位数相同的元素，个位数更大的会排在前面，个位数更小的会排在后面。\n>\n> 也就是，十位数相同的元素，个位数更大的先入队，个位数更小的后入队。\n\n中间过程略，第二趟分配结果如下。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-166.png\" style=\"zoom: 60%;\" />\n\n接下来进行**第二趟“收集”**：\n\n同理，我们从十位更大的位置开始收集，这样能够保证十位数更大的元素是排在链表的前面的。而且每个队列的队头在前，队尾在后。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-167.png\" style=\"zoom:80%;\" />\n\n**第三趟“分配“**：以”百位“进行”分配“\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-168.png\" style=\"zoom:80%;\" />\n\n> 并且，由于我们是基于第二趟处理的结果。\n>\n> 所以，如果有百位相同的元素，则十位越大的会越先入队。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-169.png\" style=\"zoom:60%;\" />\n\n中间过程略，最终第三趟“分配”结果如图所示。\n\n接下来要进行**第三趟“收集”**：\n\n先收集`Q9`队列，且队头排在前面、队尾排在后面，依次收集。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-170.png\" style=\"zoom:67%;\" />\n\n最终会得到一个按“百位”递减的序列。\n\n而且，对于百位相同的元素，我们是按十位递减的顺序排列的，而对于十位还相同的元素，我们又是按个位递减的顺序排列的。\n\n**整个过程如下**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-171.png\" style=\"zoom:67%;\" />\n\n我们再对基数排序的过程用文字的方式，完整的总结一遍，如下：\n$$\n假设长度为n的线性表中每个结点a_j的关键字由d元组(k_j^{d-1},k_j^{d-2},k_j^{d-3},...,k_j^{1},k_j^{0})组成\n$$\n\n$$\n其中，0<=k_j^i<=r-1(0<=j<n,0<=i<-d-1),r称为基数\n$$\n\n> 每个节点把它分为“d元组”。像刚才那个例子，我们就是把每个结点分为了“三元组”：个位、十位、百位。\n>\n> d元组中，最靠近左边的，称为**最高位关键字**（最主位关键字）；最靠近右边的，称为**最低位关键字**（最次位关键字）。像刚才那个例子，百位就是最高位关键字，个位就是最低位关键字。\n>\n> （因为最左边的关键字是对整个数值大小影响最大的，所以把它称为最高位关键字；同理，最低位关键字）\n>\n> 而每一位可能的取值，是0到r-1，r称为“**基数**”。像刚才的例子中，我们可能的取值是`0~9`，其基数就应该是10，即关键字的每个部分都有可能得到10种不同的取值。\n\n基数排序得到**递减**序列的过程如下：\n\n**初始化**：设置**r个空队列**，`Q_(r-1)，Q_(r-2)，...，Q_0`。\n\n按照各个 **关键字位 权重递增的次序**（个、十、百），对d个关键字位分别做“分配”和“收集“。\n\n**分配**：顺序扫描各个元素，若当前处理的关键字位 = x，则将元素插入`Q_x`队尾。\n\n**收集**：把`Q_(r-1)，Q_(r-2)，...，Q_0`各个队列中的结点依次出队并链接。\n\n> 基数排序通常只考察手算的过程，几乎不考代码。\n>\n> 所以只要理解，能用手动的方式模拟其过程即可。\n\n可见，**基数排序并不是基于“比较”的排序算法**。而我们学习的其他的那些排序都是基于比较的排序算法。\n\n> 以上是递减的序列，那么得到一个递增序列的过程，也是同理的，如下：\n>\n> 基数排序得到**递增**序列的过程如下：\n>\n> **初始化**：设置**r个空队列**，`Q_0，Q_1，...，Q_(r-1)`。\n>\n> 按照各个 **关键字位 权重递增的次序**（个、十、百），对d个关键字位分别做“分配”和“收集“。\n>\n> **分配**：顺序扫描各个元素，若当前处理的关键字位 = x，则将元素插入`Q_x`队尾。\n>\n> **收集**：把`Q_0，Q_1，...，Q_(r-1)`各个队列中的结点依次出队并链接。\n\n#### 算法性能分析\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-172.png\" style=\"zoom: 80%;\" />\n\n基数排序通常是基于链式存储实现的。\n\n```C\ntypedef struct LinkNode {\n    ElemType data;\n    struct LinkNode *next;\n}LinkNode, *LinkList;\n```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-173.png\" style=\"zoom: 67%;\" />\n\n接着，我们还定义了十个队列。而且这十个队列链接的是单链表中的一个一个的结点，所以这些队列又都是链队列。\n\n```C\ntypedef struct {\t//链式队列\n    LinkNode *front, *rear;\t//队列的队头和队尾指针\n}LinkQueue;\n```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-174.png\" style=\"zoom: 80%;\" />\n\n队头指针指向最上面那个元素，队尾指针指向最下面那个元素。\n\n> 可见，基数排序的背后，都是之前所学过的很熟悉的东西。\n\n##### 空间复杂度\n\n基数排序的空间复杂度方面，主要是需要r个辅助队列，因为我们每设立一个辅助队列，实际上就是新增了`LinkNode *front, *rear;`这两个指针域，每个队列的空间复杂度是O(1)的数量级。\n\n因此<font color='orange'>空间复杂度 = O(r)</font>\n\n> r的含义是，每个关键字有可能有多少种不同的取值。需要相应的设立r个辅助队列。\n\n##### 时间复杂度\n\n我们算法总共执行的过程，是进行了d趟的分配、收集。\n\n> d的含义是，我们的关键字可以被拆分成几个部分。\n\n每一趟的分配，就是把整个链表从头到尾扫描了一遍。总共有n个元素，那么把它们都扫一遍，总共需要O(n)的时间。\n\n而一趟收集，只需要O®这么多的时间。因为总共有r个队列，收集的过程就是依次扫描这些队列，把每个队列当中的这些元素给拆下来，然后连到我们最终收集的那个链表当中。每收集一个队列，只需要O(1)的时间复杂度。\n\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-175.png\" style=\"zoom: 80%;\" />\n>\n> 例如，当前的收集表，p指针指向收集表的最后一个元素。\n>\n> 此时需要将Q_6队列中的元素拆下来，连到链表最后。\n>\n> ```C\n> p->next = Q[6].front;\n> Q[6].front = NULL;\n> Q[6].rear = NULL;\n> ```\n>\n> 我们若要将某个队列中的元素拆下来，并且连到收集的链表上，只需要如上操作。\n>\n> 因为实际上对于每个队列中串起来的元素来说，他们之间也是用`*next`链接起来的链表。\n>\n> 所以只需要将front拆下来，连到链尾即可，之后将队列头尾指针置空。\n>\n> 因此，对于每个队列的收集，只需要O(1)的时间。\n\n而一趟收集r个队列，所以<font color='orange'>一趟收集的时间复杂度为O(r)</font>。\n\n由于我们每一趟处理，包含了这一趟的分配+收集，而我们总共有d趟处理。\n\n因此<font color='orange'>总的时间复杂度为O(d(n+r))</font>。\n\n##### 稳定性\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-176.png\" style=\"zoom:67%;\" />\n\n假设由这么一个序列，其中有两个元素的关键字是相同的。\n\n我们在分配的时候，是从左往右依次扫描初始序列中的各个元素。所以第一个被“分配”的，应该是左边的那个`12`（不带下划线的12）。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-177.png\" style=\"zoom:67%;\" />\n\n之后，不论这两个`12`之间还有多少其他的个位为2的元素，总之这两个12的相对位置是确定的。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-178.png\" style=\"zoom:67%;\" />\n\n而当我们把这个队列，进行“收集“的时候。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-179.png\" style=\"zoom: 67%;\" />\n\n肯定也是没有下划线的12排在前面，有下划线的排在后面。\n\n所以这个算法，显然是**稳定**的。\n\n基数排序是**稳定**的。（鸡你太稳）\n\n#### 基数排序的应用\n\n某学校有10000名学生，将学生信息按**年龄递减**排序。\n\n可以将学生的生日信息，拆分为三组关键字：年（1991-2005）、月（1-12）、日（1-31）。\n\n> 年有可能取得15个值，月有可能取得12个值，日有可能取得31个值。\n\n那么，生日的这三组信息，肯定是：年的影响，大于月，大于日。\n\n即，**权重：年 > 月 > 日**。\n\n所以按照基数排序的思想，我们进行“分配”和“收集“，是先按照日，再按照月，再按照年，这种权重递增的次序进行分配和收集的。\n\n所以**第一趟**分配，我们可以按”日“的信息来处理：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-180.png\" style=\"zoom:67%;\" />\n\n而由于我们最终是要得到一个年龄递减的次序，那么日越大的，年龄越小，所以我们在收集这些信息的时候，先收集日更小的，再收集日更大的。\n\n经过这一趟处理，我们就得到了这10000个学生，按照“日”递增的一个次序。“日”越大的越靠后。\n\n**第二趟**分配，我们会按照“月”的信息来处理：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-181.png\" style=\"zoom:67%;\" />\n\n同样地，“月”更大的，年龄越小，所以，我们先收集月份更小的，再收集月份更大的。\n\n**第三趟**分配，按照“年”的信息进行处理：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-182.png\" style=\"zoom:67%;\" />\n\n同理。\n\n按照这三趟分配之后，我们就能得到这10000个学生，年龄按照递减的排序。\n\n> 通过这个例子，可以说明，我们的基数排序，其实并不像课本当中举的例子那样，每一个关键字的取值都是固定的`0~r-1`这样一个范围。\n>\n> 其实像这个例子当中，我们每一个关键字的部分，它的取值有可能出现各种各样的情况。（如，年：1991-2005）。\n\n<font color='cornflowerblue'>对于这个例子当中，我们分析一下它的时间复杂度是怎么样的。</font>\n\n由于基数排序时间复杂度 = `O(d(n+r))`。\n\n我们此处，把每个学生的信息分为了三个关键字：年、月、日。因此d为3。\n\nn = 10000，因为总共有10000个学生。\n\nr，每一趟分配时是不一样的。第一趟是31，第二趟是12，第三趟是15。那在这三趟当中，r的值最大也就是31。所以我们按最坏的情况来考虑，就是r = 31。\n\nd，n，r代入，可得时间为`3*(10000+31)`，约为O(30000)。\n\n而如果采用之前的那些算法，有的算法是O(n²)的时间复杂度，那么就约为O(10^8)；\n\n有的是O(nlog₂n)，那么就约为O(140000)。\n\n> 可以看到，在这种场景下，我们基数排序的时间复杂度，比之前所有算法都要优秀不少。\n\n<font color='cornflowerblue'>所以，基数排序擅长解决的问题</font>：\n\n①数据元素的关键字可以方便地拆分为d组，且d较小；\n\n②每组关键字的取值范围不大，即r较小；\n\n③数据元素个数n较大。\n\n> 对于①的反例：给5个人的身份证号排序。\n>\n> 18位身份证号需要分配、回收18趟。而我们只有5个人的元素，即n很小，而d很大。所以此时效率是很低的。\n>\n> 对于②的反例：给中文人名排序。\n>\n> 中国人的名字，一般是两到三个字，也有四个字的，总之是d比较小的。但是我们的r，即每一位上有可能出现的汉字字符的取法，就太庞大了。所以，即使对于人名，最多只有4个分组，但是每个分组中有可能的取值有上万种，即r的值很大。相应的，空间复杂度就会很高，时间复杂度也不低，因此效率很低。\n>\n> 对于③的反例：还是，给5个人的身份证号排序的问题。\n>\n> 对于③的正例：给十亿人的身份证号排序。\n\n### 习题\n\n- 【2013】对给定的关键字序列110，113，007，911，114，120，122进行基数排序， 则第 2 趟分配收集后得到的关键字序列是-->C\n\n  A.007,110,119,114,911,120,122\n\n  B.007,110,119,114,911,122,120\n\n  C.007,110,911,114,119,120,122\n\n  D.110,120,911,122,114,007,119\n\n  > **基数排序是通过“分配”和“收集”过程来实现排序。**  \n  >\n  > **1）** **首先根据个位数值（只看个位）来排序：**  \n  >\n  > 110 120 911 122 114 007 119\n  >\n  > **2）** **再看十位（只看十位数值大小）来排序：**  \n  >\n  > 007 110 911 114 119 120 122 \n  >\n  > **3）** **最后看百位：**  \n  >\n  > 007 110 114 119 120 122 \n  >\n  > 所以第2趟分配收集后得到的关键字序列是{007 110 911 114 119 120 122 }。\n\n- 【2016】 对 10TB 的数据文件进行排序，应使用的方法是→D\n\n  A 希尔排序\n\n  B 堆排序\n\n  C 快速排序\n\n  D 归并排序 \n\n  > 外部排序指待排序文件较大，内存一次性放不下，需存放在外部介质中。外部排序通常采用归并排序法。选项A、B、C都是内部排序的方法。\n\n- 【2017】在内部排序时，若选择了归并排序而未选择插入排序，则可能的理由是-->Ⅲ\n\n  Ⅰ．归并排序的程序代码更短 \n\n  Ⅱ．归并排序的占用空间更少\n\n  Ⅲ．归并排序的运行效率更高\n\n  > 归并排序代码比选择插入排序更复杂，前者空间复杂度是O(n)，后者是O(1)。但是前者时间复杂度是O(nlog₂n)，后者是O(n²)。\n\n- 【2021】设数组S[= {93, 946, 372, 9, 146, 151, 301, 485, 236, 327, 43, 892}，采用最低位优先(LSD)基数排序将S排列成升序序列。第1趟分配、收集后，元素372之前、之后紧邻的元素分别是-->C\n\n  A、43,892\n\n  B、236,301\n\n  C、301,892\n\n  D、485,301\n\n  > 基数排序是一种稳定的排序方法。由于采用最低位优先(LSD) 的基数排序，即第1趟对个位进行分配和收集的操作，因此第一-趟 分配和收集后的结果是{151, 301, 372, 892, 93, 43,485, 946, 146, 236, 327,9},元素372之前、之后紧邻的元素分别是301和892，故选C。\n\n## 8.6 各种内部排序算法的比较及应用\n\n### 内部排序算法的比较\n\n#### 从时间复杂度来看\n\n简单选择排序、直接插入排序和冒泡排序平均情况下的时间复杂度都为O(n²),且实现过程也比较简单，但直接插入排序和冒泡排序最好情况下的时间复杂度可以达到O(n),而简单选择排序则与序列的初始状态无关。希尔排序作为插入排序的拓展，对较大规模的排序都可以达到很高的效率，但目前未得出其精确的渐近时间。堆排序利用了一种称为堆的数据结构，可在线性时间内完成建堆，且在O(nlog₂n)内完成排序过程。快速排序基于分治的思想，虽然最坏情况下快速排序时间会达到O(n²),但快速排序平均性能可以达到O(nlog₂n)，但实际应用中常常优于其他排序算法。归并排序同样基于分治思想，但由于其分割子序列与初始序列的排列无关，因此它的最好、最坏和平均实际复杂度均为O(nlog₂n)。\n\n#### 从空间复杂度来看:\n\n简单选择排序、插入排序、冒泡排序、希尔排序和堆排序都仅需要借助常数个辅助空间。快速排序在空间上只使用一个小的辅助栈，用于实现递归，平均情况下大小为O(log₂n),当然在最坏情况下可能会增长到O(n)。2路归并排序在合并操作中需要借助较多的辅助空间用于元素复制，大小为为O(n)，虽然有方法能克服这个缺点，但其代价是算法会很复杂而且时间复杂度会增加。\n\n#### 从稳定性来看\n\n插入排序、冒泡排序、归并排序和基数排序是稳定的排序方法，而简单选择排序、快速排序、希尔排序和堆排序都是不稳定的排序方法。平均时间复杂度为O(nlog₂n)的稳定排序算法只有归并排序，对于不稳定的排序，只需举出一个其不稳定的例子即可。\n\n| 排序算法     | 空间效率                                    | 时间效率                                      | 稳定性 | 备注                                                         |\n| ------------ | ------------------------------------------- | --------------------------------------------- | ------ | ------------------------------------------------------------ |\n| 插入排序     | O(1)                                        | 最好O(n)<br/>平均O(n²) <br/>最坏O(n²)         | 稳定   | 比较依赖初始状态                                             |\n| 折半插入排序 | O(1)                                        | 最好O(n)<br/>平均O(n²) <br/>最坏O(n²)         | 稳定   | 比较次数约为 O(nlog₂n)                                       |\n| 希尔排序     | O(1)                                        | 大约为 O(n^{1.3})                             | ❌      |                                                              |\n| 冒泡排序     | O(1)                                        | 最好O(n)<br/>平均O(n²)<br/>最坏 O(n²)         | 稳定   |                                                              |\n| 快速排序     | 最好O(log₂n)<br/>平均O(log₂n)<br/>最坏O(n²) | 最好O(nlog₂n)<br/>平均O(nlog₂n)<br/>最坏O(n²) | ❌      | 和划分是否对称有关<br />在所有**内部**排序算法中平均性能最优 |\n| 简单选择排序 | O(1)                                        | O(n²)                                         | ❌      | 与初始状态无关                                               |\n| 堆排序       | O(1)                                        | O(nlog₂n)                                     | ❌      |                                                              |\n| 归并排序     | O(n)                                        | O(nlog₂n)                                     | 稳定   |                                                              |\n| 基数排序     | O(r)                                        | O(d(n+r))                                     | 稳定   | r 为基数，d 为趟数，n 为元素个数                             |\n\n### 内部排序算法的应用\n\n1. 选取排序方法需要考虑的因素：\n   - 待排序的元素数目n\n   - 元素本生信息量的大小\n   - 关键字的结构极其分布情况\n   - 稳定性的要求\n   - 语言工具的条件，存储结构及辅助空间的大小\n2. 排序算法小结\n   - 若n较小，可采用**直接插入排序或简单排序**。由于直接插入排序所需的记录移动次数较**简单选择排序**的多，因而当记录本身信息量**较大**时，用**简单选择排序**较好。\n   - 若文件的初始状态已按关键字**基本有序**，则选用**直接插入**或**冒泡排序**为宜。\n   - 若n**较大**，则应采用时间复杂度为O(nlog2n)的排序方法：**快速排序，堆排序或归并排序**。**快速排序**被认为是目前基于比较的内部排序方法中最好的方法，当待排序的关键字随机分布时，快速排序的平均时间最短。**堆排序**所需的辅助空间少于**快速排序**，并且不会出现快速排序可能出现的最坏情况，这俩种排序都是不稳定的。若要求排序稳定且时间复杂度为O(nlog2n)，则可选用**归并排序**。\n   - 在基于比较的排序方法中，每次比较俩个关键字的大小之后，仅出现俩种可能的转移，因此可以用一颗二叉树来买描述比较判定过程，由此可以证明，当文件的n个关键字随机分布时，任何借助于比较的排序算法，至少需要O(nlog2n)的时间\n   - 若n很大，记录的关键字为主较少且可以分解时，采用**基数排序**较好。\n   - 当记录本身信息量较大时，为避免耗费大量时间移动记录，可用链表作为存储结构。\n\n### 习题\n\n- 【2012】在内部排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一趟排序。下列排序方法中，每趟排序结束时都至少能够确定一个元素最终位置的方法是-->仅Ⅰ、 Ⅲ、 Ⅳ\n\n  Ⅰ．简单选择排序 Ⅱ．希尔排序 Ⅲ．快速排序Ⅳ．堆排序 Ⅴ．二路归并排序\n\n  > 每一次排序之后都能确定至少一个元素位置的排序方法包括： \n  >\n  > 1.**选择排序**：每次将最大的数放到最后。所以最大的数排一次序后位置就确定了。 \n  >\n  > 2.**冒泡排序**：同选择排序。每一次排序最大的值位置确定。 \n  >\n  > 3.**快排**：每一次排序pivot的位置确定。 \n  >\n  > 4.**堆排序**：每一次排序时，都是将堆顶的元素和最后一个节点互换，然后调整堆，再将堆大小减1。所以每一次排序堆顶元素确定。 \n  >\n  > 不能至少确定一个元素的位置的方法包括： \n  >\n  > **1.插入排序**：不到最后一步求的都是相对位置。 \n  >\n  > 2.**shell排序**：对简单插入排序的改进。不到最后一步，是无法确定每个元素位置的。 \n  >\n  > 3.**归并排序**：局部有序，并不能确定任一元素在全局的位置。 \n  >\n  > 4.**基数排序，计数排序**：利用桶排序的思路，不是基于比较的排序，也无法在一次排序中确定某个元素的位置。因为每一次排序都是整体处理。\n\n- 【2015】下列排序算法中，元素的移动次数与关键字的初始序列无关的是-->C\n\n  A.直接插入排序\n\n  B.起泡排序\n\n  C.基数排序\n\n  D.快速排序\n\n  > 敲黑板了：\n  >\n  > 元素的**移动次数**与关键字的初始排列次序无关的是：基数排序\n  >\n  > 元素的**比较次数**与初始序列无关是：选择排序\n  >\n  > 算法的**时间复杂度**与初始序列无关的是：选择排序\n\n- 【2017】下列排序方法中，若将顺序存储更换为链式存储，则算法的时间效率会降低的是-->D\n\n  Ⅰ．插入排序 Ⅱ．选择排序 Ⅲ．起泡排序 Ⅳ．希尔排序 Ⅴ．堆排序\n\n  A.仅Ⅰ、Ⅱ\n  B.仅Ⅱ、Ⅲ\n  C.仅Ⅲ、Ⅳ\n  D.仅Ⅳ、Ⅴ\n\n  > 插入排序、选择排序、起泡排序原本时间复杂度是O(n2)，更换为链式存储后的时间复杂度还是O(n2)。希尔排序和堆排序都利用了顺序存储的随机访问特性，而链式存储不支持这种性质，所以时间复杂度会增加，因此选D。\n\n- 【2019】选择一个排序算法时，除算法的时空效率外，下列因素中，还需要考虑的是-->D\n\n  I．数据的规模   II．数据的存储方式   III．算法的稳定性    IV．数据的初始状态\n\n  A. 仅 III\n  B. 仅 I、II\n  C. 仅 II、III、IV\n  D. I、II、III、IV\n\n  > 当数据规模较小时可选择复杂度为0(n²)的简单排序方法，当数据规模较大时应选择复杂度为O(nlog₂n)的排序方法，当数据规模大到内存无法放下时需选择外部排序方法,I正确。\n  > 数据的存储方式主要分为顺序存储和链式存储，有些排序方法(如堆排序)只能用于顺序存储方式，II 正确。\n  > 若对数据稳定性有要求，则不能选择不稳定的排序方法，III显然正确。\n  > 当数据初始基本有序时，直接插入排序的效率最高，冒泡排序和直接插入排序的时间复杂度都是O(n)，而归并排序的时间复杂度依旧是O(nlog₂n)，IV正确。所以选D.\n\n- 【2020】对大部分元素已有序的数组排序时，直接插入排序比简单选择排序效率更高，其原因是→①\n\n  ① 直接插入排序过程中元素之间的比较次数更少\n\n  ② 直接插入排序过程中所需的辅助空间更少\n\n  ③ 直接插入排序过程中元素的移动次数更少 \n\n  > 考虑较极端的情况，对于有序数组，直接插入排序的比较次数为n-1,简单选择排序的比较次数始终为1+2+…+n-1=n(n-1)/2，I正确。两种排序方法的辅助空间都是0(1), 无差别，II错误。初始有序时，移动次数均为0; 对于通常情况，直接插入排序每趟插入都需要依次向后挪位，而简单选择排序只需与找到的最小元素交换位置，后者的移动次数少很多，III 错误。\n","tags":["408数据结构"],"categories":["408数据结构"]},{"title":"第八章 排序(二)","url":"/p/43357/","content":"\n## 8.3 交换排序\n\n### 冒泡排序 Bubble Sort\n\n#### 算法思想\n\n从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即A[i-1] > A[i]），则交换它们，直到序列比较完。称这样过程为“一趟”冒泡排序。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-38.png\" style=\"zoom:80%;\" />\n\n> 从后往前两两对比相邻元素，依次对`27 49`，`13 27`……进行对比\n>\n> 由于我们的目标是使整个表呈递增，因此，若后一个元素较小，则交换这两个元素。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-39.png\" style=\"zoom:80%;\" />\n\n第二趟同理。并且同样将最小的元素“冒”到最前面。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-40.png\" style=\"zoom:80%;\" />\n\n此时需要注意，之前已经确定位置的元素，不用再与之进行对比了。\n\n因此，第二趟结束后，会导致，最小的两个元素已经“冒”到了最前边。\n\n第三趟同理。同样地，之前确定过位置的元素不用再与之对比。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-41.png\" style=\"zoom:80%;\" />\n\n第三趟结束后，值最小的三个元素已经“冒”到了最前边。\n\n第四趟同理，两两对比，该交换交换。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-42.png\" style=\"zoom:80%;\" />\n\n**当两个数的值相等时，我们不应该交换它们两个的位置，这么做能保证算法的稳定性。能保证原本在右边的元素不会跑到左边去。**\n\n接下来，进行第五趟排序。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-43.png\" style=\"zoom:80%;\" />\n\n会发现，两两对比，每一对数字都不需要进行交换。那么这种情况其实说明，整体已经达到了一个有序的状态了。所以经过第五趟处理，我们就可以确定，整个表已经有序了，我们就不需要再进行后续的处理。\n\n#### 算法实现\n\n理清楚逻辑之后，代码的理解就很简单了。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-287.png\" style=\"zoom:67%;\" />\n\n```C\n//交换\nvoid swap(int &a, int &b) {\n\tint temp = a;\n\ta = b;\n\tb = temp;\n}\n\n//冒泡排序\nvoid BubbleSort(int A[], int n) {\n\tfor(int i=0; i<n-1; i++){\n\t\tbool flag = false;\t//表示本趟冒泡是否发生交换的标志\n\t\tfor(int j=n-1; j>i; j--){\t//一趟冒泡过程 \n\t\t\tif(A[j-1] > A[j]){\t\t//若为逆序 \n\t\t\t\tswap(A[j-1], A[j]);\t//交换\n\t\t\t\tflag = true; \n\t\t\t}\n\t\t}\n\t\tif(flag == false)\n\t\t\treturn;\t\t//本趟遍历没有发生交换，说明表已经有序 \n\t}\n}\n```\n\n> 只有A[j-1] > A[j]时才交换，相等时不交换，因此可以保证此算法是稳定的。\n\n#### 算法性能分析\n\n**空间复杂度**：O(1)\n\n**最好时间复杂度（有序）**：O(n)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-44.png\" style=\"zoom:80%;\" />\n\n> 进行一趟冒泡排序即可确认有序。两两对比，对比次数为n-1次；交换次数为0次。\n\n**最坏时间复杂度（逆序）**：O(n²)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-45.png\" style=\"zoom:80%;\" />\n\n> 每一趟，首先都是需要两两对比的，对比次数为n-1、n-2…\n>\n> 其次，由于原表是完全逆序的，因此每个关键字在进行每一次两两对比时，都需要进行交换操作。\n>\n> 比较次数 = (n-1) + (n-2) + … +1 = n(n-1)/2 = 交换次数\n\n**平均时间复杂度**：O(n²)\n\n> 上面我们说的都是“交换”的次数。\n>\n> 而每次交换，都需要移动元素3次。（因为t = a; a = b; b = t;）\n>\n> 所以如果题目中说的是**移动元素**的次数，需要和**交换元素**的次数进行区分。\n\n稳定性：稳定。\n\n**问：冒泡排序是否适用于链表？**\n\n显然是可以的。我们可以从链头开始，从头到尾地进行冒泡排序，若逆序则交换。\n\n> 可从前往后\"冒泡\"，每一趟将更大的元素\"冒\"到链尾。\n\n#### 总结\n\n**冒泡排序**\n\n- 算法原理\n  - 从后往前（或从前往后）两两比较相邻元素的值，若为逆序，则交换它们，直到序列比较完。称这样过程为“一趟”冒泡排序。最多只需n-1趟排序。\n  - 每一趟排序都可以使一个元素移动到最终位置，已经确定最终位置的元素在之后的处理中无需再对比。\n  - 如果某一趟排序过程中未发生“交换”，则算法可提前结束。\n- 性能\n  - 空间复杂度：O(1)\n  - 时间复杂度\n    - 最好（完全有序）：O(n)\n    - 最差（完全逆序）：O(n²)\n    - 平均：O(n²)\n  - 稳定性：稳定\n  - 适用性：顺序表、链表都可以\n\n### 快速排序 Quick Sort\n\n> “快速排序”，它的名字就起成这个样子，可以看出它这个算法还是比较优秀的。\n>\n> 事实上，我们学习的所有内部排序的排序算法中，快速排序确实是最优秀的。\n\n> 在冒泡排序中，我们每一次都会使一个最大/最小元素确定它的最终位置。\n>\n> 而在快速排序中，我们每次都会使一个中间元素确定它的最终位置。\n\n#### 算法思想\n\n> 在待排序表L[1…n]中任取一个元素pivot作为枢轴（或基准，通常取首元素），通过一趟排序将待排序表划分为独立的两部分L[1…k-1]和L[k+1…n]，使得L[1…k-1]中的所有元素小于pivot，L[k+1…n]中的所有元素大于等于pivot，则pivot放在了其最终位置L(k)上，这个过程称为一次“划分”。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-46.png\" style=\"zoom:80%;\" />\n\n这是一个含有8个元素的待排序表。我们每次选择一个元素作为枢轴（或者基准），通常取第一个元素。\n\n第一次取`49`为枢轴，接下来在一趟排序之后，我们应该能够找到49所要摆放的最终位置。\n\n49这个元素在整个表当中，既不是最小的，也不是最大的，它应该处于一个中间位置。\n\n所以，我们要确定49这个元素的最终位置，我们就需要对整个表进行一个调整，我们需要把这个表划分为左右两个部分，左半部分所有元素都要比49更小，而右半部分所有元素都要大于等于49这个基准元素。\n\n这样的一次处理，我们把它称为一次“划分”。因为我们利用49作为基准，把整个表划分为了左右两个部分。\n\n**我们看一下一次划分的具体过程**：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-47.png\" style=\"zoom:80%;\" />\n\n首先，low和high分别指向我们要处理的这个序列的头、尾处。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-48.png\" style=\"zoom:80%;\" />\n\n然后，我们选择low所指向的这个元素，把它作为基准元素。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-49.png\" style=\"zoom: 55%;\" />\n\n\n\n接下来，我们会让low和high都向中间移动，把中间的元素都给扫描一遍。\n\n在扫描的过程中，我们需要保证，high指针的右边，都是大于等于49的元素；而low指针的左边，都是小于49的元素。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-50.png\" style=\"zoom: 67%;\" />\n\n扫描的过程：\n\nlow所指位置当前为空，不动；\n\nhigh所指的当前元素为49，是大于等于49的，不处理，指向下一处。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-51.png\" style=\"zoom: 55%;\" />\n\nhigh当前所指的元素为`27`，而27<49，因此27最终需要放到low指针所指位置的左边，因此我们将27放到low指针指向的位置。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-52.png\" style=\"zoom: 55%;\" />\n\n此时，high所指的位置空出来了，那么我们接下来要将low指针向右扫描了。\n\n当前low所指的元素为27，27<49，所以不需要处理，指向下一处；\n\n当前low所指的元素为38，38<49，所以不需要处理，指向下一处；\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-53.png\" style=\"zoom:80%;\" />\n\n此时，low指向的元素`65`，65≥49，因此65需要放到high指针所指位置的右边。因此我们将65放到high所指的位置\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-54.png\" style=\"zoom:80%;\" />\n\n然后，low所指位置空了，所以接下来我们令high继续扫描。\n\n当前high所指元素为65，65≥49，不需要处理，继续扫描；\n\n当前high所指元素为13，13<49，需要把13放到low指针所指位置。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-55.png\" style=\"zoom:55%;\" />\n\n接下来让low指针右移，进行扫描。\n\n当前low所指元素为13，13<49，不需要处理，继续扫描；\n\n当前low所指元素为97，97≥49，需要将97放到high所指位置。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-56.png\" style=\"zoom:55%;\" />\n\n然后又让high指针左移进行扫描。\n\n当前high所指元素为97，不需要处理，继续扫描；\n\n当前high所指元素为76，不需要处理，继续扫描，即继续左移，high–-。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-57.png\" style=\"zoom:80%;\" />\n\n当low和high碰到一起的时候，就说明我们已经把所有待排序的元素都扫描了一遍，所有比基准元素更小的元素，我们都把它放到了low指针所指位置的左边；所有大于等于基准元素的元素，我们都把它放到了high指针所指位置的右边。\n\n并且此时我们可以确定，`49`就放在low和high相遇的这个位置。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-58.png\" style=\"zoom: 80%;\" />\n\n以上就是一次“划分”的过程。\n\n> 我们选定了待排序序列当中的第一个元素，作为所谓的枢轴元素，或者叫基准元素。\n>\n> 然后我们用low和high两个指针分别指向了待排序序列的最左和最右两个位置。当这两个指针往中间移动的时候，我们每扫描到一个元素，都会对比这个元素和基准元素的大小关系，如果比基准元素更小的，我们统统会把它移动到左边；如果比基准元素大于等于的，我们会把它移动到右边。\n>\n> 当low和high相遇的时候，我们就确定了这个基准元素（枢轴元素）的最终存放位置。\n\n那既然`49`的最终位置确定了，那么在接下来的排序中，我们就不需要再管49这个元素了。我们只需要管它左边的子表，和它右边的子表。\n\n接下来我们要做的，就是对其左、右子表，再次进行同样的“划分”。\n\n**先来看左子表，对它进行划分**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-59.png\" style=\"zoom:80%;\" />\n\n同样地，是用low和high分别指向待排序序列的头、尾两处。并选中第一个元素作为基准元素。\n\n现在来让high进行扫描。\n\nhigh当前所指向的元素，13<27，因此要将13放到low所指位置。\n\n然后让low进行扫描。\n\nlow指向13，不处理；\n\nlow指向38，38>27，因此要将38放到high所指位置。\n\n然后让high进行扫描，high左移。\n\nlow和high相遇，如下：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-60.png\" style=\"zoom:80%;\" />\n\n此时，low和high相遇，说明待排序序列中的所有元素都被我们扫描了一遍，说明基准元素的最终存放位置应该是low和high相遇的这个位置。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-61.png\" style=\"zoom:80%;\" />\n\n此时，这个子表，又再一次地被`27`这个基准元素划分为了左右子表。由于我们的左右两个子表都只剩余一个元素，显然，这两个子表不需要再进行处理，也就是说`0~2`这个子序列中的所有元素的最终位置，我们都已经确定了。\n\n**接下来，对`49`的右子表进行处理**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-62.png\" style=\"zoom:80%;\" />\n\n将low和high分别指向待处理序列的头、尾位置。同时选中low所指元素作为基准元素。\n\n中间过程略。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-63.png\" style=\"zoom:80%;\" />\n\n最终确定了基准元素`76`的位置。`76`再一次地把它划分成了两个更小的部分。\n\n对于`76`左半部分的处理，处理思路是一样的，结果如下图所示：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-64.png\" style=\"zoom:80%;\" />\n\n此时，显然`49`的右半部分，以及`76`的右半部分，都不需要排序了。\n\n因此整个表已经排序完毕。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-65.png\" style=\"zoom:80%;\" />\n\n以上就是快速排序的整个过程。\n\n> 我们会不断地进行“划分”这个过程。\n>\n> 每次划分，我们的序列都会被分为左边和右边两个部分，左边的元素都比枢轴元素更小；右边的元素都大于等于枢轴元素。\n>\n> 然后再对枢轴元素的左、右部分，再次进行“划分”。\n\n#### 算法实现\n\n```C\n//用第一个元素将待排序序列划分成左右两个部分\nint Partition(int A[], int low, int high) {\n\tint pivot = A[low];\t\t//第一个元素作为枢轴 \n\twhile(low < high){\t\t//用low、high搜索枢轴的最终位置 \n\t\twhile(low < high && A[high] >= pivot){\n\t\t\t--high; \n\t\t}\n\t\tA[low] = A[high];\t//比枢轴小的元素移动到左端 \n\t\twhile(low < high && A[low] <= pivot){\n\t\t\t++low;\n\t\t}\n\t\tA[high] = A[low];\t//比枢轴大的元素移动到右端 \n\t}\n\tA[low] = pivot;\t\t//枢轴元素存放到最终位置\n\treturn low;\t\t//返回存放枢轴的最终位置 \n}\n\n//快速排序\nvoid QuickSort(int A[], int low, int high) {\n\tif(low < high){\t\t//递归跳出的条件 \n\t\tint pivotpos = Partition(A, low ,high);\t//划分\n\t\tQuickSort(A, low, pivotpos-1);\t\t//划分左子表\n\t\tQuickSort(A, pivotpos+1, high);\t\t//划分右子表 \n\t}\n}\n```\n\n#### 算法性能分析\n\n##### 时间复杂度\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-66.png\" style=\"zoom: 67%;\" />\n\n其实每一轮处理，都是一层QuickSort，都是Partition函数执行一遍划分的过程，都是扫描一遍待排序序列除了基准元素外的所有元素。\n\n所以第一次Partition，扫描了n-1个元素，处理的时间复杂度为O(n)。\n\n而在之后的“划分”，每次要扫描的元素都不可能比n-1大，因此其处理的时间复杂度都不会超过O(n)。\n\n而，对于这个初始序列有8个元素的表来说，我们处理了4层QuickSort。\n\n时间复杂度 = `O(n * 递归层数)`\n\n##### 空间复杂度\n\n由于快速排序，是一个递归函数，每次执行都会向递归工作栈内存放函数信息。所以如果递归调用的层数越深，那么相应的需要的空间复杂度也会越高。\n\n空间复杂度 = O(递归层数)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-67.png\" style=\"zoom: 67%;\" />\n\n##### 递归层数\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-68.png\" style=\"zoom: 67%;\" />\n\n由于每次“划分”，都是由一个枢轴元素将序列划分为左右两部分，直至左右部分为空，或只有一个元素。\n\n因此可以将其化为一棵二叉树。\n\n然后，按照二叉树的性质，对于有n个结点的二叉树，最小高度为`⌊ log₂n ⌋ + 1`；最大高度为`n`。\n\n而这个二叉树的高度，就是快速排序递归调用的深度。\n\n也就是说，快速排序最少需要`⌊ log₂n ⌋ + 1`层调用，最多需要`n`层调用，才可以完成整个快速排序。\n\n> 刚才我们说了，\n>\n> 时间复杂度 = O(n * 递归层数)\n>\n> 空间复杂度 = O(递归层数)\n\n所以，**最好**时间复杂度 = `O(nlog₂n)`；**最坏**时间复杂度 = `O(n²)`。\n\n**最好**空间复杂度 = `O(log₂n)`；**最坏**空间复杂度 = `O(n)`。\n\n> 在实际应用当中，快速排序算法的时间复杂度还是接近于O(nlog₂n)的。\n\n平均时间复杂度 =` O(nlog₂n)`。\n\n> 快速排序是所有内部排序算法中平均性能最优的排序算法。\n\n##### 比较好的情况\n\n像我们一开始举的那个例子，就属于比较好的情况。\n\n> 若每一次选中的“**枢轴**”将待排序序列**划分**为**均匀**的两个部分，则递归深度最小，算法**效率最高**。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-69.png\" style=\"zoom:80%;\" />\n\n##### 最坏的情况\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-70.png\" style=\"zoom: 50%;\" />\n\n若初始序列就是有序的，那么high需要不断地左移，直到与low相遇，此时才能确定当前枢轴元素在此位置。\n\n之后的每一层划分都需要这么做。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-71.png\" style=\"zoom: 67%;\" />\n\n此外，经过这样的一层划分之后，划分出的左右两个部分是很不均匀的：左边有0个元素，而右边有7个元素。\n\n同样，之后的每一层处理，所划分出的左右两部分都是很不均匀的。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-72.png\" style=\"zoom:80%;\" />\n\n可见，若初始序列为**有序或逆序**，则快速排序的**性能最差**。\n\n因为每次选择的都是最靠边的元素，导致每次划分都很不均匀。\n\n而比较好的情况是，每次选取的枢轴，都能够将带排序序列划分为均匀的两个部分。\n\n##### 快速排序优化\n\n因此，我们可以将快速排序算法进行一个优化。\n\n有很多方法可以提高算法的效率:一种方法是尽量选取一个可以将数据中分的枢轴元素，如从序列的头尾及中间选取三个元素，再取这三个元素的中间值作为最终的枢轴元素；或者随机地从当前表中选取枢轴元素，这样做可使得最坏情况在实际排序中几乎不会发生。\n\n##### 稳定性\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-73.png\" style=\"zoom:80%;\" />\n\n对于这么一个序列。以第一个元素作为枢轴。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-74.png\" style=\"zoom:80%;\" />\n\n由于high所指元素1<2，所以该元素移到low所指位置。\n\n然后令low右移。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-76.png\" style=\"zoom:80%;\" />\n\nlow指向2时，由于2 == 2，所以不处理，low继续右移。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-77.png\" style=\"zoom:80%;\" />\n\nlow和high相遇，放入。可见，这是不稳定的。\n\n#### 总结\n\n**快速排序**\n\n- 算法表现主要取决于递归深度，若每次“划分”越均匀，则递归深度越低。“划分”越不均匀，则递归深度越深。\n- 性能\n  - 空间复杂度\n    - 最好：O(n)\n    - 最坏：O(log₂n)\n  - 时间复杂度\n    - 最好：O(nlog₂n)——每次划分很平均\n    - 最坏：O(n²)——原本正序或逆序\n    - 平均：O(nlog₂n)\n  - 稳定性：不稳定\n\n**注**：在王道书里面，对于“一趟排序”，指的是“进行一次划分”。\n\n而408原题当中，对于所有尚未确定最终位置的所有元素进行一遍处理，称为“一趟”排序，因此一次“划分” ≠ “一趟”排序。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-78.png\" style=\"zoom: 67%;\" />\n\n> 也就是，在408当中，每一层QuickSort，是一趟排序。\n\n而一次划分，只是对一个子序列进行一个Partition。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-79.png\" style=\"zoom: 50%;\" />\n\n所以一次划分，只能确定一个元素的最终位置；\n\n而一趟排序，可以确定多个元素的最终位置。\n\n> 这个区别，在做习题的时候会遇到。此处先提一下。\n>\n> 很多教材会认为，一次划分就是一趟排序。\n>\n> 而对于408的考试来说，是有区别的。\n\n### 习题\n\n- 【2010】对一组数据`2 12 16 88 5 10`进行排序，若前 3 趟排序结果如下\n  第一趟：`2 12 16 5 10 88`\n  第二趟：`2 12 5 10 16 88 `第三趟：`2 5 10 12 16 88`\n  则采用的排序方法可能是 → 冒泡排序\n\n  > 冒泡排序 过程:从第1个记录开始到第n个记录，对相邻记录的关键字进行比较，若与排序要求相逆，则将交换，这样一趟后，具有最大关键字的记录交换到最后；然后从第1个记录开始到第n-1个记录继续进行第2趟冒泡，使得具有次最大关键字的记录换到倒数第2个位置；进行n-1趟冒泡后，达到n个记录按关键码排序\n\n- 【2011】为实现快速排序算法，待排序序列宜采用的存储方式是 → A\n\n  A．顺序存储   \n  B．散列存储   \n  C．链式存储   \n  D．索引存储\n\n  > 快速排序中查询操作用的较多，而顺序存储 适用于频繁查询时使用； 链式存储适用于频繁地插入、删除、更新元素时使用。\n\n- 【2014】下列选择中，不可能是快速排序第2趟排序结果的是->\n\n  A. 2， 3， 5， 4， 6， 7，9 \n\n  B. 2， 7， 5， 6， 4， 3，9 \n\n  C. 3， 2， 5， 4， 7， 6，9 \n\n  D. 4， 2， 3， 5， 7， 6，9\n\n  > 四个选项都是同样的数组元素，若完全有序，应为2345679\n  > 每经过一趟快排，轴点元素都必然就位，也就是说，一趟下来至少有1个元素在其最终位置\n  > 所以考察各个选项，看有几个元素就位即可。\n  >\n  > A：2、3、6、7、9\n  >\n  > B：2、9\n  >\n  > C：9\n  >\n  > D：5、9\n  > 第二趟至少应有2个元素就位，所以C不对。\n\n- 【2010】采用递归方式对顺序表进行快速排序。下列关于递归次数的叙述中，正确的是->D\n\n  A. 递归次数与初始数据的排列次序无关\n  B. 每次划分后, 先处理较长的分区可以减少递归次数\n  C. 每次划分后, 先处理较短的分区可以减少递归次数\n  D. 递归次数与每次划分后得到的分区处理顺序无关\n\n  > 快排算法中\n  >\n  > 递归的次数与 初始 数据的排列顺序有关\n  >\n  > 递归次数与每次划分后得到的分区处理顺序无关\n  >\n  > **递归次数，取决于递归树，而递归树取决于轴枢的选择。树越平衡，递归次数越少。**\n  >\n  > **而对分区的长短处理顺序，影响的是递归时对栈的使用内存，而不是递归次数**\n\n- 【2019】排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一「趟」。下列序列中，不可能是快速排序第二趟结果的是→D\n\n  A `5 2 16 12 28 60 32 72`\n\n  B `2 16 5 28 12 60 32 72`\n\n  C `2 12 16 5 28 32 72 60 `\n\n  D `5 2 12 28 16 32 72 60`\n\n  > 每经过一趟快排，轴点元素都必然就位。也就是说，一趟下来至少有1个元素在其最终位置。所以考察各个选项，看有几个元素就位即可。\n  >\n  > 最终排序位置是：**2, 5, 12, 16, 28, 32, 60, 72**，而选项中正确的位置有：\n  >\n  > A. 5, 2, 16, 12, <font color='red'>28</font>, 60, 32, <font color='red'>72</font>\n  >\n  > B. <font color='red'>2</font>, 16, 5, 28, 12, 60, 32, <font color='red'>72</font>\n  >\n  > C. <font color='red'>2</font>, 12, 16, 5, <font color='red'>28</font>, <font color='red'>32</font>, 72, 60\n  >\n  > D. 5, 2, <font color='red'>12</font>, 28, 16, <font color='red'>32</font>, 72, 60\n  >\n  > 第一趟排序，确定一个元素位置\n  >\n  > 第二趟排序，又确定一个或两个元素位置\n  >\n  > - 当第一趟元素确认的位置为最左或最右时，第二趟排序**只能确认一个**位置（A，B选项情况）\n  > - 当第一趟元素确认位置不是最左或最右时，第二趟**能确认2个**位置（C选项情况）\n  >\n  > 所以，两趟排序共确认2或3个元素位置。\n\n- 综合题 【2016】已知由n(n>=2)个正整数构成的集合A={ak|0<=k<n},将其划分为两个不相交的子集A1和 A2，元素个数分 别是 n1和 n2，A1和 A2中元素之和分别为 S1和 S2。设计一个尽可能高效的划分算法，满足|n1-n2|最小且|S1-S2|最大。要求： \n\n  （1）给出算法的基本设计思想。 \n\n  （2）根据设计思想，采用 C 或 C++语言描述算法，关键之处给出注释。 \n\n  （3）说明你所设计算法的平均时间复杂度和空间复杂度。\n\n  > (1)将最小的⌊n/2⌋个元素放在A1中，其余的元素放在A2中，划分满足要求。不需要对全部元素进行排序，可以仿照快速排序的思想，基于枢轴将n个整数划分为两个子集。然后将划分后的枢轴位置i进行以下处理：\n  >\n  > 1）若i=⌊n/2⌋，则划分结束。\n  >\n  > 2）若i<⌊n/2⌋，则枢轴及之前的所有元素均属于A1，继续对i之后的元素进行划分。\n  >\n  > 3）若i>⌊n/2⌋，则枢轴及之后的所有元素均属于A2，继续对i之前的元素进行划分。\n  >\n  > (2)\n  >\n  > ```C\n  > int setPartition(int a[],int n){\n  >  int pivotkey,low=0,low0=0,high=n-1,high0=n-1,flag=1,k=n/2,i;\n  >  int s1=0,s2=0;\n  >  while(flag){\n  >      pivotkey=a[low]; //选择枢轴\n  >      while(low<high){  //基于枢轴对数据记性划分\n  >          while(low<high && a[high]>=pivotkey) --high;\n  >          if(low!=high) a[low]=a[high];\n  >          while(low<high && a[low]<=pivotkey) ++low;\n  >          if(low!=high) a[high]=a[low];\n  >      }\n  >      a[low]=pivotkey;\n  >      if(low==k-1) //若枢轴是第n/2个元素，划分成功\n  >      flag=0；\n  >      else if(low<k-1){\n  >          low0=++low;\n  >          high=high0;\n  >      }else{\n  >          high0=--high;\n  >          low=low0;\n  >      }\n  >  } \n  >  for(i=0;i<k;i++) s1+=a[i];\n  >  for(i=k;i<n;i++) s2+=a[i];\n  >  return s2-s1;\n  > }\n  > ```\n  >\n  > (3)算法的平均时间复杂度为O(n),空间复杂度为O(1).\n\n\n## 8.4 选择排序\n\n### 简单选择排序\n\n#### 算法思想\n\n每一趟在待排序元素中选取关键字最小的元素加入有序子序列。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-80.png\" style=\"zoom:80%;\" />\n\n刚开始所有元素都是无序排列的。\n\n第一趟扫描，我们会找到所有元素中最小的那个元素，显然`13`是最小的。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-81.png\" style=\"zoom:80%;\" />\n\n之后，我们会把最小的元素与最前面的元素进行交换。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-82.png\" style=\"zoom:80%;\" />\n\n那这样的话，接下来我们就不需要再管最前面那个位置了。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-83.png\" style=\"zoom:80%;\" />\n\n第二趟的排序，一样的。我们要从头到尾扫描各个元素，找到关键字的值最小的一个，然后把它与最前面元素交换。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-84.png\" style=\"zoom:80%;\" />\n\n这是第二趟排序。\n\n接下来，`13`和`27`的位置就确定了，不用管了，继续对后面的序列进行相同的处理。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-85.png\" style=\"zoom:80%;\" />\n\n第三趟略。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-86.png\" style=\"zoom:80%;\" />\n\n第四趟，此时最小的是`49`，但是有两个49。实际上，经过选择排序，我们会将第一个`49`交换到头部的位置。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-87.png\" style=\"zoom:80%;\" />\n\n接下来的过程略\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-88.png\" style=\"zoom:80%;\" />\n\n最后只剩下一个待排序元素。它肯定不需要再进行排序操作了。而且它一定是最大的一个。\n\n因此，n个元素的简单选择排序需要n-1趟处理。\n\n#### 算法实现\n\n```C\n//简单选择排序\nvoid SelectSort(int A[], int n) {\n\tfor(int i=0; i<n-1; i++){\t\t//一共进行n-1趟 \n\t\tint min = i;\t\t\t//记录最小元素位置 \n\t\tfor(int j=i+1; j<n; j++){\t//在A[i...n-1]中选择最小的元素 \n\t\t\tif(A[j] < A[min])\n\t\t\t\tmin = j;\t\t//更新最小元素位置 \n\t\t}\n\t\tif(min ! = i)\n\t\t\tswap(A[i], A[min]);\t//交换最小元素至最头处 \n\t}\n}\n//交换\nvoid swap(int &a, int &b) {\n\tint temp = a;\n\ta = b;\n\tb = temp;\n} \n```\n\n> 用 i 指向当前待排序序列的最开头的位置；\n>\n> 然后用 j 依次扫描其中的各个元素，找到关键字的值最小的一个。\n>\n> 接下来把通过 j 找到的那个最小的元素，放到 i 所指的位置。\n\n#### 算法性能分析\n\n##### 空间复杂度\n\n**空间复杂度：O(1)**\n\n> 空间复杂度，只是存放一些变量占用的空间。\n\n##### 时间复杂度\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-89.png\" style=\"zoom:80%;\" />\n\n对于这三个序列，我们可以看出。\n\n无论是有序、逆序，还是乱序，一定都必须经过n-1趟处理。\n\n而且总共需要对比关键字的次数为`(n-1)+(n-2)+...+1 = n(n-1)/2`次。\n\n元素交换次数 < n-1。\n\n**时间复杂度：O(n²)**\n\n##### 稳定性\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-90.png\" style=\"zoom:80%;\" />\n\n稳定性:在第i趟找到最小元素后，和第i个元素交换，可能会导致第i个元素与其含有相同关键字元素的相对位置发送改变。例如上图的序列，第一趟和最终的序列一样，显然2与**2**的相对次序已经发生变化。<font color='orange'>因此简单选择排序是一种不稳定的排序方法</font>。\n\n#### 总结\n\n**简单选择排序**\n\n- 算法原理\n  - 每一趟在待排序元素中选取关键字最小的元素加入有序子序列\n  - 必须进行总共n-1趟处理\n- 性能\n  - 空间复杂度：O(1)\n  - 时间复杂度：O(n²)\n  - 稳定性：不稳定\n  - 适用性：顺序表、链表都可以\n\n### 堆排序\n\n> 堆排序比较难理解，但同时也是考察频率较高的一个算法。\n>\n> 这种算法的实现，也是和选择排序核心思想一样的，但是它是基于一种“堆”的结构。\n\n#### 什么是堆(Heap)?\n\n若n个关键字序列L[1…n]满足下面某一条性质，则称为**堆**（Heap）：\n\n①若满足：L(i) ≥ L(2i) 且 L(i) ≥ L(2i + 1)，（1 ≤ i ≤ n/2）——**大根堆（大顶堆）** 根大于左右结点\n\n②若满足：L(i) ≤ L(2i) 且 L(i) ≤ L(2i + 1)，（1 ≤ i ≤ n/2）——**小根堆（小顶堆）** 根小于左右结点\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-91.png\" style=\"zoom: 67%;\" />\n\n> 只看定义，其实看不出来什么。\n\n我们来回顾一下，**二叉树的顺序存储**。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-92.png\" style=\"zoom:80%;\" />\n\n对于一棵二叉树，我们按照层序，将其依次存入数组中，那么对于数组下标 i ，我们可以确定各个结点的位置，以及各个结点直接的逻辑关系。\n\n此时，再回到堆这里。\n\n对于堆，从物理视角上来看，它是一片连续的数据元素。但是从逻辑的视角来看，它实际上是一棵完全二叉树。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-93.png\" style=\"zoom: 67%;\" />\n\n编号为1的结点就是这个树的根结点。\n\n而下标为 i 的结点，它的左孩子下标应该是 2i，右孩子下标应该是 2i+1。\n\n此外，当1 ≤ i ≤ n/2 时，这个结点一定是分支结点。\n\n所以，什么是**大根堆**呢：**完全二叉树中，根 ≥ 左、右**。\n\n> 在一棵完全二叉树中，对于任何一个子树，它的根结点都大于左、右子树中的所有结点的值。这样的一棵完全二叉树，就是一个大根堆。\n>\n> 可以和BST（二叉排序树）：左 ≤ 根 ≤ 右，进行一个对比。\n\n相应的，**小根堆**就是：**完全二叉树中，根 ≤ 左、右**。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-94.png\" style=\"zoom: 67%;\" />\n\n> 此时，我们已经知道了，什么是“堆”。接下来我们来看，如何利用堆，来实现排序。\n\n#### 如何基于堆进行排序\n\n> 首先，堆排序，它是属于选择排序中的一种。\n>\n> 而选择排序的基本思想是，它会在每一趟，在待排序元素中选取关键字最小（或）最大的元素加入有序子序列。\n\n那么，如果我们有一个大根堆，那么，我们在这个大根堆当中，选取关键字最大的元素，就变得非常的方便。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-95.png\" style=\"zoom: 67%;\" />\n\n对于大根堆来说，肯定是堆顶的关键字的值是最大的。\n\n如果从数组的视角来看，那么肯定是第一个元素的值是最大的。\n\n也就是说，对于一个数组，如果我们能够把它整理成“堆”这种形式，接着我们进行选择排序就会变得很简单了。\n\n> 所以接下来我们要探讨的问题是，对于一个给定的初试序列，我们如何把它建立成大根堆。\n\n#### 建立大根堆\n\n> 对于一个给定的初试序列，我们如何把它建立成大根堆，也就是具有`根 ≥ 左、右`这样一种形态。\n>\n> 也就是，保证所有子树的根结点都比它的左右孩子更大。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-96.png\" style=\"zoom: 60%;\" />\n\n既然我们要保证所有子树的根结点，都要比它的左右孩子更大。\n\n那么我们只需要检查这棵树中所有的分支节点，因为所有的分支结点，都是它所属的子树的根结点。\n\n因此，接下来我们要做的事情就是，**把所有非终端结点都检查一遍，是否满足大根堆的要求，如果不满足，则进行调整**。\n\n之前我们也说了，对于顺序存储的完全二叉树，**非终端结点编号`i ≤ ⌊n/2⌋`**。\n\n在这个例子中，n=8，也就是我们要检查 i ≤ 4 的所有结点。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-97.png\" style=\"zoom: 45%;\" />\n\n接下来，我们会从后往前地，依次来处理各个结点。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-98.png\" style=\"zoom:80%;\" />\n\n第一个被处理的，是4号结点，这个结点是所有分支结点中编号最大的一个。\n\n> 我们可以利用之前学过的，完全二叉树顺序存储的特性，根据下标，来找到它的左孩子和右孩子。\n>\n> - i 的左孩子：2i\n> - i 的右孩子：2i + 1\n> - i 的父节点：⌊i/2⌋\n\n对于这个根结点，它只有一个左孩子，而它的这个左孩子是比它要大的，不满足大根堆的特性，所以我们要进行调整。\n\n调整的方式就是，**将当前结点与它更大的那个孩子互换**。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-99.png\" style=\"zoom:80%;\" />\n\n此时就处理完毕，满足了大根堆的要求。接下来，我们处理下一个元素，3号结点`78`。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-100.png\" style=\"zoom: 80%;\" />\n\n它的右孩子比它大，不符合大根堆的特性，所以也需要调整。调整的方法就是，把当前结点，与它的值更大的孩子互换。即78和87互换。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-101.png\" style=\"zoom:80%;\" />\n\n处理下一个节点，2号节点`17`。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-102.png\" style=\"zoom:80%;\" />\n\n当前结点比它的左右孩子都要更小，不符合大根堆的特性，所以需要把当前结点和它更大的那个孩子互换。即`17`和`45`互换。\n\n> 为什么要和更大的那个孩子互换呢？\n>\n> 因为，如果不把更大的那个孩子互换，换上去之后依然不符合大根堆的特性。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-103.png\" style=\"zoom:80%;\" />\n\n最后，处理1号结点`53`。它的右孩子要更大，所以需要把它和它的右孩子互换。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-104.png\" style=\"zoom:80%;\" />\n\n但是，现在问题发生了：我们把更小的结点`53`“下坠”到下一层之后，又导致了以53为根的这棵子树不符合大根堆的要求。\n\n怎么办呢？和之前的处理方式是一样的。我们把这个元素继续往下调整。把它和它更大的孩子交换。即将`53`和`78`互换。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-105.png\" style=\"zoom:80%;\" />\n\n此时，小元素`53`不需要继续下坠了，即为调整完成。\n\n> `53`这个元素，从第一层，下坠了两次，直接落在了第三层。这个过程是一个**小元素不断下坠**的过程。（自己取的叫法，不是术语）\n\n#### 建立大根堆算法实现\n\n刚才我们用手算实现了大根堆的建立，接下来看看代码该怎么实现。\n\n```C\n//建立大根堆\nvoid BuildMaxHeap(int A[], int len) {\n\tfor(int i=len/2; i>0; i--){\t\t//从后往前调整所有非终端结点 \n\t\tHeadAdjust(A, i, len);\n\t}\n}\n//将以k为根的子树调整为大根堆\nvoid HeadAdjust(int A[], int k, int len) {\n\tA[0] = A[k];\t\t//A[0]暂存子树的根结点 \n\tfor(int i=2*k; i<=len; i*=2){\t//沿key较大的子节点向下筛选 \n\t\tif(i < len && A[i] < A[i+1])//确保当前有右孩子\n\t\t\ti++;\t\t//取key较大的子节点的下标 \n\t\tif(A[0] >= A[i]) break;\t\t//筛选结束\n\t\telse{\n\t\t\tA[k] = A[i];\t//将A[i]调整到双亲结点上 \n\t\t\tk = i;\t\t//修改k值，以便继续向下筛选 \n\t\t} \n\t}\n\tA[k] = A[0];\t\t//被筛选结点的值放入最终位置 \n}\n```\n\n> 前边几轮处理，都是较简单的处理，不再赘述。此处分析一下处理最后一个元素`53`时的具体过程。\n>\n> 其中`len`为整个表的长度。\n>\n> ```c\n> if(i < len && A[i] < A[i+1])\n> \ti++;\t\t//取key较大的子节点的下标 \n> ```\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-288.png\" style=\"zoom: 55%;\" />\n>\n> 它的意思是，由于 i = 2*k，i 指向了当前根结点的左孩子，然后比较`A[i] < A[i+1]`，即看一下右孩子是否更大，若右孩子更大，则i++，使指针 i 指向右孩子处，此时A[i]是左右孩子中较大的那个。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-289.png\" style=\"zoom: 55%;\" />\n>\n> 至于为什么要判断 i < len，是因为，若不符合这个条件，根结点的左孩子是不存在右兄弟的。\n>\n> ```c\n> if(A[0] >= A[i])  break; //筛选结束\n> ```\n>\n> 由于A[0]存放的是根结点的值，若A[0] >= A[i]，则是满足根比左右孩子都大的条件的。所以筛选结束，跳出这一轮循环，也就是当前这个根结点是不需要处理的。\n>\n> ```C\n> else{\n> A[k] = A[i];\t//将A[i]调整到双亲结点上 \n> k = i;\t\t//修改k值，以便继续向下筛选 \n> } \n> ```\n>\n> 若不满足A[0] >= A[i]，即左右孩子中较大的那个，比根结点的值还要大。那么就需要将A[i]换到此时的根结点A[k]。\n>\n> 接下来，由于我们不能确定这个值较小的根结点“下坠”后，是否满足大根堆的要求，因此需要看看它交换后，是否满足大根堆的特性。所以令 k = i，即将根结点指向刚刚的较大孩子处，再执行下一轮的for循环。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-106.png\" style=\"zoom:67%;\" />\n>\n> 这也是为什么for循环的第三个语句是`i*=2`，这是为了将指针接着指向下一处左孩子。\n>\n> 在将53假设放在上图空白处后（为什么说是假设放在，是因为还没有最终确认53的位置），执行一次循环。发现还需要将之与其更大的孩子78互换。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-107.png\" style=\"zoom:80%;\" />\n>\n> 也就是之前说的“小元素下坠”的一个处理。\n>\n> 继续 i *= 2，再次执行一次for循环，由于此时 i 的值已经超过了 len ，说明此时根结点 k 已经没有左右孩子了。(也就是不满足 i <= len了，for循环终止)\n>\n> 然后就可以执行`A[k] = A[0];`，即将最开始的那个子树根结点插入到最终得到的 k 处。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-108.png\" style=\"zoom: 67%;\" />\n\n#### 基于大根堆进行排序\n\n> 我们此时已经有一个大根堆了。（见上面这张图）\n\n> 选择排序：每一趟在待排序元素中选取关键字最大的元素加入有序子序列。\n>\n> 堆排序：每一趟将堆顶元素加入有序子序列（与待排序序列中的最后一个元素交换）\n\n我们每一趟将堆顶元素，也就是整个序列最大的元素拿出来，和末尾元素交换。也就是把`87`和`9`互换，如下。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-109.png\" style=\"zoom: 80%;\" />\n\n并且，从此以后`87`这个元素的位置就最终确定下来了，不需要改变了。(二叉树中，连接87的部分标为了虚线)\n\n接下来，我们再进行处理，只需要对除了`87`外，前面这个堆进行排序。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-110.png\" style=\"zoom: 80%;\" />\n\n而由于刚才`9`被换到了堆顶，此时显然这个堆不是一个大根堆。\n\n所以我们需要对`9`这个元素进行一个“下坠”的调整。\n\n> 即调用`void HeadAdjust(int A[], int k, int len)`，注意此时len变为7了。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-111.png\" style=\"zoom:80%;\" />\n\n调整结束。此时待排序元素序列再次构成一个大根堆。\n\n此时我们完成了**第一趟**的处理。\n\n> 在第一趟处理中，我们把最大的元素（堆顶元素）换到了末尾，同时把剩余元素重新调整成了一个大根堆。\n\n接下来进行**第二趟**的处理。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-112.png\" style=\"zoom: 80%;\" />\n\n将堆顶元素与末尾元素互换，即78和53互换。同时，78确定了最终位置，往后不再考虑。\n\n此时，由于53被换到了堆顶，不符合大根堆的特性，所以需要调整，令53不断下坠。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-113.png\" style=\"zoom: 80%;\" />\n\n\n\n53需要和它的右孩子互换，且此时53比左孩子更大（此时53是没有右孩子的，因为右孩子已经被排除在外了）。因此下坠完毕。第二趟结束。\n\n中间趟数的处理方法同理，不再赘述，直接看最后两趟。\n\n**第六趟开始时**，如图所示：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-114.png\" style=\"zoom:80%;\" />\n\n将堆顶元素与堆底元素互换，即`32`与`9`互换。并且互换后，还需要将9下坠，再次构成大根堆，才能进行第七趟处理。\n\n**第七趟开始**，如下：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-115.png\" style=\"zoom:80%;\" />\n\n堆顶元素与堆底元素互换，且堆顶元素换到堆底后不再参与处理。那么，此时只剩下最后一个待排序元素。此时就不用继续处理了。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-116.png\" style=\"zoom: 80%;\" />\n\n最后，排序结果如下。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-117.png\" style=\"zoom:80%;\" />\n\n可见，我们在经过n-1趟处理之后，就得到了一个递增序列。\n\n> 我们刚才是基于**大根堆**进行的排序，最终得到的是**递增序列**；\n>\n> 如果是基于**小根堆**，原理是一样的，但是得到的是**递减序列**。\n\n#### 基于大根堆进行排序(代码)\n\n弄清楚怎么用大根堆进行排序后，看一看如何用代码实现。\n\n```C\n//建立大根堆\nvoid BuildMaxHeap(int A[], int len) {\n\tfor(int i=len/2; i>0; i--){\t\t//从后往前调整所有非终端结点 \n\t\tHeadAdjust(A, i, len);\n\t}\n}\n//将以k为根的子树调整为大根堆\nvoid HeadAdjust(int A[], int k, int len) {\n\tA[0] = A[k];\t\t//A[0]暂存子树的根结点 \n\tfor(int i=2*k; i<=len; i*=2){\t//沿key较大的子节点向下筛选 \n\t\tif(i < len && A[i] < A[i+1])\n\t\t\ti++;\t\t//取key较大的子节点的下标 \n\t\tif(A[0] >= A[i])\n\t\t\tbreak;\t\t//筛选结束\n\t\telse{\n\t\t\tA[k] = A[i];\t//将A[i]调整到双亲结点上 \n\t\t\tk = i;\t\t//修改k值，以便继续向下筛选 \n\t\t} \n\t}\n\tA[k] = A[0];\t\t//被筛选结点的值放入最终位置 \n}\n//堆排序的完整逻辑\nvoid HeapSort(int A[], int len) {\n\tBuildMaxHeap(A, len);\t\t//初始建堆\n\tfor(int i=len; i>1; i--){\t//n-1趟的交换和建堆过程\n\t\tswap(A[i], A[1]);\t//堆顶元素和堆底元素交换\n\t\tHeadAdjust(A, 1, i-1);\t//把剩余的待排序元素整理成堆\t\t\n\t} \n}\n```\n\n首先要将一个顺序存储的数组建立为一个堆。\n\n之后对这个建好的堆进行一次排序，并且在一次排序后，把剩下的待排序元素重新整理成堆。\n\n#### 算法性能分析\n\n堆排序：①建堆；②栈顶栈底互换；③重新整理成堆(下坠调整)\n\n对于建堆操作，其中也包含了下坠调整的操作；对于排序操作，也包含下坠调整操作\n\n##### 建堆的过程\n\n所以我们必须分析清楚，下坠调整的算法效率。\n\n```C\n//建立大根堆\nvoid BuildMaxHeap(int A[], int len) {\n\tfor(int i=len/2; i>0; i--){\t\t//从后往前调整所有非终端结点 \n\t\tHeadAdjust(A, i, len);\n\t}\n}\n//将以k为根的子树调整为大根堆\nvoid HeadAdjust(int A[], int k, int len) {\n\tA[0] = A[k];\t\t//A[0]暂存子树的根结点 \n\tfor(int i=2*k; i<=len; i*=2){\t//沿key较大的子节点向下筛选 \n\t\tif(i < len && A[i] < A[i+1])\n\t\t\ti++;\t\t//取key较大的子节点的下标 \n\t\tif(A[0] >= A[i]) break;\t\t//筛选结束\n\t\telse{\n\t\t\tA[k] = A[i];\t//将A[i]调整到双亲结点上 \n\t\t\tk = i;\t\t//修改k值，以便继续向下筛选 \n\t\t} \n\t}\n\tA[k] = A[0];\t\t//被筛选结点的值放入最终位置 \n}\n```\n\n对于根结点 k 来说，每层for循环，需要进行一次对比操作（A[i] < A[i+1]），即对比其左右孩子谁更大；之后再进行一次对比（A[0] >= A[i]），即对比根结点是否比更大孩子的值大。\n\n所以对于一个有两个孩子的根结点，它每往下下坠一层，都要进行2次关键字的对比。\n\n若某个根结点只有左孩子、没有右孩子，则说明它的左孩子下标刚好等于表长，那么就不满足`i < len`的条件，因此不需要对比左右孩子的关键字。\n\n> **结论**:\n>\n> 一个结点，每“下坠”一层，最多只需对比关键字2次。\n>\n> 若树高为h，某结点在第 i 层，则将这个结点向下调整，最多只需要“下坠” `h-i` 层，关键字对比次数不超过 `2(h-i)`。\n>\n> **n个结点的完全二叉树**，它的树高 `h = ⌊log₂n⌋ + 1`。\n>\n> 第 i 层最多有`2^(i-1)`个结点，而只有第`1~(h-1)`层的结点才有可能需要“下坠”调整。\n\n$$\n第一层:1个结点，需要进行2^0*(h-1)次下坠\n$$\n\n$$\n第二层:2^1个结点，需要进行2^1*(h-2)次下坠\n$$\n\n$$\n第(h-1)层:2^{h-2}个结点，需要进行2^{h-2}*1次下坠\n$$\n\n所以，将整棵树调整为大根堆，每一层的下坠次数之和，再乘2，就是需要对比关键字的最大次数。\n\n将整棵树调整为大根堆，关键字对比次数不超过:\n$$\n\\sum_{i=h-1}^{1}{2^{i-1}2(h-i)}=\\sum_{i=h-1}^{1}{2^i(h-i)}=\\sum_{j=1}^{h-1}{2^{h-j}j}<=2n\\sum_{j=1}^{h-1}{\\frac{j}{2^j}}<=4n\n$$\n\n$$\n(其中，h=\\lfloor log_2n \\rfloor+1,代入)\n$$\n\n> 对于化简到最后一步的和式(即4n前面那个)，它是一个差比数列求和，用到的是错位相减法。(高考考的经典题型)\n\n**建堆的过程，关键字对比次数不超过4n，建堆时间复杂度 = `O(n)`**。\n\n> 如果想偷懒的话，前面推理的过程可以不用记，把结论记住也可以。\n\n##### 排序的过程\n\n```C\n//堆排序的完整逻辑\nvoid HeapSort(int A[], int len) {\n\tBuildMaxHeap(A, len);\t\t//初始建堆\n\tfor(int i=len; i>1; i--){\t//n-1趟的交换和建堆过程\n\t\tswap(A[i], A[1]);\t//堆顶元素和堆底元素交换\n\t\tHeadAdjust(A, 1, i-1);\t//把剩余的待排序元素整理成堆\t\t\n\t} \n}\n```\n\n> 我们已经知道，建堆的过程，即`BuildMaxHeap(A, len);`，其时间复杂度为O(n)。\n>\n> 接下来看排序的过程。\n\n排序的过程，总共需要n-1趟，而每一趟交换后都需要将根结点“下坠”调整。\n\n这个”下坠“，最多只会下坠h-1层，而每下坠一层，最多只需对比关键字2次。\n\n因此每一趟排序，时间复杂度不超过<font color='cornflowerblue'>O(h) = O(log₂n)</font>。\n\n共n-1趟，总的时间复杂度 =<font color='cornflowerblue'>O(nlog₂n)</font>。\n\n##### 堆排序结论\n\n因此，一次完整的堆排序，我们需要O(n)的时间来建堆，还需要O(nlog₂n)的时间来进行排序。\n\n堆排序的时间复杂度 = <font color='cornflowerblue'>O(n) + O(nlog₂n) = O(nlog₂n)</font>。\n\n堆排序的空间复杂度 = <font color='cornflowerblue'>O(1)</font>。\n\n##### 稳定性\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-118.png\" style=\"zoom:80%;\" />\n\n对于这个初始序列，我们要建立大根堆。\n\n由于根结点`1`没有左右孩子大，所以需要调整，将孩子中更大的那个换上来。\n\n但是左右孩子一样大，那么把哪个换上来呢？\n\n看一下这个代码的逻辑：\n\n```C\n//建立大根堆\nvoid BuildMaxHeap(int A[], int len) {\n\tfor(int i=len/2; i>0; i--){\t\t//从后往前调整所有非终端结点 \n\t\tHeadAdjust(A, i, len);\n\t}\n}\n\n//将以k为根的子树调整为大根堆\nvoid HeadAdjust(int A[], int k, int len) {\n\tA[0] = A[k];\t\t//A[0]暂存子树的根结点 \n\tfor(int i=2*k; i<=len; i*=2){\t//沿key较大的子节点向下筛选 \n\t\tif(i < len && A[i] < A[i+1])\n\t\t\ti++;\t\t//取key较大的子节点的下标 \n\t\tif(A[0] >= A[i])\n\t\t\tbreak;\t\t//筛选结束\n\t\telse{\n\t\t\tA[k] = A[i];\t//将A[i]调整到双亲结点上 \n\t\t\tk = i;\t\t//修改k值，以便继续向下筛选 \n\t\t} \n\t}\n\tA[k] = A[0];\t\t//被筛选结点的值放入最终位置 \n}\n```\n\n<font color='orange'>注意其中的判断条件</font>：\n\n```C\nif(i < len && A[i] < A[i+1])\n    i++;\t\t//取key较大的子节点的下标 \n```\n\ni 这个指针首先指向左孩子，i+1 指向右孩子。\n\n那么，按照这个代码逻辑，只有右孩子的值比左孩子的值更大的时候，我们才会让 i 指向右孩子。\n\n也就是说，如果左孩子和右孩子相等的话，我们不会让 i++，更大的孩子仍是左孩子。\n\n**若左右孩子一样大，则优先和左孩子交换。**\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-119.png\" style=\"zoom:80%;\" />\n\n此时我们已经完成了建堆的工作。接下来需要进行堆排序。\n\n```C\n//堆排序的完整逻辑\nvoid HeapSort(int A[], int len) {\n\tBuildMaxHeap(A, len);\t\t//初始建堆\n\tfor(int i=len; i>1; i--){\t//n-1趟的交换和建堆过程\n\t\tswap(A[i], A[1]);\t//堆顶元素和堆底元素交换\n\t\tHeadAdjust(A, 1, i-1);\t//把剩余的待排序元素整理成堆\t\t\n\t} \n}\n```\n\n把堆顶元素与堆底元素交换。且此时剩余的元素依然是一个大根堆，不需要调整。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-120.png\" style=\"zoom:80%;\" />\n\n直接进行第二趟排序。同样地，堆顶元素与堆底元素互换。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-121.png\" style=\"zoom:80%;\" />\n\n现在已经进行了n-1趟的排序，而且显然也已经排序结束了。\n\n由于初始序列为：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-122.png\" style=\"zoom:80%;\" />\n\n到此，我们可以得出结论，堆排序是**不稳定**的。\n\n#### 总结\n\n**堆排序**\n\n- 堆\n  - 顺序存储的“完全二叉树”\n    - 结点 i 的左孩子是 2i；右孩子是 2i+1；父节点是 i/2\n    - 编号 ≤ n/2 的结点都是分支结点\n  - 大根堆（根 ≥ 左、右）；小根堆（根 ≤ 左、右）\n- 算法思想（以大根堆为例）\n  - 建堆\n    - 编号 ≤ n/2 的所有结点依次“下坠”调整（自底向上处理各分支结点）\n    - 调整规则：小元素逐层“下坠”（与关键字更大的孩子交换）\n  - 排序\n    - 将堆顶元素加入有序子序列（堆顶元素与堆底元素交换）\n    - 堆底元素换到堆顶后，需要进行“下坠”调整，恢复“大根堆”的特性\n    - 上述过程重复n-1趟\n- 空间复杂度：O(1)\n- 时间复杂度：建堆O(n)、排序O(nlog₂n)；总的时间复杂度 = O(nlog₂n)\n- 稳定性：不稳定\n- 基于大根堆的堆排序得到的是“递增序列”；基于小根堆的堆排序得到的是“递减序列”\n\n> 内容确实比较多，也不算好理解的。\n>\n> 考试喜欢考堆排序，因为它顺道还考察了很多二叉树的知识。\n>\n> 所以对堆排序的理解，是很考验综合能力的。\n\n<font color='green'>关于小根堆的建堆和排序，自己可以了解并练习一下</font>\n\n### 堆的插入删除\n\n#### 在堆中插入新元素\n\n> 给你一个大根堆或小根堆，你要往这个堆里面插入一个新的元素或者删除元素，应该怎么做呢？\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-123.png\" style=\"zoom: 67%;\" />\n\n假设我们新插入的元素为`13`。首先，这个新插入的元素我们把它放到表尾的位置。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-124.png\" style=\"zoom: 67%;\" />\n\n从逻辑视角来看，我们把它放到了堆底。\n\n原本我们是一个小根堆，但是在插入了新元素`13`之后，就破坏了原来的小根堆。小根堆要求，根结点要小于等于左、右孩子。\n\n<font color='cornflowerblue'>那怎么办呢？</font>我们需要做的是，把这个元素与它的父节点相比，如果新元素更小，则将二者互换。\n\n我们的新元素在表尾的位置，而找到它的父节点很简单。\n\n> i 的左孩子——2i\n>\n> i 的右孩子——2i+1\n>\n> i 的父节点——⌊i/2⌋\n\n新结点`13`存放下标为9，而`⌊9/2⌋ = 4`，因此它的父节点存放位置为4，即`32`这个元素。\n\n找到父节点一比较，发现13 < 32，13比它的父节点更小，所以要将`13`**上升**一层。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-125.png\" style=\"zoom: 67%;\" />\n\n到了这层，我们还不能停止，还要继续与它的父节点进行比较。`13`同样比它的父节点`17`更小，所以同样也需要把它俩互换，让`13`**继续上升**。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-126.png\" style=\"zoom: 67%;\" />\n\n到了这一步，同样需要把`13`和它的父节点`9`进行对比。而13>9，所以到这一步时，就已经符合了小根堆的特性要求，所以`13`无法继续上升。\n\n> 对于**小根堆**，新元素放在表尾，与父节点相比，若**新元素**比父节点**更小**，则二者互换。新元素就这样一路“**上升**”，直到无法继续上升为止。\n\n对比关键字的次数：3次。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-127.png\" style=\"zoom: 67%;\" />\n\n接下来，再插入一个新元素`46`。新元素放在表尾，也就是堆底的位置。然后尝试着让`46`上升。\n\n发现46的父节点45更小，因此是无法上升的。所以46待在此处就可以。\n\n对比关键字的次数：1次。\n\n#### 在堆中删除元素\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-128.png\" style=\"zoom: 67%;\" />\n\n假设我们要删除的元素是`13`这个元素。那么，把13删除之后。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-129.png\" style=\"zoom: 67%;\" />\n\n这个位置就空了。怎么处理呢？我们会用堆底的元素来代替这个被删除的元素。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-130.png\" style=\"zoom: 67%;\" />\n\n即，让`46`移到之前`13`存储的位置。\n\n现在，为了让这个整体，恢复成小根堆该有的特性，所以我们需要做的事情，是让`46`这个元素不断**下坠**，直到无法下坠为止。\n\n由于小根堆要求更小的元素在上面，所以我们要把`46`的更小的孩子和它交换。也就是将46和17互换。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-131.png\" style=\"zoom: 67%;\" />\n\n到这一步后，还要和它的下一层孩子进行对比，使更小的孩子和它互换。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-132.png\" style=\"zoom: 67%;\" />\n\n到此，`46`已经无法继续下坠了。\n\n对比关键字的次数：4次。（对比两个孩子谁更小、对比父节点和较小的孩子谁更小，各算一次对比）\n\n> 其实考试还是会经常考察，问你“对比关键字的次数”的。\n\n> 上一节当中，我们说过，如果一个父节点下面有两个孩子，则需要进行关键字的对比2次，一次是两个孩子的对比，一次是根结点和孩子结点的对比。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-133.png\" style=\"zoom:80%;\" />\n>\n> 而如果说，下方只有一个孩子，则无需进行两个孩子的对比，而只需对比1次关键字。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-134.png\" style=\"zoom: 67%;\" />\n>\n> 因此，在考虑下坠过程中，关键字的对比次数的问题，这个细节一定要注意。\n\n接下来，如果我们继续删除，删除`65`这个元素。删除之后，同样地，我们会将栈底元素去替代它。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-135.png\" style=\"zoom:80%;\" />\n\n会让`46`挪到下标为3的位置。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-136.png\" style=\"zoom:80%;\" />\n\n接下来，会让`46`进行**下坠**的调整。\n\n但是会发现，`46`下面的两个关键字都要比它更大，所以46已经无法再下坠了。\n\n对比关键字的次数：2次。（第一次，是将左右孩子进行对比，选出一个更小的孩子；第二次，是将根结点与更小的孩子进行对比）\n\n#### 总结\n\n**堆**\n\n- 插入\n  - 新元素放到表尾（堆底）\n  - 根据大/小根堆的要求，新元素不断“上升”，直到无法继续上升为止\n- 删除\n  - 被删除元素用表尾（堆底）元素替代\n  - 根据大/小根堆的要求，替代元素不断“下坠”，直到无法继续下坠为止\n- 关键字对比次数\n  - 每次“上升”调整只需对比关键字1次\n  - 每次“下坠”调整可能需要对比关键字2次，也可能只需对比1次\n- 基本操作\n  - i 的左孩子 —— 2i\n  - i 的右孩子 —— 2i+1\n  - i 的父节点 —— ⌊i/2⌋\n\n### 习题\n\n- 【2009】已知关键字序列5，8，12，19，28，20，15，22是小根堆，插入关键字3，调整后得到的小根推是-->3，5，12，8，28，20，15，22，19\n\n  > 插入3，3换19再换8再换5\n\n- 【2011】已知序列 `25 13 10 12 9` 是大根堆，在序列尾部插入新元素18，将其再调整为大根堆，调整过程中元素之间进行的比较次数是 →2\n\n  > 把大根堆画成完全二叉树后，堆插入元素相当于是从最后面添加叶子节点18，先是18和10比较，18>10，将18与10对调，继续判断18与25的大小。 所以总共比较2次。\n\n- 【2015】已知小根堆为 `8 15 10 21 34 16 12` ，删除关键字 8 之后需重新建堆，再次过程中，关键字之间的比较次数是 →3 \n\n  > 叶结点 12 变为根结点，重新构建堆，第一次 15 和 10 比较，第二次 12 和 10 比较，交换 10 和 12，第三次 12 和 16 比较\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-137.png\" style=\"zoom:50%;\" />\n\n- 【2018】在将序列(6,1,5,9,8,4,7)建成大根堆时，正确的序列变化过程是-->A\n\n  A、6,1,7,9,8,4,5→6,9,7,1,8,4,5→9,6,7,1,8,4,5→9,8,7,1,6,4,5\n\n  B、6,9,5,1,8,4,7→ 6,9,7,1,8,4,5→9,6,7,1,8,4,5→9,8,7,1,6, 4,5\n\n  C、6,9,5,1,8,4,7→9,6,5,1,8,4,7→9,6,7,1,8,4,5→9,8,7,1,6,4,5\n\n  D、6,1,7,9,8,4,5→7,1,6,9,8,4,5→7,9,6,1,8,4,5→9,7,6,1,8,4,5→9,8,6,1,7,4,5\n\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-138.png\" style=\"zoom: 67%;\" />\n\n- 【2020】下列关于大根堆(至少含2个元素)的叙述中，正确的是-->C\n\n  I.可以将堆视为一棵完全二叉树\n\n  II.可以采用顺序存储方式保存堆\n\n  III.可以将堆视为一棵二叉排序树\n\n  IV. 堆中的次大值一定在根的下一层\n\n  A、仅I、II\n\n  B、仅II、III\n\n  C、仅I、II和IV\n\n  D、I、III和IV\n\n  > 这是一道简单的概念题。堆是一棵完全树，采用一维数组存储，故I正确，II 正确。大根堆只要求根结点值大于左右孩子值，并不要求左右孩子值有序，II 错误。堆的定义是递归的，所以其左右子树也是大根堆，所以堆的次大值一定是其左孩子或右孩子， IV正确。\n\n- 【2021】将关键字6,9,1,5,8,4,7依次插入到初始为空的大根堆H中，得到的H是->B\n\n  A、9,8,7,6,5,4,1\n\n  B、9,8,7,5,6,1,4\n\n  C、9,8,7,5,6,4,1\n\n  D、9,6,7,5,8,4,1\n\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-139.png\" style=\"zoom: 67%;\" />\n\n  \n","tags":["408数据结构"],"categories":["408数据结构"]},{"title":"第八章 排序(一)","url":"/p/27129/","content":"\n## 8.1 排序的基本概念\n\n### 排序的定义\n\n排序啥意思，就是字面意思 😆！比如原来数组的元素是`[1, 3, 2]`，排完序就是`[1, 2, 3]`，所谓排序，就是把n个关键字，按照递增或递减的顺序，把它们给重新排列一遍。\n\n**输入**:n个记录R1，R2,...,Rn，对应的关键字为k1,k2,...,kn。\n\n**输出**:输入序列的一个重排R1‘，R2’，...,Rn',使得有k1'<=k2'<=...<=kn'(也可递减)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-1.png\" style=\"zoom:67%;\" />\n\n### 排序的应用\n\n排序着有非常的应用。是生活中必不可少的算法。\n\n如王者荣耀战力\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-2.jpg\" style=\"zoom: 33%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-3.jpg\" style=\"zoom: 25%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-285.jpg\" style=\"zoom: 25%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-286.jpg\" style=\"zoom:33%;\" />\n\n### 排序算法的评价指标\n\n算法的**稳定性**。若待排序表中有两个元素Ri和Rj，其对应的关键字相同即keyi = keyj，且在排序前Ri在Rj的前面，若使用某一排序算法排序后，Ri仍在Rj的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-4.png\" style=\"zoom:67%;\" />\n\n> 稳定的：关键字相同的元素在排序之后相对位置不变。反之是不稳定的。\n\n**问：稳定的排序算法一定比不稳定的好？**\n\n答：不一定，要结合实际需求出发。例如实际场景对排序的稳定性没有要求，或者关键字根本就没有重复的，那么稳定不稳定都一样。\n\n### 排序算法的分类\n\n- 内部排序：数据都在内存中\n- 外部排序：数据太多，无法全部放入内存\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-5.png\" style=\"zoom: 70%;\" />\n\n所谓的内部排序，指的是我们可以把所有需要排序的数据，全部放到内存当中。比如说我们自己写的排序，我们自己定义一个数组之类的，其数据量不是很大，都是放在内存当中的。\n\n但是有的时候，我们又难免要遇到，我们需要排序的数据量很大，没有办法全部放入内存的情况。我们的外部磁盘的容量一般是很大的，而内存就小很多。比如我们现在有一个超大的文件，超过了8G，不可能将它一次性全部放入内存。那么这时，我们想对相关的数据进行排序，就只能采取一部分一部分处理这样的策略。对于一个内部排序，由于数据都在内存中，而内存又是一个很高速的设备，所以我们在设计排序算法的时候，我们会更多地关注这个算法的时间复杂度、空间复杂度是怎么样的。\n\n而当我们在设计外部排序算法的时候，除了这个算法的时间、空间复杂度之外，我们还需要关注，怎么追求更少的读写磁盘的次数。\n\n> 因为我们磁盘的读写速度很慢，比如对于一个机械硬盘来说，其读写速度在100MB/s左右。相比之下，我们内存读写的速度可以到60GB/s。\n>\n> 所以我们要将磁盘中的数据和内存之间进行读写，就会很慢。而数据一旦读入内存后，对数据的处理就不会消耗什么时间。\n>\n> 所以在设计外部排序的时候，我们也需要关注怎么使读写磁盘次数更少的问题。\n\n### 推荐\n\n接下来会介绍很多排序，光看代码挺无聊的，这里推荐一个很好玩的网站\n\n- https://visualgo.net/zh/sorting\n\n这是一个，先从感性上理解各种各样的排序网站 😉\n\n## 8.2 插入排序\n\n### 算法思想\n\n> 算法思想：每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-6.png\" style=\"zoom: 67%;\" />\n\n一开始会从第二个元素开始入手。\n\n我们会认为，当前这个元素之前的所有元素，是已经排好序的。\n\n我们现在需要将当前元素`38`，与之前元素依次进行对比，之前元素中比38大的，都要将之依次后移。\n\n49>38，所以49需要后移。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-7.png\" style=\"zoom: 67%;\" />\n\n接下来要处理的是`65`这个元素。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-8.png\" style=\"zoom: 67%;\" />\n\n而65>49，所以其之前的元素都不需要移动，直接把65放回来即可。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-9.png\" style=\"zoom: 67%;\" />\n\n接下来处理的是`97`，它比它前边的65还大，所以依然直接放回来。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-10.png\" style=\"zoom: 67%;\" />\n\n接下来要处理`76`这个元素。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-11.png\" style=\"zoom: 67%;\" />\n\n在76之前的这些元素是已经排好序的。我们从76依次往前检查，大于76的就后移一位。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-12.png\" style=\"zoom: 67%;\" />\n\n因此97需要后移一位，之后继续往前检查，65<76，则停止检查。并将76插入到65后面的位置。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-13.png\" style=\"zoom: 67%;\" />\n\n接下来要处理`13`这个元素。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-14.png\" style=\"zoom: 67%;\" />\n\n再其之前的元素依次检查，都比13要大，在检查到38并将其后移之后，再往前检查就没有元素了。所以13应该放入0号位置。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-15.png\" style=\"zoom: 67%;\" />\n\n接下来，27的处理方式是一样的。\n\n之后我们要处理49这个元素。最后一个49加一个下划线，是为了和前面的那个49作区分。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-16.png\" style=\"zoom: 67%;\" />\n\n处理的方法一样，我们要把其之前的排好序的序列中，大于49的元素依次后移一位，然后插入。结果如下。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-17.png\" style=\"zoom: 67%;\" />\n\n> 注意，我们是把比它更大的元素右移，而与之相等的元素是没有右移的。\n>\n> 这样可以保证算法的稳定性。\n\n### 算法实现\n\n```C\n//直接插入排序\nvoid InsertSort(int A[], int n) {\n\tint i, j, temp;\n\tfor(i = 1; i < n; i++){\t\t//将各元素插入已排好序的序列中 \n\t\tif(A[i] < A[i-1]){\t\t//若A[i]关键字小于前驱 \n\t\t\ttemp = A[i];\t\t//用temp暂存A[i] \n\t\t\tfor(j = i-1; j>=0 && A[j]>temp; --j){\t//检查所有前面已排好序的元素 \n\t\t\t\tA[j+1] = A[j];\t\t//所有大于temp的元素都向后挪位 \n\t\t\t}\n\t\t\tA[j+1] = temp;\t\t//赋值到插入位置 \n\t\t}\n\t}\n}\n```\n\n**另一种实现方法(带哨兵)**\n\n```C\n//直接插入排序（带哨兵）\nvoid InsertSort(int A[], int n) {\n\tint i, j;\n\tfor(i = 2; i<=n; i++) {\t\t//依次将A[2]~A[n]插入到前面已排序序列 \n\t\tif(A[i] < A[i-1]){\t\t//若A[i]关键字小于其前驱，将A[i]插入有序表 \n\t\t\tA[0] = A[i];\t\t//赋值为哨兵，A[0]不存放元素 \n\t\t\tfor(j = i-1; A[0] < A[j]; --j){\t\t//从后往前查找待插入位置 \n\t\t\t\tA[j+1] = A[j];\t\t//向后挪位 \n\t\t\t}\n\t\t\tA[j+1] = A[0];\t\t//赋值到插入位置 \n\t\t}\n\t}\n}\n```\n\n<font color='orange'>带哨兵，优点：不用每轮循环都判断j>=0</font>\n\n### 算法效率分析\n\n空间复杂度：O(1)\n\n时间复杂度：主要来自对比关键字、移动元素。若有n个元素，则需要n-1趟处理\n\n> 最好情况：\n>\n> 原始的表就是一个有序表。\n>\n> 共n-1趟处理，每一趟只需要对比关键字1次，不用移动元素。\n>\n> 最好时间复杂度——O(n)\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-18.png\" style=\"zoom: 67%;\" />\n\n> 最坏情况：\n>\n> 表中元素全部都是逆序排放。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-285.png\" style=\"zoom: 50%;\" />\n>\n> 这种情况下，我们每一趟处理，都需要把当前元素，与它之前所有元素都进行一次对比，并且把之前排好序的元素依次后移。\n>\n> 第1趟：对比关键字2次，移动元素3次；\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-286.png\" style=\"zoom: 55%;\" />\n>\n> 第2趟：对比关键字3次，移动元素4次；\n>\n> 第i趟：对比关键字i+1次，移动元素i+2次；\n>\n> …\n>\n> 第n-1趟：对比关键字n次，移动元素n+1次。\n>\n> 最坏时间复杂度——O(n²)\n\n> 稳定性:由于每次插入元素时总是从后向前先比较再移动。所以不会出现相同元素相对位置发送变化的情况，即直接插入排序是一种稳定的排序算法。\n>\n> 适用性:直接插入排序算法适用于顺序存储和链式存储的线性表。为链式存储时，可以从前往后查找指定元素的位置。\n\n<font color='red'>注意</font>:其实大部分排序算法都适用于顺序存储的线性表。\n\n所以总结一下:\n\n- 空间复杂度：O(1)\n- 最好时间复杂度（全部有序）：O(n)\n- 最坏时间复杂度（全部逆序）：O(n²)\n- 平均时间复杂度：O(n²)\n- 算法稳定性：稳定\n\n### 折半插入排序\n\n之前我们执行插入的时候，都是从当前元素顺序地往前依次寻找，找到它应该插入的位置。\n\n但是由于当前处理的元素，它之前的元素已经是有序的了，并且还是顺序存储的话，那么就可以用折半查找的方法，更快的找到当前处理元素应该插入的位置。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-19.png\" style=\"zoom: 50%;\" />\n\n> 先把当前处理的元素a[i]保存下来。（放入哨兵，或者存入temp）\n>\n> 之后，对当前元素之前的元素(已经有序)，进行折半查找。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-20.png\" style=\"zoom: 67%;\" />\n\n当low>high时折半查找停止，此时应该将`[low, i-1]`内的元素全部右移，并将A[0]赋值到low所指位置。\n\n之后，处理下一个元素，60。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-21.png\" style=\"zoom: 50%;\" />\n\n同样利用折半查找的算法，但是有一个问题。当mid所指元素为60时，由于折半查找算法的原理，当查找到相同的元素，就会停止折半查找。\n\n但是此处我们为了保证插入排序的稳定性，当我们发现和当前元素相等的元素时，我们还应该继续查找，继续往右半部分确定处理元素的插入位置。\n\n所以此时并不会让折半查找停止，我们还会继续在mid所指的60的右半部分，继续进行折半查找，即令low=mid+1。\n\n> 当A[mid] == A[0]时，为了保证算法的“稳定性”，应继续在mid所指位置右边寻找插入位置。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-22.png\" style=\"zoom: 67%;\" />\n\n继续执行，到low>high时，停止折半查找。并将`[low, i-1]`范围内的元素全部右移，并将A[0]复制到low所指位置。剩下的步骤不多说了。\n\n**代码实现**:\n\n```C\n//折半插入排序\nvoid InsertSort(int A[], int n) {\n\tint i, j, low, high, mid;\n\tfor(i = 2; i<=n; i++){\t//依次将A[2]~A[n]插入前面的已排序序列 \n\t\tA[0] = A[i];\t//将A[i]暂存到A[0]\n\t\tlow=1; high=i-1;\t//设置折半查找的范围\n\t\twhile(low<=high){\t//折半查找 \n\t\t\tmid = (low + high) / 2;\t//取中间点\n\t\t\tif(A[mid] > A[0])\n\t\t\t\thigh = mid - 1; //查找左半子表\n\t\t\telse low = mid + 1;\t//查找右半子表 \n\t\t} \n\t\tfor(j = i-1; j>=high+1; --j){\n\t\t\tA[j+1] = A[j];\t\t//统一后移元素，空出插入位置 \n\t\t}\n\t\tA[high+1] = A[0];\t\t//插入操作 \n\t}\n}\n```\n\n> 当low>high时折半查找停止，应将[low, i-1]内的元素全部右移，并将A[0]复制到low所指位置。\n>\n> 当A[mid]==A[0]时，为了保证算法的“稳定性”，应继续在mid所指位置右边寻找插入位置。\n\n比起“直接插入排序”，比较关键字的次数减少了,约为O(nlog₂n),该比较次数与待排序表的初始状态无关，仅取决于表中的元素个数n，但是元素的移动元素的次数没变，它依赖于待排序表的初始状态，整体来看**时间复杂度依然是O(n²)**。对于数据量不很大的排序，折半插入排序往往能表现出很好的性能。折半插入排序是一种稳定的排序方法。\n\n### 对链表进行插入排序\n\n插入排序的思想也可以对链表进行。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-23.png\" style=\"zoom: 67%;\" />\n\n对链表的插入排序，代码实现自己思考。\n\n此处要说的是，当我们用链表进行插入排序的话，移动元素的次数变少了。但是关键字对比的次数依然是O(n²)数量级，整体来看**时间复杂度依然是O(n²)**。（因为链表没办法用折半查找，所以只能顺序地，从后往前依次对比各个元素）\n\n### 希尔排序\n\n> 希尔排序是一个叫希尔的人发明的。\n>\n> 它是对上一面中讲的插入排序，进行的一个优化。\n\n对于插入排序来说，若原本表中的元素是有序的，则在这种情况下，直接插入排序可以得到一个很不错的执行效率。\n\n那么，再把这个条件放宽一点，若原本表中的元素是**基本有序**的。那这种情况下，直接插入排序的效率也会很不错。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-24.png\" style=\"zoom:67%;\" />\n\n总之，如果能保证表中元素基本有序的话，我们的插入排序也能得到很好的执行。\n\n希尔排序的思想就是基于这样的一个考虑。\n\n我们先追求表中的元素部分有序，再逐渐逼近全局有序。\n\n#### 算法思想\n\n希尔排序：先将待排序表分割成若干形如`L[i, i+d, i+2d, ..., i+kd]`的“特殊”子表，对各个子表分别进行直接插入排序。缩小**增量d**，重复上述过程，直到d=1为止。\n\n> 在每一趟排序时，我们都会设一个增量d，然后对相距距离为d的各个元素，对它们进行直接插入排序。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-25.png\" style=\"zoom:80%;\" />\n\n若**第一趟**排序，令d=4。则子表情况如下:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-26.png\" style=\"zoom:80%;\" />\n\n接下来要对各个子表分别进行直接插入排序。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-28.png\" style=\"zoom:80%;\" />\n\n在进行完毕第一趟排序之后，表中的数据应该如下所示。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-27.png\" style=\"zoom:80%;\" />\n\n**第二趟**：令d = d/2 = 2。则子表情况如下：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-29.png\" style=\"zoom:80%;\" />\n\n接下来对各个子表分别进行直接插入排序。\n\n在进行完毕第二趟排序之后，表中数据如下。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-30.png\" style=\"zoom:80%;\" />\n\n**第三趟**：令d = d/2 = 1。则子表情况如下：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-31.png\" style=\"zoom:80%;\" />\n\n最后一趟处理就相当于总体对所有元素直接进行插入排序。\n\n但这时，经过前两趟处理，我们这时这个序列已经达成了基本有序的状态。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-32.png\" style=\"zoom:80%;\" />\n\n经过三趟的处理之后，最终得到一个递增序列。\n\n> 整个过程如下图所示：\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-33.png\" style=\"zoom: 80%;\" />\n\n此处，我们每次将增量d缩小一半。实际上这也是希尔本人建议的。\n\n不过，考试当中，可能会遇到各种的增量。按照原理分析即可。\n\n#### 算法实现\n\n```C\n//希尔排序\nvoid ShellSort(int A[], int n) {\n\tint d, i, j;\n    //A[0]只是暂存单元，不是哨兵，当j<=0时，插入位置已到\n\tfor(d = n/2; d>=1; d = d/2)\t//步长变化 \n\t\tfor(i = d+1; i<=n; ++i)\n\t\t\tif(A[i] < A[i-d]){\t//需将A[i]插入有序增量子表 \n\t\t\t\tA[0] = A[i];\t//暂存在A[0] \n\t\t\t\tfor(j = i-d; j>0 && A[0]<A[j]; j-=d){\n\t\t\t\t\tA[j+d] = A[j];\t//记录后移，查找插入的位置 \n\t\t\t\t}\n\t\t\t\tA[j+d] = A[0];\t//插入 \n\t\t\t}//if\t\n}\n```\n\n#### 算法性能分析\n\n**空间复杂度**:O(1)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-34.png\" style=\"zoom:80%;\" />\n\n我们的d，如果依次采用不同的增量序列，如取4、2、1，和取3、1，其希尔排序过程的趟数会受到影响，同时在每一趟排序当中，各个元素的对比、元素的移动这些也都会受到影响。\n\n<font color='cornflowerblue'>所以希尔排序的时间复杂度是怎么样的，到目前为止分析起来都很困难。</font>\n\n**时间复杂度**：和增量序列d的选择有关，目前**无法用数学手段证明确切的时间复杂度**。\n\n> 如果第一趟就取d=1，那么希尔排序就会退化成直接插入排序。\n>\n> 于是其最坏时间复杂度为O(n²)。\n>\n> 另外，当n在某个范围内时，希尔排序的时间复杂度可以达到O(n^{1.3})，可见与直接插入排序相比，效率还是提升了很多的。\n\n<font color='orange'>接下来看这个算法的稳定性如何。</font>\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-35.png\" style=\"zoom: 80%;\" />\n\n对于这个表，第一趟取d=2，会导致49跑到49的前边。所以，显然是不稳定的。\n\n此外，其必须要具有随机访问的特性，才可以实现。因此希尔排序仅适用于顺序表，不适用于链表。\n\n#### 总结\n\n**希尔排序**\n\n- 先将待排序表分割成若干形如`L[i, i+d, i+2d, ..., i+kd]`的“特殊”子表，对各个子表分别进行直接插入排序。缩小增量d，重复上述过程，直到d=1为止。\n- 性能\n  - 空间复杂度：O(1)\n  - 时间复杂度：未知，但优于直接插入排序\n  - 稳定性：不稳定\n  - 适用性：仅可用于顺序表\n- <font color='red'>高频题型</font>：给出增量序列，分析每一趟排序后的状态\n\n### 习题\n\n- 对于5个不同的数据元素进行直接插入排序，最多需要进行的比较次数是（不包含与哨兵的比较）→10次；\n\n  > 4+3+2+1=10次，如果加上与哨兵的比较就是14次（5+4+3+2）\n\n- 【2012】 对同一待排序序列分别进行折半插入排序和直接插入排序，两者之间可能的不同之处是→④\n\n  ① 排序的总趟数\n\n  ② 元素的移动次数\n\n  ③ 使用辅助空间的数量\n\n  ④ 元素之间的比较次数\n\n  > 折半插入排序，是对插入排序算法的一种改进，由于排序算法过程中，就是不断的依次将元素插入前面已排好序的序列中。由于前半部分为已排好序的数列，这样我们不用按顺序依次寻找插入点，可以采用折半查找的方法来加快寻找插入点的速度。 所以，很明显比较的次数减少了\n\n- 对有 n 个元素的顺序表采用直接插入排序算法进行排序，在最坏情况下所需的比较次数是多少？最好情况呢？（不考虑和哨兵的比较）?→最坏情况 ( n - 1 ) n / 2，最好情况 n - 1\n\n- 【2009】若数据元素序列{11,12,13,7,8,9,23,4,5}是采用下列排序方法之一得到的第二趟排序后的结果，则该排序算法只能是-->C\n\n  A. 冒泡排序\n  B. 选择排序\n  C. 插入排序\n  D. 归并排序\n\n  > 解答本题需要对各种排序算法的特点极为清楚。对于冒泡排序和选择排序，每一趟都能确定一个元素的最终位置，而题目中，前  2  个元素和后  2  个元素均不是最小或最大的  2  个元素并按序排列。选项  D  中的  2  路归并排序，第一趟排序结束都可以得到若干个有序子序列，而此时的序列中并没有两两元素有序排列。插入排序在每趟排序后能确定前面的若干元素是有序的，而此时第二趟排序后，序列的前三个元素是有序的，符合其特征。\n\n- 【2014】 用希尔排序方法对一个数据序列排序，若第1趟排序结果为` 9 1 4 13 7 8 20 23 15` ，则采用的增量间隔可能是 ?→3\n\n  > 希尔排序：设待排序元素序列由n个，首先取gap(增量)<n作为间隔，将全部元素分为gap个子序列，所有距离为gap的元素放在同一个子序列中，在每个子序列进行直接插排。\n  >\n  > 从定义可知，在进行第一趟希尔排序后，由于执行了直接插排，每个子序列都是有序的。 \n  >\n  > 根据题目，反过来，找间隔gap，使得每个子序列{a[i],a[i+gap],a[i+2*gap]....}有序，其中i~[0,n-1]。\n  >\n  > ![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-36.png)\n  >\n  > 如图，相同颜色的属于同一个子序列，增序。因此题目中第一趟gap=3.\n  >\n  > 关于疑问：算法的定义不是gap=gap/3+1吗？那为什么不选择4呢？\n  >\n  > 可以看出该公式相当于a1=a0/3+1,是基于本次gap来计算下一次的gap。而第一次的gap是给定的，不是计算得来的\n\n- 【2015】希尔排序的组内排序采用的是→A \n\n  A 直接插入排序\n  B 折半插入排序\n  C 快速排序\n  D 归并排序\n\n  > 希尔排序的思想是：先将待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成），分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。\n\n- 【2018】对初始数据序列(8,3,9,11,2,1,4,7,5,10,6)进行希尔排序，若第一趟排序结果为(1,3,7,5,2,6,4,9,11,10,8)，则两趟排序采用的增 量（间隔）依次是-->5，3\n\n  > 第一趟分组: 8,1,6; 3,4; 9,7; 11,5; 2, 10;间隔为5,排序后组内递增。\n  > 第二趟分组: 1,5,4,10; 3,2,9,8; 7,6,11; 间隔为3，排序后组内递增。\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-37.png\" style=\"zoom:80%;\" />\n","tags":["408数据结构"],"categories":["408数据结构"]},{"title":"第七章 查找(四)","url":"/p/15017/","content":"\n## 7.5 散列表\n\n### 散列表的基本概念\n\n**散列表**：根据关键字而直接进行访问的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系\n\n**散列函数**:一个把查找表中的关键字映射成该关键字对应的地址的函数，记为\n$$\n\\rm Hash(key) = Addr\n$$\n\n特点是：数据元素的**关键字**与其**存储地址直接相关**。\n\n就是数据元素本身的关键字，和它的存储地址之间有一个映射关系。\n\n> 如何建立“关键字”与“存储地址”的关系？\n>\n> 通过“散列函数（哈希函数）”：Addr = H(key)\n\n例：有一堆数据元素，关键字分别为`{19, 14, 23, 1, 68, 20, 84, 27, 55, 11, 10, 79}`，散列函数`H(key) = key%13`。\n\n因此，任何一个关键字，都会被映射到`0~12`这个区间内。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-125.png\" style=\"zoom:55%;\" />\n\n> 依次计算：\n>\n> 19%13 = 6   14%13 = 1     23%13 = 10\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-126.png\" style=\"zoom:55%;\" />\n\n> 但是，当继续计算至： 1%13 = 1时\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-127.png\" style=\"zoom:55%;\" />\n\n会发现，`1`这数据，应该放在下标为1的位置处，但是放不进去。因为已经有`14`这个数据占住了。\n\n基于这个问题，我们引出两个概念：\n\n散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为**冲突**，这些发送碰撞的不同关键字称为**同义词**。\n\n### 处理冲突的方法--拉链法\n\n例：有一堆数据元素，关键字分别为`{19, 14, 23, 1, 68, 20, 84, 27, 55, 11, 10, 79}`，散列函数`H(key) = key%13`。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-128.png\" style=\"zoom:60%;\" />\n\n用**拉链法**（又称链接法、链地址法）处理“冲突”：**把所有“同义词”存储在一个链表中**。\n\n则上述所有关键字全部存入完毕后，结果如下所示。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-129.png\" style=\"zoom:67%;\" />\n\n将新元素插入到链表的链尾（链头也可以，无所谓）。\n\n**拉链法的小优化**\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-130.png\" style=\"zoom: 55%;\" />\n\n对于拉链法，对于同义词，各个关键字的排序其实是乱序的。\n\n而如果我们能够保持其中关键字是有序的，即增序 / 降序的话，会略微提高查找效率。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-131.png\" style=\"zoom:60%;\" />\n\n\n\n### 散列查找\n\n接下来看这样存储的数据元素如何进行查找。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-132.png\" style=\"zoom:67%;\" />\n\n基于上述例子中利用拉链法存储的散列表，如何进行查找。\n\n例如查找`27`这个数据。\n\n首先，根据散列函数计算出这个关键字所对应的存放位置：`27%13 = 1`\n\n那么`27`要存放的话，一定是存放在下标为1所对应的那个链表当中。于是在那个链表当中依次检查各个元素的值。对比次数为3次，即查找长度为3。\n\n若查找目标为`20`，则根据`20%13 = 7`，去查找索引为7的链表，查找长度为1。\n\n若查找目标为`21`，则根据`21%13 = 8`，去查找索引为8的链表，然而索引为8的地方为空，则查找失败，**且查找长度为0**。\n\n> 查找长度——在查找运算中，需要**对比关键字的次数**称为查找长度。\n>\n> 下标为8的位置没有关键字，只是有个空指针而已，所以查找长度为0(**大多数学校的计算方法**)。\n>\n> 你查找成功的时候，也没有把判断指针的操作算到查找长度当中啊。比如27就是对比三次关键字，查找长度为3。所以此处查找长度为0是合理的计算方式。(**但有的教材也会把“空指针”的判定算作一次比较**)\n\n若查找目标为`66`，则根据`66%13 = 1`，去查找索引为1的链表，对比4次，查找失败，即查找长度为4。\n\n**计算一下平均查找长度**：\n$$\nASL_{成功}=\\frac{1*6+2*4+3+4}{12}=1.75\n$$\n\n> 查找成功时的平均查找长度。\n>\n> 因为哈希表中共有12个数据元素，每一个数据元素被查找的概率是相等的。\n>\n> 如果数据目标是“第一层”的话，就只需进行一次对比操作。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-133.png\" style=\"zoom: 55%;\" />\n>\n> “其他层”同理。最终算出查找成功的平均查找长度。\n>\n> 而顺序查找，12个关键字需要平均进行6次对比。可见哈希查找比顺序查找要快得多。\n\n$$\nASL_{成功}=\\frac{1+2+3+4+1+2+1+2+1+1+2+1}{12}=1.75\n$$\n\n> 我们也可以从另一个思路来考虑查找成功的平均查找长度。\n>\n> 对于索引为1的链表：查找到`14`的查找长度为1，`1`为2，`27`为3，`79`为4……\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-134.png\" style=\"zoom:55%;\" />\n\n第二种计算思路和第一种有什么区别呢？\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-200.png\" style=\"zoom:67%;\" />\n\n实际上，对于“1次”以后的查找，都是“冲突”的数据元素的查找，往后的数字越大，也就说明“冲突”的情况越严重，查找效率越低。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-201.png\" style=\"zoom:55%;\" />\n\n更理想的情况是这个样子。也就是所有关键字都没有同义词，这样对于所有元素都只需要查找1次。使得哈希查找在效率上得到提升。\n\n当然了，如果我们坚持使用之前的那个哈希函数`H(key)=key%13`的话，显然不会得到上图这样的理想效果。\n\n而理论上来说，如果我们的哈希函数设计的足够好，在理论上就有可能达到这种最理想情况。\n\n> 最理想情况：散列查找时间复杂度可达到O(1)。\n>\n> 接下来，我们的问题就是：如何设计冲突更少的散列函数？\n>\n> 这个问题先放一下。\n\n刚才计算了查找成功的平均查找长度，那么如何计算查找失败的平均查找长度？\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-137.png\" style=\"zoom:55%;\" />\n\n查找成功的平均查找长度，是对其中的关键字分别计算得到的。那么查找失败的平均查找长度该怎么算呢？查找失败的情况有很多很多。\n\n实际上，可以这样考虑。不论我们要查找的数是多少，其在经过哈希函数`H(key)=key%13`的映射后，只有可能映射到`0~12`上。而映射到每个位置上的概率是相等的。\n\n基于这样一种考虑，查找失败的平均查找长度计算如下：\n$$\nASL_{失败}=\\frac{0+4+0+2+0+0+2+1+0+0+2+1+0}{13}=0.92(装填因子)\n$$\n\n> 实际上可以发现，此处的分母`13`就是散列表长度；而分子各个数字加起来之和，就是表中数据元素的个数。\n\n**装填因子α** = 表中记录数 / 散列表长度\n\n> 如何理解装填因子这个参数呢？\n>\n> 其实就是描述散列表装的有多满。\n>\n> 装填因子越大，说明散列表装的越满。\n\n可见，装填因子的大小会直接影响散列表的查找效率。\n\n这是查找失败的情况。其实，查找成功的情况，也多多少少会和装填因子有一定的关联。因为，一个散列表装得越满，则说明发生“冲突”的可能性就越大。所以装填因子其实是一个很重要的参数。\n\n到此，我们再来考虑：\n\n**如何设计冲突更少的散列函数？**\n\n### 散列函数的构造\n\n#### 除留余数法\n\n**除留余数法 —— H(key) = key % p**\n\n散列表表长为m，取一个不大于m但最接近或等于m的**质数**p。\n\n例：散列表表长13。\n\n> 那么，取一个不大于13但最接近或等于13的质数。\n>\n> 其实就是可以取13。\n\n散列函数H(key) = key%13。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-138.png\" style=\"zoom:67%;\" />\n\n例：散列表表长15，那么散列函数H(key) = key%13。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-139.png\" style=\"zoom:67%;\" />\n\n> 这会有个什么问题呢？——我们的表，表长是15，但是所有的关键字被13整除，取余之后只有可能被映射到`0~12`的范围，也就是`13 14`两个位置被舍弃了。\n\n会有个问题：为什么p一定要取质数？\n\n不要忘记，我们设计散列函数的目标，就是让不同关键字的冲突尽可能地少。若p取质数的话，会让发生冲突的可能性更少。\n\n> 设：可能出现的关键字 = `{1,2,3,4,5,6,7,8,9,10......}`\n>\n> 散列表表长为8。\n>\n> 如果p取8。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-140.png\" style=\"zoom: 80%;\" />\n>\n> 如果p取不超过表长8的最大质数，即取7。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-141.png\" style=\"zoom: 80%;\" />\n\n> 不是说取质数，冲突的情况会更少吗？\n>\n> 但是为什么看上面两个图，取7的时候反而冲突更多了呢？\n>\n> 问题出在哪里？\n>\n> 问题出在，我们所给的例子当中，可能出现的关键字是一系列连续的自然数。\n\n接下来我们换一个例子。\n\n> 设：可能出现的关键字 = `{2,4,6,8,10,12......}`，即可能出现的都是偶数。\n>\n> 散列表表长为8。\n>\n> 若p取8。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-142.png\" style=\"zoom:80%;\" />\n>\n> 若p取7。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-143.png\" style=\"zoom:80%;\" />\n\n可见，若p取8，将会导致每个关键字的散列地址集中在`0,2,4,6`处。\n\n而p取质数7，则各关键字会被均匀地映射到每一个位置。\n\n即，**用质数取模，分布更均匀，冲突更少**。\n\n> 具体怎么证明，可以看一下数论。\n>\n> 其原因，大致的意思，就是\n>\n> 一个合数，例如8，那么它会与`6 4 2`这些数，存在很多相似的特征。所以对一系列关键字进行取模操作时，如果关键字具备与之类似的特征（例如关键字都是偶数）的话，会引起较多冲突。\n>\n> 而对于一个质数来说，它与这些数都是没有公因子的，因此没有相似的特征。可以保证对7取模后，这些关键字的分布是均匀的。\n\n> 因此，如果关键字就是连续的自然数：`{1,2,3,4,5,6,7,8,9,10......}`的话，如果表长为8，那么对8取模会更好（因为不会浪费一个位置）。即，对于实际应用来讲，散列函数的设计要结合实际的关键字分布特点来考虑。\n>\n> 但是对于答题的角度来讲，我们要做的就是，令p取最大的质数。\n\n#### 直接定址法\n\n**直接定址法 —— H(key) = key 或 H(key) = a*key + b**\n\n> 即，令关键字本身为存储位置，或者令关键字进行一个线性变化后作为其存储位置。\n\n其中，a和b是常数。这种方法计算最简单，且不会产生冲突。它**适合关键字的分布基本连续的情况**，若关键字分布不连续，空位较多，则会造成存储空间的浪费。\n\n例：存储同一个班级的学生信息，班内学生学号为（1120112176—1120112205）。\n\nH(key) = key - 1120112176。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-144.png\" style=\"zoom:67%;\" />\n\n#### 数字分析法\n\n**数字分析法 —— 选取数码分布较为均匀的若干位作为散列地址**\n\n设关键字是r进制数（如十进制数），而**r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些**，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时可选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数。\n\n例：以“手机号码”作为关键字设计散列函数\n\n> 下图号码忽略中间四位不计，那么对于138开头的号码来说，只有后四位是不同的。\n>\n> 因此可以设计长度为10000的散列表，并且以手机号后四位作为散列地址。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-145.png\" style=\"zoom:67%;\" />\n\n#### 平方取中法\n\n**平方取中法 —— 取关键字的平方值的中间几位作为散列地址**\n\n具体取多少位要视实际情况而定。**这种方法得到的散列地址与关键字的每位都有关系**，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。\n\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-146.png\" style=\"zoom:40%;\" />\n>\n> 什么意思？\n>\n> 我们在对一个数做平方时，如上图右侧，做手算的步骤，是下面数字的每一个数位，分别对上面的数字做乘法，最后再求和。\n>\n> 而，我们会发现，对于上图左侧的一系列数字，其实头部和尾部均为`1`开头，`0`结尾。因此，这些数字若做平方，则头部、尾部会有较多重复数字，而只有中间几位是变化的。\n\n例：要存储整个学校的学生信息，以“身份证号”作为关键字设计散列函数。\n\n> 身份证号码规则：\n>\n> 前1、2位数字表示：所在省份的代码；\n>\n> 第3、4位数字表示：所在城市的代码；\n>\n> 第5、6位数字表示：所在区县的代码；\n>\n> 第7-14位数字表示：出生年、月、日；\n>\n> 第15、16位数字表示：所在地的派出所的代码；\n>\n> 第17位数字表示性别：奇数表示男性，偶数表示女性；\n>\n> 第18位数字是校验码。\n\n由于一个学校的学生，其出生年、月、日，通常都是较为接近的，如，都是1999年、2000年等。因此，将身份证号求平方，能够得到中间几位分布较为均匀的关键字。因为一个数字求平方，根本上讲，是由原数的各个数位得来的。\n\n假设学生不超过十万人，则可以令身份证号平方取中间5位。可以令散列地址分布比较均匀。\n\n但是，这种方法只是能够使得散列地址分布比较均匀，但不代表不会有冲突。\n\n**有没有可能绝对避免冲突呢？**\n\n当然可以，比如身份证号，我们散列表长度为1000000000000000000（18个0），则可以直接用身份证号作为散列地址，且不可能有冲突，查找时间复杂度为O(1)。其实也就是上面说的直接定址法。\n\n但是这种做法，很显然是不切实际的。可以算一下需要使用多少内存空间。\n\n但是通过这个想法，我们可以体会到：\n\n散列查找是典型的“**用空间换时间**”的算法，只要散列函数设计的合理，则散列表越长，冲突的概率越低。\n\n### 处理冲突的方法--开放定址法\n\n> 无论散列函数取得多么优秀，都是不可避免的会有“冲突”的情况发生。\n>\n> 之前我们讲过处理冲突的方法，拉链法。\n>\n> 此处再讲一个，开放定址法。\n\n所谓**开放定址法**，是指可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。其数学递推公式为：\n$$\nH_i=(H(key)+d_i)\\%m   \n$$\n\n$$\ni=0,1,2,...,k(k<=m-1)\n$$\n\n**m**表示**散列表表长**；**di**为**增量序列**；i可理解为“第i次发生冲突”。\n\n> 关于这个增量如何设计，有以下方法\n>\n> - 线性探测法\n> - 平方探测法\n> - 伪随机序列法\n\n#### 线性探测法\n\n##### (1)线性探测法\n\n**线性探测法** —— di = 0, 1, 2, 3, …, m-1；即发生冲突时，每次往后探测相邻的下一个单元是否为空。\n\n例：有一堆数据元素，关键字分别为`{19, 14, 23, 1, 68, 20, 84, 27, 55, 11, 10, 79}`，散列函数`H(key) = key%13`。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-147.png\" style=\"zoom:67%;\" />\n\n当即将要存放关键字`1`时。\n\n先计算\n$$\nH(key)=1\\%13=1 \\\\  H_0=(1+d_0)\\%16=1\n$$\n于是，发生冲突。于是。\n$$\nH_1=(1+d_1)\\%16=2\n$$\n之后，发现2这个位置是空闲的，于是将关键字`1`存入其中。\n\n这个2就是，发生第1次冲突后重新计算，得到的哈希地址。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-148.png\" style=\"zoom:67%;\" />\n\n再往后，当即将要存放关键字`84`时。\n\n先计算\n$$\nH(key)=84\\%13=6 \\\\ H_0=(6+0)\\%16=6,冲突 \\\\ H_1=(6+1)\\%16=7,冲突\\\\H_2=8\n$$\n将`84`存入8处。\n\n其余关键字的存入可以自行计算。\n\n最终，所有元素全部存入，结果如下所示。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-149.png\" style=\"zoom: 67%;\" />\n\n> 线性探测法，就是当我们用哈希函数算出一个关键字的存放地址之后，如果这个地址冲突，那么我们应该一步一步地往后探测这些存储单元。\n\n接下来看一个问题。对于以上存储结果，如果我要再存入一个数据元素`25`。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-150.png\" style=\"zoom:67%;\" />\n\n则，`25`将会被放入13号位置当中。\n\n> 这个例子，想表示\n>\n> 算哈希函数，是对13取模，13是不大于哈希表表长的最大质数，所以哈希函数算出的地址是`0~12`之间；\n>\n> 而线性探测的时候，是对表长m取模，是可以算出`1~15`的范围。\n\n##### (2)查找操作\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-151.png\" style=\"zoom:67%;\" />\n\n如果要查找`27`这个元素。\n\n首先要算出哈希函数`H(key) = 27%13 = 1`，而1号位的元素`14`，与`27`是不相等的，于是我们会线性探测，依次探测后续的位置。按照线性探测公式，最终找到`H3 = 4`时，关键字为`27`。`27`的查找长度为4。\n\n> 可见，开放定址法，在查找的时候，可能要与同义词作对比，也可能要与非同义词作对比。\n\n如果要查找`11`这个元素。\n\n根据`H(11) = 11%13 = 11`，而11号位的元素`11`，没有冲突，直接可以查找成功。\n\n如果要查找`21`这个元素。\n\n`H(key)=21%13=8`，冲突；`H1 = 9`，冲突；……；`H5 = 13`，而13号位置没有存放任何元素，确定查找失败。`21`的查找长度为6。\n\n> 要强调的是，对最后一处空位置的判断，也要算作一次比较。\n>\n> 为什么拉链法，对于空指针的判断不算次数，而此处对于空位置的判断需要算作一次比较？\n>\n> 因为拉链法的空位置，是一个指针；而此处的空位置，是一个元素，和空指针是不一样的，所以在这个地方还是把它算作关键字的比较次数。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-152.png\" style=\"zoom:67%;\" />\n\n> 实际上，查找失败，就是从哈希地址开始，往后依次探测，直到探测为空停止。\n\n越早遇到空位置，就越早确定查找失败。上图对`21`的查找长度为3。\n\n##### (3)删除操作\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-153.png\" style=\"zoom:67%;\" />\n\n如果我们直接把`1`给删掉。会引发一个问题：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-154.png\" style=\"zoom:67%;\" />\n\n当`1`直接被我们拿掉之后，再查找`27`，就出问题了。\n\n<font color='red'>注意</font>：\n\n采用“开放定址法”时，删除结点不能简单地将被删除结点的空间置为空，否则将截断在它之后填入散列表的同义词结点的查找路径，可以做一个“删除标记”，进行逻辑删除。\n\n这样一来，当我们探测到“空位置”处，根据“删除标记”，就能够知道，还应该继续往后探测。\n\n<font color='cornflowerblue'>再看这样一个问题。</font>\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-155.png\" style=\"zoom:67%;\" />\n\n如，`79`之前的元素都被删除了，且都标注了“删除标记”。\n\n那我们需要从1处，一路往后走，找到`79`。我们总共发生了8次冲突，对比了9次关键字，才找到。\n\n所以，看起来很满，但实际上很空。有很多东西都已经被逻辑删除了。\n\n所以这也是开放定址法的一个弊端。\n\n##### (4)查找效率分析\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-156.png\" style=\"zoom:67%;\" />\n\n> 19%13 = 6（1次）     14%13 = 1（1次）   23%13 = 10（1次）    1%13 = 1（2次）\n>\n> 68%13 = 3（1次）     20%13 = 7（1次）   84%13 = 6（3次）     27%13 = 1（4次）\n>\n> 55%13 = 3（3次）     11%13 = 11（1次）  10%13 = 10（3次）    79%13 = 1（9次）\n\n$$\nASL_{成功}=\\frac{1+1+1+2+1+1+3+4+3+1+3+9}{12}=2.5\n$$\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-157.png\" style=\"zoom:67%;\" />\n\n再来看查找失败的情况。\n\n查找失败的情况我们这样考虑：\n\n初次探测的地址H0，只有可能在`0~12`范围内。\n\n那么，对于0号位置元素，对比1次即可确定查找失败，即查找长度为1。\n\n而对于1号位置的元素，查找失败所需查找长度为13。其他位置的元素同理，得：\n$$\nASL_{失败}=\\frac{1+13+12+11+9+8+7+6+5+4+3+2}{13}=7\n$$\n可见，查找失败时的效率很低。\n\n> 线性探测法很容易造成同义词、非同义词的“**聚集（堆积）**”现象，严重影响查找效率。\n>\n> 产生原因——冲突后再探测，一定是放在某个连续的位置\n\n#### 平方探测法\n\n$$\n当d_i=0^2,1^2,-1^2,2^2,-2^2,...,k^2,-k^2时，称为平方探测法，又称二次探测法。其中k<=\\frac{m}{2}\n$$\n\n> d0 = 0\n>\n> d1 = 1\n>\n> d2 = -1\n>\n> d3 = 4\n>\n> d4 = -4\n>\n> d5 = 9\n>\n> d6 = -9\n>\n> …\n\n可以比较好地解决“聚集”的问题。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-158.png\" style=\"zoom:67%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-159.png\" style=\"zoom:67%;\" />\n\n> 值得注意的是：当存放最后一个元素`84`的时候，计算出它需要存放到`d6 = -9`的增量位置处。而从6往左数9个位置，没位置了怎么办？实际上，由于我们是取模运算，最终`84`会存放到24的位置。也就是没位置了就从表尾接着数。\n\n平方探测法：比起线性探测法更不易产生“聚集（堆积）”问题。\n\n> 这是由增量序列的特性所决定的。\n\n查找的过程，和线性探测法的原理是一样的。就是从H0、H1、H2…依次对比，只不过增量序列di不同而已。\n\n> 此处提一个非重点的小问题：\n>\n> 平方探测法**散列表长度m必须是一个可以表示成 4j + 3 的素数**，才能探测到所有位置。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-160.png\" style=\"zoom:67%;\" />\n\n#### 伪随机序列法\n\ndi是一个伪随机序列。如di = 0, 5, 24, 11, …\n\n### 处理冲突的方法--再散列法\n\n**再散列法**（再哈希法）：除了原始的散列函数 H(key) 之外，多准备几个散列函数，当散列函数冲突时，用下一个散列函数计算一个新地址，直到不冲突为止：\n$$\nH_i=RH_i(key),i=1,2,3,...,k\n$$\n\n> 注。此处给出的定义，是严蔚敏《数据结构》教材上的定义。而王道数据结构书上的定义，与该定义有出入，可能存在一些问题。还是以此处为准。\n\n### 总结\n\n- 概念\n  - 散列表、散列函数H(key)、同义词、冲突\n  - 装填因子α = 表中记录个数 / 散列表表长\n- 常见散列函数\n  - 目标是，对给定的关键字集合，应尽可能均匀地散列到各个地址，使冲突更少。\n  - 除留余数法：H(key) = key%p，p是不大于表长的质数\n  - 直接定址法：H(key) = key 或 H(key) = a*key + b\n  - 数字分析法：选取数码分布较为均匀的若干位作为散列地址\n  - 平方取中法：取关键字的平方值的中间几位作为散列地址\n- 冲突的处理\n  - 拉链法（链地址法）：同义词串成一个链表\n  - 开放定址法\n    - 原理都是 Hi = (H(key) + di) % m，只不过di序列的选取方式不同\n    - 线性探测法：di = 0, 1, 2, 3, …, m-1\n    - 平方探测法：di = 0², 1², -1², 2², -2², …\n    - 伪随机序列法：di = 一个伪随机序列\n  - 再散列法：准备多个散列函数，一个发生冲突了就用下一个\n- 查找效率：取决于 散列函数、处理冲突的方法、装填因子α\n\n> 实际上，对于冲突的处理，实际应用方面还是普遍采用拉链法，Java当中的HashMap就是用拉链法实现的。\n>\n> 而开放定址法由于坑比较多，实际操作用的并不多。但是由于是考研，坑多的地方容易出考题。而开放定址法中，线性探测法的坑是较多的，所以线性探测法出的考题比较多。\n\n### 习题\n\n- 设有一个含有 200 个表项的散列表，用线性探测法解决冲突，按关键字查询时找到一个表项的平均探测次数不超过 1.5，则散列表表项应能够容纳多少个表项（设查找成功的平均查找长度为 ASL = [1+1/(1-α)]/2，其中 α 为装填因子）→400\n\n- 【2011】为提高散列表的查找效率，可以采取的正确措施是-->仅Ⅱ、 Ⅲ\n\n  Ⅰ．增大装填（载）因子\n\n  Ⅱ．设计冲突（碰撞）少的散列函数\n\n  Ⅲ．处理冲突（碰撞）时避免产生聚集（堆积）现象\n\n  > 装填因子的计算公式为=关键字个数 / 表长度 这个装填因子和hash表的平均查找长度有关。如果要增大装填因子显然要么增加关键字个数，要么减少表长度，这两种方式都只会导致更多冲突的产生。因此I不对\n\n- 【2014】用哈希(散列)方法处理冲突(碰撞)时可能出现堆积(聚集)现象，下列选项中，会受堆积现象直接影响的是-->D\n\n  A.存储效率\n  B.散列函数\n  C.装填（装载）因子\n  D.平均查找长度\n\n  > 首先装填因子是不会受影响的，装填因子反应的是空间利用率；平均查找长度之所以受影响是因为，如果堆积比较严重（特别是在冲突处理之后出现堆积），每次查找都需要进行多次的比较才能找到所需要的值\n\n- 【2018】现有长度为7、初始为空的散列表HT，散列函数H(k)=k%7,用线性探测再散列法解 决冲突。将关键字 22, 43, 15 依次插入到 HT 后，查找成功的平均查找长度是->2\n\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-161.png\" style=\"zoom:67%;\" />\n\n- 【2019】现有长度为 11 且初始为空的散列表 HT，散列函数是 H(key) = key%7，采用线性探测法（线性探测再散列）法解决冲突。将关键字序列`87 40 30 6 11 22 98 20`依次插入 HT 后，HT 查找失败的平均查找长度是 →ASL=5.25\n\n  > **1. 构造散列表**\n  > 根据散列函数 H(key) = key %7 以及线性再探测，我们可以构造出散列表，如下图\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-162.png\" style=\"zoom: 50%;\" />\n  >\n  > **2. 计算失败的平均查找长度**\n  >\n  > 计算失败，可以转换理解，就是在已经构造好的散列表上，我们再去插入一个新的值需要比较多少次。\n  >\n  > 比如，现在我再插入一个数 21，那么理论上应该存放在地址 0 的位置，但是地址 0 有 98 了，则我们线性再探测（就是依次增加一个地址，看是否为空，空则可以插入），同理地址 1 也存在元素。以此类推，我们一共要比较地址 0~7，发现都有值，直到比较地址 8 才为空。所以一共比较了 9 次。\n  >\n  > 对其他地址（0~6）用同样的方式去理解，则一共比较的次数是 9+8+7+6+5+4+3 = 42\n  >\n  > 这里要注意，因为我们的模是 7，所以计算的地址只可能在（0~6）这个范围，所以最后的结果是 42/7 =6\n  >\n  > **3.计算成功的平均查找长度**\n  > 计算成功的长度，就是记录下每个数值比较了几次找到可存储的空间。\n  > 比如，本题每个数值比较（并存入）对应地址的次数如下图\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-163.png\" style=\"zoom: 33%;\" />\n  >\n  > 所以其 ASL = 1+1+1+1+1+1+1+1/8=1\n  >\n  > **note\n  > 1.注意失败与成功的查找长度的分母意义是不同的，失败时，分母是模的值；成功时，分母是元素个数。**\n\n- 综合题 5【2010】将关键字序列`7 8 30 11 18 9 14 `散列存储到散列表中。散列表的存储空间是一个下标从 0 开始的一维数组，散列函数为 H(key) = (key × 3) MOD 7，处理冲突采用线性探测再散列法，要求装填（载）因子为 0.7\n\n  1)画出所构造的散列表\n\n  2)分别计算等概率的情况下，查找成功和查找不成功的平均查找长度 \n\n  > 1）由装载因子为0.7，数据总数为7，得一维数组大小为7/0.7=10，数组下标为0～9。所构造的散列函数值见表B-3。\n  >\n  > 表**B-3**\n  >\n  > | key    | 7    | 8    | 30   | 11   | 18   | 9    | 14   |\n  > | ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n  > | H(key) | 0    | 3    | 6    | 5    | 5    | 6    | 0    |\n  >\n  > 采用线性探测再散列法处理冲突，所构造的散列表见表B-4。\n  >\n  > 表**B-4**\n  >\n  > | 地址   | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |\n  > | ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n  > | 关键字 | 7    | 14   |      | 8    |      | 11   | 30   | 18   | 9    |      |\n  >\n  > 表**B-5**\n  >\n  > | key  | 7    | 8    | 30   | 11   | 18   | 9    | 14   |\n  > | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n  > | 次数 | 1    | 1    | 1    | 1    | 3    | 3    | 2    |\n  >\n  > 故ASL成功=查找次数/元素个数=(1+2+1+1+1+3+3)/7=12/7。   \n  >\n  > 这里要特别防止惯性思维。查找失败时，是根据查找失败位置计算平均次数，根据散列函数mod 7，初始只可能在0～6的位置。等概率情况下，查找0～6位置查找失败的查找次数见表B-6。\n  >\n  > 表**B-6**\n  >\n  > | H(key) | 0    | 1    | 2    | 3    | 4    | 5    | 6    |\n  > | ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n  > | 次数   | 3    | 2    | 1    | 2    | 1    | 5    | 4    |\n  >\n  > 故ASL不成功=查找次数/散列后的地址个数=(3+2+1+2+1+5+4)/7=18/7。\n","tags":["408数据结构"],"categories":["408数据结构"]},{"title":"第七章 查找(三)","url":"/p/4437/","content":"\n## 7.4 B 树和 B+树\n\n### B树\n\n#### 回顾二叉查找(排序)树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-60.png\" style=\"zoom:67%;\" />\n\n二叉查找树也叫二叉排序树。\n\n其意义在于，把搜索的范围不断的分为两个部分。（小于的，和大于的）\n\n> 例如，我们原本的搜索范围为：`(-∞, +∞)`\n>\n> 经过了根结点29后，搜索范围被划分为了：(-∞, 29)，(29, +∞)，到这两个范围之一中进行进一步查找。\n\n**问题来了**：能不能把二叉查找树，拓展为m叉查找树？\n\n#### 5叉查找树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-61.png\" style=\"zoom:67%;\" />\n\n> 和二叉查找树其实是类似的。\n>\n> 只不过二叉查找树的每个结点将范围分割成了两个部分。\n>\n> 而多叉查找树，对每个结点，其将查找范围可能分为了多个部分。\n>\n> 例如：\n>\n> 根结点22将范围划分为了两个部分。\n>\n> 而根结点的右孩子，包含两个关键字36和45，因此，在该结点处，查找范围被划分为了：\n>\n> (22, 36)，(36, 45)，(45, +∞)。\n>\n> 也就是可能不只是将范围一分为二了，有可能多加了几个分割点。\n\n因此对于5叉查找树，每个节点最少有1个关键字，2个分叉；最多4个关键字，5个分叉。\n\n此外，结点中的关键字都是有序的，要么递增要么递减。\n\n同时，失败结点的区间范围都是很明确的，因为结点中关键字是有序的。\n\n> 如，最下面一层，从左到右的第三个节点，即包含了`13、15`的那个结点，其15右侧指向的失败结点的范围，就应该是`(15, 22)`。\n>\n> 如，最下面一层，从左到右的第四个结点，即包含了`40、42`的那个结点，其40左侧指向的失败结点的范围，就应该是`(36, 40)`。\n\n##### 查找成功的例子\n\n对于上面这个5叉查找树，若查找目标为`9`，查找过程如下：\n\n- 9 < 22，因此在22的左子树当中。\n- 在22的左孩子结点处，依次扫描其中的关键字；\n  - 5<9，跳过，看下一个；\n  - 11>9。因此，9肯定在11的左子树中。\n- 在11的左孩子结点处，依次扫描其中的关键字：\n  - 6<9，跳过，看下一个；\n  - 8<9，跳过，看下一个；\n  - 9 == 9。\n- 查找成功。\n\n> 此处，对于每个结点中关键字的遍历，我们使用的是顺序查找的方式。\n>\n> 但是，由于每个结点中的关键字都是有序的，因此，若必要的话，我们也可以使用折半查找。\n\n##### 查找失败的例子\n\n对于上面这个5叉查找树，若查找目标为`41`，查找过程如下：\n\n- 41>22，因此在22的右子树中。\n- 45>41，因此在45的左子树中。\n- 42>41，因此在42的左子树中，而42的左子树是一个失败结点。\n- 查找失败。\n\n#### 如何保证查找效率\n\n对于5叉查找树，我们只是规定了，每个结点最多只能有四个关键字、五个分叉。\n\n如果我们在每个结点中，只保存一个关键字、两个分叉的话，那这个5叉查找树就退化成了二叉查找树。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-62.png\" style=\"zoom: 50%;\" />\n\n那么，在这种情况下，由于每个结点中的关键字数量变少，所以树会变高（关键字总数相同的情况下，每个结点存放的关键字个数越少，树肯定就会越高），就要查更多层结点，效率低。\n\n**策略**：m叉查找树中，规定**除了根结点外**，任何结点**至少有`⌈m/2⌉`个分叉**，即**至少含有`⌈m/2⌉ -1`个关键字**。\n\n> 例如，对于5叉排序树，规定除了根结点外，任何结点都至少有3个分叉，2个关键字。\n\n这样就可以保证每个结点中，关键字个数不会太少，树的层数不会太高，查找效率也能够得到保证。\n\n> 为什么是：除了根结点外？\n>\n> 实际上做不到。假设整棵树只有一个数据元素，那么根结点肯定只能有1个关键字、2个分叉。\n\n接下来再看这样一棵树：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-63.png\" style=\"zoom:67%;\" />\n\n这棵树满足了每个结点关键字、分叉数量合理的特性。\n\n但是你觉得这棵树优秀吗？显然不是。\n\n结合我们在学习二叉查找树时的知识，其实不难想到，这棵树的问题在于，它是不平衡的。\n\n> 一个结点，它的各个子树高度相差很大，这就是所谓的不平衡。\n>\n> 不够平衡，树会很高，要查很多层结点。\n\n对于二叉排序树，我们的解决策略是，让左右子树高度之差不超过1。\n\n我们把同样地思想，迁移到这里。\n\n我们可不可以规定，对多叉查找树，令其所有子树，高度之差都不超过1？\n\n仔细想想，这个条件，在二叉查找树中实现起来是比较方便的，但是在多叉查找树中，其实是很麻烦的。\n\n我们可以直接实现一个简单粗暴的策略，如下。\n\n**策略**：m叉查找树中，规定对于**任何一个结点，其所有子树的高度都要相同**。\n\n如果一棵多叉查找树，能够同时保证这两条策略，那么这其实就是一棵B树。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-64.png\" style=\"zoom:67%;\" />\n\n> 可见，这棵5叉查找树：\n>\n> - 所有结点都至少有`⌈5 / 2⌉ = 3`个分叉\n> - 所有结点高度都相同\n>\n> 同时这会导致所有失败结点都是出现在最下面同一层的。\n\n#### B树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-65.png\" style=\"zoom: 80%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-66.png\" style=\"zoom: 80%;\" />\n\n- 最下面一层含有实际数据的一层，叫做**终端结点**。\n- 最下面一层失败结点，叫做**叶子结点**。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-67.png\" style=\"zoom: 70%;\" />\n\n#### B树的高度\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-165.png\" style=\"zoom: 80%;\" />\n\n**注**：大部分学校算B树的**高度不包括**叶子结点（失败结点）。\n\n**问题**：含n个关键字的m阶B树，最小高度、最大高度是多少？\n\n##### 最小高度\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-166.png\" style=\"zoom:79%;\" />\n\n最小高度——让每个结点尽可能的满，有m-1个关键字，m个分叉，<font color='orange'>最大总关键字数=最大总的节点个数*每个节点的最大关键字数</font>，则有\n$$\nn\\leq(m-1)(1+m+m^2+...+m^{h-1})=m^h-1\n$$\n因此，\n$$\nh\\geq log_m(n+1)\n$$\n\n##### 最大高度\n\n要使得B树的高度达到最大，也就意味着在每个节点中，关键字的个数达到最小，这样在容纳相同个数的关键字的B树中，其高度可以达到最大。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-202.png\" style=\"zoom:80%;\" />\n\n根结点只有2个分叉，其他结点只有⌈m/2⌉个分叉。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-203.png\" style=\"zoom:80%;\" />\n\n**n个关键字的B树必有n+1个叶子结点**([结论推导](./B树叶子结点个数和关键字个数间的关系推导.md))，则\n$$\nn+1\\geq2(⌈m/2⌉)^{h-1}\n$$\n即\n$$\nh\\leq log_{\\lceil{m/2}\\rceil}\\frac{n+1}{2}+1\n$$\n\n> 对于n个关键字的B树必有n+1个叶子结点的说明：\n>\n> 类似于二叉排序树的失败结点一样。\n>\n> 是由于，共有n个关键字，所以共将(-∞，+∞)这个区间分割成了n+1个部分，也就对应了n+1种失败的情况。\n\n对于最大高度，以上是课本中给出的方法。\n\n其实也可以从另外一个角度考虑：\n\n> 上面那个思路，是从最下层叶子结点的个数入手。\n>\n> 下面这个思路，是从每层关键字的最少关键字个数并求和入手。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-164.png\" style=\"zoom:67%;\" />\n\n我们将每层的最少关键字进行求和，那么。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-71.png\" style=\"zoom:80%;\" />\n\n既然h层的m阶B数，关键字个数至少有这么多，换句话说，也就是如果我的关键字个数少于这个值的话，就不对，或者说就不是h层了。\n\n**结论**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-72.png\" style=\"zoom: 80%;\" />\n\n这个公式能记下来最好\n\n#### 总结\n\n- **m阶B树**的核心特性：\n\n1）根结点的子树数∈[2,m]，关键字数∈[1,m-1]。\n\n 其他结点的子树数∈[⌈m/2⌉,m]；关键字数∈[⌈m/2⌉-1, m-1]。\n\n> 即，尽可能“满”\n\n2）对任一结点，其所有子树高度相同。\n\n> 即，尽可能“平衡”。（实际上是绝对平衡）\n\n3）关键字的值：子树0 < 关键字1 < 子树1 < 关键字2 <子树2 < … （类比二叉查找树的 左<中<右）\n\n- 含n个关键字的m叉b树，\n  $$\n  log_m(n+1)\\leq h\\leq log_{⌈m/2⌉}\\frac{n+1}{2}+1\n  $$\n\n- B树怎么查找？只要理解了就会查找，此处不再赘述。\n\n### B树的插入和删除\n\n#### B树的插入\n\nhttps://www.cnblogs.com/nullzx/p/8729425.html\n\n我们尝试着从0开始，建立一个B树。\n\n5阶B树——结点关键字个数`⌈m/2⌉-1 ≤ n ≤ m-1`，即：`2 ≤ n ≤ 4`（注：此处省略失败结点）\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-73.png\" style=\"zoom:80%;\" />\n\n对于根结点，我们按次序插入了4个结点（此时一个结点的关键字个数已经到达了上限）。\n\n若要再插入一个数据元素`80`，则不能向根结点中继续插入\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-74.png\" style=\"zoom:80%;\" />\n\n而是要分裂。我们需要把当前这个结点，分裂成两个结点。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-75.png\" style=\"zoom:80%;\" />\n\n怎么分裂的？如下。\n\n> 在插入key后，若导致原结点关键字数超过上限，则从中间位置（⌈m/2⌉）将其中的关键字分为两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置（⌈m/2⌉）的结点提取到原结点的父结点。\n>\n> \n\n接下来，如果我们再插入一个`90`这个元素。\n\n**新元素一定是插入到最底层“终端结点”，用“查找”来确定插入位置**。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-76.png\" style=\"zoom:80%;\" />\n\n注意，我们的新元素一定的插入到最底层的终端结点中，所以如果90插入到了以下位置，就是错的：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-77.png\" style=\"zoom: 80%;\" />\n\n插入`90`之后，我们再插入`99`，如图\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-78.png\" style=\"zoom: 80%;\" />\n\n接下来，如果我们要再插入`88`这一元素。则要插入到80和90之间的位置。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-79.png\" style=\"zoom:80%;\" />\n\n那到这一步，又导致它的关键字的个数超出了它的上限。\n\n所以和刚才一样，我们需要找到它的中间元素`88`，把这个元素提到父节点当中，然后把左右两部分分别放到两个不同的结点当中，如下。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-80.png\" style=\"zoom:80%;\" />\n\n接下来，依次插入`83`、`87`。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-81.png\" style=\"zoom:80%;\" />\n\n此时，如果要继续插入一个`70`。不难看出，`70`需要插到60和80之间的位置。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-82.png\" style=\"zoom:80%;\" />\n\n到了这里，又出现了结点关键字个数超过上限的情形。又要进行分裂了。\n\n那么我们需要把它最中间的元素`80`提到父节点中，然后把当前这个结点拆分成左右两个部分。\n\n那么就出现一个问题，80放到父节点中，应该放到父节点中的什么位置呢？\n\n显然，我们把`80`放到父节点中，依然需要保证父节点中的元素是有序排放的。所以80应该放在49和88之间。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-83.png\" style=\"zoom:80%;\" />\n\n> 如果一个关键字，因为分裂，需要把它提到父节点当中，那么我们应该把这个关键字放到它所处的结点的这条指针，指针的右边这个位置，方可保证其仍然保持B树的特性，如图。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-84.png\" style=\"zoom: 45%;\" />\n>\n> 同理，\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-85.png\" style=\"zoom:45%;\" />\n>\n> 93应该放到这个结点上方指针对应的右边的位置处，也就是88的右边。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-86.png\" style=\"zoom: 67%;\" />\n\n现在，继续插入元素，遇到以下情形。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-87.png\" style=\"zoom: 67%;\" />\n\n此时，我们需要把`73`这个元素，提到它的父节点中，也就是提到该结点所连指针的右侧位置，也就是49和80之间。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-88.png\" style=\"zoom:67%;\" />\n\n此时，又会导致，父节点当中的关键字个数超出了上限。\n\n那么我们需要把父节点继续往上分裂。\n\n> 在插入key后，若导致原结点关键字数超过上限，则从中间位置（**⌈m/2⌉**）将其中的关键字**分为两部分**，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置（⌈m/2⌉）的结点插入原结点的父节点。若此时导致其**父节点的关键字**个数也**超过了上限**，则**继续**进行这种**分裂**操作，直至这个过程传到根结点为止，进而导致B树高度增1。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-89.png\" style=\"zoom:67%;\" />\n\n核心要求：\n\n①对m阶B树——除根结点外，结点关键字个数`⌈m/2⌉ - 1 ≤ n ≤ m-1`\n\n②子树0 ＜ 关键字1 ＜ 子树1 ＜ 关键字2 ＜ 子树2 ＜ …\n\n> 即，每个结点中关键字个数一定要保证是B树规定的范围。\n>\n> 此外，插入后，一定要保持，对于每个关键字，它左边一定比它小，它右边一定比它大。\n\n新元素一定是插入到最底层“终端结点”，用“查找”来确定插入位置\n\n在插入key后，若导致原结点关键字超过上限，则从中间位置（**⌈m/2⌉**）将其中的关键字**分为两部分**，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置（⌈m/2⌉）的结点插入原结点的父节点。若此时导致其**父结点的关键字**个数也**超过了上限**，则**继续**进行这种**分裂**操作，直至这个过程传到根结点为止，进而导致B树高度增1。\n\n#### B树的删除\n\n##### 引言\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-90.png\" style=\"zoom:67%;\" />\n\n如果要删除`60`这个元素，那么很简单。直接删掉即可。而且删除后，这个结点还有3个关键字，符合B树的要求，是合法的。\n\n> 若被删除关键字在**终端节点**，则直接删除该关键字（要注意结点关键字个数是否低于下限`⌈m/2⌉-1`）\n\n如果要删除`80`这个元素。删除之后，80这个位置就空了。\n\n我们可以找`80`的直接前驱或直接后继，来顶替80的这个位置。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-91.png\" style=\"zoom:67%;\" />\n\n比如我们用`80`的直接前驱`77`来顶替它。\n\n找**直接前驱**的方法也很简单，就是当前关键字**左侧指针所指子树中“最右下”的元素**。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-92.png\" style=\"zoom:67%;\" />\n\n> 若被删除关键字在**非终端节点**，则用直接前驱或直接后继来替代被删除的关键字。\n>\n> **直接前驱**：当前关键字**左侧指针所指子树中“最右下”的元素**。\n\n此时，我们如果删除`77`这个元素，并且，我们用`77`的直接后继来顶替它的位置。\n\n`77`的**直接后继**怎么找呢？也很简单，就是当前关键字**右侧指针所指子树中“最左下”的元素**。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-93.png\" style=\"zoom:67%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-94.png\" style=\"zoom:67%;\" />\n\n> **直接后继**：当前关键字**右侧指针所指子树中”最左下“的元素**。\n>\n> 将直接前驱或直接后继顶替到要删除的终端节点位置处之后，再将其从原来位置处删除。\n>\n> 因此，这个操作也相当于把对非终端结点的删除操作，转换成了对终端节点的删除操作。那么就是直接删除即可。\n>\n> 也就是说，**对非终端结点关键字的删除，必然可以转化为对终端节点的删除操作**。\n>\n> 因为“最左下”或者“最右下”，也就是直接前驱或者直接后继，它必然是最下面一层的结点，也就是终端节点。\n\n因此，接下来我们重点探讨对终端结点的删除。\n\n##### 对终端结点的删除\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-95.png\" style=\"zoom:67%;\" />\n\n以上我们探讨的，对终端节点的删除，都很简单，都是直接删除的，因为它们删除之后，也都符合B树的要求，即没有低于每个结点关键字个数的下限。\n\n下面我们来看一个删除后，低于下限的情况。\n\n比如我们删除`38`这个元素。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-96.png\" style=\"zoom:67%;\" />\n\n删除`38`之后，这个结点里面的关键字个数，已经低于了下限。\n\n该怎么处理呢？\n\n此时又要划分为多种情况进行处理：\n\n###### (1)兄弟够借\n\n> 若被删除关键字所在结点删除前的关键字个数低于下限，且与此结点右（或左）兄弟节点的关键字个数还很宽裕，则需要调整该结点右（或左）兄弟结点及其双亲节点（父父子换位法）。\n\n**向右兄弟借**\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-97.png\" style=\"zoom:60%;\" />\n\n当前结点删除后，关键字个数不够了，而其右兄弟中的结点个数还绰绰有余，那么我们可以把右兄弟中的`70`贡献给它。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-98.png\" style=\"zoom: 45%;\" />\n\n直接放到这个位置可以吗？显然是不对的。因为其父节点49的左指针所指的，肯定都要比49小。\n\n所以如果直接把其右兄弟中的结点直接挪过来，显然是不正确的，将会不满足B树要求的特性。\n\n那么该怎么做呢？\n\n我们可以先把`49`这个元素给拉下来，然后让`70`这个元素去顶替`49`原来的位置。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-99.png\" style=\"zoom: 80%;\" />\n\n这样，就可以保证B树原有的特性。\n\n> 说白了，当**右兄弟很宽裕**时，用当前结点的**后继**，**后继的后继**来填补空缺。\n>\n> 在此例子中，也就是，用当前结点（`25`所在的这个结点）的后继`49`，后继的后继`70`，来填补空缺。\n\n上面是借右兄弟的例子，现在再看一个借左兄弟的例子。\n\n**向左兄弟借**\n\n比如，我们要删除`90`这个元素。删除之后，当前结点关键字个数不足。而其右兄弟本身就不宽裕，因此要向左兄弟借。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-100.png\" style=\"zoom: 80%;\" />\n\n> 当**左兄弟很宽裕时**，用当前结点的**前驱**、**前驱的前驱**来填补空缺。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-101.png\" style=\"zoom: 33%;\" />\n\n> `92`的前驱是`88`，`92`的前驱的前驱是`87`。\n\n需要做的操作是，将88插入到92的前面，然后用87顶替88的位置。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-102.png\" style=\"zoom: 80%;\" />\n\n总之，其**本质**在于，要永远保证：子树0 ＜ 关键字1 ＜ 子树1 ＜ 关键字2 ＜ 子树2 ＜ …\n\n###### (2)兄弟不够接\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-103.png\" style=\"zoom:67%;\" />\n\n若要删除`49`，会发现删除后关键字个数不足，且其右兄弟也不够借。\n\n那怎么办呢？我们的策略是，让这两个结点进行一个合并的操作。\n\n> 兄弟不够借。\n>\n> 若被删除关键字所在节点删除前的关键字个数低于下限，且此时与该结点相邻的左、右兄弟结点的关键字个数均 =`⌈m/2⌉-1`，则将关键字删除后与左（或右）兄弟结点及双亲结点中的关键字进行合并。\n\n也就是，`49`删除后，再将含有`25`的那一结点、含有`71 72`的那一结点，以及父节点中的关键字`70`，这三者进行合并。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-104.png\" style=\"zoom: 80%;\" />\n\n但是，此时又出现一个问题，由于我们把它的父节点中关键字拿了一个下来，所以导致了它的父节点中关键字个数又发生了不足。\n\n而且该结点的兄弟节点也属于不够借的状态。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-105.png\" style=\"zoom: 80%;\" />\n\n所以我们也需要进行合并的操作，即，将含有`73`的那一结点、含有`87 93`的那一结点，以及它俩在父节点内夹住的那个关键字`82`，这三者进行合并。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-106.png\" style=\"zoom:80%;\" />\n\n而现在，根结点中没有任何关键字，所以我们可以把根结点删除，并成立新的根结点，结果如下图。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-107.png\" style=\"zoom:80%;\" />\n\n> 兄弟不够借。\n>\n> 若被删除关键字所在节点删除前的关键字个数低于下限，且此时与该结点相邻的左、右兄弟结点的关键字个数均 = `⌈m/2⌉ - 1`，则将关键字删除后与左（或右）兄弟结点及双亲结点中的关键字进行合并。\n>\n> 在合并过程中，双亲节点中的关键字个数会减1。若其双亲结点是根结点且关键字个数减少至0（根结点关键字个数为1时，有2棵子树），则直接将根结点删除，合并后的新结点称为根；若双亲结点不是根结点，且关键字个数减少到`⌈m/2⌉ - 2`，则又要与它自己的兄弟节点进行调整或合并操作，并重复上述步骤，直至符合B树的要求为止。\n\n#### 总结\n\n**B树的插入**\n\n- 通过“查找”确定插入位置（一定是在终端结点）\n- 若插入后结点关键字个数未超过上限，则无需做其他处理\n- 若插入后关键字个数超过上限，则需要将当前结点的中间元素放到父节点中，当前结点分裂为两个部分；该操作会导致父节点关键字个数+1，若父节点关键字个数也超过了上限，则需要再向上分裂；根结点的分裂会导致B树高度+1。\n\n**B树的删除**\n\n- 非终端结点关键字\n\n  - 用其直接前驱或直接后继替代其位置，转化为对“终端节点”的删除\n  - 直接前驱：当前关键字左边指针所指子树中“最右下”的元素\n  - 直接后继：当前关键字右边指针所指子树中”最左下“的元素\n\n- 终端结点关键字\n\n  - 删除后结点关键字个数未低于下限，无需任何处理\n  - 低于下限\n    - 右兄弟够借，则用当前结点的后继、后继的后继依次顶替空缺\n    - 左兄弟够借，则用当前结点的前驱、前驱的前驱依次顶替空缺\n    - 左（右）兄弟都不够借，则需要与父节点内的关键字、左（右）进行合并，合并后导致父节点关键字数量-1，可能需要继续合并。\n\n- 核心要求:\n\n  ①对m阶B树——除根结点外，结点关键字个数`⌈m/2⌉ -1 ≤ n ≤ m-1`\n\n  ②子树0 < 关键字1 < 子树1 < 关键字2 < 子树2 < …\n\n  > ①每个结点的关键字是有上下限的。插入或删除操作使得结点的关键字个数超出了上下限的范围，就需要进行相应的调整。\n  >\n  > ②调整完了以后，一定也需要保证，B树的每个关键字，一定要大于它的左子树，同时一定要小于它的右子树。\n\n  <font color='red'>注意</font>，此处讲B树的所有操作，都是用5阶B树来讲的，而对于考试来说，不可能再出现比5阶更高阶的B树了，所以只需把此处讲的5阶B树的操作都理解到位，就可以了。\n\n### B+树\n\n考研中对B+树的考察一般不会太深，都是一些概念性的东西。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-108.png\" style=\"zoom:80%;\" />\n\n观察上图，其实可以看出，它和分块查找有些相似之处。\n\n#### 对比:分块查找\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-109.png\" style=\"zoom:67%;\" />\n\n在分块查找中，我们会把数据分成一块一块，并在索引表当中保存每一块最大的元素。\n\n#### B+树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-110.png\" style=\"zoom:80%;\" />\n\n可以看到，每一层的数据元素都是分块的，而且每一块的最大元素，都对应地存放在它的上一层中。\n\n一棵**m阶的B+树**需满足下列条件：\n\n1）每个分支节点最多有m棵子树（孩子结点）。\n\n2）非叶根结点至少有两棵子树，其他每个分支结点至少有⌈m/2⌉棵子树。\n\n> 什么叫非叶根结点，如下。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-111.png\" style=\"zoom: 80%;\" />\n>\n> 为什么要这样规定呢？\n>\n> 可以理解为：要追求“绝对平衡”，即所有子树高度要相同。\n\n> 为什么要保证每个分支结点至少有⌈m/2⌉棵子树？\n>\n> 和B树那里是类似的，是为了保证每个结点都不太空，来保证查找效率。\n\n3）**结点的子树个数与关键字个数相等**。\n\n> 这是B+树这里比较容易考察的，因为这是它和B树最大的区别。\n>\n> B+树每个结点有几个关键字，就会有几个分支。例如有3个关键字，就会对应3个分支。\n>\n> 而B树，有2个结点，会有3个分支。\n\n4）所有**叶结点包含全部关键字**及指向相应记录的指针，叶结点中将关键字按大小顺序排列，并且**相邻叶结点按大小顺序相互链接起来**。\n\n> 例如，上面这棵B+树，若每个关键字代表某个学生的学号，那么当查找到叶子结点处，找到某个学号后，在那个关键字处会附有一个指向相应记录的指针，即指向某个学生数据项的具体记录。\n>\n> 此外，B+树的叶子结点这一层，是**支持顺序查找的**。\n\n5）所有**分支结点**中仅包含它的各个子节点中**关键字的最大值**及指向其子节点的指针。\n\n> 和分块查找是类似的原理。\n\n#### B+树的查找\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-112.png\" style=\"zoom: 80%;\" />\n\n如上图，若要查找9。\n\n从根结点的第一个关键字开始检查，9比15小，于是向15的左子树找去，于是指针指向15的左子树的根结点的第一个关键字，即指向3。\n\n指向3，3<9，则指针后移，指向9，此时，9==9，但是要注意的是，在B+树中，在分支节点处，若查找目标和关键字相匹配了，查找并没有真正结束，因为只有我们找到叶子结点的对应关键字之后，才能查找到其指向的记录信息，才能完成B+树的查找。\n\n因此，指针指向9的左子树。依次遍历，最终找到9对应的记录。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-113.png\" style=\"zoom:80%;\" />\n\n15的左分支–>9的左分支–>6<7；8>7，于是判定7是不存在的，查找失败。\n\n**B+树中，无论查找成功与否，最终一定都要走到最下面一层结点**\n\n> 因为上面层次的分支结点的信息，并不能反应查找信息是否存在。\n>\n> 并且，只有在叶子结点找到某个关键字后，才可以找到这个关键字对应的实际的记录存放的位置。\n\n**对比:B树的查找**\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-114.png\" style=\"zoom:67%;\" />\n\n对于B树的查找，只要关键字匹配上就算查找成功，即指针可能停在任何一层。\n\n对于B+树的查找，除了逐层的查找外，还可以直接进行顺序查找。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-115.png\" style=\"zoom:67%;\" />\n\n在叶子结点那一层进行顺序查找，从1开始向后依次遍历，查找到9。\n\n#### B+树 VS B树\n\n我们可以看到，B+树有很多特点是和分块查找很类似的，而有很多特点也是和B树很类似的。考研中很容易将B+树和B树对比着来进行考察。\n\nm阶B+树：\n\n1）结点中的n个关键字对应n棵子树。\n\n2）根结点的关键字数`n∈[1, m]`。其他结点的关键字数`n∈[⌈m/2⌉, m]`。\n\n3）在B+树中，叶结点包含全部关键字，非叶结点中出现过的关键字也会出现在叶结点中。\n\n4）在B+树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。\n\nm阶B树：\n\n1）结点中的n个关键字对应n+1棵子树。\n\n2）根结点的关键字数`n∈[1, m-1]`。其他结点的关键字数`n∈[⌈m/2⌉-1, m-1]`。\n\n> 其实特点（2）的上下限之所以不同，还是由特点（1）所导致的。\n\n3）在B树中，各结点中包含的关键字是不重复的。\n\n4）B树的结点中都包含了关键字对应的记录的存储地址。\n\n> <font color='purple'>一个涉及到操作系统相关内容的区别</font>（数据结构这里不考，属于超纲的），也是B+树和B树<font color='cornflowerblue'>最本质的区别</font>：\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-116.png\" style=\"zoom:80%;\" />\n>\n> 这里面一个一个的结点，实际上是存储在计算机的磁盘当中的。\n>\n> 操作系统对磁盘的读写，一般是以磁盘块为单位。\n>\n> 一般来说，B+树/B树的一个个结点，就会存放在一个个不同的磁盘块当中。\n>\n> 此外，由于把数据读入内存中，计算机才能处理这些数据。\n>\n> 如：根结点`15 56`存放在`块1`当中，`32 42 56`存放在`块7`当中，`40 42以及其对应的记录`存放在`块23`当中。\n>\n> 那么，如果我们要查找`42`对应的记录，就会先把`块1`读入内存中，之后，根据根结点中存放的指针信息来进行索引，可知如果要查询42，需要将`块7`读入内存中，最后同理，将`块23`读入内存中。最后，找到`42`所指向的记录的指针，即可读出记录信息。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-117.png\" style=\"zoom:67%;\" />\n>\n> 对于B树也是一样的，也是要进行一次次读取磁盘块的操作。\n>\n> 其实，计算机读磁盘的这个操作，时间开销是很大的，因为磁盘是一种慢速设备。\n>\n> 所以，每一次读取一个磁盘块，都需要花费很高的时间。因此，也就意味着，如果整棵B+树高度越高，就意味着查找过程当中读磁盘的次数会越多，就会导致查找速度更慢。\n>\n> <font color='cornflowerblue'>那怎么减少这个树的高度呢</font>？——每个结点中存放的关键字个数越多，就意味着这棵树总的高度越低。\n>\n> 刚刚我们说了，这一个个的结点都是存放在磁盘块中的，而每一个磁盘块的大小其实是固定的。既然一个磁盘块的大小是固定的，我们要想让一个磁盘块包含尽可能多的关键字的信息。这就是B+树为什么要这样设计的原因。——非叶结点并不含有该关键字对应记录的存储地址，就会使这份数据需要花费的存储空间更少。\n>\n> 而B树当中，对每个结点的每个关键字，除了要保存这个关键字的信息以外，还要保存相应的记录的存储地址信息，就会导致一个磁盘块存放的关键字更少。\n>\n> 总之，在B+树中，**非叶结点不含有该关键字对应记录的存储地址**。这就可以使一个磁盘块可以包含更多个关键字，使得B+树的阶更大，**树高更矮**，**读磁盘次数更少**，查找更快。\n>\n> 实际上这也是B+树和B树最本质的区别。\n>\n> <font color='orange'>典型应用</font>：关系型数据库的“索引”，如MySQL。这些数据库的索引，实际上就是用B+树来实现的。\n\n### 总结\n\n|                | m阶B树                                                       | m阶B+树                                                      |\n| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 类比           | 二叉查找树的进化->m叉查找树                                  | 分块查找的进化->多级分块查找                                 |\n| 关键字与分叉   | n个关键字对应n+1个分叉(子树)                                 | n个关键字对应n个分叉                                         |\n| 结点包含的信息 | 所有结点中都包含记录的信息                                   | 只有最下层叶子结点才包含记录的信息(可使树更矮)               |\n| 查找方式       | 不支持顺序查找。查找成功时，可能停在任何一层结点，查找速度\"不稳定\" | 支持顺序查找。查找成功或失败都会到达最下一层结点，查找速度\"稳定\" |\n| 相同点         | 除根结点外，最少⌈m/2⌉个分叉(确保结点不要太\"空\")              | 任何一个结点的子树都要一样高(确保\"绝对平衡\")                 |\n\n### 习题\n\n- 【2009】下列叙述中，不符合m阶B树定义要求的是-->D\n\n  A.根结点最多有m棵子树\n  B.所有叶结点都在同一层上\n  C.各结点内关键字均升序或降序排列\n  D.叶结点之间通过指针链接\n\n  > 选项A、B和C都是B树的特点，而选项D则是B+树的特点。注意区别B树和B+树各自的特点。\n\n- 【2012】已知一棵3阶B树，如下图所示。删除关键字78得到一棵新B树，其最右叶结点中的关键字是-->65\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-122.png\"  />\n\n  > 在B树叶结点上删除一个关键字的方法是：\n  >\n  > 首先将要删除的关键字  k直接从该叶子结点中删除。然后根据不同情况分别作相应的处理，共有三种可能情况： \n  >\n  > （1）如果被删关键字所在结点的原关键字个数n>=⌈m/2⌉（即向上取整），说明删去该关键字后该结点仍满足B-树的定义。这种情况最为简单，只需从该结点中直接删去关键字即可。 \n  >\n  > （2）如果被删关键字所在结点的关键字个数n等于⌈m/2⌉-1，说明删去该关键字后该结点将不满足B-树的定义，需要调整。\n  >\n  > 调整过程为：如果其左右兄弟结点中有“多余”的关键字,即与该结点相邻的右（左）兄弟结点中的关键字数目大于⌈m/2⌉-1。则可将右（左）兄弟结点中最小（大）关键字上移至双亲结点。而将双亲结点中小（大）于该上移关键字的关键字下移至被删关键字所在结点中。 \n  >\n  > **对于本题，n=⌈m/2⌉-1 。所以将做节点最大关键字62上移，同时将双亲结点中大于62的关键字（65）下移至删除结点位置。**\n\n- 【2013】在一棵高度为2的5阶B树中，所含关键字的个数至少是→5\n\n  > 1.根节点至少有两个孩子节点，那么根节点的关键字至少为1 \n  >\n  > 2.第二层节点（至少2个），每个节点至少有⌈m/2⌉=3个孩子节点，那么其关键字至少为2 \n  >\n  > 3.综上：高度为2的5阶B树，关键字个数至少为1+2+2=5\n\n- 【2014】在一棵具有15个关键字的4阶B树中，含关键字的结点个数最多是→15\n\n  > 根据m阶**B-**树定义，\n  >\n  > - 根结点至多有m棵子树，即至多有m-1个关键字\n  > - 若根结点不是终端结点，则至少有2棵子树\n  > - 除根以外的所有非叶结点至少有 ⌈m/ 2⌉ 棵子树，即至少含有 ⌈m/2⌉ −1 个关键字\n  >\n  > ⌈4/2⌉−1 = 1 \n  >\n  > 因此，根据题干，只需要满足根结点有1个关键字。非叶结点至少1个关键字，即，一个结点一个关键字时，结点数最多，最多为15个结点。\n\n- 【2016】B+树不同于B树的特点之一是→A\n\n  A 能支持顺序查找\n  B 结点中含有关键字\n  C 根结点至少有两个分支\n  D 所有叶结点都在同一层上\n\n  > 看上面的总结\n\n- 【2017】下列应用中，适合使用B+树的是→B\n\n  A 编译器的词法分析\n  B 关系数据库系统中的索引\n  C 网络中的路由表快速查找\n  D 操作系统的磁盘空闲块管理\n\n  > B+树是应文件系统所需而产生的B-树的变形，前者比后者更加适用于实际应用中的操作系统的文件索引和数据库索引，因为前者磁盘读写代价更低，查询效率更加稳定。编译器中的词法分析使用有穷自动机和语法树。网络中的路由表快速查找主要靠高速缓存、路由表压缩技术和快速查找算法。系统一般使用空闲空间链表管理磁盘空闲块。所以B正确。\n\n- 【2018】高度为5的3阶B树含有的关键字个数至少是→31\n\n  > 1）B树通过向上“分裂”结点增加树的高度；\n  >\n  > 2）B树的所有叶子结点都在同一层上；\n  >\n  > 因此树深达到5时，最后一次一层是满的，即5层的满二叉树（算叶子结点一层共25-1）\n\n- 【2020】依次将关键字5，6，9，13，8，2，12，15插入初始为空的4阶B树后，根结点中包含的关键字是→6和9\n\n  > 一个4阶B树的任意非叶结点至多含有m-1=3个关键字，在关键字依次插入的过程中，会导致结点的不断分裂，插入过程如下所示。得到根结点包含的关键字为6，9.\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-123.png\" style=\"zoom:80%;\" />\n\n- 【2021】在一棵高度为3的3阶B树中，根为第1层，若第2层中有4个关键字，则该树的结点个数最多是-->A\n\n  A、11       B、10\n\n  C、9        D、8\n\n  > 在阶为3的B树中，每个结点至多含有2个关键字(至少1个)，至多有3棵子树。本题规定第二层有4个关键字，欲使B树的结点个数达到最多，则这4个关键字包含在3个结点中，B树树形如下图所示，其中A.B. c… M表示关键字，最多有11个结点，故选A。\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-124.png\" style=\"zoom:67%;\" />\n","tags":["408数据结构"],"categories":["408数据结构"]},{"title":"第七章 查找(二)","url":"/p/33271/","content":"\n## 7.3 树型查找\n\n### 二叉排序树（BST）\n\n#### 二叉排序树的定义\n\n二叉排序树，又称二叉查找树(BST,Binary Search Tree),一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：\n\n- 左子树上所有结点的关键字均小于根结点的关键字\n- 右子树上所有结点的关键字均大于根结点的关键字\n- 左子树和右子树又各是一棵二叉排序树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-179.png\" style=\"zoom: 55%;\" />\n\n#### 二叉排序树的查找\n\n若树非空，目标值与根节点的值比较，若相等，则查找成功。若小于根节点，则在左子树上查找，否则在右子树上查找。\n\n例如，对于如下二叉排序树，查找关键字为30的结点：\n\n①指针T指向根结点19\n\n②30>19，则T往右子树查找，T指向50\n\n③30<50，则T往左子树查找，T指向26\n\n④30>26，则T往右子树查找，T指向30\n\n⑤30==30，则查找成功，返回指针T\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-180.png\" style=\"zoom:55%;\" />\n\n```C\n// 二叉排序树结点\ntypedef struct BSTNode{\n    int key;\n    struct BSTNode *lchild,*rchild;\n}BSTNode,*BSTree;\n\n// 在二叉排序树中查找值为key的结点(传入根节点指针和值)\nBSTNode *BST_Search(BSTree T,int key){\n    while(T! =NULL&&key! =T->key){\t\t// 若树空或等于根结点,则结束循环\n        if(key<T->key){\n            T=T->lchild;\t\t\t\t// 小于,则在左子树上查找\n        }else{\n            T=T->rchild;\t\t\t\t// 大于,则在右子树上查找\n        }\n        return T;\n    }\n}\n```\n\n<font color='orange'>最坏空间复杂度O(1)</font>\n\n> 注意，在以上代码中，为了表示简单，我们的关键字信息用的是`int key;`，而实际上，你的每个节点的内容信息可以是更复杂的信息，只要你指定一种比较大小的规则即可\n\n当然我们也可以**递归实现**\n\n```C\n// 在二叉排序树中查找值为key的结点(递归实现)\nBSTNode *BSTSearch(BSTree T,int key){\n    if(T==NULL){\n        return NULL; // 查找失败\n    }\n    if(key==T->key){\n        return T;\t// 查找成功\n    }else if(key<T->key){\n        return BSTSearch(T->lchild,key);\t// 在左子树中找\n    }else{\n        return BSTSearch(T->rchild,key);\t// 在右子树中找\n    }\n}\n```\n\n<font color='orange'>最坏空间复杂度O(h)</font>\n\n**两者不同点在于最坏空间复杂度不同**\n\n#### 二叉排序树的插入\n\n若原二叉排序树为空，则直接插入结点；否则，若关键字k小于根节点值，则插入到左子树，若关键字k大于根节点值，则插入到右子树。\n\n<font color='red'>注意</font>：新插入的结点一定是叶子结点\n\n由于是采用递归实现，所以这个算法<font color='orange'>最坏时间复杂度为O(h)</font>。\n\n```C\n// 在二叉排序树插入关键字为k的新结点(递归实现)\nint BST_Insert(BSTree &L,int k){\n    if(T==NULL){\t\t\t\t// 原树为空,新插入的结点为根结点\n        T=(BSTree)malloc(sizeof(BSTNode));\n        T->key=k;\n        T->lchild=T->rchild=NULL;\n        return 1;\t\t// 返回1,插入成功\n    }else if(k==T->key){\t\t// 树中存在相同关键字的结点,插入失败\n\t\treturn 0;        \n    }else if(k<T->key){\t\t\t// 插入到T的左子树\n        return BST_Insert(T->lchild,k);\n    }else{\t\t\t\t\t\t// 插入到T的右子树\n        return BST_Insert(T->rchild,k);\n    }\n}\n```\n\n#### 二叉排序树的构造\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-183.png\" style=\"zoom:55%;\" />\n\n```C\n// 按照str[]中的关键字序列建议二叉排序树\nvoid Create_BST(BSTree &T,int str[],int n){\n    T=NULL;  //初始时T为空树\n    int i = 0;\n    while(i<n){  // 依次将每个关键字插入到二叉排序树中\n        BST_Insert(T,str[i]);\n        i++;\n    }\n}\n```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-184.png\" style=\"zoom:55%;\" />\n\n如上图，其中，例1、例2构造的二叉排序树为左图；而例3构造的二叉排序树为右图。这是给定序列的关键字前后顺序不同导致的。\n\n<font color='cornflowerblue'>不同的关键字序列可能得到同款二叉排序树，也可能得到不同款二叉排序树</font>\n\n**比较常考的内容**：给你一个关键字序列，让你来构造出一个二叉排序树\n\n#### 二叉排序树的删除\n\n先搜索到目标结点：\n\n1. 若被删除结点z是叶子结点，则直接删除，不会破坏二叉排序树的性质\n2. 若结点z只有一棵左子树或右子树，则让z的子树成为z父结点的子树，替代z的位置\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-108.png\" style=\"zoom:50%;\" />\n\n- 如13这个结点，它只有左子树，我们删除 13，然后让其子树顶上。这样就依然可以保证二叉排序树的性质\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-109.png\" style=\"zoom:50%;\" />\n\n- 若结点z有左、右两棵子树，则令z的直接后继(或直接前驱)替代z，然后从二叉排序树中删去这个直接后继(或直接前驱)，这样就转换成了第一或第二种情况\n\n  - 删除有两种方式，第一种我们可以使用结点z的直接后继替代z(也就是z结点右子树中第一个被中序遍历的结点(或者说右子树中值最小的结点))`{z的后继:z的右子树中最左下结点(该结点一定没有左子树)}`。\n\n    > 由于我们在删除之后，依然要保证二叉排序树`左子树结点值 < 根节点值 < 右子树结点值`的特性。由于**对二叉排序树进行中序遍历，可以得到一个递增的有序序列**。也就是我们删除之后，再次进行中序遍历，得到的仍然是一个递增的有序序列，即可保证我们的删除操作没有破坏二叉排序树的性质。\n\n    > 中序遍历——左、根、右。将根结点删除，中序遍历序列仍为一个递增的有序序列。那么就要让**右子树中第一个由中序遍历被访问到的结点**，来补到根结点的位置。不难得知，这个第一个被访问到的结点，就是右子树中最小的结点。即：**在z的右子树中找到最左下的那个结点**（该结点一定没有左子树；也就是它只有一个右子树，或者它就是叶子结点；因此便转换为了前两种情况）。\n\n  - 第二种我们可以使用结点z的直接前驱替代z(也就是z结点左子树中最后一个被中序遍历的结点(或者说左子树中值最大的结点))`{z的前驱:z的左子树中最右下结点（该结点一定没有右子树}`。\n\n    > 用直接前驱来替代被删除的结点。也就是要找到它的左子树当中最大的那个值，来替代当前被删除的这个结点。\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-110.png\" style=\"zoom:50%;\" />\n\n    例如，我们要删除值为50的结点，我们采用第一种方法，找其右子树中值最小的结点替代，此时60结点只有右子树，我们删除60结点，让其子树顶上，如下：\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-111.png\" style=\"zoom:50%;\" />\n\n    若我们采用第二种方法，找其左子树中值最大的结点替代，如图：\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-112.png\" style=\"zoom:50%;\" />\n\n#### 查找效率分析\n\n**查找长度**——在查找运算中，需要对比关键字的次数，称为查找长度。它反映了查找操作的时间复杂度。\n\n不论是用非递归的循环方式，还是用递归的方式，对一种二叉树的查找，是有时间复杂度的衡量的。时间复杂度和查找长度的数量级是相同的。\n\n对查找的时间复杂度的度量，我们是使用**查找成功**的**平均**查找长度**ASL**（Average Search Length）\n\n##### 查找成功的平均查找长度ASL\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-181.png\" style=\"zoom:55%;\" />\n\n> 对于左图：\n>\n> 如果我们要找的是第一层的结点，则需要对比1次，即可；\n>\n> 如果我们要找的是第二层的结点，则需要对比2次；\n>\n> 如果我们要找的是第三层的结点，则需要对比3次；\n>\n> ……\n>\n> 又由于左图中，\n>\n> 第一层有1个结点，每个节点需要对比1次，所以总查找次数是1 * 1；\n>\n> 第二层有2个结点，每个节点需要对比2次，所以总查找次数是2 * 2；\n>\n> ……\n>\n> 由于共8个结点，因此，将总次数求和之后，取平均值即可得到**ASL**。\n>\n> 因此，左图的`ASL = (1*1 + 2*2 + 3*4 + 4*1) / 8 = 2.625`\n\n> 对于右图：\n>\n> 右图的`ASL = (1*1 + 2*2 + 3*1 + 4*1 + 5*1 + 6*1 + 7*1) / 8 = 3.75`\n\n那么显然，左边这棵树的查找效率要高一些，即使它们存储的内容是完全相同的。\n\n由于我们在一棵树中对比关键字的次数，最多不会超过二叉树的高度h。因此查找效率最坏情况的复杂度，也是和二叉树的高度h是同等数量级的，即O(h)。<font color='orange'>因此，二叉排序树的查找效率，很大程度上取决于这棵树的高度到底是多少。</font>在之前讲二叉树的几个小节中我们说过，对于有n个结点的二叉树:\n\n- （最好情况）最小高度为`⌊log₂n⌋ + 1`，平均查找长度为O(log₂n)；\n- （最坏情况）每个节点只有一个分支，树高h = 结点数n。平均查找长度为O(n)。\n\n> 所以对于二叉排序树，我们应该尽可能的让这棵树的高度接近我们所期待的最小值，这样可以保证查找效率最高，也就是到达O(log₂n)这样一个数量级。\n>\n> 下一小节我们会介绍，怎么让一棵二叉排序树在构建的过程当中尽可能的保持平衡。也就是达到一棵**平衡二叉树**的标准。\n>\n> **平衡二叉树**：树上任一结点的**左子树**和**右子树**的**深度之差不超过1**。\n\n##### 查找失败的平均查找长度ASL\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-182.png\" style=\"zoom:55%;\" />\n\n对于上图左边的这棵树，我们先把叶子结点下的空结点给补上\n\n> 查找失败时，指针最终停留的位置只会在如图紫色方框处。也就是有9种情况会是查找失败的。\n>\n> 那么每一种情况的平均概率为九分之一。\n>\n> 由于**查找长度**的定义是，在查找运算中，需要对比关键字的次数称为查找长度。\n>\n> 那么对于靠上侧的7个小方块，这7种情况，需要对比关键字的次数为3次。靠下侧的2个小方块，需要对比关键字的次数为4次。\n>\n> 那么**查找失败**的**平均**查找长度`ASL = (3*7 + 4*2) / 9 = 3.22`。\n\n对于上图右边的这棵树，我们先把空节点给补上\n\n> 同样的道理，它的查找失败的平均查找长度`ASL = (2*3 + 3 + 4 + 5 + 6 + 7*2) / 9 = 4.22`\n\n显然，也是左边这棵比较胖的树，它的查找效率要更高一些。\n\n#### 总结\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-186.png\" style=\"zoom:80%;\" />\n\n### 平衡二叉树AVL\n\n<font color='cornflowerblue'>有了二叉排序树，为什么还需要平衡二叉树？</font>\n\n如果不做平衡处理的话，极端情况下二叉树会退化成一条链表，这时时间复杂度也会从O(log₂n)退化成O(n)。\n\n引入对左右子树高度差有限制的平衡二叉树，保证查找操作的最坏时间复杂度\n\n#### 平衡二叉树的定义\n\n平衡二叉树(Balanced Binary Tree)，简称平衡树(AVL)：树上任一结点的左子树和右子树的高度之差不超过1。\n\n**结点的平衡因子** = 左子树高度 - 右子树高度\n\n一棵平衡二叉树或者是空树，或者是具有下列性质的二叉排序树：\n\n1. 左子树与右子树的高度之差的绝对值小于等于1\n\n2. 左子树和右子树也是平衡二叉树\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-185.png\" style=\"zoom:55%;\" />\n\n   如图，每个结点下方的数字即为该结点的平衡因子。\n\n3. 平衡二叉树结点的平衡因子的值只可能是 -1、0或1\n\n4. 只要有任一结点的平衡因子绝对值大于1，就不是平衡二叉树。\n\n所以，我们可以在二叉树的各个结点的结构类型中，增加一个平衡因子的属性，如下：\n\n```C\n// 平衡二叉树结点\ntypedef struct AVLNode{\n    int key;\t\t\t// 数据域\n    int balance;\t\t// 平衡因子\n    struct AVLNode *lchild,*rchild;\n}AVLNode,*AVLTree;\t\n```\n\n#### 平衡二叉树的插入\n\n<font color='cornflowerblue'>在二叉排序树种插入新结点后，如何保持平衡？</font>\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-186.png\" style=\"zoom:55%;\" />\n\n例如上图我们插入结点 67 后，右边的结点受到了不平衡的影响，我们需要进行调整，调整的对象是从插入点往回找到**第一个不平衡的结点**，调整以该结点为根的子树。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-187.png\" style=\"zoom:55%;\" />\n\n例如上图的 66 和 70 结点都不平衡，我们要找**所含结点最小**的，70有3个结点，66有5个结点，所以我们将70为根节点组成的子树称为最小不平衡子树。\n\n其实上述说法是归纳出来的。我们将距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，称为**最小不平衡子树**。\n\n#### 调制最小不平衡子树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-118.png\" style=\"zoom:80%;\" />\n\n##### LL\n\nLL：在A的左孩子的左子树中插入导致不平衡\n\n我们调整至平衡，还要使其保持二叉排序树特性。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-165.png\" style=\"zoom:55%;\" />\n\n在插入之前，子树A是一棵平衡二叉树。其左右子树高度之差为1。\n\n在向A的左孩子的左子树中插入一个结点后，即A的左子树高度增加1，那么A的左右子树高度之差就变为了2，就不平衡了。\n\n> 思考：在插入之前，为什么要假定所有子树的高度都是H？\n>\n> 因为，若A的右子树高度为H+1，则左子树再插入一个后，仍为平衡二叉树；若A的右子树高度为H-1，则A即使没有新插入，它直接就不是平衡二叉树了\n>\n> 若B的右子树BR的高度为H-1，则在向BL插入一个结点后，B结点的左右子树高度之差为2，那么以B为根结点的子树就是最小平衡二叉树了，就轮不到A了；如果BR高度为H+1，则A直接就不平衡了。\n\n总之，在我们假定一棵最小平衡二叉树中的某个子树的高度为H的话，其他的子树的高度一定为H。只有这样，在进行LL插入之后，A会由最小平衡二叉树的根结点，变为最小不平衡二叉树的根结点。\n\n<font color='cornflowerblue'>下面开始探讨，如何恢复平衡？</font>\n\n我们的目标是：\n\n- 恢复平衡；\n- 保持二叉排序树的特性。\n  - 也就是`左子树结点值 ＜ 根节点值 ＜ 右子树结点值`\n  - 也就是`BL < B < BR < A < AR`\n\n对于这种情况，我们的做法是，**将B右旋**。具体的做法是：\n\n> **LL平衡旋转（右单旋转）。由于在结点A的左孩子（L）的左子树（L）上插入了新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要一次向右的旋转操作。将A的左孩子B向右上旋转**代替A称为根结点，将**A结点向右下旋转**称为B的右子树的根结点，而B的原右子树则作为A结点的左子树。\n\n也就是将B结点旋转，成为新的根结点，之后，由于BL<B，所以BL当然成为B的左孩子，但是由于B的右孩子已经挂了A了，那么BR就要去挂到A的下方，又因为BR<A，所以BR成为A的左孩子（旋转后A保证是没有左子树的）。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-188.png\" style=\"zoom:55%;\" />\n\n这样一来，就将最小不平衡子树恢复平衡，并且依然保持着二叉排序树的特性。\n\n##### RR\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-189.png\" style=\"zoom:55%;\" />\n\n> 同样的道理可以推敲一下，为什么每棵子树的高度都必须是H。\n\n同样地，对它调整平衡的目标是：\n\n- 恢复平衡\n- 保持二叉排序树的特性AL < A < BL < B < BR。\n\n这种情况我们需要做的调整，**将B左旋**。让B结点向左上旋转，替代A结点的位置，B结点变成新的根结点。而A结点向左下旋转，变成B的左孩子。\n\n接下来再把剩余的AL、BL、BR看情况给挂上去，就行了。由于BR>B，所以BR肯定要挂在B的右孩子；AL<A，则AL挂在A的左孩子；BL>A，则BL挂在A的右孩子。\n\n这就使得二叉树恢复了平衡，同时使得其保持了二叉排序树的特性。\n\n##### 代码思路\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-190.png\" style=\"zoom:55%;\" />\n\n##### LR\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-191.png\" style=\"zoom:55%;\" />\n\n> 我们先假设是插入到了B的右子树C的右子树中。当然，也有可能是插入到C的左子树中。但是情况是一样的，我们下面另外再说。此处先认为是插入到C的右子树中。\n\n> **LR平衡旋转（先左后右双旋转）**。由于在A的左孩子（L）的右子树（R）上插入新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。先将A结点的左孩子B的右子树的**根结点C向左上旋转提升到B结点的位置**，然后再把该**C结点向右上旋转提升到A结点的位置**。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-192.png\" style=\"zoom:55%;\" />\n\n实际上，新结点插入到C的左子树还是右子树，处理的操作是一样的，最终达到的效果也是一样的。如下所示。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-193.png\" style=\"zoom:55%;\" />\n\n##### RL\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-194.png\" style=\"zoom:55%;\" />\n\n> 我们先认为，是插入到B的左子树C的左子树中。实际上，插入到C的左子树还是右子树，处理的操作和处理的结果是一样的。\n\n> **RL平衡旋转（先右后左双旋转）**。由于在A的右孩子（R）的左子树（L）上插入新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转。先将A结点的右孩子B的左子树的根结点C向右上旋转提升到B结点的位置，然后再把该C结点向左上旋转提升到A结点的位置。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-195.png\" style=\"zoom:55%;\" />\n\n可以看到，无论是LR，还是RL，其思想，或者说最终效果，就是最终让C去顶替A的位置。C先去顶替B的位置，然后再去顶替A的位置。\n\n而LR、RL中的两次旋转，其实现思路与LL、RR的一次左旋/右旋实现思路是一样的，只不过它们是先左/右旋、后右/左旋了。\n\n再次总结一下左旋、右旋的代码实现思路：\n\n> f：father，p：左/右孩子，gf:grandfather\n>\n> 实现f向右下旋转，p向右上旋转：\n>\n> ①f->lchild = p->rchild； ②p->rchild = f； ③gf->lchild/rchild = p。\n>\n> 实现f向左下旋转，p向左上旋转：\n>\n> ①f->rchild = p->lchild； ②p->lchild = f； ③gf->lchild/rchild = p。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-196.png\" style=\"zoom:55%;\" />\n\n可以看到，只有左孩子才能右上旋；只有右孩子才能左上旋。\n\n##### 为什么只需调整最小不平衡子树\n\n至此，我们已经能够具备平衡化的操作手段了，也就能够解决一开始的那个问题了。\n\n但是我们不禁要思考一个问题：\n\n<font color='cornflowerblue'>在插入操作中，只要将最小不平衡子树调整平衡，则其他祖先节点都会恢复平衡。</font>为什么？\n\n是因为，插入操作导致**最小不平衡子树**高度+1，经过调整后，高度恢复。所以，对于它的上一级结点来说，只要我们能把这棵子树的高度恢复原状，那么它上一级的父节点的平衡因子肯定也能恢复原状。因此，再往上的各个父节点的平衡因子也均恢复至原状了。\n\n#### 王卓平衡二叉树的调整\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-128.png\" style=\"zoom: 67%;\" />\n\n- LL型：C<B<A,所以我们调整之后也得保持C<B<A\n- LR型：B<C<A,所以我们调整之后也得保持B<C<A\n\n##### LL型\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-129.png\" style=\"zoom: 67%;\" />\n\n- B结点带左子树α一起上升\n- A结点成为B的右孩子\n- 原来B结点的右子树β作为A的左子树\n\n##### RR型\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-130.png\" style=\"zoom: 67%;\" />\n\n- B结点带右子树β一起上升\n- A结点成为B的左孩子\n- 原来B结点的左子树α作为A的右子树\n\n例如：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-131.png\" style=\"zoom:67%;\" />\n\n##### LR型\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-132.png\" style=\"zoom:67%;\" />\n\n- C结点穿过A、B结点上升\n- B结点成为C的左孩子,A结点成为C的右孩子\n- 原来C结点的左子树β作为B的右子树，原来C结点的右子树γ作为A的左子树\n\n例如：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-133.png\" style=\"zoom:60%;\" />\n\n##### RL型\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-134.png\" style=\"zoom:67%;\" />\n\n#### 查找效率分析\n\n若树高为h，则最坏情况下，查找一个关键字最多需要对比h次，即查找操作的时间复杂度不可能超过O(h)。\n\n也就是，分析二叉排序树的查找效率，实际上就是分析这棵树有多高。\n\n平衡二叉树——树上任一结点的左子树和右子树的高度之差不超过1。\n\n假设以n(h)表示深度为h的平衡树中含有的最少结点数。\n\n> 当h=0时，也就是空树，即n(0)=0；\n>\n> 当h=1时，也就是只有1个结点，即n(1)=1；\n>\n> 当h=2时，也就是有一个根结点和一个左/右孩子，即n(2)=2；\n\n实际上，有`n(h) = n(h-1) + n(h-2) + 1`。\n\n> 也就是，由于左右子树高度之差不超过1，所以我们为了让结点数更少，就使左右子树高度之差为1。也就是根结点的左子树高度为h-1，右子树高度为h-2。再算上根结点，加1。\n>\n> 由此，我们可推得n(3)=4，n(4)=7，n(5)=12……\n\n因此，如果说某个平衡二叉树的结点数为9的话，那么它的最大高度h=4。\n\n> 因为如果它的高度要等于5的话，它最小节点数应该为12。因此，对于一个有9个结点的平衡二叉树，它的最大高度为4。也就是说，对于一个有9个结点的平衡二叉树，其查找一个关键字最多需要对比4次。\n\n即，如果一棵平衡二叉树的节点总数为n的话，那么它的最大高度h(max) = O(log₂n)。\n\n而它的最大高度又反映了它的查找时间复杂度。\n\n因此，**平衡二叉树的平均查找长度为O(log₂n)**。\n\n#### 平衡二叉树的删除\n\n和插入操作所维持的特性一样\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-185.png\" style=\"zoom:67%;\" />\n\n平衡二叉树的删除操作时间复杂度=O(log₂n)\n\n##### 具体步骤\n\n1. 删除结点(方法同“二叉排序树”)\n   - 若删除的结点是叶子，直接删\n   - 若删除的结点只有一个子树，用子树顶替删除位置\n   - 若删除的结点有两棵子树，用前驱(或后继)结点顶替，并转换为对前驱(或后继)结点的删除\n2. 一路向北找到最小不平衡子树，找不到就完结撒花\n3. 找最小不平衡子树下，“个头”最高的儿子、孙子\n4. 根据孙子的位置，调整平衡(LL/RR/LR/RL)\n   - 孙子在LL:儿子右单旋\n   - 孙子在RR:儿子左单旋\n   - 孙子在LR:孙子先左旋，再右旋\n   - 孙子在RL:孙子先右旋，再左旋\n5. 如果不平衡向上传导，继续2\n   - 对最小不平衡子树的旋转可能导致树变矮，从而导致上层祖先不平衡\n\n##### 例题1\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-188.png\" style=\"zoom: 50%;\" />\n\n删除结点9，9是叶子结点可直接删除。然后一路向北找到最小不平衡子树，发现没有不平衡情况\n\n再删除55这个叶子结点，直接删除，一路向北找到以75为根节点的最小不平衡子树。找最小不平衡子树下，“个头”最高的儿子80、孙子90。根据孙子在RR，儿子左单旋。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-189.png\" style=\"zoom: 50%;\" />\n\n检查不平衡是否向上传导，显然没有出现这种情况\n\n##### 例题2\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-190.png\" style=\"zoom:50%;\" />\n\n删除叶子结点32，然后一路向北找到以44为根节点的最小不平衡子树，做法类似，找到“个头”最高的儿子78、孙子50。根据孙子在RL，孙子先右旋，再左旋。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-191.png\" style=\"zoom:50%;\" />\n\n发现不平衡并没有向上传导\n\n##### 例题3\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-192.png\" style=\"zoom:60%;\" />\n\n可以看出此例中右子树与例2一样，删除叶子结点32，重复例2操作\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-193.png\" style=\"zoom:60%;\" />\n\n现在根节点33的左子树高度为5，右子树高度为3，这里就出现了不平衡向上传导的现象。\n\n继续步骤2，一路向北找到以33为根节点的最小不平衡子树。找到最小不平衡子树下，“个头”最高的儿子10、孙子20。根据孙子在LR，孙子先左旋后右旋。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-194.png\" style=\"zoom:60%;\" />\n\n不平衡向上传导现象消失，恢复平衡\n\n##### 例题4\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-195.png\" style=\"zoom:50%;\" />\n\n删除结点75，该结点有两棵子树，这里用前驱60顶替。如何找前驱后继前面已经提过了。\n\n这样就转变为删除原60位置的结点了。注意:删除方法同“二叉排序树”。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-196.png\" style=\"zoom:50%;\" />\n\n从删除位置(现结点55的位置)一路向北，找到以60为根节点的最小不平衡子树。调整方法不作赘述了。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-197.png\" style=\"zoom:50%;\" />\n\n------\n\n例4中如果用后继结点77来顶替的话，被删除位置的结点是叶子结点，直接删除即可。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-198.png\" style=\"zoom:50%;\" />\n\n此时出现了最小不平衡子树，找其“个头”最高的儿子90，85、95都可以作为“个头”最高的孙子。\n\n> 考试一般不会考这样多种处理方式的题目\n\n### 红黑树RBT\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-168.png\" style=\"zoom:67%;\" />\n\n红黑树、平衡二叉树和二叉排序树都是用于查找的二叉树。\n\n上图可以看出，<font color='cornflowerblue'>红黑树和平衡二叉树在算法复杂度上一样优秀，那么为什么还需要红黑树呢？</font>\n\n平衡二叉树在插入/删除时很容易破坏”平衡“特性，需要频繁调整树的形态。如插入操作导致不平衡，则需要**先计算平衡因子，找到最小不平衡子树(时间开销大)**，再进行LL/RR/LR/RL调整\n\n红黑树在删除/插入很多时候不会破坏”红黑“特性，无需频繁调整树的形态。**即便需要调整，一般都可以在常数级时间内完成**。\n\n所以就知道了两者的使用场景\n\n- 平衡二叉树:适用于以查为主、很少插入/删除的场景\n- 红黑树:适用于频繁插入、删除的场景，实用性更强\n\n#### 红黑树大概会怎么考\n\n红黑树的定义、性质————选择题\n\n红黑树的插入/删除————要能手绘插入过程(不太可能考代码、略复杂)，删除操作也比较麻烦，也许不考\n\n#### 红黑树的定义与性质\n\n- 红黑树是二叉排序树   **左子树结点值<=根结点值<=右子树结点值**\n\n- 与普通BST相比 \n\n  1. 结点是红色或黑色；\n\n  2. 根结点是黑色。\n\n  3. 叶子结点（也叫外部结点、NULL结点、失败结点）是黑色。\n\n  4. 不存在两个相邻的红结点。(即红结点的父结点和子结点都是黑色的)\n\n  5. 对每个结点，从该节点到任一叶结点的简单路径上，所含黑结点的数目相同\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-169.png\" style=\"zoom:67%;\" />\n\n  口诀:<font color='orange'>左根右，根叶黑。不红红，黑路同。</font>\n\n- ```C\n  // 红黑树的结点定义\n  struct RBnode{\n      int key;    // 关键字的值\n      RBnode *parent;   // 父节点的指针\n      RBnode *lChild;   // 左孩子的指针\n      RBnoce *rChild;   // 右孩子的指针\n      int color;  // 结点颜色，如可用 0/1 表示 黑/红。也可用枚举型 enum 表示颜色。\n  };\n  ```\n\n- 练习:是否符合红黑树\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-170.png\" style=\"zoom:67%;\" />\n\n  上图中，从结点1出发，到左结点NIL的黑结点个数为2；到右子树的结点NIL的黑结点个数都为3；黑色结点数不相同，所以该树不是红黑树。(把结点6变成红色结点即符合红黑树)\n\n- 补充概念:结点的”黑高“\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-171.png\" style=\"zoom:67%;\" />\n\n  结点的**黑高**bh———从某结点出发(不含该结点)到达任一空叶结点的路径上黑结点总数\n\n  <font color='cornflowerblue'>思考:根节点黑高为h的红黑树，内部结点数(关键字)至少有多少个？</font>\n\n  回答:内部结点数最少的情况——总共h层黑结点的满树形态\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-182.png\" style=\"zoom:67%;\" />\n\n  结论:若根节点黑高为h，内部结点数(关键字)最少有2^h-1个\n\n  > 凭借这一结论即可对性质进行证明\n\n- 性质\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-172.png\" style=\"zoom:67%;\" />\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-183.png\" style=\"zoom:67%;\" />\n\n  \n\n- 红黑树的查找\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-173.png\" style=\"zoom:67%;\" />\n\n#### 红黑树的插入\n\n##### 插入的策略\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-174.png\" style=\"zoom:67%;\" />\n\n##### 例题\n\n从一棵空的红黑树开始，插入:20，10，5，30，40，57，3，2，4，35，25，18，22，23，24，19，18\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-178.png\" style=\"zoom:67%;\" />\n\n刚开始插入20是根结点，染黑；再插入新结点10，染红，新结点非根染红的目的是防止违反”黑路同“。再插入新结点5，插入在10的左孩子结点处，染红，此时违反了”不红红“需要进行调整，即看5这个结点”叔叔“的脸色。\n\n黑叔并且新结点是LL型的，进行右单旋，父换爷+染色\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-177.png\" style=\"zoom:67%;\" />\n\n接下来应在20的右孩子处插入新结点30，染红，又违反了“不红红”，看它“叔叔”5这个结点的脸色。红叔，进行叔父爷染色，爷变为新结点。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-179.png\" style=\"zoom:67%;\" />\n\n> 注意：红黑树的插入，并不用考虑是否满足“左根右，根叶黑，黑路同”的条件。只需考虑是否破坏了“不红红”的特点，如果父子都是红结点，则按“红叔”、“黑叔”的划分进行下一步。\n\n剩下的插入操作就不作赘述了。无非就是违反了“不红红”规则进行调整，但注意的是调整一次后可能导致父爷结点违反“不红红”，需要进一步调整。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-180.png\" style=\"zoom:67%;\" />\n\n#### 总结\n\n![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-181.png)\n\n#### 红黑树的删除\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-184.png\" style=\"zoom:67%;\" />\n\n<font color='red'>王道说23、24不会考</font>\n\n22年才加入新大纲，还没有出过红黑树相关的题目，所以即使23出了也不会出难题\n\n### 习题\n\n- 【2010】对下列关键字序列，不可能构成某二叉排序树中一条查找路径的是-->A\n\n  A.95、22、91、24、94、71\n\n  B.92、20、91、34、88、35\n\n  C.21、89、77、29、36、38\n\n  D.12、25、71、68、33、34\n\n  > 二叉排序树，又叫二叉查找树，它或者是一棵空树；或者是具有以下性质的二叉树：若\n  >\n  > 1.它的左子树不空，则左子树上所有节点的值均小于它的根节点的值；\n  > 2.若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；\n  > 3.它的左右子树也分别为二叉排序树。\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-118.png\" style=\"zoom:50%;\" />\n\n- 【2012】若平衡二叉树的高度为6，且所有非叶子结点的平衡因子均为1，则该二叉树的结点总数为-->20\n\n  > 除叶节点外平衡因子都为1，说明左子树都比右子树高度多1，也就是说，是左子树撑起了该局部根节点的高度，所以可以按照这样的思路，自顶而下画这棵树：（节点标号是为了区分各个节点）\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-119.png\" style=\"zoom: 50%;\" />\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-120.png\" style=\"zoom:50%;\" />\n  >\n  > 为了看着清楚些，我把各层子节点提出来了，最后只需要自底而上把整个树合并起来就行。\n  >\n  > 按照fib公式算也是可以的，需要注意有的书里高度是从0开始算，有的是从1开始算。\n  >\n  > 斐波那契数列，平衡二叉树的最小结点数：f(n)=f(n-1)+f(n-2)+1。（公式验证就不写了） \n  >\n  > 其中 f(1)=1, f(0)=0。括号中的数代表深度。\n  >\n  > 从下往上数：深度为2时，f(2)=f(1)+f(0)+1=2；\n  >\n  > f(3)=f(2)+f(1)+1=4;依此类推 f(4)=7,f(5)=12,f(6)=20。\n\n- 【2013】将关键字 1，2，3，4，5，6，7 依次插入初始为空的平衡二叉树 T，则 T 中平衡因子为 0 的分支结点的个数是 →3\n\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-153.png\" style=\"zoom: 33%;\" />\n\n- 【2013】在任意一棵非空二叉排序树T1中，删除某结点v之后形成二叉排序树T2，再将v插入T2形成二叉树T3。下列关于T1与T3的叙述中，正确的是-->仅②、③\n\n  ①若v是T1的叶结点，则T1与T3不同\n\n  ②若v是T1的叶结点，则T1与T3相同\n\n  ③若v不是T1的叶结点，则T1与T3不同\n\n  ④若v不是T1的叶结点，则T1与T3相同\n\n  > 在一棵二叉排序树中删除一个结点后再将此结点插入到二叉排序树中 \n  >\n  > 若删除的结点是叶子结点,那么在插入结点后,后来的二叉树与删除结点之前相同(二叉树结构不变,切不发生重新排序) \n  >\n  > 若删除的结点不是叶结点,而是某个分支结点或是叶结点,则二叉树重新排序,结构改变, \n  >\n  > 此时若再插入这个结点后,后来的二叉树可能发生变化,不完全相同\n\n- 【2015】现有一棵无重复关键字的平衡二叉树(AVL),对其进行中序遍历可得到一个降序序列。下列关于该平衡二叉树的叙述中，正确的是-->D\n\n  A.根结点的度一定为2\n\n  B.树中最小元素一定是叶结点\n\n  C.最后插入的元素一定是叶结点\n\n  D.树中最大元素一定无左子树\n\n  > 只有两个结点的平衡二叉树的根结点的度为1 ，A错误。中序遍历后可以得到一个降序序列，树中最小元素一定无左子树（可能有右子树），因此不一定是叶结点，B错误。最后插入的结点可能会导致平衡调整，而不一定是叶结点，C错误。左大右小，最大元素没有左子树，最小元素没有右子树,选D。\n\n- 【2018】已知二叉排序树如下图所示，元素之间应满足的大小关系是-->x3<x5<x4\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-121.png\" style=\"zoom:50%;\" />\n\n  > 据二叉排序树的特性:中序遍历(LNR) 得到的是一个递增序列。图中二叉排序树的中序遍历序列为x1，x3,x5, x4,x2，可知x3<x5<x4.\n\n- 【2019】在任意一棵非空平衡二叉树(AVL)T1中，删除某结点v之后形成平衡二叉树T2，再将v插入T2形成平衡二叉树T3。下列关于T1与 T3 的叙述中，正确的是-->I\n\n  I．若 v 是 T1的叶结点，则 T1与 T3 可能不相同\n\n  II．若 v 不是 T1 的叶结点，则 T1 与 T3一定不相同\n\n  III．若 v 不是 T1的叶结点，则 T1与 T3 一定相同\n\n  > 在非空平衡二叉树中插入结点，在失去平衡调整前，一定插入在叶结点的位置。\n  > 若删除的是T1的叶结点，则删除后平衡二叉树不会失去平衡，即不会发生调整，再插入此结点得到的二叉平衡树T1与T3相同;若删除后平衡二叉树失去平衡而发生调整,再插入结点得到的二叉平衡树T3与T1可能不同。I正确。例如，如下图所示，删除结点0，平衡二叉树失衡调整，再插入结点0后，平衡二叉树和以前不同。\n  > 对于比较绝对的说法II和III，通常只需举出反例即可。\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-168.png\" style=\"zoom: 80%;\" />\n  >\n  > 若删除的是T1的非叶结点，且删除和插入操作均没有导致平衡二叉树的调整(这时可以首先想到删除的结点只有一个孩子的情况)，则该结点从非叶结点变成了叶结点，T1与T3显然不同。例如，如下图所示，删除结点2,用右孩子结点3填补，再插入结点2，平衡二叉树和以前不同。\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-169.png\" style=\"zoom:80%;\" />\n  >\n  > 若删除的是T1的非叶结点，且删除和插入操作后导致了平衡二叉树的调整，则该结点有可能通过旋转后继续变成非叶结点，T1与T3相同。例如，如下图所示，删除结点2,用右孩子结点3填补，再插入结点2，平衡二叉树失衡调整，调整后的平衡二叉树和以前相同。\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-170.png\" style=\"zoom:80%;\" />\n\n- 【2020】下列给定的关键字输入序列中，不能生成如下二叉排序树的是-->B\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-171.png\" style=\"zoom:67%;\" />\n\n  A.4,5,2,1,3   B.4,5,1,2,3\n\n  C.4,2,5,3,1   D.4,2,1,3,5\n\n  > 每个选项都逐一验证，选项B生成二叉排序树的过程如下:显然B选项错误\n\n><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-172.png\" style=\"zoom:67%;\" />\n\n- 【2021】给定二叉平衡树如下图所示，插入关键字23后，根中的关键字是-->25\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-173.png\" style=\"zoom:67%;\" />\n\n  > 关键字23的插入位置为25的左孩子，此时破坏了平衡的性质，需要对平衡二叉树进行调整。最小不平衡子树就是该树本身，插入位置在根结点的右子树的左子树上，因此需要进行RL旋转，RL旋转过程如下图所示，旋转完成后根结点的关键字为25,故选D.\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-174.png\" style=\"zoom:67%;\" />\n","tags":["408数据结构"],"categories":["408数据结构"]},{"title":"第七章 查找(一)","url":"/p/57685/","content":"\n## 7.1 查找的基本概念\n\n### 基本概念\n\n**查找**————在数据集合中寻找满足某种条件的数据元素的过程称为**查找**。结果分为查找成功与查找失败。\n\n**查找表**（查找结构）————用于查找的数据集合称为**查找表**，它由同一类型的数据元素(或记录)组成。\n\n**关键字**———数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-1.png\" style=\"zoom:80%;\" />\n\n上图学号可以唯一标识，而姓名不能唯一标识(可能存在重名)；下图同理，微信名、昵称不能唯一标识\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-2.png\" style=\"zoom:80%;\" />\n\n\n\n==注意==:查找表并不是一个新的数据结构，只是你要查找的数据元素的一个集合而已。\n\n### 对查找表的常见操作\n\n1. 查找符合条件的数据元素\n   - 查询某个特定的元素是否在查找表中\n   - 检索满足条件的某个特定的数据元素的各种属性\n2. 插入、删除某个数据元素\n   - 在查找表中插入一个数据元素\n   - 从查找表中删除某个数据元素\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-3.png\" style=\"zoom:80%;\" />\n\n**静态查找表**————只涉及操作1，则无须动态修改查找表，称为静态查找表。适合其的查找方法有顺序查找、折半查找、散列查找等。\n\n**动态查找表**————与之对应，需要动态的插入、删除的查找表称为动态查找表。适合其的查找方法有二叉排序树的查找、散列查找等。\n\n### 查找算法的平均指标\n\n**查找长度**————在查找运算中，需要对比关键字的次数称为查找长度\n\n**平均查找长度**(ASL)————所有查找过程中进行关键字的比较次数的平均值\n$$\nASL = \\sum^n_{i=1}P_iC_i\n$$\n其中n表示数据元素个数；Pi表示查找第i个元素的概率，一般认为每个数据元素的查找概率相等；Ci表示查找第i个元素所需进行的比较次数(查找第i个元素的查找长度)。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-4.png\" style=\"zoom:80%;\" />\n\n图中为二叉排序树的ASL，公式为ASL=（层数该层的结点个数）每个结点被查找的概率\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-5.png\" style=\"zoom:80%;\" />\n\n查找失败的情况，就是查询到紫色框框（紫色框框就是 NULL）都发现没有找到要比对的数字，那么此时查找失败，其计算方式同成功时一样，只是我们只用计算失败的那些紫色的框框。后面会详细说一下\n\n## 7.2 顺序查找和折半查找\n\n### 顺序查找\n\n**顺序查找**又称**线性查找**，它对顺序表和链表都是适用的。对于**顺序表**，可通过数组下标递增来顺序扫描每个元素；对于**链表**，可通过指针next来依次扫描每个元素。顺序查找通常分为对<font color='cornflowerblue'>一般的无序线性表的顺序查找</font>和对<font color='cornflowerblue'>按关键字有序的线性表的顺序查找</font>\n\n#### 一般线性表的顺序查找\n\n从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值key相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于key的结点，表示查找失败。\n\n##### 顺序查找的实现\n\n```C\ntypedef struct{     //查找表的数据结果(顺序表)\n    ElemType *elem; //动态数组基址\n    int TableLen;   //表的长度\n}SSTable;\n//顺序查找\nint Search_Seq(SSTable ST,ElemType key){\n    int i;\n    for(i=0;i<ST.TableLen && ST.elem[i]! =key;++i);\n    //查找成功，则返回元素下标；查找失败，则返回-1\n    return i==ST.TableLen?-1:i;\n}\n```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-6.png\" style=\"zoom:70%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-7.png\" style=\"zoom:80%;\" />\n\n```C\n// 方式一\nint Search_Seq(SSTable ST,KeyType key){\n   \t// 若成功返回其位置信息,否则返回0\n    for(i=ST.TableLen;i≥1;--i){\n        if(ST.elem[i] == key){\n            return i;\n        }\n    }\n    return 0;\n}\n// 方式二\nint Search_Seq(SSTable ST,KeyType key){\n    for(i=ST.TableLen;ST.elem[i]! =key;--i){\n        if(i<=0){\n            break;\n        }if(i>0){\n            return i;\n        }else{\n            return 0;\n        }\n        \n    }\n}\n// 方法二也可以这么写\nint Search_Seq(SSTable ST,KeyType key){\n    for(i=ST.TableLen;ST.elem[i]! =key && i>0;--i);\n    if(i>0){\n        return i;\n    }else{\n        return 0;\n    }\n}\n```\n\n上述每执行一次循环都要进行两次比较，我们还可以改进：把待查关键字key存入表头(“哨兵”),从后向前挨个比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-8.png\" style=\"zoom: 80%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-9.png\" style=\"zoom: 80%;\" />\n\n```C\nint Search_Seq(SSTable ST,KeyType key){\n    ST.elem[0] = key;      //\"哨兵\"\n    int i;\n    for(i=ST.TableLen;ST.elem[i]! =key;--i);//从后往前找\n    return i;//查找成功，返回元素下标；查找失败，则返回0\n}\n```\n\nST.elem[0]称为”哨兵“。引入它的目的是使得Search_Seq内的循环不必判断数组是否会越界，因为满足i==0时，循环一定会跳出。需要说明的是。<font color='red'>”哨兵“并不是这个算法独有的</font>。引入”哨兵“可以避免很多不必要的判断语句，当ST.TableLen较大时，此改进能使进行一次查找所需的平均时间几乎减少一半，从而提高程序效率。\n\n##### 查找效率分析\n\n对于有n个元素的表，给定值key与表中第i个元素相等，即定位第i个元素时，需进行n-i+1次关键字的比较，即Ci=n-i+1。查找成功时，顺序查找的平均长度为\n$$\nASL_{成功}=\\sum_{i=1}^{n}{P_i(n-i+1)}\n$$\n当每个元素的查找概率相等，即Pi=1/n时，有\n$$\nASL_{成功}=\\sum_{i=1}^{n}{P_i(n-i+1)}=\\frac{n+1}{2}\n$$\n查找失败时，与表中各关键字的比较次数显然是n+1次，从而顺序表查找失败的平均查找长度为\n$$\nASL_{失败}=n+1\n$$\n<font color='orange'>通常，查找表中记录的查找概率并不相等。若能预先得知每个记录的查找概率，则应先对记录的查找概率进行排序，使表中记录按查找概率由大至小重新排序。</font>\n\n综上，顺序查找的**缺点**:当n较大时，平均查找长度较大，效率低；\n\n**优点**:对数据元素的存储没有要求，逻辑次序无要求，顺序或链式存储皆可。\n\n#### 有序表的顺序查找\n\n若查找前就已知道表是关键字有序的，则查找失败时可以不用再比较到表的另一端就能返回查找失败的信息，从而降低顺序查找失败的平均查找长度。\n\n假设表L是按关键字从小到大排列的，查找的顺序是从前往后，待查找元素的关键字为key，当查找到第i个元素时，发现第i个元素对于的关键字小于key，但第i+1个元素对应的关键字大于key，这时就可返回查找失败的信息，因为第i个元素之后的元素的关键字均大于key，所以表中不存在关键字为key的元素。\n\n==例如==：<font color='orange'>7 13 19 29 37 43</font>\n\n我们要查找的目标为：<font color='cornflowerblue'>21</font>\n\n若从前往后查找，那么，当我们访问到<font color='red'>29</font>时，就已经说明查找失败，就不必继续向后检查了。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-10.png\" style=\"zoom:69%;\" />\n\n==用查找判定树分析ASL==\n\n如上图所示，即为**查找判定树**。\n\n其中，有n+1个“失败结点”，有n个“成功结点”。\n\n- 一个成功结点的查找长度 = 自身所在层数\n- 一个失败节点的查找长度 = 其父节点所在层数\n\n默认情况下，各种失败情况或成功情况都等概率发生。\n\n------\n\n在有序线性表的顺序查找中，查找成功的平均查找长度和一般线性表的查找顺序一样。查找失败时，查找指针一定走到了某个失败结点。这些失败结点是我们虚构的空结点，实际上是不存在的，所以到达失败结点时所查找的长度等于它上面的一个圆形结点的所在层数。查找不成功的平均查找长度在相等查找概率的情形下为\n$$\nASL_{失败}=\\sum_{j=1}^{n}{q_j(l_j-1)}=\\frac{1+2+...+n+n}{n+1}=\\frac{n}{2}+\\frac{n}{n+1}\n$$\n式中，qj是到达第j个失败结点的概率，在相等查找概率的情形下，它为1/(n+1)；lj是第j个失败结点所在的层数。当n=6时，ASL失败=6/2+6/7=3.86，比一般的顺序查找算法好:+1:。\n\n#### 顺序查找的优化(被查概率不相等)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-11.png\" style=\"zoom:67%;\" />\n\n### 折半查找\n\n折半查找又称**二分查找**。二分查找要求：<font color='cornflowerblue'>线性表是有序表</font>，即表中结点按关键字有序排列，并且用向量作为表的存储结构，例如递增有序的数组。\n\n折半查找的**基本思想**:首先将给定值key与表中中间位置的元素比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分(例如，在查找表升序排列时，若给定值key大于中间元素，则所查找的元素只可能在后半部分)。然后在缩小的范围内继续进行同样的查找，如此重复，直到找到为止，或确定表中没有所需要查找的元素，则查找失败，返回查找失败信息。\n\n① low=1；high=length； // 设置初始区间\n\n② 当low>high 时，返回查找失败信息// 表空，查找失败\n\n③ low≤high，mid=(low+high)/2; //确定该区间的中点位置\n   a. 若kx<tbl.elem[mid].key，high = mid-1；转② // 查找在左半区进行\n   b. 若kx>tbl.elem[mid].key，low = mid+1； 转② // 查找在右半区进行\n   c. 若kx=tbl.elem[mid].key，返回数据元素在表中位置// 查找成功\n\n#### 算法实现\n\n```C\ntypedef struct{    //查找表的数据结构\n    ElemType *elem; //动态数组基址\n    int TableLen;  //表的长度\n}SSTable;\n//折半查找\nint Binary_Search(SSTable L,ElemType key){\n    int low=0,high=L.TableLen-1,mid;\n    while(low<=high){\n        mid=(low+high)/2;     //取中间位置\n        if(L.elem[mid]==key)\n            return mid;       //查找成功则返回所在位置\n        else if(L.elem[mid]>key)\n            high=mid-1;       //从前半部分继续查找\n        else\n            low=mid+1;        //从后半部分继续查找\n    }\n    return -1;                //查找失败，返回-1\n}\n```\n\n**递归算法**:\n\n```C\nint Search_Bin(SSTable L,ELemType key,int low,int high){\n    if(low>high){\n        return 0 ;\t// 查找不到时返回0\n    }\n    mid = (low+high)/2;\n    if(key == L.elem[mid]){\n        return mid;\n    }else if(key<L.elem[mid]){\n        // 递归,在前半区间进行查找\n    }else{\n        // 递归，在后半区间进行查找\n    }\n}\n```\n\n> **注意**，以上代码是基于我们的查找表内元素是升序排列的。如果是降序排列，则大于/小于判定后的操作要进行相应的更改。（原理是一样的）\n\n举个算法应用的例子：已知如下11个数据元素的有序表：（3，6，7，14，19，24，30，35，56，65，88）查找元素30。\n\n起始，low指向a[0]，high指向a[10]，mid=(0+10)/2=5，即mid指向a[5]，如图所示：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-12.png\"  />\n\n由于查找元素key=30大于a[mid]，所以low=mid+1=6，mid=(6+10)/2=8，再一次进行比较：\n\n![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-13.png)\n\n此时，查找元素key=30小于a[mid]，所以high=mid-1=7，mid=(6+7)/2=6，再一次进行比较：\n\n![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-14.png)\n\n此时，查找元素key=30等于a[mid]，查找成功，返回mid=6。\n\n#### 一个查找成功的例子\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-15.png\" style=\"zoom: 67%;\" />\n\n首先，我们定义**low**和**high**。\n\nlow指向第一个元素，high指向最后一个元素。\n\n然后使最中间的元素为**mid**。（mid=(low+high)/2）\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-16.png\" style=\"zoom: 67%;\" />\n\n由于我们的查找目标33>mid，所以只可能在右边区域。（即下标6~10范围）\n\n因此，我们需要把low指向下标为6的位置。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-17.png\" style=\"zoom: 67%;\" />\n\n**注：只有在[low, high]之间才有可能找到目标关键字**\n\n同样地，我们取low和high的最中间元素mid，并判断目标元素在左边区域，还是右边区域。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-18.png\" style=\"zoom:67%;\" />\n\n由于我们的查找目标33<mid，所以只可能在左边区域。（即下标6~7范围）\n\n因此，我们需要把high指向下标为7的位置。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-19.png\" style=\"zoom:67%;\" />\n\n同样地，我们取low和high的最中间元素mid，mid = (low+high) / 2 = (6+7)/2 = 6，因此mid指向下标6的位置。\n\n由于我们的查找目标33>mid，所以只可能在右边区域。（即下标7）\n\n因此，我们需要把low指向下标为7的位置。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-20.png\" style=\"zoom:67%;\" />\n\n同样地，我们取mid = (low+high) / 2。因此mid指向下标为7的位置。\n\n此时，我们的查找目标33==mid。查找成功。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-21.png\" style=\"zoom:67%;\" />\n\n#### 一个查找失败的例子\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-22.png\" style=\"zoom:67%;\" />\n\n首先，让low和high指向整个数组的头和尾部。\n\n然后令mid = (low+high)/2 = 5。然后看目标元素在mid的左、右、相等？\n\n由于12<mid，则只可能在左边区域。因此将high指向4。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-23.png\" style=\"zoom:67%;\" />\n\n令mid = (low+high) / 2 = 2。然后看目标元素在mid的左、右、相等？\n\n由于12<mid，则只可能在左边区域。因此将high指向1。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-24.png\" style=\"zoom:67%;\" />\n\n令mid = (low+high) / 2 = 0。然后看目标元素在mid的左、右、相等？\n\n由于12>mid，则只可能在右边区域。因此将low指向1。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-25.png\" style=\"zoom:67%;\" />\n\n令mid = 1。然后看目标元素在mid的左、右、相等？\n\n由于12>mid，则只可能在右边区域。因此将low指向2。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-26.png\" style=\"zoom:67%;\" />\n\n此时，**low>high，查找失败**。\n\n> 到此，我们可以理解，为什么折半查找仅适用于**有序**的**顺序表**。\n>\n> 用顺序表，我们才可以直接根据下标找到中间位置mid。如果查找表是用链表，我们要找到中间元素，只能从头开始依次往后找。链表不具有随机存取的特性，而顺序表有。\n\n#### 折半查找判定树的构造\n\n对于查找算法的查找效率分析，我们都是基于查找判定树来看的。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-27.png\" style=\"zoom: 80%;\" />\n\n如果当前low和high之间**有奇数个**元素，则mid分隔后，**左右两部分元素个数相等**。分隔后，左右两部分均为奇数个元素。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-28.png\" style=\"zoom: 80%;\" />\n\n如果当前low和high之间**有偶数个**元素，则mid分隔后，**左半部分比右半部分少一个元素**。并且分隔以后，左半部分是偶数个元素，右半部分是奇数个元素。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-29.png\" style=\"zoom:80%;\" />\n\n**折半查找的判定树中**，若mid = ⌊(low+high)/2⌋，则对于任何一个结点，必有：\n\n**右子树结点数 - 左子树结点数 = 0或1** （也就是，左子树结点数不可能比右子树的多）\n\n##### 练习\n\n若mid = ⌊(low+high)/2⌋，画出含1个元素、2个元素、3个元素…16个元素的查找表对应的折半查找判定树，注：暂不考虑失败结点。（Key：**右子树结点数 - 左子树结点数 = 0或1**）\n\n- 对于1个元素，就不说了。\n\n- 对于2个元素的判定树，2号元素一定是右子树，如下。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-30.png\" style=\"zoom: 33%;\" />\n\n  这是由于，左子树结点数不可能比右子树结点数多\n\n- 对于3个元素的判定树\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-31.png\" style=\"zoom:50%;\" />\n\n  一定不可能是这个样子，因为右子树最多比左子树多1个结点。而此图，对于1来说，其右子树比左子树多2个结点了。\n\n  所以一定是如下所示<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-32.png\" style=\"zoom: 40%;\" />\n\n- 对于4个元素的判定树，只有可能是下图所示\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-33.png\" style=\"zoom: 45%;\" />\n\n- 中间的不再赘述。16个元素的判定树，如下所示：\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-34.png\" style=\"zoom: 67%;\" />\n\n##### 结论\n\n- 不难发现，折半查找的判定树一定是**平衡二叉树**。（任何一个结点的左子树、右子树深度之差，都不会超过1）\n\n- 另外，折半查找的判定树中，**只有最下面一层是不满的**。\n\n因此，元素个数为n时，<font color='orange'>树高h=⌈log₂(n+1)⌉</font>。（和完全二叉树的树高，计算方法是一样的）\n\n- 而这个树高的数量级，就反映了折半查找算法的时间复杂度。\n\n  因此，折半查找的时间复杂度为<font color='orange'>O(log₂n)</font>\n\n- 判定树结点关键字：左 < 中 < 右，满足二叉排序树的定义。\n\n- <font color='orange'>失败结点：n+1个</font>（等于成功结点的空链域数量）\n\n#### 查找效率分析\n\n用折半查找法查找到给定值的比较次数最多不会超过树的高度。在等概率查找时，查找成功的平均查找长度为\n$$\nASL=\\frac{1}{n}\\sum_{i=1}^{n}{l_i}=\\frac{1}{n}(1*1+2*2+...+h*2^{h-1})=\\frac{n+1}{n}log_2(n+1)-1\\approx log_2(n+1)-1\n$$\n式中，h是树的高度，并且元素个数为n时树高h=⌈log₂(n+1)⌉。所以，折半查找的时间复杂度为O(log₂n)，平均情况下比顺序查找的效率高\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-35.png\" style=\"zoom:80%;\" />\n$$\nASL_{成功}=\\frac{每个结点的比较次数之后}{结点数}\n$$\n\n$$\nASL_{失败}=\\frac{空指针处比较次数之和}{空指针数}\n$$\n\n**NOTE:\n每个结点的比较次数之和，即该结点所在的层次数\n空指针处比较次数之和，就是该空指针的双亲结点所在的层次**\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-189.png\" style=\"zoom:67%;\" />\n\n#### 拓展思考\n\n==1.折半查找是否一定更快==\n\n折半查找的时间复杂度 = O(log₂n)；顺序查找的时间复杂度 = O(n)\n\n<font color='cornflowerblue'>那么，折半查找的速度一定比顺序查找更快？</font>\n\n显然不是，如下例子\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-36.png\" style=\"zoom:67%;\" />\n\n所以我们只能说，大部分情况下，折半查找比顺序查找更快。但是不能说，任何情况下，折半查找都一定比顺序查找更快。\n\n==2.mid的取法问题==\n\n另外，刚才我们构造判定树时，<font color='cornflowerblue'>mid = ⌊(low+high)/2⌋</font>，是向下取整。\n\n如果我们让<font color='cornflowerblue'>mid = ⌈(low+high)/2⌉</font>，向上取整，那么判定树是什么样的？\n\n稍加思考，不难想到，按照这样取mid的话。\n\n- 如果当前low和high之间有偶数个元素，则mid分隔后，**左半部分比右半部分多一个元素**。\n\n折半查找的判定树中，若<font color='cornflowerblue'>mid = ⌈(low+high)/2⌉</font>，则对于任何一个结点，必有：\n\n**左子树结点数 - 右子树结点数 = 0或1**\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-37.png\" style=\"zoom:67%;\" />\n\n### 分块查找\n\n分块查找又称索引顺序查找，它吸取了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找。\n\n#### 分块查找的算法思想\n\n分块查找的**基本思想**:将查找表分为若干子块。块内元素可以无序，但块之间是有序的，即第一个块中的最大关键字小于第二个块中的所有记录的关键字，第二个块中的最大关键字小于第三个块中的所有记录的关键字，以此类推。再建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排列。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-38.png\" style=\"zoom:67%;\" />\n\n对于这个数组，看上去是没什么规律的，其实，如果仔细观察，可以发现。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-39.png\" style=\"zoom:67%;\" />\n\n如果把这些元素分块，会发现，第一块都是小于等于10的；第二块都是小于等于20的；......。\n\n这个数组看上去是乱序的，但是当我们把它分成一小块一小块的小区间后，会发现，各个区间内其实是有特点的，区间与区间之间相比较来看是有序的。\n\n于是我们可以给这个查找表，建立上一级的索引。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-40.png\" style=\"zoom:67%;\" />\n\n“索引表”中保存每个分块的最大关键字和分块的存储区间。\n\n**特点**：块内无序、块间有序。将每一块看作一个整体的话，会发现块与块之间呈一个递增/递减的顺序。\n\n查找过程：先确定待查记录所在块(顺序或折半查找)，再在块内查找(顺序查找)。\n\n```C\n//索引表\ntypedef struct {\n    ElemType maxValue;\n    int low, high;\n}Index;\n\n//顺序表存储实际元素\nElemType List[100];\n```\n\n##### 查找成功的例子\n\n如果我们要查找的元素为：<font color='cornflowerblue'>22</font>。那么，先在索引表中查找：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-41.png\" style=\"zoom:67%;\" />\n\n10，小于22；20，小于22；30，大于等于22。因此，要查找的22一定是在\"30\"这个分块内\n\n接下来，就从“30”这个块表示的区间，即数组的[6,8]内寻找。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-42.png\" style=\"zoom:67%;\" />\n\n27，不对；22，对。查找成功。\n\n##### 查找失败的例子\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-43.png\" style=\"zoom:67%;\" />\n\n若查找目标为：<font color='cornflowerblue'>29</font>。\n\n同样地，29应该是在“30”这个块内。因此，我们从查找表的下标为[6, 8]范围内进行查找。\n\n遍历完下标为6、7、8的元素后，均未匹配成功。此时遍历到9号元素，而下标为9，超出了“30”这个块的范围，即查找失败。\n\n##### 结论\n\n分块查找的过程分为两步:\n\n第一步是在索引表中确定查记录所在的块，可以顺序查找或折半查找索引表；\n\n第二步是在块内顺序查找。\n\n#### 用折半查找查索引\n\n##### 情形一:索引表中包含该关键字\n\n若查找目标为索引表中包含的关键字，则经过若干次mid即可找到。（即折半查找的“查找成功”的情形）\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-44.png\" style=\"zoom:67%;\" />\n\n##### 情形二:索引表中不包含该关键字，但能查找成功\n\n若查找目标为19，则过程如下：\n\n- 首先，low和high各指向头（0号）、尾部（4号），mid指向中间（2号）。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-45.png\" style=\"zoom:67%;\" />\n\n- 由于19<mid，则令high = mid-1，high指向1号。此时mid指向0号。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-46.png\" style=\"zoom:67%;\" />\n\n- 由于19>mid，则令low = mid + 1，low指向1号。此时mid指向1号。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-47.png\" style=\"zoom:67%;\" />\n\n- 由于19<mid，则令high = mid - 1，high指向0号。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-48.png\" style=\"zoom:67%;\" />\n\n- 此时low > high。若按照折半查找的规则，实际上属于是“查找失败”了。但实际上对于索引表来说，我们的**查找目标其实是在low指向的块当中**。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-49.png\" style=\"zoom:67%;\" />\n\n因此，若索引表中不包含目标关键字，则折半查找索引表最终停在low > high，要**在low所指分块内查找**。\n\n**原因**：最终low左边一定小于目标关键字，high右边一定大于目标关键字。（因为key>mid，则low=mid+1；key<mid，则high=mid-1）而分块存储的索引表中保存的是各个分块的最大关键字。\n\n##### 情形三:查找失败\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-50.png\" style=\"zoom:67%;\" />\n\n我们省略中间具体过程。最终会停在上图所示位置。\n\n和上面一模一样：若索引表中不包含目标关键字，则折半查找索引表最终停在low > high，要**在low所指分块内查找**。但此时low所指向的，已经超出了索引表。所以这种情况就是查找失败。\n\n#### 查找效率分析\n\n##### 采用顺序查找\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-51.png\" style=\"zoom:67%;\" />\n\n如果对索引表采用的是顺序查找。\n\n则查找到7这个元素，需要先在索引表中对比1次，再在块内对比1次，共2次。\n\n查找到10这个元素，需要先在索引表中对比1次，再在块内对比2次，共3次。以此类推。\n\n> 若索引表采用顺序查找，则\n>\n> 7：2次；10：3次；13：3次……\n\n总之，最后可以算出平均查找长度ASL。\n\n##### 采用折半查找\n\n如果对索引表采用的是折半查找。\n\n则查找到30这个元素，需要在索引表中对比1次，再在块内对比3次，共4次。没问题。\n\n<font color='cornflowerblue'>但是，对于查找到27这个元素，需要在索引表中对比1次，再在块内对比1次，共2次。是这样吗？</font>\n\n不是的。\n\n对于30这个元素，由于它本身是包含在索引表中的，所以进行一次对比即可查找到。\n\n但是对于27这个元素，由于它不是索引表的关键字，所以并不是对比一次就完成了的。而是需要完成若干次，直到low>high时，才算确定了27所在的分块！\n\n27具体需要对比几次，此处不再分析，自己按照折半查找的过程，考虑一下即可。\n\n> 不难发现，对于索引表采用折半查找的例子，这么多元素，如果一个一个计算它们的对比次数，是过于繁杂的。因此考试一般不会考这样的情况。一般只会考一下索引表为顺序查找下的ASL。\n\n> 而且，以上均为查找成功的情况。而查找失败的情况呢？\n>\n> 因为对于每个分块内，元素都是无序排放的，所以我们不能像之前的折半查找那样明确的表明，就是在某个指定的区间内，是查找失败的情况。\n>\n> 因此对于分块查找，查找失败的情况，会更加复杂。因此考试一般不考查找失败的情况，可以跳过这个问题。\n\n##### 特殊情形\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-52.png\" style=\"zoom:67%;\" />\n\n刚才我们举的两个例子都是比较杂乱的。\n\n此处，若长度为n的查找表被均匀地分为b块，每块s个元素。\n\n设**索引查找和块内查找**的平均查找长度分别为LI、LS，则分块查找的平均查找长度为\n$$\nASL=L_I+L_S\n$$\n在**等概率情况**下，若在块内和索引表中均采用**顺序查找索引表**时\n$$\nL_I=\\frac{1+2+...+b}{b}=\\frac{b+1}{2},L_S=\\frac{1+2+...+s}{s}=\\frac{s+1}{2}\n$$\n则\n$$\nASL = L_I+L_S=\\frac {s^2+2s+n}{2s},当s=\\sqrt n时，ASL_{最小}=\\sqrt n+1\n$$\n\n这个ASL相加之和为什么等于这个结果呢？因为上面我们说了，长度为n的查找表被均匀地分为b块，每块s个元素。所以n = s * b，代入即可。\n\n而ASL的最小值是什么？其实就是一个求极值的问题。求ASL的导数，令导数等于0即可。\n\n> 由此，可以看出。\n>\n> 若n = 10000，也就是查找表中共有10000个元素。\n>\n> 则ASL最小值 = 101，即最优的分块策略为：将n个元素分成100块，每块有100个元素。\n>\n> 即对于这10000个元素来说，平均来看对每个元素只需要101次对比即可找到。\n>\n> 那相比于单纯的顺序查找来说，我们这样的分块查找，效率是提升了很多的。\n>\n> （对于10000个元素，若采用顺序查找，则ASL = 5000）\n\n若对索引表采用折半查找时，则平均查找长度为\n$$\nASL = L_I+L_S=\\lceil\\log_2(b+1)\\rceil+\\frac {s+1}2\n$$\n\n折半查找这个地方有个印象就可以，不是特别重要，也不再深入探讨。\n\n#### 拓展思考\n\n<font color='cornflowerblue'>若查找表是“动态查找表”，有没有更好的实现方式？</font>——链式存储\n\n对于之前的例子，我们的数据都是用顺序存储的方式进行存放的。\n\n但是如果查找表中经常需要进行元素的增加、删除。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-53.png\" style=\"zoom:67%;\" />\n\n比如我要添加一个8，那么我肯定不是在查找表的最后一位插入的。如果我们要插入8，是要在第一个分块内插入8。\n\n<font color='cornflowerblue'>那么这会导致什么</font>？\n\n会导致，我们需要把其之后的全部元素，全部往后移一位。\n\n所以，如果我们使用数组的方式来实现查找表的话，那么如果你是一个动态查找表，即需要进行插入、删除操作，那么你要维护块间有序的特性，就要付出很大的代价。\n\n<font color='cornflowerblue'>那么有没有更好的实现方式</font>？\n其实我们可以用**链式存储**。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-54.png\" style=\"zoom:67%;\" />\n\n索引表中的元素，链式地存储起来。对应的各个分块中的数据元素，也链式地存储起来。\n\n那么这样一来，你若要添加8这个元素，只需要在第一个分块的链表尾部插入8即可，如下\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-55.png\" style=\"zoom: 33%;\" />\n\n删除一个元素也是类似的。\n\n甚至，如果你感觉某一个分块内的元素太多了，你也可以对这个分块的链表进行拆分。总之，可以根据现实遇到的需求，进行灵活的决定。（数据结构这门课不可能给你把所有能够遇到的情况全部罗列出来，它只是点明一种逻辑思想）\n\n### 习题\n\n- 由n个数据元素组成的两个表：一个递增有序，一个无序。采用顺序查找算法，对有序表从头开始查找，发现当前元素已不小于待查元素时，停止查找，确定查找不成功，已知查找任一元素的概率是相同的，则在两种表中成功查找→B\n\n  A 平均时间后者小\n  B 平均时间两者相同\n  C 平均时间前者小\n  D 无法确定\n\n- 【2010】已知一个长度为16的顺序表L，其元素按关键字有序排列，若采用折半查找法查找一个L中不存在的元素，则关键字的比较次数最多是→5\n\n  > 一次找到最边界的那一个数的情况下是最多次数的。 \n  >\n  > eg:  找的是第16个数 \n  >\n  > (0+15)/2  7   　第1次   (8+15)/2  11  　第2次 \n  >\n  > (12+15)/2  13 　第3次   (14+15)/2 14   第4次 \n  >\n  > (15+15)/2  15  第5次\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-56.png\" style=\"zoom: 33%;\" />\n\n- 【2015】下列选项中，不能构成折半查找中关键字比较序列的是-->A\n\n  A. 500,200,450,180\n\n  B. 500,450,200,180\n\n  C. 180,500,200,450\n\n  D. 180,200,500,450\n\n  > 试着画出查找路径图，因为折半查找的判定树是一棵二叉排序树，看其是否满足二叉排序树的要求。很显然，选项 A 的查找路径不满足。\n\n- 【2016】在有n(n>1000)个元素的升序数组A中查找关键字x。查找算法的伪代码如下:\n\n  ```C\n  while(k<n 且 A[k]<x) k=k+3;\n  if(k<n 且 A[k]==x) 查找成功;\n  else if(k-1<n 且 A[k-1]==x) 查找成功;\n          else if(k-2=n 且 A[k-2]==x) 查找成功;\n                  else 查找失败;\n  ```\n\n  本算法与折半查找算法相比，有可能具有更少比较次数的情形是-->B\n\n  A．当x不在数组中\n\n  B．当x接近数组开头处\n\n  C．当x接近数组结尾处\n\n  D．当x位于数组中间位置\n\n  > 该程序采用跳跃式的顺利查找法查找升序数组中的x，显然是x越靠前，比较次数才会越少。\n\n- 【2017】下列二叉树中，可能成为折半查找判定树(不含外部结点)的是-->A\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-57.png\" style=\"zoom: 33%;\" />\n\n  > 折半查找判定树实际上是一棵二叉排序树，它的中序序列是一个有序序列。可以在树结点上依次填上相应的元素，符合折半查找规则的树即是所求。 \n  >\n  > B选项4、5相加除二向上取整，7、8相加除二向下取整，矛盾。C选项，3、4相加除二向上取整，6、7相加除二向下取整，矛盾。D选项，1、10相加除二向下取整，6、7相加除二向上取整，矛盾。A符合折半查找规则，正确。\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-58.png\" style=\"zoom:67%;\" />\n  >\n  > 可以看看https://blog.csdn.net/qq_41754065/article/details/106590844\n\n- 综合题【2013】设包含4个数据元素的集合S={'do','for','repeat','while'}，各元素的查找概率依次为p1 = 0.35 ,p2 = 0.15,p3 = 0.15,p4 = 0.35。将S保存在一个长度为4 的顺序表中，采用折半査找法，査找成功时的平均查找长度为2.2。请回答： \n\n  (1) 若采用顺序存储结构保存S,且要求平均査找长度更短，则元素应如何排列？应使用何种查找方法？査找成功时的平均査找长度是多少？ \n\n  (2) 若釆用链式存储结构保存S,且要求平均査找长度更短，则元素应如何排列？应使用何种查找方法？查找成功时的平均查找长度是多少？\n\n  > (1)采用顺序存储结构，数据元素按其查找概率降序排列。\n  >\n  > 采用顺序查找方法。\n  >\n  > 查找成功时的平均查找长度=0.35x1+0.35x2+0.15x3+0.15x4=2.1。\n  >\n  > (2)\n  >\n  > 答案一：\n  >\n  > 采用链式存储结构，数据元素按其查找概率降序排列，构成单链表。\n  >\n  > 采用顺序查找方法。\n  >\n  > 查找成功时的平均查找长度=0.35x1+0.35x2+0.15x3+0.15x4=2.1。\n  >\n  > 答案二：\n  >\n  > 采用二叉链表存储结构，构造二叉排序树，元素存储方式见下图\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-59.png\" style=\"zoom:67%;\" />\n  >\n  > 采用二叉排序树的查找方法。\n  >\n  > 查找成功时的平均查找长度=0.15x1+0.35x2+0.35x2+0.15x3=2.0\n","tags":["408数据结构"],"categories":["408数据结构"]},{"title":"第六章 图(下)","url":"/p/12342/","content":"\n## 6.4 图的应用\n\n### 最小生成树 Minimum-Spanning-Tree, MST\n\n之前我们已经学过什么是生成树。\n\n连通图的**生成树**是包含图中全部顶点的一个极小连通子图。\n\n若图中顶点数为n，则它的生成树含有n-1条边。对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-57.png\" style=\"zoom:80%;\" />\n\n一个图可以有许多棵不同的生成树，所有生成树具有以下共同特点：\n\n- 生成树的顶点个数与图的顶点个数相同\n- 生成树是图的极小连通子图，去掉一条边则非连通\n- 一个有n个顶点的连通图的生成树有 n-1 条边（含有n个顶点，n-1条边的图不一定是生成树。）\n- 在生成树中再加一条边必然形成回路\n- 生成树中任意两个顶点间的路径是唯一的。\n\n#### 无向图的生成树\n\n就在上一小节，我们也介绍了，广度优先生成树和深度优先生成树。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-58.png\" style=\"zoom: 67%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-59.png\" style=\"zoom: 67%;\" />\n\n#### 最小生成树\n\n给定一个无向网，在该网中的所有生成树中，使得各边权值之和最小的那棵生成树称为该网的**最小生成树**，也叫**最小代价生成树**。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-60.png\" style=\"zoom:67%;\" />\n\n构造最小生成树的算法很多，其中多数算法都利用了 MST 的性质。\n\n<font color='red'>MST性质</font>：设N=(V,E)是一个连通网，U是顶点集V的一个非空子集。若边(u,v)是一条具有最小权值的边，其中u∈U，v∈V-U，则必存在一棵包含边(u,v)的最小生成树。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-61.png\" style=\"zoom: 67%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-62.png\" style=\"zoom:67%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-63.png\" style=\"zoom:67%;\" />\n\n#### Prim算法(普利姆)\n\n**Prim算法**:从某一个顶点开始构建生成树；每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止。\n\n**算法思想**:\n\n此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。\n\n1. 图的所有顶点集合为V；初始令集合u={s},v=V−u={s},v=V−u;\n2. 在两个集合u,v能够组成的边中，选择一条代价最小的边(u0,v0)，加入到最小生成树中，并把v0并入到集合u中。\n3. 重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。\n\n例如：\n\n我们要构造如下图的最小生成树，我们选取一个顶点，这个顶点就是U集合，其他顶点就是V-U集合\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-64.png\" style=\"zoom: 67%;\" />\n\n在U集合当中的顶点和V-U集合当中的顶点中找一条权值最小的边，将边关联的顶点选取到我们的U集合，其他顶点为V-U集合\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-65.png\" style=\"zoom: 67%;\" />\n\n之后在U集合当中的顶点和V-U集合当中的顶点中找一条权值最小的边，V1到V2为6，V1到V4为5，V3到V2为5，V3到V4为5，V3到V5为6，V3到V6为4。所以选取权值最小的边4，其关联的顶点为V6，将其加入到U集合中。此时U集合为{V1,V3,V6}\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-66.png\" style=\"zoom:67%;\" />\n\n重复上述操作，V1周边的权值为6，5，V3周边的权值为5,5,6，V6周边的权值为6，V4周边不能选(一旦选了有回路成环了)\n\n我们选择权值最小的V3到V2的5，将V2加入到U集合中\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-67.png\" style=\"zoom:67%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-72.png\" style=\"zoom:67%;\" />\n\n#### Kruskal算法(克鲁斯卡尔)\n\n**Kruskal算法**:每次选择一条权值最小的边，使这条边的两头连通(原本已经连通的就不选) 直到所有结点都连通\n\n**算法思想**：\n\n此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。\n\n1. 把图中的所有边按代价从小到大排序；\n2. 把图中的n个顶点看成独立的n棵树组成的森林；\n3. 按权值从小到大选择边，所选的边连接的两个顶点ui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。\n4. 重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。\n\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-68.png\" style=\"zoom: 67%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-71.png\" style=\"zoom:67%;\" />\n\n#### 比较\n\n| 算法名     | 普里姆算法 | 克鲁斯卡尔算法            |\n| :--------- | :--------- | :------------------------ |\n| 算法思想   | 选择点     | 选择边                    |\n| 时间复杂度 | O(\\|V\\|^2) | O(\\|E\\|log\\|E\\|)(E为边数) |\n| 适应范围   | 稠密图     | 稀疏图                    |\n\n#### 代码思想\n\n##### Prim算法\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds-142.png\" style=\"zoom: 67%;\" />\n\n从v0开始。\n\n- 由于当前树中只有v0，所以isJoin数组中只有v0是TRUE，其他为FALSE。此外，lowCost中的各个结点加入树的最低代价，是看从v0出发，加入各个结点的最低代价。\n\n- 第1轮：循环遍历所有结点，找到lowCost最低的，且还没加入树的顶点。于是将v3加入树。\n\n- 此时，由于v3的加入，isJoin数组中v3也是TRUE。且，此时lowCost中的各个结点加入树的最低代价，不止是看由v0出发的边，而是也要看v3出发的边，因此lowCost数组应该更新。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds-142.png\" style=\"zoom: 67%;\" />\n\n  \n\n- 第2轮：和第1轮是一模一样的。循环遍历所有结点，找到lowCost最低的，且还没加入树的顶点。因此我们会把v2加入到树里面。并同时需要把lowCost数组的内容重新更新。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-145.png\" style=\"zoom:67%;\" />\n\n- 第3轮：同理。把v5加入。并且更新lowCost。\n\n- 第4轮：同理。把v1加入。并且更新lowCost值。\n\n- 第5轮：只剩下v4。所以再把v4加入。\n\n> 由v0开始，总共需要n-1轮处理。\n>\n> 每一轮处理：循环遍历所有结点，找到lowCost最低的，且还没加入树的顶点。接着，再次循环遍历，更新还没加入的各个顶点的lowCost值。（所以每一轮的时间复杂度为O(2n)）。\n>\n> 所以总的时间复杂度的数量级为O(n^2)， 也就是O(|V|^2)。\n\n算法的大致执行就是这样的。有能力的可以自己动手实现一遍。但是对于考研初试阶段来说我们可以先不展开此处代码的编写\n\n##### Kruskal算法\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-144.png\" style=\"zoom: 50%;\" />\n\n\n\n由于这个算法每次要选择权值最小的一条边。所以我们要做这样的一个预处理，就是要先把各条边按照权值递增的顺序做一个排序。那么这个算法的执行，就是要把所有的这些边都检查一遍。\n\n第1轮：检查第1条边的两个顶点是否连通（是否属于同一个集合）。将v0——v3连起来。\n\n- 进行这个判断实际上是用到了**并查集**，并查集相关的内容由于在408中不要求掌握，我们只是大概说一下。\n- 我们首先把不同的顶点看作一个个不同的集合。那么v0和v3刚开始是从属于不同的集合的。也就意味着它们此时不连通。那么我们就可以把这条边给选上。\n- 同时，如果把这两个顶点给连上的话，那么这两个顶点此时就变成了同一个集合。\n\n第2轮：检查第2条边的两个顶点是否连通（是否属于同一个集合）。将v2——v5连起来。\n\n第3轮：检查第3条边的两个顶点是否连通（是否属于同一个集合）。将v1——v4连起来。\n\n第4轮：检查第4条边的两个顶点是否连通（是否属于同一个集合）。将v2——v3连起来。\n\n第5轮：检查第5条边的两个顶点是否连通（是否属于同一个集合）。由于**已连通，则跳过**。\n\n接下来的过程省略，总之我们需要把所有边都遍历一遍。在遍历到每条边的时候我们都要判断，这条边的两个顶点，它们是否从属于同一个集合。如果不属于一个集合，那就把这条边选上。\n\n> 整个图里，总共有|E|条边。\n>\n> 那么这个算法总共要执行|E|轮。\n>\n> 每轮判断两个顶点是否属于同一集合，需要O(log₂|E|)。（需要用到并查集）。\n>\n> 总时间复杂度为O(|E|log₂|E|)。\n\n### 最短路径 Short Path First, SPF\n\n问题抽象：在有向网中A点(源点)到达B点(终点)的多条路径中，寻找一条各边权值之和最小的路径。即最短路径。\n\n<font color='cornflowerblue'>最短路径与最小生成树不同，路径上不一定包含n个顶点，也不一定包含n-1条边。</font>\n\n第一类问题:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-73.png\" style=\"zoom:67%;\" />\n\n第二类问题:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-74.png\" style=\"zoom:67%;\" />\n\n- 单源最短路径\n  - BFS算法（无权图）\n  - Dijkstra算法（带权图、无权图）\n- 各顶点间的最短路径\n  - Floyd算法（带权图、无权图）\n\n#### BFS求无权图的单源最短路径\n\n**注**：无权图可以视为一种特殊的带权图，只是每条边的权值都为1。\n\n对这个图执行一次广度优先遍历，我们就可以得到由某个源点出发，到其他各个结点的最短路径。\n\n**代码实现**:\n\n先看BFS算法\n\n```C\nbool visited[MAX_VERTEX_NUM];\t//访问初始数组\n\n//广度优先遍历\nvoid BFS(Graph G, int v) {\n    visit(v);\n    Enqueue(Q,v);\n    while(!isEmpty(Q)) {\n        DeQueue(Q,v);\n        for(w=FirstNeighbor(G,v); w>=0; w=NextNeighbor(G,v,w)) {\n            if(!visited[w]) {\n                visit(w);\n                visited[w] = TRUE;\n                EnQueue(Q,w);\n            }\n        }\n    }\n}\n\n```\n\n我们要通过BFS算法来求单源最短路径，那么主体框架不变，对其中的一些地方的处理进行一些改变就可以。如下。\n\n```C\n//求顶点u到其他顶点的最短路径\nvoid BFS_MIN_Distance(Graph G, int u) {\n    //d[i]表示从u到i结点的最短路径\n    for(i=0; i<G.vexnum; ++i) {\n        d[i] = ∞;\t//初始化路径长度\n        path[i] = -1;\t//最短路径从哪个顶点过来\n    }\n    d[u] = 0;\n    visited[u] = TRUE;\n    EnQueue(Q,u);\n    while(!isEmpty(Q)) {\t//BFS算法主体过程\n        DeQueue(Q,u);\t//队头元素u出队\n        for(w=FirstNeighbor(G,u); w>=0; w=NextNeighbor(G,u,w)) {\n            if(!visited[w]) {\t\t//w为u的尚未访问的邻接点\n                d[w] = d[u] + 1;\t//路径长度+1\n                path[w] = u;\t\t//最短路径应从u到w\n                visited[w] = TRUE;\t//设已访问标记\n                EnQueue(Q,w);\t//顶点w入队\n            }\n        }\n    }\n}\n```\n\n![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-146.png)\n\n![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-147.png)\n\n就是对BFS算法的小修改。\n\n在visit一个顶点时，修改其最短路径长度`d[]`并在`path[]`记录前驱结点。\n\n> 可以看出。2到8的最短路径长度 = `d[8]` = 3\n>\n> 通过path数组可知，2到8的最短路径为：`8<--7<--6<--2`\n\n之前也说到，通过广度优先遍历，能够得到广度优先生成树。那么也可以观察一下这个广度优先生成树：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-148.png\" style=\"zoom:67%;\" />\n\n这个生成树，它的每个结点在第几层，也直接地反映了从根结点2，到达它的最短路径是多少。\n\n不难得知，通过广度优先遍历构造出的这个广度优先生成树，它的高度一定是最小的。\n\n#### Dijkstra算法\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-83.png\" style=\"zoom:67%;\" />\n\n**BFS算法的局限性**:BFS算法求单源最短路径只适用于<font color='orange'>无权图</font>，或<font color='orange'>所有边的权值都相同</font>的图\n\nDijkstra(迪杰斯特拉)算法是典型的<font color='orange'>单源最短路径算法</font>，用于计算一个节点到其他所有节点的最短路径。主要特点是<font color='orange'>以起始点为中心向外层层扩展，直到扩展到终点为止</font>。Dijkstra算法是很有代表性的最短路径算法，在很多专业课程中都作为基本内容有详细的介绍，如数据结构，图论，运筹学等等。注意该算法要求图中不存在负权边。\n\n**问题描述**：在无向图 G=(V,E) 中，假设每条边 E[i] 的长度为 w[i]，找到由顶点 V0 到其余各点的最短路径。（单源最短路径）\n\n1. 初始化：先找出从源点V0到各终点Vk的直达路径(V0,VK),即通过一条弧到达的路径。\n2. 选择：从这些路径中找出一条长度最短的路径(V0,u)\n3. 更新：然后对其余各条路径进行适当调整\n   - 若在图中存在弧(u,Vk),且(V0,u)+(u,Vk) < (V0,Vk)，则以路径(V0,u,Vk)代替(V0,Vk)\n   - 在调整后的各条路径中，再找长度最短的路径，以此类推。\n\n------\n\n**迪杰斯特拉算法**：按路径长度递增次序产生最短路径\n\n1. 把V分成两组：\n\n   (1)S：已求出最短路径的顶点的集合\n\n   (2)T=V-S：尚未确定最短路径的顶点集合\n\n2. 将T中顶点按最短路径递增的次序加入到S中，保证：\n\n   (1)从源点V0到S中各顶点的最短路径长度都不大于从V0到T中的任何顶点的最短路径长度。\n\n   (2)每个顶点对应一个距离值：\n\n    S中顶点：从V0到此顶点的最短路径长度\n\n    T中顶点：从V0到此顶点的只包括S中顶点作中间顶点的最短路径长度。\n\n执行动画过程如下图\n\n![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-75.gif)\n\n**多说无益，我们来看一个例子**\n\n##### 王卓版本\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-76.png\" style=\"zoom:67%;\" />\n\n初始时令 S = {V0}，T={其余顶点}\n\n记录V0到其他顶点的距离：若<V0,Vi>存在，则为其权值，若不存在，则为∞。使用辅助数组D存放\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-77.png\" style=\"zoom:67%;\" />\n\nV0到V1可以直达，为其权值13。V0到V2可以直达，为其权值8。V0到V3不可以直达，为∞。以此类推，然后从T中选取一个距离值最小的顶点Vj，加入S。例如我们上图中的8最小，则将V2加入S。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-78.png\" style=\"zoom:67%;\" />\n\n接下来我们要计算 **从V0直接出发到各个顶点的路径和从V0出发经过V2再到各个顶点的路径**，看是否有距离减少，没有减少则不需要改值。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-79.png\" style=\"zoom:67%;\" />\n\n如上图，加入V2之后：\n\nV0到V1的值为13，V0经过V2再到V1是无法直达为∞，所以V0到V1的最短路径依旧是13\n\nV2已经加入到S集合，所以不需要管V2。\n\nV0到V3无法直达为∞，V0经过V2再到V3可以直达为 8+5=13，所以V0到V3的最短路径为13\n\nV0到V4直达为30，V0经过V2再到V4无法直达为∞，所以V0到V4的最短路径为30\n\nV0到V5无法直达为∞，V0经过V2再到V5也无法直达为∞，所以V0到V5的最短路径为∞\n\nV0到V6直达为36，V0经过V2再到V6无法直达为∞，所以V0到V6的最短路径为32\n\n从上述最短路径中选出最小的为13，我们选择序号更小的V1，将其加入到S集合中。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-80.png\" style=\"zoom:67%;\" />\n\n此时S集合为V0、V1、V2\n\nV0到V3的最短路径依旧13\n\nV0到V4的最短路径依旧是30\n\nV0到V5无法直达，但是可以经过V1再直达，所以最短路径为 13+9=22\n\nV0到V6直达为32，但是可以经过V1再直达，所以最短路径为 13+7=20\n\n从上述最短路径中挑选值最小的为13，所以将V3加入到集合S中。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-81.png\" style=\"zoom:67%;\" />\n\n最终结果如下：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-82.png\" style=\"zoom:67%;\" />\n\n------\n\n##### 王道版本\n\n这里以有向图举例。为什么不用无向图呢，因为无向图的边等价于两条有向边，是一样的道理。我们只需要说清楚有向图的原理，无向图自然也就清楚了。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-149.png\" style=\"zoom: 50%;\" />\n\n由v0作为源点出发。\n\n我们需要设三个数组\n\n- final数组，表示各顶点是否已找到最短路径。显然先设v0为TRUE。\n- dist数组（distance），表示目前已知条件下，到达某结点的最短路径长度。\n  - 此时只有一个v0是可知的，那么目前来看，到v1的最短路径是10，到v4的最短路径是5，而到v2和v3是∞。\n- path数组，和BFS算法中的path数组是一个意思，就是记录通往结点的路径是由哪个结点过来的，也就是最短路径上的前驱结点。\n  - v1结点目前能找到的最好的一条路径，是从v0过来的，那么path设为0。v4同理。\n\n以上是三个数组的初始化，接下来我们开始一轮一轮的处理。\n\n**第一轮**：\n\n循环遍历所有结点，找到还没确定最短路径，且dist最小的顶点Vi，令final[i] = TRUE。\n\n- 那么显然，在V1~V4中，dist最小的顶点是V4的5。并将V4的final设为TRUE。也就是说，我现在已经可以确定V4的最短路径长度就是5，并且它的直接前驱是0号结点。\n\n检查所有邻接自Vi的顶点，若其final值为false，则更新dist和path信息。\n\n- 也就是检查V1~V3，看看它们如果由V4过来的话，有没有可能比之前的路径更短。\n  - 对于V1：如果改用从V4过来，那么总长度为5+3=8，比原先的10更短，则更新。\n  - 对于V2：原先我们根本就没有到达V2的路径，现在如果我们从V4出发，则有一条到V2的路径，则更新。\n  - 对于V3：和V2同理，更新。\n\n第一轮处理结果如下\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-150.png\" style=\"zoom: 67%;\" />\n\n**第二轮**：\n\n处理逻辑和第一轮是相同的。\n\n- 遍历V1~V3，看看谁的dist最小，找到V3，将V3的final设为TRUE。\n- 检查所有能够从V3过去的顶点，当然我们只需要检查final为false的顶点。\n  - 从V3过去的顶点有V0和V2，但是V0我们不需要考虑，所以只看V2。\n  - 对V2这个顶点，如果我们是从V3过去的，那么路径长度为7+6=13的路径，显然比原先的14更短，则更新V2的dist为13，并更新V2的path为3。\n\n第二轮处理结果：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-151.png\" style=\"zoom: 67%;\" />\n\n**第三轮**：\n\n- 遍历V1~V2，看看谁的dist最小，则找到V1，并将其final设为TRUE。\n- 检查所有从V1过去，且final为false的顶点。即V2。\n  - 对于V2，检查是否需要更新dist和path信息。\n  - 若V2是由V1过去的，则路径长度为8+1=9，比原先的13短。于是更新dist为9，更新path为1。\n\n第三轮处理结果：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-152.png\" style=\"zoom: 67%;\" />\n\n**第四轮**：\n\n- 遍历V2，V2的dist最小，将V2的final设为TRUE。\n- 所有结点的final全部为TRUE。此时已经找不到final为false的顶点了。\n- 算法到此结束。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-153.png\" style=\"zoom:67%;\" />\n\n以上就是Dijkstra算法的执行过程。\n\n> 通过执行结果可知，\n>\n> V0到V2的最短（带权）路径长度为：dist[2] = 9\n>\n> 通过`path[]`可知，V0到V2的最短（带权）路径：`V2<--V1<--V4<--V0`\n\n##### Dijkstra算法的时间复杂度\n\n**对于考研来说，这个算法只需要理解手动执行的过程，能够手算即可。**\n\n我们也简单的提一下，如果用代码实现，大致的思路是什么样的。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-154.png\" style=\"zoom:67%;\" />\n\n- 初始：若从V0开始。令`final[0] = TRUE`；`dist[0] = 0`；`path[0] = -1`。其余顶点`final[k] = false`；`dist[k] = arcs[0][k]`；`path[k] = (arcs[0][k]==∞) ? -1 : 0`。\n- 第n-1轮处理:\n  - 循环遍历所有顶点，找到还没确定最短路径，且dist最小的顶点Vi，令其`final[i] = true`。并遍历所有邻接自Vi，且还没确定最短路径的顶点，即`final[j] == false`，若`final[j] == false && dist[i]+arcs[i][j] < dist`，则令`dist[j] = dist[i] + arcs[i][j]; path[j] = i;`（注：`arcs[i][j]`表示Vi到Vj的弧的权值）\n\n**现在探讨一下其时间复杂度的问题**\n\n对于每一轮处理来说，我们都要循环**遍历所有顶点**，找到还没确定最短路径，且dist最小的顶点。所以需要O(n)的时间复杂度。此外，找到这个结点之后，还需要检查所有和它相邻的邻接点，又需要O(n)的时间复杂度。\n\n所以每一轮处理的时间复杂度为O(2n)，即O(n)。\n\n而总共需要n-1轮处理。所以整个算法的时间复杂度为O(n²)。即O(|V|²)。\n\n> 可以发现，这个算法其实和Prim算法是比较类似的。此代码的`dist[]`数组，和Prim算法中的`lowCost[]`数组的作用是很类似的。\n\n##### 用于负权值带权图\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-155.png\" style=\"zoom:50%;\" />\n\n\n\n这是Dijkstra算法的一个小坑。\n\n如果带权图里，有负权值的边。那么Dijkstra算法有可能就会失效，找不到最短路径。\n\n按照算法的规则，我们执行一遍：\n\n- 初始：如上图所示。\n- 第一轮：\n  - 遍历V1、V2，找到V2的dist最短，设其final为true，path为0。\n  - 第一轮结束。\n- 第二轮：\n  - 只剩下V1，将其final设为true，path为0。\n- 此时所有结点的final均为TRUE，算法执行完毕。\n\n最终结果如下\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-156.png\" style=\"zoom: 50%;\" />\n\n但是，事实上，V0到V2的最短带权路径长度为5。\n\n因此，**Dijkstra算法不适用于有负权值的带权图**。\n\n#### Floyd算法\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-86.png\" style=\"zoom:67%;\" />\n\n**Floyd-Warshall算法**（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd-Warshall算法的时间复杂度为O(N3)，空间复杂度为O(N2)。\n\n**算法思想**:\n\n<font color='cornflowerblue'>Floyd算法是一个经典的动态规划算法</font>。用通俗的语言来描述的话，首先我们的目标是寻找从点i到点j的最短路径。从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在）\n\n   从任意节点i到任意节点j的最短路径不外乎2种可能，1是直接从i到j，2是从i经过若干个节点k到j。所以，我们假设Dis(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，我们<font color='cornflowerblue'>检查Dis(i,k) + Dis(k,j) < Dis(i,j)</font>是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，我们<font color='cornflowerblue'>便设置Dis(i,j) = Dis(i,k) + Dis(k,j)</font>，这样一来，当我们遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。\n\n对于n个顶点的图G，求任意一对顶点Vi—>Vj之间的最短路径可分为如下几个阶段：\n\n- 初始：不允许在其他顶点中转，最短路径是？\n- 0：若允许在V0中转，最短路径是？\n- 1：若允许在V0、V1中转，最短路径是？\n- 2：若允许在V0、V1、V2中转，最短路径是？\n- ……\n- n-1：若允许在V0、V1、V2……V(n-1)中转，最短路径是？\n\n步骤如下：\n\n1. 初始时设置一个n阶方阵，令其对角线元素为0，若存在弧 <Vi,Vj>,则对应元素为权值，否则为∞\n2. 逐步试着在原直接路径中增加中间顶点，若加入中间顶点后路径变短，则修改之，否则，维持原值。所有顶点试探完毕，算法结束\n\n**来看一个例子**：\n\n##### 王卓版本\n\n有3各顶点，则设置一个3阶方阵，令其对角线为0，若存在弧，则对应元素为权值。\n\n例如<A,B>权值为4，<A,C>权值为11.\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-84.png\" style=\"zoom:67%;\" />\n\n加入A顶点后：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-85.png\" style=\"zoom:67%;\" />\n\nA到B，A到C距离没有变化。B到A，B到C距离也没有变化。C到A距离没有变化，C到B之前没有直达路径，加入A顶点之后可以从C经过A再到B，所以距离为 3+4=7\n\n加入B顶点之后：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-87.png\" style=\"zoom:67%;\" />\n\nA带B距离无变化，A到C直达路径为11，但是经过B路径为 4+2=6。\n\nB到A，B到C距离无变化。\n\nC到A，C到B距离无变化。\n\n加入C顶点后：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-88.png\" style=\"zoom:67%;\" />\n\n------\n\n##### 王道版本\n\n我们来把这个算法流程跑一遍。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-157.png\" style=\"zoom:67%;\" />\n\n我们设置两个矩阵（二维数组）。\n\n第一个矩阵，其实就是这个有向图的邻接矩阵。\n\n> 由于初始阶段，我们不允许有其他顶点中转的情况出现，因此，例如V0——V2，就只能走13这条路。\n>\n> 所以，第一个矩阵中，第一行第三列就是13。\n\n第二个矩阵，存放的就是，我们目前能够找到的最短路径当中，两个顶点之间的一个中转点。\n\n> 初始阶段，所有顶点之间都不可以有中转点，所以全是-1。\n\n以上是**初始阶段**的流程。\n\n**0阶段**：\n\n若允许在**V0**中转，最短路径是？——求A(0)和path(0)。\n\n我们要基于上一轮求得的两个矩阵的信息，得到这一轮的两个矩阵中应该填入的最优信息。\n\n求解的方法很简单，我们需要遍历上一阶段留下来的这个矩阵A，对于矩阵A当中的每一个具体的元素，我们都需要进行以下处理：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-158.png\" style=\"zoom:67%;\" />\n\n> 例如对于矩阵A中，第三行第二列，也就是V2——V1的这个数据。如果允许在V0中转，那么考虑\n> $$\n> A^{(-1)}[2][1]>A^{(-1)}[2][0]+A^{(-1)}[0][1]=11\n> $$\n>\n> $$\n> 则A^{(0)}[2][1]=11\n> $$\n>\n> $$\n> path^{(0)}[2][1]=0\n> $$\n\n当然，对于这个矩阵中的所有位置的元素，都需要依次循环遍历一遍，各进行判断。（按照上面的处理方法）\n\n实际上，在对所有位置元素均各执行一遍判断之后，需要改变的也就只有这一个位置，如下图\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-159.png\" style=\"zoom:67%;\" />\n\n**1阶段**：\n\n若允许在V0、**V1**中转，最短路径是？——求A(1)和path(1)。\n\n我们需要在基于0阶段得到的两个矩阵的基础上，来计算该阶段的矩阵内容，也就是1阶段的最优解。\n\n那还是利用刚才的这个规则：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-159.png\" style=\"zoom:67%;\" />\n\n我们要基于前一个阶段的矩阵的值，来对此阶段的矩阵内容进行一个判断。\n\n> 对所有元素都遍历一遍之后，我们会发现这样一个地方，是满足需要被处理的条件的：\n> $$\n> A^{(0)}[0][2]>A^{(0)}[0][1]+A^{(0)}[1][2]=10\n> $$\n>\n> $$\n> 则A^{(1)}[0][2]=10\n> $$\n>\n> $$\n> path^{(1)}[0][2]=1\n> $$\n\n经过修改之后，矩阵会变成这样：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-160.png\" style=\"zoom:67%;\" />\n\n**2阶段**：\n\n若允许在V0、V1、**V2**中转，最短路径是？——求A(2)和path(2)。\n\n要以1阶段得出的矩阵信息，作进一步处理，得到此阶段的最优解。\n\n依然是同样的处理规则。依次扫描矩阵中的所有元素，并处理满足条件的元素。\n\n> 全部扫描过后，可以发现只有一个地方满足，如下\n> $$\n> A^{(1)}[1][0]>A^{(1)}[1][2]+A^{(1)}[2][0]=9\n> $$\n>\n> $$\n> 则A^{(2)}[1][0]=9\n> $$\n>\n> $$\n> path^{(2)}[1][0]=2\n> $$\n\n到此，我们就求出了A(2)和path(2)：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-161.png\" style=\"zoom:67%;\" />\n\n到了这一步，从A(-1)和path(-1)开始，我们已经经过了**n轮递推，**每一轮递推，我们都会增加考虑一个新的结点作为中转点，**得到A(n-1)和path(n-1)**。到此，我们便得到了每两个顶点之间最短路径的长度，和路径上的信息。（n指的是总结点个数）\n\n> 观察两表，\n>\n> 例如，V1到V2的最短路径。检查A数组，发现长度是4；再检查path数组，发现它们之间是不经过任何中转点的，因此这条最短路径为V1—V2。\n>\n> 例如，V0到V2的最短路径。查找A数组，发现长度是10；再查path数组，V0到V2之间的中转点是1号中转点，因此这条最短路径为V0—V1—V2。\n>\n> 同理，V1到V0的最短路径长度为9，路径为V1—V2—V0。\n\n所以，Floyd算法的思想虽然有些抽象，但是实现起来还是比较简单的。\n\n**Floyd算法核心代码**：\n\n```C\n//......准备工作，根据图的信息初始化矩阵A和path（如上图）\nfor(int k=0; k<n; k++) {\t\t//考虑以Vk作为中转点\n    for(int i=0; i<n; i++) {\t//遍历整个矩阵，i为行号，j为列号\n        for(int j=0; j<n; j++) {\n            if(A[i][j] > A[i][k] + A[k][j]) {\t//以Vk为中转点的路径更短\n                A[i][j] = A[i][k] + A[k][j];\t//更新最短路径长度\n                path[i][j] = k;\t\t//中转点\n            }\n        }\n    }\n}\n```\n\n可见，这个算法的时间复杂度为O(n³)，即O(|V|³)。（三层嵌套）；空间复杂度为O(|V|²)。（两个矩阵）。\n\n> 注意，上面这个例子，只是有三个结点，这个例子虽然能帮助我们理解Floyd算法的流程，但是，这个例子在我们考虑加入中转点的时候，最多也就只需要走两条边。\n>\n> 而对于Floyd算法的真正的作用、效果，这个例子体现的并不是很好。\n\n##### 一个较复杂的例子\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-162.png\" style=\"zoom:67%;\" />\n\n**0阶段**：\n\n若允许在**V0**中转，最短路径是？\n\n依次检查矩阵中所有元素，检查规则为：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-158.png\" style=\"zoom:67%;\" />\n\n代码体现如下：\n\n```C\nfor(int i=0; i<n; i++) {\t\t//遍历整个矩阵，i为行号，j为列号\n    for(int j=0; j<n; j++) {\n        if(A[i][j] > A[i][k] + A[k][j]) {\t//以Vk为中转点的路径更短\n            A[i][j] = A[i][k] + A[k][j];\t//更新最短路径长度\n            path[i][j] = k;\t//中转点\n        }\n    }\n}\n```\n\n对于这个代码，此阶段就是执行k=0的情况。\n\n遍历矩阵中所有元素后，会发现所有元素都不需要更新。\n\n得到A(0)和path(0)：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-163.png\" style=\"zoom:67%;\" />\n\n> 实际上，从这个图本身也很好理解。V0这个结点只有出边，没有入边。那么，没有任何一个结点能够进入V0处，又怎么可能在V0中转呢？所以两矩阵内容并没有发生任何改变。\n\n**1阶段**：\n\n若允许在V0、**V1**中转，最短路径是？\n\n依然是遵循同样的规则/代码（k=1）。\n\n遍历过后，发现需要更改的地方，如下\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-164.png\" style=\"zoom:67%;\" />\n\n经过这一轮的处理，两矩阵更新如下：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-165.png\" style=\"zoom:67%;\" />\n\n**2阶段**：\n\n若允许在V0、V1、**V2**中转，最短路径是？\n\n遍历过后，发现需要更改的地方，如下：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-166.png\" style=\"zoom:67%;\" />\n\n> **注意**：\n>\n> 分析此步骤所反映出的结果。\n>\n> 也就是有两处需要优化：\n>\n> 0结点到1结点，改为了0—2，再2—1，OK；\n>\n> 0结点到3结点，改为了0—2，再2—3，？？？\n>\n> 通过看图，我们发现V2到V3之间没有“边”呀？为什么呢？\n>\n> **这就是因为，在上一阶段，对于V2到V3的路径，已经是由V1中转过的结果了（也就是为什么每一阶段要在上一阶段两个矩阵中的信息的基础之上进行求最优解）**。而不是单纯的理解为V2到V3是否有”边“的问题。\n>\n> 实际上，这个`A^{(1)}[2][3]`，它反映的就是在上一阶段处理2结点到3结点最短路径问题，所得的结果。（即1阶段中，允许由V0、V1中转，所求得的V2到V3的最短路径）。\n\n由此，我们就能很好的体会到，我们在之前就已经考虑到，增加V1作为中转节点，然后，现在我们的计算，是基于之前已经求得的最优结果的基础之上，再增加V2作为中转点。\n\n> 所以此处这个0结点到3结点的最优路径，表面上看是0—2，再2—3，其实是0—2，再2—1，再1—3。\n\n而对于整个路径来看，其实就已经考虑到了以V0、V1、V2作为中转点的所有情况了。\n\n此阶段处理完后，两矩阵的最新信息如下：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-167.png\" style=\"zoom:67%;\" />\n\n**3阶段**：略\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-168.png\" style=\"zoom:67%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-169.png\" style=\"zoom:67%;\" />\n\n**4阶段**：略。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-170.png\" style=\"zoom:67%;\" />\n\n结束。最终得到的两个矩阵内容如上图\n\n> 现在我们来看一下，怎么解读这两个矩阵中的信息：\n>\n> 例如，要找V0到V4的最短路径。\n>\n> - 由A矩阵可知长度为4。\n> - 由path矩阵\n>   - 首先可以知道V0到V4需要经过一个中转点是V3，也就是说V0需要先到V3，V3再到V4。但是由图中可以看出，V0到V3并没有一条直接存在的路径供我们经过，其实V0到V3的最短路径，其中还是要经过一些中转节点的。而V3到V4是不需要中转的（由path的值为-1即可看出）。\n>   - 再看V0到V3怎么走。由path数组可知，V0到V3，中间还要经过V2。也就是V0需要先到V2，V2再到V3。V0到V2（path的值为-1）是没有中转点的；而V2到V3（path值为1）还需要经过V1中转点。\n>   - 到这一步，整理一下，即`V0 V2 V1 V3 V4`，实际上这就是最终结果了。\n>\n> 总结一下获取最短路径走法的过程（通过path矩阵递归地找到完整路径）：\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-171.png\" style=\"zoom:67%;\" />\n\n可以用path矩阵配合上递归算法很好的解决这个问题。\n\n但是单从考试的角度来看，会手算即可。\n\n但是有个问题，在手算A矩阵的时候，由于这是5行5列的矩阵，我们如果要把所有元素依次完整地执行一遍，其实我们总共需要5³=125次检查。所以在考试的时候，不可能会给你这么复杂的一个图的。让你在考场上进行125次加法、比大小，是没什么意义的。所以考试的时候给的图一般阶数都比较小。\n\n##### 用于负权值带权图\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-172.png\" style=\"zoom:67%;\" />\n\n```C\n//......准备工作，根据图的信息初始化矩阵A和path（见上图）\nfor(int k=0; k<n; k++) {\t//考虑以Vk作为中转点\n    for(int i=0; i<n; i++) {\t//遍历整个矩阵，i为行号，j为列号\n        for(int j=0; j<n; j++) {\n            if(A[i][j] > A[i][k] + A[k][j]) {\t//以Vk作为中转点的路径更短\n                A[i][j] = A[i][k] + A[k][j];\t//更新最短路径长度\n                path[i][j] = k;\t\t//中转点\n            }\n        }\n    }\n}\n```\n\n**Floyd算法可以用于负权值带权图**。（就解决了Dijkstra算法解决不了的问题）\n\n但是，这个算法也有它所解决不了的问题。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-173.png\" style=\"zoom:67%;\" />\n\n对于这个图，其中的这个回路来说，你会发现，你走这个回路，走的次数越多，你的带权路径长度会越来越小。因此根本就找不到最短路径。\n\n#### 总结\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-174.png\" style=\"zoom:69%;\" />\n\n> BFS算法有两种时间复杂度的情况，是由于图的存储方式，是邻接矩阵还是邻接表存储的区别导致的。\n\n### 有向无环图\n\n#### 有向无环图(DAG)\n\n**有向无环图**：若一个**有向图**中**不存在环**，则称为有向无环图，简称**DAG图**（Directed Acyclic Graph）\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-199.png\" style=\"zoom: 45%;\" />\n\n#### DAG描述表达式\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-190.png\" style=\"zoom:40%;\" />\n\n之前我们说过，算术表达式可以用树来表示。但是对于上图来说，不难看出，有两部分是重复的，`((c+d)*e)`出现了两次。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-191.png\" style=\"zoom: 30%;\" />\n\n实际上，图中红色、绿色两棵子树，其计算结果是一样的。所以其实可以去除其中一棵，只保留一棵。就成了如下这种样子：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-244.png\" style=\"zoom:60%;\" />\n\n这么做的好处显而易见，能够节省存储空间。而现在产生的这种结构，其实就是有向无环图。\n\n其实我们继续再看一下，里面还有重复的部分：`(c+d)`。可以继续进行“合并”。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-245.png\" style=\"zoom:60%;\" />\n\n合并后，就变成如下这样：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-194.png\" style=\"zoom:30%;\" />\n\n到此，继续观察，还是有相同的“子树”：`b`出现了两次。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-195.png\" style=\"zoom:30%;\" />\n\n“合并”后，结果如下：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-196.png\" style=\"zoom:30%;\" />\n\n这个过程，如果不细心的话，有可能会无法找全所有可以合并的点。\n\n但是在考研408真题中，又会遇到类似的题，如下：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-197.png\" style=\"zoom: 50%;\" />\n\n经过合并，如下图所示\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-198.png\" style=\"zoom:33%;\" />\n\n由于这种题**容易遗漏可以合并的点**，因此总结以下解题规律：\n\n- 顶点中不可能出现重复的操作数。\n\n------\n\n因此，有以下解题步骤：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-199.png\" style=\"zoom:67%;\" />\n\n- 第一步：把各个操作数不重复地排成一排，如下图所示。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-200.png\" style=\"zoom:67%;\" />\n\n- 第二步：标出各个运算符的生效顺序（先后顺序有点出入无所谓，目的是为了不重不漏地处理完毕所有运算符）\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-201.png\"  />\n\n- 第三步：按顺序加入运算符，注意“分层”。（分层的意思见下图）\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-202.png\" style=\"zoom:67%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-203.png\" style=\"zoom:67%;\" />\n\n- 第四步：从底向上逐层检查同层的运算符是否可以合体。\n\n  （为什么一层一层检查同层的运算符，不难体会到，如果是不同层的，则是一定不可能合并的。这也是第三步构造的过程中要注意“分层”的原因）\n\n  - 看最下面一层运算符。有四个加法。但是最左边的那一个加号，它是对`a和b`进行相加，右边三个加号，均是对`c和d`进行相加。因此右边三个加号可以合并，而左边一个加号不能合并。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-204.png\" style=\"zoom:69%;\" />\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-205.png\" style=\"zoom:67%;\" />\n\n- 运算符合体完毕如下图所示。此时我们就得到了一个最简的有向无环图。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-206.png\" style=\"zoom:67%;\" />\n\n#### 拓扑排序\n\n##### 如何进行拓扑排序\n\n**AOV网**（Activity On Vertex NetWork，用顶点表示活动的网）：\n\n**用DAG图**（有向无环图）表示一个工程。顶点表示活动，有向边`<Vi, Vj>`表示活动`Vi`必须先于活动`Vj`进行。\n\n如果存在环路，则一定不是AOV网。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-207.png\" style=\"zoom: 33%;\" />\n\n> **拓扑排序**：在图论中，由一个**有向无环图**的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：\n>\n> ①每个顶点出现且只出现一次。\n>\n> ②若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径。\n>\n> 或定义为：\n>\n> 拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条从顶点A到顶点B的路径，则在排序中顶点B出现在顶点A的后面。**每个AOV网都有一个或多个拓扑排序序列**。\n\n上述定义可能看不懂，我们直接看如何进行拓扑排序。拓扑排序实际上就是：找到做事的先后顺序。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-208.png\" style=\"zoom: 33%;\" />\n\n例如这个AOV网，我们可以从`准备厨具`或`买菜`开始做起。\n\n- 例如我们将`准备厨具`作为第一件事开始。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-209.png\" style=\"zoom: 50%;\" />\n\n- 那么第二件事是什么？第二件事一定是`买菜`。因为如果不这样，那么是不可能进行其他操作的。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-210.png\" style=\"zoom: 33%;\" />\n\n- 第三件事，同理，可以先选择`打鸡蛋`，也可以先选择`洗番茄`。例如我们先选择洗番茄。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-211.png\" style=\"zoom:33%;\" />\n\n- 第四件事，我们可以先选择`打鸡蛋`，也可以先选择`切番茄`。例如我们选择先切番茄。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-212.png\" style=\"zoom:33%;\" />\n\n- 至此，剩下的事情顺序，就必须是`打鸡蛋、下锅炒、吃`了。最终拓扑排序如下所示：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-213.png\" style=\"zoom:67%;\" />\n\n**拓扑排序的实现**：\n\n①从AOV网中选择一个没有前驱（**入度为0**）的顶点并输出。\n\n②从网中删除该顶点和所有以它为起点的有向边。\n\n③重复①和②直到当前的**AOV网为空**或**当前网中不存在无前驱的顶点为止（说明有回路）**。\n\n> **注**:如果③的结果为`当前网中不存在无前驱的顶点`，则说明有回路，则说明其是不可以拓扑排序的。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-214.png\" style=\"zoom:33%;\" />\n>\n> 例如，若有回路，则，到这一步时，发现没有入度为0的结点。说明原图存在回路。\n>\n> 所以，对于存在回路的图，是不可能存在拓扑排序序列的。\n>\n> 如果原图是一个DAG图（有向无环图），那么就存在拓扑排序序列。\n\n##### 拓扑排序的代码实现\n\n其实代码实现思路很简单，就是把刚才说的那两个需要不断重复的步骤①②，不断地重复，直到达到③的条件就可以。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-215.png\" style=\"zoom:35%;\" />\n\n```C\n#define MaxVertexNum 100\t//图中顶点数目的最大值\ntypedef struct ArcNode {\t//边表结点 \n\tint adjvex;\t\t//该弧所指向的顶点的位置\n\tstruct ArcNode *nextarc;\t//指向下一条弧的指针\n\t//InfoType info;\t//网的边权值 \n}ArcNode \n\ntypedef struct VNode {\t//顶点表结点 \n\tVertexType data;\t//顶点信息\n\tArcNode *firstarc;\t//指向第一条依附该顶点的弧的指针 \n}VNode, AdjList[MaxVertexNum];\n\ntypedef struct {\n\tAdjList vertices;\t//邻接表\n\tint vexnum, arcnum;\t//图的顶点数和弧数 \n}Graph;\t\t//Graph是以邻接表存储的图类型\n\nbool TopologicalSort(Graph G) {\n\tInitStack(S);\t//初始化栈，存储入度为0的顶点\n\tfor(int i=0; i<G.vexnum; i++) {\n\t\tif(indegree[i] == 0)\n\t\t\tPush(S, i);\t//将所有入度为0的顶点进栈 \n\t}\n\tint count = 0;\t//计数，记录当前已经输出的顶点数\n\twhile(!IsEmpty(S)) {\t//栈不空，则存在入度为0的顶点 \n\t\tPop(S, i);\t//栈顶元素出栈\n\t\tprint[count++] = i;\t//输出顶点i\n\t\tfor(p=G.vertices[i].firstarc; p; p=p->nextarc) {\n\t\t\t//将所有i指向的顶点的入度减1，并且将入度为0的顶点压入栈S\n\t\t\tv = p->adjvex;\n\t\t\tif(!(--indegree[v])) \n\t\t\t\tPush(S, v);\t//入度为0，则入栈 \n\t\t}\n\t}//while\n\tif(count < G.vexnum)\n\t\treturn false;\t//排序失败，有向图中有回路 \n\telse \n\t\treturn true;\t//拓扑排序成功 \n}\n```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-216.png\" style=\"zoom:35%;\" />\n\n**时间复杂度**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-217.png\" style=\"zoom:45%;\" />\n\n由于每个顶点都需要处理一次，每条边都需要处理一次。\n\n时间复杂度：`O(|V|+|E|)`若采用邻接矩阵，则需`O(|V|²)`\n\n#### 逆拓扑排序\n\n##### 如何进行逆拓扑排序\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-218.png\" style=\"zoom: 33%;\" />\n\n对一个AOV网，如果采用下列步骤进行排序，则称之为**逆拓扑排序**：\n\n①从AOV网中选择一个没有后继（**出度为0**）的顶点并输出。\n\n②从网中删除该顶点和所有以它为终点的有向边。\n\n③重复①和②直到当前的AOV网为空。\n\n> 上图的逆拓扑排序如下：\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-219.png\" style=\"zoom:67%;\" />\n\n##### 逆拓扑排序的代码实现\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-246.png\" style=\"zoom: 50%;\" />\n\n把“拓扑排序”中，进行`入度为0`的条件判断改为`出度为0`即可实现逆拓扑排序的代码。\n\n自己练习：模仿拓扑排序的思想实现逆拓扑排序。\n\n思考：使用不同的存储结构（即改用邻接矩阵实现）对时间复杂度的影响。\n\n> 对于逆拓扑排序来说，由于每次都要寻找该顶点的入边，若采用邻接表存储，则需要重新整个遍历所有邻接表，找到指向该顶点的边。是很低效的。而如果采用邻接矩阵，会很方便。\n>\n> 甚至，还可以采用“逆邻接表”：邻接表中，每一个顶点所对应的边的信息，是由该顶点发射出的边；而逆邻接表中，每一个顶点所对应的边的信息，是指入该顶点的边。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-247.png\" style=\"zoom:50%;\" />\n\n##### 逆拓扑排序的实现(DFS算法)\n\n> 用深度优先算法实现拓扑排序或逆拓扑排序。\n>\n> 这里先不讲。但是这里先补充一个课本中没有讲的，DFS算法实现逆拓扑排序。\n\n```C\nvoid DFSTraverse(Graph G) {\t//对图G进行深度优先遍历 \n\tfor(v=0; v<G.vexnum; ++v) {\n\t\tvisited[v] = FALSE;\t//初始化已访问标记数据 \n\t}\n\tfor(v=0; v<G.vexnum; ++v) {\t//本代码中是从v=0开始遍历 \n\t\tif(!visited[v])\n\t\t\tDFS(G, v);\n\t}\n}\n\nvoid DFS(Graph G, int v) {\t//从顶点v出发，深度优先遍历图G \n\tvisit(v);\t//访问顶点v\n\tvisited[v] = TRUE;\t//设已访问标记\n\tfor(w=FirstNeighbor(G, v); w>=0; w=NextNeighbor(G,v,w)) {\n\t\tif(!visited[w]) {\t//w为u的尚未访问的邻接顶点 \n\t\t\tDFS(G, w);\n\t\t}\n\t}\n    print(v);\t//输出顶点\n}\n```\n\n在DFS算法的基础上，添加一个`print(v);`的操作，输出出来的就是逆拓扑序列。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-222.png\" style=\"zoom:80%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-223.png\" style=\"zoom:80%;\" />\n\n> 上图，本身是不存在环路的。且我们的代码实现也没有考虑回路的问题。\n>\n> 思考：如果存在回路，则不存在逆拓扑排序序列，那么如何判断回路的存在？试着对代码进行一个改进。\n\n### 关键路径\n\n#### AOE网\n\nAOE网:\n\n在带权有向图中，以**顶点表示事件**，以**有向边表示活动**，以**边上的权值表示完成该活动的开销**（如完成活动所需的时间），称之为用边表示活动的网络，简称**AOE网**（Activity On Edge NetWord）。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-224.png\" style=\"zoom: 33%;\" />\n\n> AOV网，V表示`Vertex`，指用顶点表示活动；\n>\n> AOE网，E表示`Edge`，指用边表示活动。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-225.png\" style=\"zoom: 33%;\" />\n\n> 顶点表示事件，是一瞬间发生的事情；边表示活动，是需要持续一段时间的。\n\nAOE网具有以下两个性质：\n\n①只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始；\n\n②只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。另外，有些活动是可以并行进行的。\n\n#### 关键路径\n\nAOE网还有一些概念：\n\n- 在AOE网中**仅有一个**入度为0的顶点，称为**开始顶点**（**源点**），它表示整个工程的开始；\n- 也**仅有一个**出度为0的顶点，称为**结束顶点**（**汇点**），它表示整个工程的结束。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-226.png\" style=\"zoom:33%;\" />\n\n从源点到汇点的有向路径可能有多条，所有路径中，具有最大路径长度的路径称为**关键路径**，而把关键路径上的活动称为**关键活动**。\n\n完成整个工程的最短时间就是关键路径的长度，若关键活动不能按时完成，则整个工程的完成时间就会延长。\n\n> 找到关键活动是哪些，我们就知道了影响整个项目的，是哪些事。\n\n> 对于上图：\n>\n> 最快多久可以开始做？——现在，立刻（0分钟）    最快多久可以开切？——1分钟\n>\n> 最快多久可以开炒？——4分钟                  最快多久可以吃？——6分钟\n\n**事件`Vk`的最早发生时间`Ve(k)`**——决定了所有从`Vk`开始的活动能够开工的最早时间。\n\n> （等于其前驱活动的最早开始时间 + 该活动需要消耗的时间）\n>\n> 例如，`可以切了`事件它的最早发生时间为1分钟，则在它之后的所有活动最早也要在1分钟时开工。\n\n**活动`ai`的最早开始时间`e(i)`**——指该活动弧的起点所表示的事件的最早发生时间。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-227.png\" style=\"zoom:40%;\" />\n\n上图，黄色为事件的最早发生时间，红色为活动的最早开始时间。\n\n> 如果有一个人说：6分钟后我一定要吃到，不然我会被饿死。\n>\n> 之后厨师分析了一下：整个项目6分钟可以结束。\n>\n> 由于炒菜需要2分钟，于是推出：4分钟时一定要开始炒菜这一活动。(如果4分钟时不能完成`可以炒了`事件，就意味着6分钟不可能结束)\n>\n> 继续往前推，由切番茄需要3分钟，可以推出：`可以切了`事件，必须在1分钟时就发生。\n>\n> 继续，由洗番茄需要1分钟，推出：`开始`必须是现在。\n\n上述我们从后往前推，推出了每个事件允许发生的最迟的时间。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-228.png\" style=\"zoom:40%;\" />\n\n**事件`Vk`的最迟发生时间`Vl(k)`**——它是指在不推迟整个工程完成的前提下，该事件最迟必须发生的时间。\n\n**活动`ai`的最迟开始时间`l(i)`**——它是指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差。\n\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-229.png\" style=\"zoom:43%;\" />\n>\n> 上图，红色表示活动的最早开始时间，绿色表示活动的最迟开始时间。\n\n**活动`ai`的时间余量`d(i) = l(i)-e(i)`**，表示在不增加完成整个工程所需总时间的情况下，活动`ai`可以拖延的时间。\n\n若一个活动的时间余量为零，则说明该活动必须要如期完成，`d(i)=0`即`l(i)=e(i)`的活动`a(i)`是**关键活动**。\n\n#### 求关键路径的步骤\n\n①求所有事件的最早发生时间`ve()`\n\n②求所有事件的最迟发生时间`vl()`\n\n③求所有活动的最早发生时间`e()`\n\n④求所有活动的最迟发生时间`l()`\n\n⑤求所有活动的时间余量`d()`\n\n> 到第⑤步，由于`d(i)=0`的活动就是关键活动，由关键活动可得关键路径。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-230.png\" style=\"zoom: 67%;\" />\n\n##### 求所有事件的最早发生时间\n\n> ①求所有事件的最早发生时间`ve()`\n>\n> （某一事件的最早发生时间，等于其前驱活动的最早开始时间 + 该活动需要消耗的时间）\n\n按**拓扑排序**序列，依次求各个顶点的`ve(k)`：\n\nve(源点) = 0\n\nve(k) = Max{ ve(j) + Weight(Vj, Vk) }，Vj为Vk的任意前驱\n\n> 首先我们要对这个AOE网进行一个拓扑排序。\n\n**拓扑序列**：V1、V3、V2、V5、V4、V6\n\n> 根据拓扑排序序列的顺序，来依次计算各个顶点所代表的事件的最早发生时间。\n>\n> 这是因为，拓扑排序表示活动所必需的先后次序，我们根据拓扑排序序列依次计算最早发生时间，可以做到有条不紊。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-237.png\" style=\"zoom: 50%;\" />\n\n> 一般有多个入边才需要取max\n>\n> 而取max是因为当前事件要发生的前提是它的入边的弧的起点所代表的事件要完成了\n\n##### 求所有事件的最迟发生时间\n\n> ②求所有事件的最迟发生时间`vl()`\n>\n> （某一事件的最迟发生时间，等于其后继活动的最迟发生时间-该活动需要消耗的时间）\n\n按**逆拓扑排序**序列，依次求各个顶点的`vl(k)`：\n\nvl(汇点) = ve(汇点)\n\nvl(k) = Min{ vl(j) - Weight(Vk，Vj) }，Vj为Vk的任意后继\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-238.png\" style=\"zoom:50%;\" />\n\n> 当有多个出边时才需要取min\n>\n> 取min是表示，当该事件的所有弧中所指向的事件在完成的情况下，当前事件最迟发生的事件，为了确保所有指向的事件都完成，所以取min\n\n##### 求所有活动的最早发生时间\n\n> ③求所有活动的最早发生时间`e()`\n>\n> （某活动的最早发生时间，等于其弧尾事件的最早发生时间）\n\n若边`<Vk, Vj>`表示活动`ai`，则有`e(i) = ve(k)`\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-239.png\" style=\"zoom:67%;\" />\n\n##### 求所有活动的最迟发生时间\n\n> ④求所有活动的最迟发生时间`l()`\n>\n> （某活动的最迟发生时间，等于其弧头事件的最迟发生时间 - 该活动所需时间）\n\n若边`<Vk, Vj>`表示活动`ai`，则有`l(i) = vl(j) - Weight(Vk, Vj)`\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-240.png\" style=\"zoom:67%;\" />\n\n##### 求所有活动的时间余量\n\n> ⑤求所有活动的时间余量`d()`\n>\n> 用活动的最迟发生时间 - 活动的最早发生时间\n\nd(i) = l(i) - e(i)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-241.png\" style=\"zoom: 67%;\" />\n\n##### 找出关键路径\n\n根据最终得到的各个活动的时间余量，可以发现活动a2、a5、a7的时间余量都等于0，也就是说这几个活动是绝对不允许拖延的。因此我们就找到了所有的关键活动。\n\n> 关键活动：a2、a5、a7\n>\n> 关键路径：V1——>V3——>V4——>V6\n\n#### 关键活动、关键路径的特性\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-242.png\" style=\"zoom: 50%;\" />\n\n- 若关键活动耗时增加，则整个工程的工期将增长\n- 缩短关键活动的时间，可以缩短整个工程的工期\n- 当缩短到一定程度时，关键活动可能会变成非关键活动\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-243.png\" style=\"zoom:50%;\" />\n\n- 可能有多条关键路径，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的\n  - 要么把两条路径上的关键活动分别都加速。要么把这两个关键路径的交集路线上的活动加速（也相当于给两条路径都加速了）。\n\n### 习题\n\n- 【2010】对下面进行拓扑排序，可得不同拓扑序列的个数是-->3\n\n  ![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-102.png)\n\n  > a没有被其他节点指向;d没有指向其他节点;\n  >\n  > **所以拓扑排序的形式如下:aXXXd;**又因为b指向c,**那么b一定是在c的前面**;\n  >\n  > 所以可能的拓扑排序如下:**abced,aebcd,abecd**。\n\n- 【2012】下列关于最小生成树的叙述中，正确的是→①\n  ① 最小生成树的代价唯一\n  ② 所有权值最小的边一定会出现在所有的最小生成树中\n  ③ 使用 Prim 算法从不同定点开始得到的最小生成树一定相同\n  ④ 使用 Prim 算法和 Kruskal 算法得到的最小生成树总不相同\n\n  > Ⅰ．最小生成树的代价唯一这种叙述是正确的。Ⅱ．如果利用kruskal算法，那么权值最小的边一定会出现在所有的最小生成树中，但是利用prim算法权值最小的边不一定会在最小生成树中。Ⅲ．用prim算法从不同的顶点开始得到的最小生成树也不一定相同。最后，用prim算法和kruskal算法得到的最小生成树也有可能相同。\n\n- 【2012】对下图所示的有向带权图，若采用Dijkstra算法求从源点a到其他各顶点的最短路径，则得到的第一条最短路径的目标顶点是b，第二条最短路径的目标顶点是c,后续得到的其余各最短路径的目标顶点依次是-->f,d,e\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-103.png\"  />\n\n  > 从a到各顶点的最短路径的求解过程：\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-104.png\" style=\"zoom:60%;\" />\n  >\n  > 后续目标顶点依次为f,d,e\n  >\n  > 【排除法】对于A，若下一个顶点为d，路径a,b,d的长度5，而a,b,c,f的长度仅为4，显然错误。同理可以排除B。将f加入集合S后，采用上述的方法也可以排除D。\n\n- 【2013】下列AOE网表示一项包含8个活动的工程。通过同时加快若干活动的进度可以缩短整个工程的工期。下列选项中，加快其进度就可以缩短工程工期的是-->f 和 d\n\n  ![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-105.png)\n\n  > 这个网有三条关键路径：\n  >\n  > - b、d、c、g\n  > - b、d、e、h\n  > - b、f、h\n  >\n  > 缩短工期的活动要涵盖三条路径。\n  >\n  > 具体运算如下:@牛客 我是超越迷妹了\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-106.png\" style=\"zoom: 25%;\" />\n\n- 【2012】若用邻接矩阵存储有向图，矩阵中主对角线以下的元素均为零，则关于该图拓扑序列的结论是-->C\n\n  A.存在,且唯一          B.存在,且不唯\n  C.存在,可能不唯一      D.无法确定是否存在\n\n  > 1)若邻接矩阵为 \n  >\n  > 0 1 1 \n  >\n  > 0 0 0 \n  >\n  > 0 0 0 \n  >\n  > 满足主对角线以下元素均为零 \n  >\n  > 且只有从结点1到结点2，3的边，此时拓扑序列有1，2和1，3，不唯一 \n  >\n  > 2)若邻接矩阵为   \n  >\n  > 0 1 0 \n  >\n  > 0 0 1 \n  >\n  > 0 0 0 \n  >\n  > 满足主对角线以下元素均为零， \n  >\n  > 且只有结点1到结点2，结点2到结点3的边，此时拓扑序列为1，2，3，唯一\n\n- 【2014】对下图所示的有向图进行拓扑排序，得到的拓扑序列可能是-->3,1,4,2,6,5\n\n  ![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-107.png)\n\n  > 每次选取极大顶点（入度为0的顶点），并把它跟它的出度一起从图中删掉\n  >\n  > 第一次删掉3。第二次删掉1。第三次删掉4\n  >\n  > 第四次可以删掉2或者6，若依据选项CD删掉2，那么第五次删掉6，最后删掉5\n  >\n  > 314265，选D\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-108.png\"  />\n\n- 【2015】求下面的带权图的最小生成树时，可能是Kruskal算法第2次选中但不是Prim算法（从 V4 开始）第 2 次选中的边是-->C\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-109.png\"  />\n\n  A. (V1,V3)   B. (V1,V4)\n  C. (V2,V3)   D. (V3,V4)\n\n  > 从V4开始，Kruskal算法选中的第一条边一定是权值最小的（V1,V4），B 错误。由于  V1和V4已经可达，第二条边含有V1和V4的权值为8的一定符合Prim算法，排除A、D  。\n\n- 【2016】使用Dijkstra算法求下图中从顶点1到其他各顶点的最短路径，依次得到的各最短路径的目标顶点是-->5, 2, 3, 6, 4\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-110.png\" style=\"zoom: 50%;\" />\n\n  > 对于dijkstra算法来说，只有当一个点的所有入度都被遍历过之后，才能完全确认起点到这个点的距离。但这道题没有那么严谨，它的意思似乎仅仅是给各最短路径排序，从短到长。\n\n- 【2016】若对 n 个顶点、e 条弧的有向图采用邻接表存储，则拓扑排序算法的时间复杂度是 →O(n+e)\n\n  > 对有n个顶点和e条弧的有向图而言，建立求各顶点的入度的时间复杂度为O(e)；建零入度顶点栈的时间复杂度为O(n)；在拓扑排序过程中，若有向图无环，则每个顶点进一次栈、出一次栈，入度减1的操作在while语句中总共执行e次，所以总的时间复杂度为O(n+e)。 拓扑排序初始参数只有邻接表，所以第一步建立入度数组，因为每1入度对应一条弧，总共e条弧，建立入度数组的复杂度为O(e)。每个节点输出一次，n个节点遍历一次，时间复杂度为O(n)。（使用零入度节点栈的原因是，如果不把零入度节点入栈，每次输出时都要遍历节点。建立此栈，只需遍历一次。）然后节点入度减1的操作，也是一条弧对应一次，e条弧总共O(e)。以上总计O(n+2e)即O(n+e)。 即对每条弧要建立入度数组操作和删除操作，每个顶点要遍历一次并删除。故时间复杂度为O(n+e)\n\n- 【2018】下列选项中，不是如下有向图的拓扑序列是-->D\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-111.png\" style=\"zoom:50%;\" />\n\n  A.1,5,2,3,6,4     B.5,1,2,6,3,4\n\n  C.5,1,2,3,6,4     D.5,2,1,6,3,4\n\n  > 拓扑排序每次选取入度为0的结点输出，经观察不难发现拓扑序列前两位一定是1，5或5，1(因为只有1和5的入度均为0，且其他结点都不满足仅有1或仅有5作为前驱)。\n\n- 【2019】下图所示的AOE网表示一项包含8个活动的工程。活动d的最早开始时间和最迟开始时间分别是-->12 和 14\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-112.png\" style=\"zoom:67%;\" />\n\n  > 因为活动d的最早开始时间等于该活动弧的起点所表示的时间的最早发生时间=max(a,b+c)=max(3,12)=12 \n  >\n  > 活动d的最迟开始时间等于该活动弧的最迟发生时间与该活动所需时间之差，图中的关键路径长度为27，所以事件发生的最迟时间为min(27-g)=21,所以d的最迟开始时间为21-d=14\n\n- 【2019】用有向无环图描述表达式`(x+y)((x+y)/x)`，需要的顶点个数至少是 →5\n\n  > https://blog.csdn.net/amoscn/article/details/103452640\n\n- 【2020】修改递归方式实现的图的深度优先搜索（DFS）算法，将输出（访问）顶点信息的语句移到退出递归前（即执行输出语句后立刻退出递归）。采用修改后的算法遍历有向无环图 G，若输出结果中包含 G 的全部顶点，则输出的顶点序列是G的-->B\n  A 拓扑有序序列       B 逆拓扑有序序列\n  C 广度优先搜索序列   D 深度优先搜索序列 \n\n  > https://blog.csdn.net/cuisl37186486/article/details/117968121\n\n- 【2020】若使用AOE网估算工程进度，则下列叙述中正确的是-->B\n\n  A. 关键路径是从源点到汇点边数最多的一条路径\n  B. 关键路径是从源点到汇点路径长度最长的路径\n  C. 增加任一关键活动的时间不会延长工程的工期\n  D. 缩短任一关键活动的时间将会缩短工程的工期\n\n  > 关键路径是指权值之和最大而非边数最多的路径，故选项A错误。选项B正确，是关键路径的概念。无论是存在一条还是存 在多条关键路径，增加任一关键活动的时间都会延长工程的工期，因为关键路径始终是权值之和最大的那条路径，选项C错误。仅有一条关键路径时，减少关键活动的时间会缩短工程的工期;存在多条关键路径时，缩短一条关键活动的时间不一定会缩短工程的工期，缩短了路径长度的那条关键路径不一定还是关键路径,选项D错误。\n\n- 【2020】已知无向图G如下所示，使用克鲁斯卡尔（Kruskal）算法求图G的最小生成树，加入到最小生成树中的边依次是：\n\n  A．(b,f)(b,d)(a,e)(c,e)(b,e)\n\n  B．(b,f)(b,d)(b,e)(a,e)(e,c)\n\n  C．(a,e)(b,e)(c,e)(b,d)(b,f)\n\n  D．(a,e)(c,e)(b,e)(b,f)(b,d)\n\n  ![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-114.png)\n\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-115.png\" style=\"zoom:80%;\" />\n\n- 【2021】给定如下有向图，该图的拓扑有序序列的个数是-->A\n\n  A. 1      B. 2\n\n  C. 3      D. 4\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-116.png\" style=\"zoom:67%;\" />\n\n  > 求拓扑序列的过程如下:从图中选择无入边的结点，输出该结点并删除该结点的所有出边,重复上述过程，直至全部结点都已输出，求得拓扑序列ABCDEF.每次输出一个结点并删除该结点的所有出边后，都发现仅有一个结点无入边，因此该拓扑序列唯一\n\n- 【2021】使用Djkstra算法求下图中从顶点1到其余各顶点的最短路径，将当前找到的从顶点1到顶点2,3, 4, 5的最短路径长度保存在数组dist中，求出第二条最短路径后，dist 中的内容更新为-->C\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-117.png\" style=\"zoom:67%;\" />\n\n  A、26,3,14,6      B、25,3,14,6\n\n  C、21,3,14,6      D、15,3,14,6\n\n  > 在执行Dijkstra算法时，首先初始化dist],若顶点1到顶点i(i=2,3,4, 5)有边，就初始化为边的权值;若无边，就初始化为∞;初始化顶点集s只含顶点1。Djkstra算法每次选择一个到顶点1距离最近的顶点j加入顶点集s,并判断由顶点1绕行顶点j后到任一顶点k是否距离更短，若距离更短(即distj] + arcs[j][k] < dist[k])， 则将dist[x]更新为dist[j] +arcs[j][k];重复该过程，直至所有顶点都加入顶点集S。数组dist的变化过程如下图所示,可知将第二个顶点5加入顶点集S后，数组dist更新为21,3, 14,6,故选C。\n\n><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-118.png\" style=\"zoom:67%;\" />\n\n- 综合题【2009】带权图(权值非负，表示边连接的两顶点)的最短路径问题是找出从初始顶点到目标顶点之间的一条最短路径。假设从初始顶点到目标顶点之间存在路径，现有一种解决该问题的方法∶\n  ①设最短路径初始时仅包含初始顶点，令当前顶点u为初始顶点;\n  ② 选择离u最近且尚未在最短路径中的一个顶点v，加入最短路径中，修改当前顶点u=v;\n  ③ 重复步骤②，直到u是目标顶点时为止。\n  请问上述方法能否求得最短路径?若该方法可行，请证明之;否则，请举例说明。\n\n  > 该方法不一定能（或不能）求得最短路径。  \n  >\n  > 举例说明： \n  >\n  > 图A-4中，设初始顶点为1，目标顶点为4，欲求从顶点1到顶点4之间的最短路径，显然这两点之间的最短路径长度为2。利用给定方法求得的路径长度为3，但这条路径并不是这两点之间的最短路径。 \n  >\n  > 图A-5中，设初始顶点为1，目标顶点为3，欲求从顶点1到顶点3之间的最短路径。利用给定的方法，无法求出顶点1到顶点3的路径。\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-119.png\" style=\"zoom:80%;\" />\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-120.png\" style=\"zoom:80%;\" />\n\n- 综合题【2017】使用Prim算法求带权连通图的最小生成树(MST)。请回答下列问题:\n\n  (1)对下列图 G，从顶点 A 开始求 G 的 MST，依次给出按算法选出的边。\n\n  (2)图 G 的 MST 是唯一的吗？\n\n  (3)对任意的带权连通图，满足什么条件时，其 MST 是唯一的？\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-128.png\" style=\"zoom:50%;\" />\n\n  > (1)Prim 算法属于贪心策略。算法从一个任意的顶点开始，一直长大到覆盖图中所有顶点为止。算法每一步在连接 树集合 S 中顶点和其他顶点的边中，选择一条使得树的总权重增加最小的边加入集合 S。当算法终止时，S 就是最小生 成树。 \n  >\n  > ①S 中顶点为 A，候选边为(A,D)、(A,B)、(A,E)，选择(A,D)加入 S。 \n  >\n  > ②S 中顶点为 A、D，候选边为(A,B)、(A,E)、(D,E)、(C,D)，选择(D,E)，加入 S。 \n  >\n  > ③S 中顶点为 A、D、E，候选边为(A,B)、(C,D)、(C,E)，选择(C,E)加入 S。 \n  >\n  > ④S 中顶点为 A、D、E、C，候选边为(A,B)、(B,C)，选择(B,C)加入 S。 \n  >\n  > ⑤S 就是最小生成树。 依次选出的边为： (A，D),(D，E),(C，E),(B，C) \n  >\n  > (2)图 G 的 MST 是唯一的 第一小题的最小生成树包括了图中权值最小的四条边，其他边都比这四条 边大，所以此图的 MST 唯一。\n  >\n  > (3)当带权连通图的任意一个环中所包含的边的权值均不相同时，其 MST 是唯一的\n\n- 综合题【2011】已知有6个顶点(顶点编码为0~5)的有向带权图G，其邻接矩阵 A 为上三角矩阵，按行为主序（行优先）保存在如下的一维数组中。\n\n  | 4    | 6    | ∞    | ∞    | ∞    | 5    | ∞    | ∞    | ∞    | 4    | 3    | ∞    | ∞    | 3    | 3    |\n  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n\n  要求∶\n  （1）写出图G的邻接矩阵 A。\n  （2）画出有向带权图 G。\n  （3）求图 G的关键路径，并计算该关键路径的长度。\n\n  > (1)给的一维数组可以理解为上三角矩阵的压缩存储。图有6个顶点，而且第一个值是4，说明，它没有记录节点自己到自己的节点。那么，上三角的第一行就有5个值，第二行有4个值，第三行有3个值，第四行有2个值，第五行有1个值。5+4+3+2+1 正好是给定的一维数组值得个数。主对角线都是零。\n  >\n  > 因为是有向图，下三角部分没有给值，说明没有路径。就都是无穷。\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-121.png\" style=\"zoom: 25%;\" />\n  >\n  > （2）根据邻接矩阵画出图\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-122.png\" style=\"zoom: 50%;\" />\n  >\n  > （3）关键路径的求法:https://www.bilibili.com/video/BV1Kt411R7SD/\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-123.png\" style=\"zoom: 33%;\" />\n  >\n  > |                  | 0    | 1    | 2    | 3    | 4    | 5    |\n  > | :--------------- | :--- | :--- | :--- | :--- | :--- | ---- |\n  > | 事件最早开始时间 | 0    | 4    | 9    | 13   | 12   | 16   |\n  > | 事件最晚开始时间 | 0    | 4    | 9    | 13   | 13   | 16   |\n  >\n  > |                  | a1   | a2   | a3   | a4   | a5   | a6   | a7   |\n  > | :--------------- | :--- | :--- | :--- | :--- | :--- | :--- | ---- |\n  > | 活动最早开始时间 | 0    | 0    | 4    | 9    | 9    | 13   | 12   |\n  > | 活动最晚开始时间 | 0    | 3    | 4    | 9    | 10   | 13   | 13   |\n  >\n  > 关键路径为：0 -> 1 -> 2 -> 3 -> 5      路径长度为：16\n\n- 综合题【2014】某网络中的路由器运行OSPF路由协议，下表是路由器R1维护的主要链路状态信息(LSI)，R1构造的网络拓扑图(见下图)是根据题下表及R1的接口名构造出来的网络拓扑\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-124.png\" style=\"zoom:67%;\" />\n\n   请回答下列问题。\n\n  1)   本题中的网络可抽象为数据结构中的哪种逻辑结构？\n  2)   针对题42表中的内容，设计合理的链式存储结构，以保存题42表中的链路状态信息(LSI)。要求给出链式存储结构的数据类型定义，并画出对应题42表的链式存储结构示意图(示意图中可仅以ID标识结点)。\n  3)   按照迪杰斯特拉(Dijkstra)算法的策略，依次给出R1到达题42图中子网192.1.x.x的最短路径及费用。\n\n  > 1)题中给出的是一个简单的网络拓扑图，可以抽象为无向图。\n  >\n  > 2)链式存储结构的如下图所示\n  >\n  > ![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-125.png)\n  >\n  > 其数据类型定义如下：\n  >\n  > ```C\n  > typedef struct{\n  > \n  > unsigned int ID, IP;\n  > \n  > }LinkNode; //Link 的结构\n  > \n  > typedef struct{\n  > \n  > unsigned int Prefix, Mask;\n  > \n  > }NetNode; //Net 的结构\n  > \n  > typedef struct Node{\n  > \n  > int Flag; //Flag=1 为Link;Flag=2为Net\n  > \n  > union{\n  > \n  >  LinkNode Lnode;\n  > \n  >  NetNode Nnode\n  > \n  > }LinkORNet;\n  > \n  > unsigned int Metric;\n  > \n  > struct Node *next;\n  > \n  > }ArcNode; //弧结点\n  > \n  > typedef struct HNode{\n  > \n  > unsigned int RouterID;\n  > \n  > ArcNode *LN_link;\n  > \n  > Struct HNode *next;\n  > \n  > }HNODE; //表头结点\n  > ```\n  >\n  > 对应题42表的链式存储结构示意图如下\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-126.png\" style=\"zoom: 80%;\" />\n  >\n  > 3)计算结果如下表所示\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-127.png\" style=\"zoom: 67%;\" />\n\n- 综合题【2018】拟建设一个光通信骨干网络连通BJ,CS,XA,OD,JN,NJ,TL 和 WH 8 个城市，下图中无向边上的权值表示两个城市间备选光纤的铺设费用。\n\n  请回答下列问题。 \n\n    （1）仅从铺设费用角度出发，给出所有可能的最经济的光纤铺设方案（用带权图表示）， 并计算相应方案的总费用。 \n\n    （2）题 42 图可采用图的哪种存储结构？给出求解问题（1）所使用的算法名称。 \n\n    （3）假设每个城市采用一个路由器按（1）中得到的最经济方案组网，主机 H1 直接连接在 TL 的路由器上，主机 H2 直接连接在 BJ 的路由器上。若 H1 向 H2 发送一个 TTL = 5 的 IP 分组， 则 H2 是否可以收到该 IP 分组？\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-129.png\" style=\"zoom: 33%;\" />\n\n  > 1)为了求解最经济的方案，可以把问题抽象为求无向带权图的最小生成树。可以采用手 动 Prim 算法或 Kruskal 算法作图。注意本题最小生成树有两种构造，如下图所示。\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-130.png\" style=\"zoom: 67%;\" />\n  >\n  > 方案的总费用为 16。\n  >\n  > 2)存储题中的图可以采用邻接矩阵（或邻接表）。构造最小生成树采用 Prim 算法（或 Kruskal 算法）\n  >\n  > 3)TTL = 5，即 IP 分组的生存时间（最大传递距离）为 5，方案 1 中 TL 和 BJ 的距离过远， TTL = 5 不足以让 IP 分组从 H1 传送到 H2，因此 H2 不能收到 IP 分组。而方案 2 中 TL 和 BJ 邻近，H2 可以收到 IP 分组。\n","tags":["408数据结构"],"categories":["408数据结构"]},{"title":"第六章 图(上)","url":"/p/63800/","content":"\n## 6.1 图的基本概念\n\n### 图的定义\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-1.png\" style=\"zoom:69%;\" />\n\n- 有向图、无向图\n\n  无向图：每条边都是无方向的\n\n  有向图：每条边都是有方向的\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-2.png\" style=\"zoom: 80%;\" />\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-3.png\" style=\"zoom:80%;\" />\n\n- 简单图、多重图\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-4.png\" style=\"zoom: 80%;\" />\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-5.png\" style=\"zoom: 80%;\" />\n\n- 顶点的度、入度和出度\n\n  > 例如微信好友关系图，我们如何评判某人是否是“交际达人”？只需看某人这个结点，连接的边数，即可。连接的边数越多，则越有可能是一个交际达人。\n  >\n  > 例如微博粉丝关注图，如何评判某人是否是“微博大V”？只需看这个人的结点，它作为弧尾的弧有多少条，即可。\n  >\n  > 因此，无论是有向图还是无向图，讨论某个结点所联系的边或弧的条数，是很有意义的一件事。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-6.png\" style=\"zoom: 78%;\" />\n\n  如上面这张有向图，对于顶点A\n\n  ID(A) = 1\n\n  OD(A) = 4\n\n  TD(A) = 1+4 = 5\n\n- 顶点-顶点的关系描述\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-7.png\" style=\"zoom:78%;\" />\n\n- 连通图、强连通图\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-8.png\" style=\"zoom:78%;\" />\n\n- 研究图的局部--子图\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-9.png\" style=\"zoom:70%;\" />\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-10.png\" style=\"zoom:70%;\" />\n\n- 连通分量、强连通分量\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-11.png\" style=\"zoom:70%;\" />\n\n  **极大连通子图**，即**子图必须连通，且包含尽可能多的顶点和边**。\n\n  > 连通分量这个概念也是有很多现实意义的，比如说全国铁路线路图\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-176.png\" style=\"zoom:65%;\" />\n  >\n  > 这个图里面有三个连通分量——整个大陆区域的铁路图、海南岛铁路图、台湾岛铁路图。\n  >\n  > 当然，对于大陆区域的铁路图，你可以把其中长江三角区的铁路图挑出来，那么挑出来的这个图，它是一个子图，但是并不是极大连通子图。\n\n  \n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-12.png\" style=\"zoom:70%;\" />\n\n- 生成树、生成森林\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-175.png\" style=\"zoom:70%;\" />\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-14.png\" style=\"zoom:70%;\" />\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-15.png\" style=\"zoom:70%;\" />\n\n  > 其实生成树和生成森林有很多意义：\n  >\n  > 例如有图上顶点那么多的村庄，这些村庄之间如果要开通公路，但是由于经费有限，不可能把所有的路都修起来，但是又想让每个村庄之间道路都连通。如何能有一个成本最低的修路方案呢。\n  >\n  > 就可以用无向图，推出所有可能的生成树。因为生成树能保证是连通的，且能保证边的数量是尽可能的少的。\n  >\n  > 于是，通过生成树，就可以初步得到若干个修路的施工方案。\n  >\n  > 但是在不同的生成树之间，选择哪种方案，能让修路的成本最低呢？\n  >\n  > 其实就要看一下每一条边，修起路来的成本到底是多少。\n  >\n  > 于是在生成树的基础上，再将各个边的成本考虑进去，就能得到一个最经济的方案。\n\n- 边的权、带权图/网\n\n  > 可以发现，图这种数据结构，我们除了在顶点部分保存信息外，有时候也需要给各条边赋予一个数值，来表示权值。用这个数值来表示一些具有现实含义的一些信息。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-16.png\" style=\"zoom:78%;\" />\n\n- 完全图\n\n  完全图：任意两个点都有一条边相连\n\n  无向完全图：n个顶点，任意两个顶点都要有边。所以n个顶点，共有 \n  $$\n  C_n^2 = n(n-1)/2\n  $$\n  条边。\n\n  有向完全图：n个顶点，任意两个顶点都要有两条边。所以n个顶点，共有 \n  $$\n  2C_n^2 = n(n-1)\n  $$\n  条边\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-17.png\" style=\"zoom:80%;\" />\n\n- 稀疏图、稠密图\n\n  稀疏图：有很少或弧(有向图的边也称作弧)的图\n\n  稠密图：有较多边或弧的图\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-18.png\" style=\"zoom:80%;\" />\n\n- 有向树\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-19.png\" style=\"zoom:80%;\" />\n\n### 习题\n\n- 【2011】下列关于图的叙述中，正确的-->仅 ③\n\n  ① 回路是简单路径\n  ② 存储稀疏图，用邻接矩阵比邻接表更省空间\n  ③ 若有向图中存在拓扑序列，则该图不存在回路\n\n  > 第一个顶点和最后一个顶点相同的路径称为回路；序列中顶点不重复出现的路径称为简单路径；回路显然不是简单路径，故  Ⅰ  错误；稀疏图是边比较少的情况，此时用邻接矩阵的空间复杂度为  O(n²)  ，必将浪费大量的空间，而邻接表的空间复杂度为  O(n+e)  ，应该选用邻接表，故  Ⅱ  错误。存在回路的有向图不存在拓扑序列，若拓扑排序输出结束后所余下的顶点都有前驱，则说明只得到了部分顶点的拓扑有序序列，图中存在回路，故  Ⅲ  正确。\n\n- 【2009】下列关于无向连通图特性的叙述中，正确的是-->只有Ⅰ\n\n  Ⅰ．所有顶点的度之和为偶数\n\n  Ⅱ．边数大于顶点个数\n\n  Ⅲ．至少有一个顶点的度为1\n\n  > 1，每条边连接两个顶点，所有顶点的度之和等于边数的2倍，是偶数，正确\n  > 2，如两个顶点一条边的图就不满足这个条件，错\n  > 3，如三个顶点三条边连成一个三角形的图每个顶点度为2，错\n\n- 设有无向图 G=(V, E)和 G'(V', E')，若 G'是 G 的生成树，则下列不正确的→ 只有 ①\n\n  ① G'为 G 的连通分量\n\n  ② G'为 G 的无环子图\n\n  ③ G'为 G 的极小连通子图且 V'=V\n\n- 【2013】设图的邻接矩阵A如下图所示，各顶点的度依次是-->C\n  $$\n   A=\\left[\n   \\begin{matrix}\n     0 & 1 & 0 &1\\\\\n     0 & 0 & 1 &1\\\\\n     0 & 1 & 0 &0\\\\\n     1 & 0 & 0 &0\n    \\end{matrix}\n    \\right] \n  $$\n  A.1,2,1,2       B.2,2,1,1\n\n  C.3,4,2,3       D.4,4,2,2\n\n  > 无向图的边数组（邻接矩阵）是对阵矩阵。各顶点的度为邻接矩阵中对应行的元素之和。\n  >\n  > 有向图的各顶点的度为出度加上入度之和。出度为对应顶点所在行的所有元素之和，入度为对应顶点所在列的所有元素之和。\n  >\n  > 该图明显为有向图。所以各个顶点的度为其出度和入度之和，即所在行和列元素之和。\n\n- 【2017】已知无向图G含有16条边，其中度为4的顶点个数为3，度为3的顶点个数为4，其他顶点的度均小于3。图G所含的顶点个数至少是-->11\n\n  > 无向图边数的两倍等于各顶点度数的总和。由于其他顶点的度均小于3，可以设它们的度都为2，设它们的数量是x，可列出这样的方程4×3+3×4+2×x=16x2，解得x=4。4+3+4=11，B正确。\n\n\n## 6.2 图的存储及基本操作\n\n### 邻接矩阵法\n\n所谓邻接矩阵存储，是指用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息(即各顶点之间的邻接关系)，存储顶点之间的邻接关系的二维数组称为**邻接矩阵**。\n\n结点数为n的图G=(V,E)的邻接矩阵A是n×n的。将G的顶点编号为v1,v2,...,vn则\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-253.png\" style=\"zoom: 80%;\" />\n\n上述解释为：如果两个顶点之间存在边或者弧，那么二维数组就为1，如果两个顶点之间不存在边或者弧，那么二维数组就为0\n\n#### 邻接矩阵表示法\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-20.png\" style=\"zoom: 80%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-21.png\" style=\"zoom:80%;\" />\n\n- 无向图的邻接矩阵是**对称**的。\n- 顶点i的度 = 第i行(列)中1的个数。\n- **特别的，完全图(任意两个顶点都有边)的邻接矩阵中，对角元素为0，其余均为1**。\n\n邻接矩阵的实现也很简单，只需要用一个二维数组就可以。\n\n```C\n#define MaxVertexNum 100\t//顶点数目的最大值\ntypedef struct {\n    char Vex[MaxVertexNum];\t//顶点表\n    int Edge[MaxVertexNum][MaxVertexNum];\t//邻接矩阵，边表\n    int vexnum, arcnum;\t//图的当前顶点数和边数\n}MGraph;\n```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-22.png\" style=\"zoom:80%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-23.png\" style=\"zoom: 67%;\" />\n\n在有向图的邻接矩阵中：\n\n- 第i行含义：以结点Vi为尾的弧(即出度边)\n- 第i列含义：以结点Vi为头的弧(即出度边)\n\n分析：\n\n- 有向图的邻接矩阵**可能是不对称**的。\n- 顶点的出度 = 第 i 行元素之和\n- 顶点的入度 = 第 i 列元素之和\n- 顶点的度 = 第i行元素之和+第i列元素之和\n\n<font color='red'>邻接矩阵法求顶点的度/出度/入度的时间复杂度为O(|V|)</font>\n\n#### 网(带权图)的邻接矩阵表示法\n\n对于带权图而言，若顶点vi和vj之间有边相连，则邻接矩阵中对应项存放着该边对应的权值，若顶点vi给vj不相连，则用 ∞ 来代表着两个顶点之间不存在边:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-254.png\" style=\"zoom:80%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-24.png\" style=\"zoom:80%;\" />\n\n```C\n//带权图\n#define MaxVertexNum 100  //顶点数目的最大值\ntypedef char VertexType;  //顶点的数据类型\ntypedef int EdgeType;     //带权图中边上权值的数据类型\ntypedef struct{\n    VertexType Vex[MaxVertexNum];  //顶点表\n    EdgeType Edge[MaxVertexNum][MaxVertexNum]; //邻接矩阵，边表\n    int vexnum,arcnum;     //图的当前顶点数和弧数\n}MGraph;\n```\n\n#### 邻接矩阵法的性质\n\n1. 无向图的邻接矩阵一定是一个对称矩阵(唯一)。因此，在实际存储邻接矩阵时只需要存储上(或下)三角矩阵的元素。\n\n2. 对于无向图，邻接矩阵的第i行(或第i列)非零元素(或非∞元素)的个数正好是顶点i的度TD(vi)。\n\n3. 对于有向图，邻接矩阵的第i行非零元素(或非∞元素)的个数正好是顶点i的出度OD(vi);第i列非零元素(或非∞元素)的个数正好是顶点i的入度ID(vi)。\n\n4. 用邻接矩阵存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。\n\n5. 稠密图适合使用邻接矩阵的存储表示。\n\n6. <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-26.png\" style=\"zoom:85%;\" />\n\n   > 上图中的话是什么意思呢？我们举个例子来看一下，例如A²\n   >\n   > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-177.png\" style=\"zoom:80%;\" />\n   >\n   > 我们挑其中的一项看一下它具有什么实际意义，如a(1,2)*a(2,4)\n   >\n   > 其中a(1,2)的意思是A到B是否有边，a(2,4)表示B到D是否有边。\n   >\n   > 因此a(1,2)*a(2,4)便表示从A到D，但是是由A经过B到D的路径的数目。\n   >\n   > 那么其他项也是从A到D，但是是经过不同顶点到D的路径的数目。\n   >\n   > 把这些乘积的项都加起来，就表示从A到D，且长度为2的路径的数目。\n   >\n   > 具体的矩阵乘法去学线代吧。\n\n   > 如果是A³，那么原理也是类似的。\n   >\n   > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-132.png\" style=\"zoom: 80%;\" />\n   >\n   > 看最右侧的那个结果，其中第一行第四列的值为1，就意味着，从A到D，长度为3的路径，只有一条。\n   >\n   > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-133.png\" style=\"zoom:80%;\" />\n   >\n   > 其背后的含义是什么呢？\n   >\n   > 由于这个1是前一个矩阵的第一行对应相乘后一个矩阵的第四列得到的，我们分别看这四个加项的含义。\n   >\n   > 第一项（1*0）的含义是说：从A到A且长度为2的路径有1条；而从A到D长度为1的路径有0条。\n   >\n   > 所以我们没办法把这两条路径凑起来，拼成一个更长的路径。\n   >\n   > 第二项（0*1）同理。\n   >\n   > 第三项（1*1）的含义是说：从A到C且长度为2的路径有1条；从C到D且长度为1的路径有1条。\n   >\n   > 我们把这两条路径一拼接，就能得到从A到D，且是经过C的，长度为3的路径有1条。\n   >\n   > 第四项（0*0）同理。\n   >\n   > 最后，求和之后，就能得到，由A到D，长度为3的所有路径的数目。 \n\n#### 邻接矩阵法的性能分析\n\n1. 在简单应用中，可直接用二维数组作为图的邻接矩阵(顶点信息等均可省略)。\n\n2. 当邻接矩阵的元素仅表示相应边是否存在时，EdgeType可采用值为0和1的枚举类型。\n\n3. 无向图的邻接是对称矩阵，对规模特大的邻接矩阵可采用压缩存储(只存储上三角区/下三角区)。\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-25.png\" style=\"zoom:80%;\" />\n\n4. 邻接矩阵表示法的空间复杂度为<font color='orange'>O(n²)</font>,其中n为图的顶点数|V|。所以只和顶点数相关，和实际的边数无关\n\n5. 适用于存储稠密图\n\n邻接矩阵的**优点**：\n\n- 直观、简单、好理解\n- 方便检查任意一对顶点间是否存在边\n- 方便找任一顶点的所有\"邻接点\"(有边直接相连的顶点)\n- 方便计算任一顶点的\"度\"(从该点发出的边数为\"出度\",指向该点的边数为\"入度\")\n\n**缺点**：\n\n- 不便于删除和增加顶点\n- 浪费空间-存稀疏图(点很多而边很少)，有大量无效元素\n- 浪费时间-统计稀疏图中一共有多少条边\n\n### 邻接表法\n\n所谓邻接表，是指对图G中的每个顶点vi建立一个单链表，第i个单链表中的结点表示依附于顶点vi的边(对于有向图则是以顶点vi为尾的弧)，这个单链表就称为顶点vi的**边表**(d4对于有向图则称为**出边表**)。\n\n边表的头指针和顶点的数据信息采用顺序存储(称为**顶点表**)，所以在邻接表中存在两种结点:顶点表结点和边表结点\n\n#### 无向图的邻接表\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-27.png\" style=\"zoom: 67%;\" />\n\n顶点：按编号顺序将顶点数据存储在**一维数组中**。\n\n关联同一顶点的边(以顶点为尾的弧)：用线性**链表**存储\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-178.png\" style=\"zoom:67%;\" />\n\n例如，由A指向B有一条边，那么在A的*first域中，就有一个顶点号为1的结点（顶点号为1的就是B），下一个依次为2、3（即C、D顶点）。\n\n如果我们要存的是带权图，我们可以在存放边的类型中定义权值的信息。\n\n> 其实不难发现，这种邻接表法的实现，和我们之前讲的树的孩子表示法，是相同的一种实现方式。\n>\n> 各个结点顺序存储，然后再用一个链表来指明和这个结点相连的各个边。\n\n------\n\n无向图的邻接表特点：\n\n- 邻接表不唯一\n- 若无向图中有n个顶点、e条边，则其邻接表需n个头结点和2e个表结点。适宜存储稀疏图。\n- 无向图中顶点Vi的度为第 i 个单链表中的结点数。\n\n#### 有向图的邻接表\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-179.png\" style=\"zoom:67%;\" />\n\n原理是类似的。有一条弧是从A指向B，所以A的后面跟了顶点号为1的结点。\n\n> 实际上就是，对于有向图来说，它后面这个链域存储的信息，只是由这个顶点向外射的一些弧。\n>\n> 而对于无向图来说，是不分方向的一个个边。实际上，在无向图中，每一条边在邻接表中都会对应两个结点。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-180.png\" style=\"zoom: 38%;\" />\n>\n> 比如这个，0号结点（A）后存放了一个1号结点（B）；同时，1号结点（B）后面也存放了一个0号结点（A）。而这两个结点表示了同一条边。\n>\n> 实际上在无向图中，边的数据的存放实际是有冗余的。是实际边的数量的两倍。边结点的数量是2|E|，整体空间复杂度为O(|V|+2|E|)。\n\n> 而有向图，每一条弧，都只对应于一个边结点。所以边结点的数量为|E|。所以空间复杂度为O(|V|+|E|)。\n\n<font color='cornflowerblue'>接下来需要探讨的一个问题是</font>：\n\n- 如何求顶点的度、入度、出度？\n- 如何找到与一个顶点相连的边/弧。\n\n首先来看无向图，对于无向图我们只讨论度。如何确定一个顶点的度是多少？\n\n- 我们只需要遍历，和这个顶点相关的这个边链表就可以。有多少个边结点，它的度就是多少。同时，这些边结点就是与这个顶点相连的边。\n\n再来看有向图，有向图的度=入度+出度。\n\n- 如果要找到一个顶点的出度很简单，我们只需要遍历这个结点相关的边链表就可以。同时，它也反应了从这个顶点发射出去的弧有哪些。\n- 但是如果我们要找一个顶点的入度，或者是指向该顶点的弧有哪些，就有些麻烦了。\n  - 比如我们要统计A结点的入度，或者要找到指向A结点的弧。那唯一的办法就是，把所有的结点的边链表，都依次地遍历一遍。是很麻烦的，时间复杂度也会很高。这是邻接表法存储有向图的一个比较大的缺点。\n\n> 此外，由于在一个图中，各个边出现的先后顺序是任意的，因此图的邻接表表示方式并不是唯一的。（如A的边链表可以是1、2、3，也可以是3、2、1）\n>\n> 而上一小节中我们讲的邻接矩阵，只要确定了顶点编号，图的邻接矩阵表示方式就是唯一的。（这是选择题可能会考察的一个点）\n\n#### 图的邻接表存储结构定义\n\n```C\n#define MaxVertexNum 100 //图中顶点数目的最大值\ntypedef struct ArcNode{  //边表结点\n    int adjvex;          //该弧所指向的顶点的位置\n    struct ArcNode *next;//指向下一条弧的指针\n    //InfoType info;     //网的边权值\n}ArcNode;\ntypedef struct VNode{    //顶点表结点\n    VertexType data;     //顶点信息\n    ArcNode *first;      //指向第一条依附该顶点的弧的指针\n}VNode,AdjList[MaxVertexNum];\ntypedef struct {\n    AdjList vertices;    //邻接表\n    int vexnum,arcnum;   //图的顶点数和弧数\n} ALGraph;               //ALGraph是以邻接表存储的图类型\n```\n\n#### 邻接表的特点\n\n1. 若G是无向图，则所需的存储空间为<font color='orange'>O(|V|+2|E|)</font>;若G是有向图，则所需的存储空间为<font color='orange'>O(|V|+|E|)</font>。|E|是边的数量，前者的倍数2是由于无向图中，每条边在邻接表中出现了两次。\n2. 对于稀疏图，采用邻接表表示将极大地<font color='orange'>节省存储空间</font>。\n3. 在邻接表中，给定一顶点，能很容易地找出它的所有邻边，因为只需要读取它的邻接表。在邻接矩阵中，相同的操作则需要扫描一行，花费的时间为O(n)。但是，若要确定给定的两个顶点间是否存在边，则在邻接矩阵中可以立刻查到，而在邻接表中则需要在相应结点对应的边表中查找另一结点，效率低。\n4. 在有向图的邻接表表示中，求一个给定顶点的出度只需计算其邻接表中的结点个数；但求其顶点的入度则需要遍历全部的邻接表。因此，也有人采用逆邻接表的存储方式来加速求解给定顶点的入度。当然，这实际上与邻接表存储方式是类似的。\n5. 图的邻接表表示并不唯一，因为在每个顶点对应的单链表中，各边结点的链接次序可以是任意的，它取决于建立邻接表的算法及边的输入次序。\n\n#### 邻接表和邻接矩阵的关系\n\n联系：邻接表中每个链表对应于邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数。\n\n|                  | 邻接表                                     | 邻接矩阵             |\n| ---------------- | ------------------------------------------ | -------------------- |\n| 空间复杂度       | 无向图O(\\|V\\|+2\\|E\\|);有向图O(\\|V\\|+\\|E\\|) | O(\\|V\\|²)            |\n| 适合用于         | 存储稀疏图                                 | 存储稠密图           |\n| 表示方式         | 不唯一                                     | 唯一                 |\n| 计算度/出度/入度 | 计算有向图的度、入度不方便，其余很方便     | 必须遍历对应的行或列 |\n| 找相邻的边       | 找有向图的入边不方便，其余很方便           | 必须遍历对应行或列   |\n\n### 十字链表\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-31.png\" style=\"zoom: 67%;\" />\n\n邻接矩阵的缺点是空间复杂度太高；邻接表的缺点是当它存储有向图的时候，计算入度、找入边不方便。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-32.png\" style=\"zoom:67%;\" />\n\n十字链表是<font color='cornflowerblue'>有向图</font>的另一种链式存储结构。我们也可以把它看成是将有向图的邻接表和逆邻接表结合起来形成的一种链表。\n\n有向图中的每一条弧对应十字链表中的一个**弧结点**，同时有向图中的每个顶点在十字链表中对应有一个结点，叫做顶点结点。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-181.png\" style=\"zoom:55%;\" />\n\n> 例如顶点A。\n>\n> 若要找从A射出的弧，则找A顶点结点的“绿色”部分指针，找到0→1（即A→B），而在此个弧结点的“绿色”部分指针，存放着A发出的下一条弧0→2（即A→C），下一个绿色指针为空，意味着已经没有其他从A顶点出发的弧了。\n>\n> 若要找进入A的弧，则找A顶点结点的“橙色”部分指针，找到2→0（即C→A），继续找该弧结点的下一个“橙色”指针，找到下一个进入A的弧3→0（即D→A），下一个橙色指针为空，意味着已经没有其他指向A顶点的弧了。\n\n顶点结点中有一个数据域和两个指针域（分别用 firstin 和 firstout 表示）：\n\n- firstin 指针用于连接以当前顶点为弧头的其他顶点构成的链表；\n- firstout 指针用于连接以当前顶点为弧尾的其他顶点构成的链表；\n- data 用于存储该顶点中的数据；\n\n十字链表中弧节点的存储分为 5 部分内容，它们各自的作用是：\n\n- tailvex 用于存储以首元节点为弧尾的顶点位于数组中的位置下标；\n- headvex 用于存储以首元节点为弧头的顶点位于数组中的位置下标；\n- hlink 指针：用于链接下一个存储以首元节点为弧头的顶点的节点；\n- tlink 指针：用于链接下一个存储以首元节点为弧尾的顶点的节点；\n- info 指针：用于存储与该顶点相关的信息，例如量顶点之间的权值；\n\n**空间复杂度**:<font color='orange'>O(|V|+|E|)</font>（顶点的个数+边的个数）\n\n可以看到，空间复杂度和邻接表是一样优秀的，并不会像邻接矩阵那样有空间的冗余。\n\n此外，还可以很方便的找到所有的边，包括出边和入边。\n\n- 如何找到指定顶点的所有出边?--顺着绿色线路找\n\n\n- 如何找到指定顶点的所有入边?--顺着橙色线路找\n\n<font color='red'>注意:十字链表只用于存储有向图</font>\n\n十字链表的构建过程:\n\n```C\n#define  MAX_VERTEX_NUM 20\n#define  InfoType int//图中弧包含信息的数据类型\n#define  VertexType int\ntypedef struct ArcBox{\n    int tailvex,headvex;//弧尾、弧头对应顶点在数组中的位置下标\n    struct ArcBox *hlik,*tlink;//分别指向弧头相同和弧尾相同的下一个弧\n    InfoType *info;//存储弧相关信息的指针\n}ArcBox;\ntypedef struct VexNode{\n    VertexType data;//顶点的数据域\n    ArcBox *firstin,*firstout;//指向以该顶点为弧头和弧尾的链表首个结点\n}VexNode;\ntypedef struct {\n    VexNode xlist[MAX_VERTEX_NUM];//存储顶点的一维数组\n    int vexnum,arcnum;//记录图的顶点数和弧数\n}OLGraph;\nint LocateVex(OLGraph * G,VertexType v){\n    int i=0;\n    //遍历一维数组，找到变量v\n    for (; i<G->vexnum; i++) {\n        if (G->xlist[i].data==v) {\n            break;\n        }\n    }\n    //如果找不到，输出提示语句，返回 -1\n    if (i>G->vexnum) {\n        printf(\"no such vertex.\\n\");\n        return -1;\n    }\n    return i;\n}\n//构建十字链表函数\nvoid CreateDG(OLGraph *G){\n    //输入有向图的顶点数和弧数\n    scanf(\"%d,%d\",&(G->vexnum),&(G->arcnum));\n    //使用一维数组存储顶点数据，初始化指针域为NULL\n    for (int i=0; i<G->vexnum; i++) {\n        scanf(\"%d\",&(G->xlist[i].data));\n        G->xlist[i].firstin=NULL;\n        G->xlist[i].firstout=NULL;\n    }\n    //构建十字链表\n    for (int k=0;k<G->arcnum; k++) {\n        int v1,v2;\n        scanf(\"%d,%d\",&v1,&v2);\n        //确定v1、v2在数组中的位置下标\n        int i=LocateVex(G, v1);\n        int j=LocateVex(G, v2);\n        //建立弧的结点\n        ArcBox * p=(ArcBox*)malloc(sizeof(ArcBox));\n        p->tailvex=i;\n        p->headvex=j;\n        //采用头插法插入新的p结点\n        p->hlik=G->xlist[j].firstin;\n        p->tlink=G->xlist[i].firstout;\n        G->xlist[j].firstin=G->xlist[i].firstout=p;\n    }\n}\n```\n\n### 邻接多重表\n\n邻接多重表是<font color='cornflowerblue'>无向图</font>的另一种链式存储结构\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-182.png\" style=\"zoom: 35%;\" />\n\n怎么解决这些问题呢？我们可以用邻接多重表的方式来存储无向图\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-183.png\" style=\"zoom:70%;\" />\n\n> 例如，A结点，顺着它的指针域寻找，能够找到0—1（即A—B）这条边，之后继续顺着“橙色”（即iLink）指针继续寻找，则能够找到0—3（即A—D）这条边，接着继续顺着”橙色“指针，发现为空，则表示没有与A相连的边了。\n>\n> 对于B结点，顺着它的指针，找到0—1（即A—B）这条边，可见B结点在此处存放于右侧的编号域上（实际上在左边还是在右边是没区别的），于是我们便顺着“绿色”（即jLink）指针继续寻找，继续找到2—1（同样的，B也是在右边这个位置上的），4—1（B在右边），接着继续找“绿色”结点，为空，则到此为止找到所有和B相连的边的信息。\n\n可见，利用邻接多重表想要找到某顶点的所有边是很方便的。同时每个边只对应一份边结点的数据，因此，就不必像邻接表那样，同时维护两份冗余的数据，可以保证我们在删除一个结点或删除一条边的时候，操作会方便很多。\n\n> 比如，现在我们要删除A—B这条边。这条边对应的结点是0—1这个结点。那么我们想要把这个结点删掉，并且重新改变A结点、B结点的指针域，指向这个被删除结点的下一个结点即可。那么，A结点的指针域需要顺着被删除结点的“橙色”指针，指到下一个结点上去；B结点的指针域需要顺着被删除结点的“绿色”指针，指到下一个节点上去。\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-134.png\" style=\"zoom: 50%;\" />\n\n> 比如，要删除E这个顶点。\n>\n> 那么除了删除E这个顶点外，还需要删除与E相连的所有边。\n>\n> 通过与E相连的指针，可以找到，4—1和2—4两条边。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-135.png\" style=\"zoom: 33%;\" />\n>\n> 此时需要注意，将这两个边结点删除之后，会影响到另外两个指针的指向问题。即2—1中的“1”，和2—3中的“2”的下一结点指针指向。\n>\n> 不过，可以看到，对于2—1的“绿色”指针，它指向4—1后便停止了，没有再指向下一个结点。因此将4—1删除后，只需修改2—1的“绿色”指针为空即可。另一个受影响的结点同理。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-136.png\" style=\"zoom:50%;\" />\n\n**空间复杂度**:<font color='orange'>O(|V|+|E|)</font>\n\n顶点结点:\n\n- data：存储此顶点的数据；\n- firstedge：指针域，用于指向同该顶点有直接关联的存储其他顶点的节点。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-36.png\" style=\"zoom:80%;\" />\n\n边结点:\n\n- mark：标志域，用于标记此节点是否被操作过，例如在对图中顶点做遍历操作时，为了防止多次操作同一节点，mark 域为 0 表示还未被遍历；mark 为 1 表示该节点已被遍历；\n- ivex 和 jvex：数据域，分别存储图中各边两端的顶点所在数组中的位置下标；\n- ilink：指针域，指向下一个存储与 ivex 有直接关联顶点的节点；\n- jlink：指针域，指向下一个存储与 jvex 有直接关联顶点的节点；\n- info：指针域，用于存储与该顶点有关的其他信息，比如无向网中各边的权；\n\n<font color='red'>注意:邻接多重表只适用于存储无向图</font>\n\n邻接多重表的整体结构:\n\n```C\n#define MAX_VERTEX_NUM 20                   //图中顶点的最大个数\n#define InfoType int                        //边含有的信息域的数据类型\n#define VertexType int                      //图顶点的数据类型\ntypedef enum {unvisited,visited}VisitIf;    //边标志域\ntypedef struct EBox{\n    VisitIf mark;                           //标志域\n    int ivex,jvex;                          //边两边顶点在数组中的位置下标\n    struct EBox * ilink,*jlink;             //分别指向与ivex、jvex相关的下一个边\n    InfoType *info;                         //边包含的其它的信息域的指针\n}EBox;\ntypedef struct VexBox{\n    VertexType data;                        //顶点数据域\n    EBox * firstedge;                       //顶点相关的第一条边的指针域\n}VexBox;\ntypedef struct {\n    VexBox adjmulist[MAX_VERTEX_NUM];//存储图中顶点的数组\n    int vexnum,degenum;//记录途中顶点个数和边个数的变量\n}AMLGraph;\n```\n\n`总结`\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-184.png\" style=\"zoom:67%;\" />\n\n![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-185.png)\n\n对于十字链表和邻接多重表，其实现方式比较复杂。所以在考研当中不太可能让大家用手写的方式来实现十字链表和邻接多重表。因此这两种实现方式，只需要理解它们的一些特性就可以。\n\n- 十字链表用来存放有向图，可以解决在邻接矩阵中空间复杂度较高的问题，以及在邻接表中不方便查找入度、入边的问题。\n- 邻接多重表用来存放无向图，可以解决邻接矩阵中空间复杂度较高的问题，以及在邻接表中存放无向图需要存放两份冗余数据，导致删除边、删除顶点操作较复杂的问题。\n- 另外，对于一个给定的图，采用十字链表或是邻接多重表，表示方式都是不唯一的。\n\n### 图的基本操作\n\n- Adjacent(G, x, y)\n- Neighbors(G, x)\n- InsertVertex(G, x)\n- AddEdge(G, x, y)\n- RemoveEdge(G, x, y)\n- FirstNeighbor(G, x)\n- NextNeighbor(G, x, y)\n- Get_edge_value(G, x, y)\n- Set_edge_value(G, x, y, v)\n\n那么基本操作的实现，还是和图的存储结构密不可分的。\n\n我们说过，考研当中最常考的还是邻接矩阵和邻接表法。（因为十字链表和邻接多重表实现起来较为复杂，所以不太会考察代码的书写而只考察性质的理解）\n\n此外还有图的遍历算法见下一节\n\n### 习题\n\n- 4 带权有向图G用邻接矩阵存储，则vi的入度等于邻接矩阵中→D\n\n  A 第i行非∞的元素个数\n  B 第i列非∞的元素个数\n  C 第i行非∞且非0的元素个数\n  D 第i列非∞且非0的元素个数\n\n- 13 假设有n个顶点、e条边的有向图用邻接表表示，则删除与某个顶点v相关的所有边的时间复杂度为多少？答案→O(n+e)\n\n- 综合【2015】已知含有5个顶点的图G如下图所示。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-37.png\" style=\"zoom:50%;\" />\n\n  请回答下列问题： \n\n  1）写出图 G 的邻接矩阵 A（行、列下标从 0 开始）。 \n\n  2）求 A²，矩阵 A^2中位于 0 行 3 列元素值的含义是什么？ \n\n  3）若已知具有 n（n≥2）个顶点的图的邻接矩阵为B，则 B^m（2≤m≤n）中非零元素的含义是什么？\n\n  > 1)图G的邻接矩阵A如下:\n  > \n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-257.png\" style=\"zoom:80%;\" />\n  > \n  > 2）A²如下:\n  > \n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-258.png\" style=\"zoom:80%;\" />\n  > \n  > 0行3列的元素值3表示从顶点0到顶点3之间长度为2的路径共有3条\n  > \n  > 3)B^m(2<=m<=n)中位于i行j列(0<=i,j<=n-1)的非零元素的含义是:图中从顶点i到顶点j长度为m的路径条数。\n  \n- 【2021】已知无向连通图G由顶点集V和边集E组成，|E| >0,当G中度为奇数的顶点个数为不大于2的偶数时，G存在包含所有边且长度为|E|的路径（称为EL路径）。设图G采用邻接矩阵存储类型定义如下;\n\n  ```C\n  typedef struct{ //图的定义\n  int numVertices,numEdges;\n  //图中实际的顶点数和边数\n  char Vericeslist[MAXV];\n  //顶点表。MAXV为已定义常量\n  int Edge[MAXV][MAXV];\n  // 邻接矩阵\n  }MGraph;\n  ```\n\n  请设计算法∶int IsExistEL（MGraph G），判断 G是否存在 EL 路径，若存在，则返回1，否则，返回 0。要求：\n  （1）给出算法的基本设计思想。\n  （2）根据设计思想，，采用C或C++语言描述算法，关键之处给出注释。\n  （3）说明你所设计算法的时间复杂度和空间复杂度。\n\n  > （1）算法的基本设计思想\n  > 对于采用邻接矩阵存储的无向图，邻接矩阵每一行（列）中非零元素的个数为本行（列）对应顶点的度。可以依次计算连通图 G中各顶点的度，并记录度为奇数的顶点个数，若个数为0或2，则返回1，否则返回0。\n  >\n  > （2）算法实现\n  >\n  > ```C\n  > int IsExistEL(MGraph G){\n  > //采用邻接矩阵存储，判断图是否存在 EL路径\n  > int degree,i,j,count=0;\n  > for(i=0;i<G.numVertices;i++){\n  >     degree=0;\n  >     for(j=0;j<G.numVertices;j++)\n  >         degree+=G.Edge[i][j]; //依次计算各个顶点的度\n  >     if(degree%2! =0)\n  >         count++; //对度为奇数的顶点计数\n  > }\n  > if(count == 0 || count == 2)\n  >  return l; //存在 EL路径，返回1\n  > else\n  >  return 0; //不存在 EL路径，返回0\n  > }\n  > ```\n  >\n  > （3）时间复杂度是O（n²），空间复杂度是0（1）\n\n## 6.3 图的遍历\n\n### [深度优先和广度优先遍历](https://blog.csdn.net/wdy00000/article/details/123295871)(可先点开看)\n\n从已给的连通图中某一顶点出发，沿着一些边访遍图中的所有的顶点，且使每个顶点仅被访问依次，就叫做图的遍历，它是图的基本运算。\n\n图中可能存在回路，且图的任一顶点都可能与其他顶点相通，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。那么怎么样避免重复访问呢？\n\n解决思路：设置辅助数组 visited[n]，用来标记每个被访问过的顶点。\n\n- 初始状态 visited[i] 为0\n- 顶点i被访问，改visited[i]为1，防止被多次访问\n\n### 广度优先搜索 Breadth-First-Search, BFS\n\n广度优先搜索算法(Breadth First Search)，又称为\"宽度优先搜索\"或\"横向优先搜索\"，简称BFS\n\n方法如下：\n\n从图的某一顶点出发，首先依次访问该结点的所有邻接点Vi1，Vi2，Vi3…Vin ，再按这些顶点被访问的先后次序依次访问与它们想邻接的所有未被访问的顶点。重复此过程，直至所有顶点均被访问为止。\n\n换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2...的顶点。\n\n#### 无向图的广度优先搜索\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-38.png\" style=\"zoom: 50%;\" />\n\n**第1步**：访问A。\n\n**第2步**：依次访问C,D,F。\n  在访问了A之后，接下来访问A的邻接点。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，C在\"D和F\"的前面，因此，先访问C。再访问完C之后，再依次访问D,F。\n\n**第3步**：依次访问B,G。\n  在第2步访问完C,D,F之后，再依次访问它们的邻接点。首先访问C的邻接点B，再访问F的邻接点G。\n\n**第4步**：访问E。\n  在第3步访问完B,G之后，再依次访问它们的邻接点。只有G有邻接点E，因此访问G的邻接点E。\n\n因此访问顺序是：**A -> C -> D -> F -> B -> G -> E**\n\n------\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-186.png\" style=\"zoom:50%;\" />\n\n比如我们从2号结点出发，开始进行图的广度优先遍历。\n\n那同样地，首先我们找到2号结点。然后，找到与之相连的1、6号结点。\n\n再由1、6出发，找到与它们相连的5、3、7号结点。\n\n接着，再由5、3、7号结点，找到它们更下一层的结点，4、8。\n\n#### 有向图的广度优先搜索\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-39.png\" style=\"zoom: 50%;\" />\n\n**第1步**：访问A。\n\n**第2步**：访问B。\n\n**第3步**：依次访问C,E,F。\n  在访问了B之后，接下来访问B的出边的另一个顶点，即C,E,F。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，因此会先访问C，再依次访问E,F。\n\n**第4步**：依次访问D,G。\n  在访问完C,E,F之后，再依次访问它们的出边的另一个顶点。还是按照C,E,F的顺序访问，C的已经全部访问过了，那么就只剩下E,F；先访问E的邻接点D，再访问F的邻接点G。\n\n因此访问顺序是：**A -> B -> C -> E -> F -> D -> G**\n\n#### 非连通图的广度优先遍历\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-40.png\" style=\"zoom: 50%;\" />\n\n#### 树VS图\n\n[树的深度与广度优先]:https://blog.csdn.net/weixin_55953988/article/details/122538609\n\n图的广度优先遍历，这个过程其实和树的广度优先是很类似的。我们看看有什么联系和区别。\n\n首先，不论是树还是图的广度优先遍历，我们都需要实现这样一个操作，就是通过某一个结点，找到与之相邻的其它结点。因为只有实现了这个操作，我们才有可能一层一层的往下找到所有的结点。\n\n对于树来说，找到与之相邻的其他结点，其实就是找它的孩子结点。而对于图来说，我们可以利用之前学过的两个基本操作来完成这件事情。\n\n另外，对于树来说，是不存在“回路”的，搜索相邻的结点时，不可能搜到已经访问过的结点。而对于图来说，搜索相邻的结点时，有可能搜索到已经访问过的顶点，所以我们需要对这一问题进行处理，而处理起来也很简单， 我们只需要对每个结点进行一个标记来表示有没有被访问过就可以了。\n\n#### 算法实现\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-41.png\" style=\"zoom: 80%;\" />\n\n```C\nbool visited[MAX_VERTEX_NUM];//访问标记数组\nvoid BFS(Graph G,int v){ //从顶点v出发，广度优先遍历图G\n    visit(v);   //访问初始顶点v\n    visited[v]=TRUE;   //对v做已访问标记\n    Enqueue(Q,v);    //顶点v入队列Q\n    while(!isEmpty(Q)){\n        DeQueue(Q,v);  //顶点v出队列\n        for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w)) //检测v所有邻接点\n            if(!visited[w]){  //w为v的尚未访问的邻接顶点\n                visit(w);    //访问顶点w\n                visited[w]=TRUE;//对w做已访问标记\n                EnQueue(Q,w);  //顶点w入队列\n            }\n    }\n}\n```\n\n其中，对于`visited[]`数组，刚开始我们把它全部设为false，并且数组的下标和各个结点的编号是一一对应的。（此处为了与顶点编号对应，数组的0号下标弃置不用）\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-248.png\" style=\"zoom: 55%;\" />\n\n> 对于上图：\n>\n> 从顶点2出发得到的广度优先遍历序列：`2 1 6 5 3 7 4 8`\n>\n> 从顶点1出发得到的广度优先遍历序列：`1 2 5 6 3 7 4 8`\n>\n> 从顶点3出发得到的广度优先遍历序列：`3 4 6 7 8 2 1 5`\n\n**遍历序列的可变性**\n\n每一“层”的顶点，应该按照什么样的一个顺序？\n\n实际上，这要看是按照什么存储结构来存储的。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-249.png\" style=\"zoom:55%;\" />\n\n- 如果是用邻接表存储的，由于每个顶点后面的链表中，结点的顺序是不确定的，所以顺序不确定。这个遍历序列是可变的，是不唯一的。\n  - 即：同一个图的**邻接矩阵**表示方式**唯一**，因此广度优先**遍历序列唯一**。\n- 如果是用邻接矩阵存储的，由于遍历某顶点的所有边，是按照该结点在矩阵中对应行的一个从左向右的遍历，所以遍历出来的序列应该是按照由小到大的一个递增的顺序。（一定是这样的）这个遍历序列是唯一的。\n  - 即：同一个图的**邻接表**表示方式**不唯一**，因此广度优先**遍历序列不唯一**。\n\n**算法存在的问题**\n\n至此，我们发现一个问题。\n\n刚刚对于图的广度优先遍历，无论是从哪个顶点出发，都是能够遍历到图中所有顶点的。\n\n这是因为它是一个连通图。如果是非连通图，则无法遍历完所有结点。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-250.png\" style=\"zoom:55%;\" />\n\n对于一个非连通图来说，通过刚才的代码。例如从2号结点出发，就没有办法访问到9、10、11三个结点。\n\n**怎么解决？**\n\n我们不是定义了一个`visited[]`数组吗，这个数组记录了所有顶点是否已经被访问的信息。那么当我们在第一次调用BFS这个函数遍历完毕之后，可以检查一下在visited数组当中能否找到值为false的顶点，如果能找到，那么从这个顶点出发，再次调用BFS这个函数，就可以了。\n\n#### BFS算法(Final版)\n\n```C\nbool visited[MAX_VERTEX_NUM];//访问标记数组\nvoid BFSTraverse(Graph G){ //对图G进行广度优先遍历\n    for(i=0;i<G.vexnum;++i)\n        visited[i]=FALSE;   //访问标记数组初始化\n    InitQueue(Q);           //初始化辅助队列Q\n    for(i=0;i<G.vexnum;++i) //从0号顶点开始遍历\n        if(!visited[i])     //对每个连通分量调用一次BFS\n            BFS(G,i);       //vi未访问过，从vi开始BFS\n}\nvoid BFS(Graph G,int v){ //从顶点v出发，广度优先遍历图G\n    visit(v);   //访问初始顶点v\n    visited[v]=TRUE;   //对v做已访问标记\n    Enqueue(Q,v);    //顶点v入队列Q\n    while(!isEmpty(Q)){\n        DeQueue(Q,v);  //顶点v出队列\n        for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w)) \n            //检测v所有邻接点\n            if(!visited[w]){  //w为v的尚未访问的邻接顶点\n                visit(w);    //访问顶点w\n                visited[w]=TRUE;//对w做已访问标记\n                EnQueue(Q,w);  //顶点w入队列\n            }\n    }\n}\n```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-251.png\" style=\"zoom:55%;\" />\n\n到此，我们就可以遍历完非连通图里的所有结点。此外，对于**无向图**，**调用BFS函数的次数 = 连通分量数**。\n\n#### 复杂度分析\n\n对于空间复杂度来说，其关键是要看辅助队列所需要的空间大小。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-46.png\" style=\"zoom:67%;\" />\n\n再看时间复杂度。在这个BFS算法中，我们首先要visit(v)这个顶点，其次对于每个顶点，我们还需要探索其所有的边。所以我们可以简要的认为，它的时间开销主要用于，探索每个顶点，和探索每条边。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-252.png\" style=\"zoom:55%;\" />\n\n> 可以看出，这个算法的时间复杂度的分析，并不是单纯地看最深层循环的次数。\n>\n> 而是看关键代码的次数。这个算法的关键代码在于visit(v)，和深层for循环，两者兼具（访问顶点+找各条边）。\n>\n> 这是由问题的实际过程考虑得出的，而不要一味地只顾最深层循环。\n\n#### 广度优先生成树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-137.png\" style=\"zoom: 33%;\" />\n\n标红的这些边，表示这个结点在被访问的时候，是由哪条边过去的。例如4号结点，在被访问到的时候，是由3号结点过去的，而不是由7或8过去的。\n\n对于这个n个结点的图来说，我们总共标红了n-1条边。如果把其余的那些边去掉，那么这个图其实就变成了树，因为它里面已经没有回路存在了。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-138.png\" style=\"zoom: 33%;\" />\n\n那么这就是这个图的广度优先生成树。\n\n这个生成树是由广度优先遍历，遍历的顺序得来的。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-139.png\" style=\"zoom:67%;\" />\n\n> 注意其中遍历序列的顺序。例如，由6得来的结点，有3、7，但是要注意在这个实际存储当中，是3在前、7在后的。\n>\n> 而，如果按照下面的存储，那么生成树中的次序也会随之改变，如下。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-140.png\" style=\"zoom: 67%;\" />\n\n可以看到，两棵广度优先生成树，是有区别的。\n\n广度优先生成树由广度优先遍历过程确定。由于邻接表的表示方式不唯一，因此基于邻接表的广度优先生成树也不唯一。\n\n但是如果一个图是用邻接矩阵来存储的，那么它的广度优先生成树肯定也是唯一的了\n\n可以看看下面的视频：\n\n[暨大830数据结构每周一讲-广度优先生成树](https://www.bilibili.com/video/BV1sS4y1p7v2?spm_id_from=333.337.search-card.all.click&vd_source=278af11bcc7fe34571197ce600d488f4)\n\n#### 广度优先生成森林\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-187.png\" style=\"zoom:43%;\" />\n\n对非连通图的广度优先遍历，可以得到广度优先生成森林。很好理解，对于其中的每一个连通分量，都能得到一个广度优先生成树。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-188.png\" style=\"zoom:43%;\" />\n\n这两棵树放在一起，就可以组成一个广度优先生成森林。\n\n### 深度优先搜索 Depth-First-Search, DFS\n\n它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。\n\n方法如下：\n\n- 在访问图中某一起始顶点 v 后，由 v 出发，访问它的任一邻接顶点W1\n- 再从 W1 出发，访问与 W1 邻接但还未被访问过的顶点W2\n- 然后再从 W2 出发，进行类似的访问\n- 如此进行下去，直至到达所有的邻接顶点都被访问过的顶点u为止\n- 接着，退回一步，退到前一次刚访问过的顶点，看是否还有其他没有被访问的邻接顶点\n- 如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问\n- 如果没有，那就再退回一步进行搜索。重复上述过程，直到连通图中的所有顶点都被访问过为止。\n\n#### 无向图的深度优先搜索\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-48.png\" style=\"zoom:67%;\" />\n\n**第1步**：访问A。\n\n**第2步**：访问(A的邻接点)C。\n  在第1步访问A之后，接下来应该访问的是A的邻接点，即\"C,D,F\"中的一个。但在本文的实现中，顶点ABCDEFG是按照顺序存储，C在\"D和F\"的前面，因此，先访问C。\n\n**第3步**：访问(C的邻接点)B。\n  在第2步访问C之后，接下来应该访问C的邻接点，即\"B和D\"中一个(A已经被访问过，就不算在内)。而由于B在D之前，先访问B。\n\n**第4步**：访问(C的邻接点)D。\n  在第3步访问了C的邻接点B之后，B没有未被访问的邻接点；因此，返回到访问C的另一个邻接点D。\n\n**第5步**：访问(A的邻接点)F。\n  前面已经访问了A，并且访问完了\"A的邻接点B的所有邻接点(包括递归的邻接点在内)\"；因此，此时返回到访问A的另一个邻接点F。\n\n**第6步**：访问(F的邻接点)G。\n\n**第7步**：访问(G的邻接点)E。\n\n因此访问顺序是：**A -> C -> B -> D -> F -> G -> E**\n\n#### 有向图的深度优先搜索\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-49.png\" style=\"zoom:67%;\" />\n\n**第1步**：访问A。\n\n**第2步**：访问B。\n  在访问了A之后，接下来应该访问的是A的出边的另一个顶点，即顶点B。\n\n**第3步**：访问C。\n  在访问了B之后，接下来应该访问的是B的出边的另一个顶点，即顶点C,E,F。在本文实现的图中，顶点ABCDEFG按照顺序存储，因此先访问C。\n\n**第4步**：访问E。\n  接下来访问C的出边的另一个顶点，即顶点E。\n\n**第5步**：访问D。\n  接下来访问E的出边的另一个顶点，即顶点B,D。顶点B已经被访问过，因此访问顶点D。\n\n**第6步**：访问F。\n  接下应该回溯\"访问A的出边的另一个顶点F\"。\n\n**第7步**：访问G。\n\n因此访问顺序是：**A -> B -> C -> E -> D -> F -> G**\n\n#### 算法实现\n\n```C\nbool visited[MAX_VERTEX_NUM];\t//访问标记数组（初始都为false）\nvoid DFS(Graph G, int v) {\t//从顶点v出发，深度优先遍历图G\n    visit(v);\t//访问顶点v\n    visited[v] = TRUE;\t//设已访问标记\n    for(w = FirstNeighbor(G,v); w>=0; w = NextNeighbor(G,v,w)) {\n        if(!visited[w]){\t//w为v的尚未访问的邻接顶点\n            DFS(G,w);\n        }//if\n    }//for\n}\n```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-141.png\" style=\"zoom: 50%;\" />\n\n> 如果由2号顶点出发。\n>\n> 2号顶点有子树1，则访问1号，1号还有子树5，则继续访问5号。\n>\n> 5号执行结束没有子树，则返回到1号结点，1号没有其他子树，则返回到2号顶点。\n>\n> 找到2号顶点的下一个邻接点，即6号顶点。\n>\n> 和6号相邻的，访问3号结点，接着访问4号顶点，接着访问7号结点，接着访问8号顶点。\n>\n> 8号执行完后，由于与之相邻的所有顶点都已经被访问过，因此可以结束执行，向上返回，一路返回到最上层。最终整个函数执行完毕。\n>\n> 从2出发的深度遍历序列：2 1 5 6 3 4 7 8。\n\n**算法存在的问题**\n\n这段代码也存在类似的问题，就是，如果是非连通图，则无法遍历完所有结点\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-50.png\" style=\"zoom:80%;\" />\n\n处理的方法类似。\n\n我们在进行了一次DFS后，还可以扫描一次visited[]数组，如果在这个数组中发现了有某一个元素，它依然是false，那么就说明与之相对应的顶点是没有被访问过的，那么我们再从这个顶点出发再调用一次DFS函数就可以了。\n\n#### DFS算法(Final版)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-51.png\" style=\"zoom:80%;\" />\n\n```C\nbool visited[MAX_VERTEX_NUM];\t//访问标记数组\nvoid DFSTraverse(Graph G) {\t\t//对图G进行深度优先遍历\n    for(v=0; v<G.vexnum; ++v) {\n        visited[v] = FALSE;\t\t//初始化已访问标记数据\n    }\n    for(v=0; v<G.vexnum; ++v) {\t//本代码中是从v=0开始遍历（也可以从1开始）\n        if(!visited[v]) {\n            DFS(G, v);\n        }\n    }\n}\n\nvoid DFS(Graph G, int v) {\t//从顶点v出发，深度优先遍历图G\n    visit(v);\t//访问顶点v\n    visited[v] = TRUE;\t//设已访问标记\n    for(w=FirstNeighbor(G,v); w>=0; w=NextNeighbor(G,v,w)) {\n        if(!visited[w]) {\t//w为v的尚未访问的邻接顶点\n            DFS(G,w);\n        }//if\n    }//for\n}\n```\n\n#### 复杂度分析\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-52.png\" style=\"zoom:67%;\" />\n\n**最坏情况，递归深度为O(|V|)**。即，从1号顶点出发进行深度优先遍历，一直遍历到8号，才能发现其没有继续的子树，才能结束DFS并依次返回。那么此时函数调用栈中存放了8层递归。\n\n**最好情况，O(1)**。找到一个子树就结束DFS并返回上级。那么我们的递归调用栈只会有2层。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-53.png\" style=\"zoom:80%;\" />\n\n广度优先和深度优先，都可以把代码的时间开销简化为访问各结点+探索各条边的时间开销。\n\n无论是广度优先还是深度优先，其时间复杂度都是分为邻接矩阵和邻接表两种存储方式讨论的。\n\n### 图的遍历与图的连通性\n\n图的遍历算法可以用来判断图的连通性。\n\n对于无向图来说，如果无向图是连通的，则从任一结点出发，仅需一次遍历就能够访问图中所有顶点；\n\n如果无向图是非连通的，则从某一个顶点出发，一次遍历只能访问到该顶点所在连通分量的所有顶点，而对于图中其他连通分量的顶点无法通过这次遍历访问。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-255.png\" style=\"zoom:67%;\" />\n\n对于有向图来说，若从初始点到图中的每个顶点都有路径，则能够访问图中的所有顶点，否则不能访问到所有顶点。\n\n故而在BFSTraverse()和DFSTraverse()中添加了第二个for循环，再选取初始点，继续进行遍历，以防止一次无法遍历图中所有顶点。\n\n对于无向图，上述两个函数调用BFS(G,i)或DFS(G,i)的次数等于图中的连通分量树；\n\n而对于有向图，则不是这样没因为一个连通的有向图分为强连通的和非强连通的，它的连通子图也分为强连通分量和非强连通分量，非强连通分量一次调用BFS(G,i)或DFS(G,i)无法访问到该连通分量的所有顶点。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-256.png\" style=\"zoom:67%;\" />\n\nhttps://zhuanlan.zhihu.com/p/37792015\n\n### 习题\n\n- 【2013】若对如下无向图进行遍历，则下列选项中，不是广度优先遍历序列的是-->D\n\n  A.h，c，a，b，d，e，g，f    B.e，a，f，g，b，h，c，d\n\n  C.d，b，c，a，h，e，f，g    D.a，b，c，d，h，e，f，g\n\n  ![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-54.png)\n\n  > 图的广度优先遍历，类似树的层序遍历，需要借助辅助队列实现。 以A答案为例，从结点h开始访问，h先入队。此时队列非空，h出队，然后依次访问与h邻接但未被访问过的c，a结点，c,a结点入队。此时队列非空，取出队头元素c，依次访问与c邻接但未被访问过的结点b,d，b,d结点入队(现在队列中有abd)。队列非空，取出队头元素a，依次访问与a结点邻接但未访问过的e结点，e入队。后面的操作类似，在整个执行过程中，结点被访问的次序是hcabdegf。D是深度优先遍历\n\n- 【2015】设有向图 G=(V, E)，顶点集 V={V0, V1, V2, V3}，边集E={<v0,v1>, <v0,v2>, <v0,v3>, <v1,v3>}。若从顶点 V0 开始对图进行深度优先遍历，则可能得到的不同遍历序列个数是 -->5\n\n  > 画出该有向图图形如下：\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-55.png\" style=\"zoom:80%;\" />\n  >\n  > 采用图的深度优先遍历，共5种可能<v0, v1, v3, v2>，<v0, v2, v3, v1>，<v0, v2, v1, v3>，<v0, v3, v2, v1>，<v0, v3, v1, v2>\n\n- 【2016】下列选项中，不是下图深度优先搜索序列的是-->D\n\n  ![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-56.png)\n\n  　　A.V1，V5，V4，V3，V2 B.V1，V3，V2，V5，V4\n\n  　　C.V1，V2，V5，V4，V3 D.V1，V2，V3，V4，V5\n\n  > 对于本题，只需按深度优先遍历的策略进行遍历即可。对于选项A：先访问V1，然后访问与V1邻接且未被访问的任一顶点（满足的有V2、V3和V5），此时访问V5，然后从V5出发，访问与V5邻接且未被访问的任一顶点（满足的只有V4），然后从V4出发，访问与V4邻接且未被访问的任一顶点（满足的只有V3），然后从V3出发，访问与V3邻接且未被访问的任一顶点（满足的只有V2），结束遍历。选项B和C的分析方法与选项A相同，不再赘述。对于选项D，首先访问V1，然后从V1出发，访问与V1邻接且未被访问的任一顶点（满足的有V2、V3和V5），然后从V2出发，访问与V2邻接且未被访问的任一顶点（满足的只有V5），按规则本应该访问V5，但选项D却访问V3，D错误。\n","tags":["408数据结构"],"categories":["408数据结构"]},{"title":"第五章 树与二叉树(下)","url":"/p/56280/","content":"\n## 5.4 树、森林 Tree Forest\n\n### 树的存储结构\n\n#### 树的逻辑结构回顾\n\n树是 n(n≥0)个结点的有限集合，n=0时，称为空树，这是一种特殊情况。在任意一棵**非空树**中应满足：\n\n1. 有且仅有一个特定的称为根的结点\n2. 当 n>1 时，其余结点可分为 m(m>0) 个互不相交的有限集合 T1、T2、T3、…Tm ,其中每个集合本身又是一棵树，并且称为树结点的子树。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-222.png\" style=\"zoom:55%;\" />\n\n#### 双亲表示法(顺序存储)\n\n双亲表示法：每个结点中保存指向双亲的指针。\n\n因为在一棵树中，除了根结点外，每个结点都有且仅有一个它的父节点。\n\n所以，利用这一特性，我们在保存每个结点本身的数据之外，再保存一个指向它双亲的指针。\n\n> 即使用顺序存储，每个数据元素存放了数据data、双亲索引parent。\n>\n> 根结点固定存储在0号位置，parent = -1表示没有双亲。\n>\n> 当然，这个“指针”实际上是个int型变量。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-223.png\" style=\"zoom:55%;\" />\n\n该存储结构利用了每个结点(根结点除外)只有唯一双亲的性质，可以很快得到每个结点的双亲结点，但求结点的孩子时需要遍历整个结构。\n\n若要<font color='red'>增加</font>一个结点，只需要在数组的空闲位置写入一个结点即可，写入其数据值，并绑定其与双亲的关系即可。而结点在数组中存放的先后顺序是无所谓的，没必要按照树中层次的先后顺序来存储。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-224.png\" style=\"zoom: 55%;\" />\n\n若我们要<font color='red'>删除</font>G这个结点，有两种删除方法。方案一，把该结点的指针域置为-1，让此位置无效。方案二：将数组中最后一个结点置于此节点上将之覆盖，方案二可以保证每个位置都是有效的存储位置。最后再将树的结点数n减一即可。（方案二是较好的，见下方查找操作中的描述可知）\n\n<font color='cornflowerblue'>思考一个问题，若删除的结点不是一个叶子结点，而是某一个分支结点，该怎么进行删除操作呢？</font>\n\n那此时就不能只删除这个结点在数组中存放的位置了，因为如果这样删除，就意味着以这个结点为根的整棵子树都被删除了。我们还要将这个结点的孩子结点找到，并且用一定的办法保留在原树中。\n\n那么此时就涉及到树的**查找**操作了。\n\n在这种存储结构中，给定一个结点，对于查找它的双亲节点是很简单的，只需访问其parent指针即可（**优点**）。但如果要找到它的孩子，我们就只能从头到尾依次遍历，然后匹配出它的所有孩子结点（**缺点**）。（此处也暴露出删除一个结点操作中，方案一的缺点，会导致遍历操作的时候访问很多无效的结点，导致遍历的速度更慢）\n\n<font color='orange'>注意:区别树的顺序存储结构与二叉树的顺序存储结构。在树的顺序存储结构中，数组下标代表结点的编号，下标中所存的内容指示了结点之间的关系。而在二叉树的顺序存储结构中，数组下标既代表了结点的编号，又指示了二叉树中各结点之间的关系。当然，二叉树属于树，因此二叉树都可以用树的存储结构来存储，但树却不能用二叉树的存储结构来存储。</font>\n\n#### 孩子表示法(顺序+链式存储)\n\n孩子表示法：顺序存储各个结点，每个结点中保存孩子链表头指针。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-164.png\" style=\"zoom: 33%;\" />\n\n```C\nstruct CTNode {\n\tint child;\t//孩子结点在数组中的位置\n\tstruct CTNode *next;\t//下一个孩子 \n};\n\ntypedef struct {\n\tElemType data;\n\tstruct CTNode *firstChild;\t//第一个孩子 \n}CTBox;\n\ntypedef struct {\n\tCTBox nodes[MAX_TREE_SIZE];\n\tint n, r;\t//结点数和根的位置 \n}CTree;\n```\n\n思考这种存储方式，在进行增/删/查时的操作。以及其优缺点。此处不再展开。\n\n#### 孩子兄弟表示法(链式存储)🔥\n\n<font color='cornflowerblue'>这是最重要的一种表示法。就是用纯链式存储的方式来表示一棵树。</font>\n\n从存储的角度来看，这就是个二叉链表（每个结点有两个指针）。其实和二叉树的存储是相似的，只是变量的含义、命名有所区别。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-225.png\" style=\"zoom:55%;\" />\n\n- 左指针指向第一个孩子结点，右指针指向兄弟结点\n- A 是根节点，A的第一个孩子是B，所以A左连接B，B的兄弟结点是C，所以让B右连接C，D是C的兄弟结点，所以让C右连接D\n- B的第一个孩子是E，所以让B左连接E，E的兄弟结点是F，所以让E右连接F\n- E的第一个孩子是K，所以让E左连接K\n- C的第一个孩子是G，所以让C左连接G\n- D的第一个孩子是H，所以让D左连接H，I、J都是是H的兄弟结点，所以让H右连接I、J\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-214.png\" style=\"zoom:55%;\" />\n\n- A是根节点，左边的B是第一个孩子，B的右边C、F、L都是B的兄弟\n- D连在B的左边，所以D是B的第一个孩子，H是D的兄弟\n- G连在D的左边，所以G是D的孩子\n- E连在C的左边，所以E是C的第一个孩子，I连在E的左边，所以I是E的第一个孩子，J连在E的右边，所以J是E的兄弟\n\n### 树、森林与二叉树的转换\n\n#### 树和二叉树的转换\n\n- 将树转化为二叉树进行处理，利用二叉树的算法来实现对树的操作\n- 由于树和二叉树都可以用二叉链表作存储结构，则以二叉链表作媒介可以导出树与二叉树之间的一个对应关系。\n\n`树转化为二叉树`\n\n每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟，这个规则称\"**左孩子右兄弟**\"。由于根结点没兄弟。所以对应的二叉树没有右子树。\n\n**画法**:\n\n1. 加线：在兄弟之间加一条线\n2. 抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系\n3. 旋转：以树的根节点为轴心，将整树顺时针转45°\n\n<font color='orange'>树变二叉树：兄弟相连留长子</font>\n\n**看个例子**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-142.png\" style=\"zoom:67%;\" />\n\n`二叉树转化为树`\n\n**画法**:\n\n1. 加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子…沿分支找到所有右孩子，都与p的双亲用线连起来\n2. 抹线：抹掉原二叉树中双亲与右孩子之间的连线\n3. 调整：将结点按层序排列，形成树结构\n\n<font color='orange'>二叉树变树：左孩右右连双亲，去掉原来右孩线</font>\n\n**看个例子**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-143.png\" style=\"zoom:67%;\" />\n\n#### 森林和二叉树的转换\n\n`森林转化为二叉树`\n\n先将森林中的每棵树转换为二叉树，由于任何一棵和树对应的二叉树的右子树必空，若把森林中的第二棵树根视为第一棵树根的右兄弟，即将第二棵树对应的二叉树当作第一棵二叉树根的右子树，将第三棵树对应的二叉树当作第二棵二叉树根的右子树...以此类推\n\n**画法**:\n\n1. 将各棵树分别转换成二叉树\n2. 将每棵树的根结点用线相连\n3. 以第一课树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构\n\n<font color='orange'>森林变二叉树，树变二叉根相连</font>\n\n**看个例子**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-226.png\" style=\"zoom:55%;\" />\n\n- B、C、D 是兄弟结点，各个树的根节点视为兄弟关系，所以将C、D右连接B\n- E是B的第一个孩子，所以将E左连接B，F是E的兄弟结点，所以将F右连接E\n- K是E的第一个孩子，所以将K左连接E，L是K的兄弟结点，所以将L右连接L\n\n**再看一个例子**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-144.png\" style=\"zoom:67%;\" />\n\n`二叉树转化为森林`\n\n若二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形式，故将根的右链断开。二叉树根的右子树又可视为一个由除第一棵树外的森林转换后的二叉树，应用同样的方法，直到最后只剩一棵没有右子树的二叉树为止，最后再将每棵二叉树依次转换成树，就得到了原森林。 \n\n**画法**:\n\n1. 抹线：将二叉树中**根节点**与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树\n2. 还原：将孤立的二叉树还原成树\n\n<font color='orange'>去掉全部右孩线，孤立二叉再还原</font>\n\n**看个例子**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-227.png\" style=\"zoom:55%;\" />\n\n- A、C、F、L是兄弟结点，分别为二叉树的跟结点\n- A的左边连接了B，所以B是A的第一个孩子，B的左边连接了D，所以D是B的第一个孩子，D的左边连接了G，所以G是D的第一个孩子，D的右边连接了H，所以D和H是兄弟结点\n- C的左边连接了E，所以E是C的第一个孩子，E的左边连接了I，所以I是E的第一个孩子，E的右边连接了J，所以E和J是兄弟结点。\n- F的左边连了K，所以K是F的第一个孩子\n\n**再看个例子**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-146.png\" style=\"zoom:67%;\" />\n\n<font color='red'>二叉树转换为树或森林是唯一的</font>\n\n`小结`\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-228.png\" style=\"zoom:60%;\" />\n\n### 树和森林的遍历\n\n#### 树的先根遍历\n\n先根遍历：若树非空，先访问根节点，再依次对每棵子树进行先根遍历。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-200.png\" style=\"zoom: 42%;\" />\n\n```C\n// 树的先根遍历\nvoid PreOrder(TreeNode *R){\n    if(R!=NULL){\n        visit(R); // 访问根结点\n        while(R还有下一个子树T){\n            PreOrder(T);\t\t\t// 先根遍历下一棵子树\n        }\n    }\n}\n```\n\n把这棵树转化为与之对应的二叉树后，会发现，对**树的先根遍历序列**，和与之对应的**二叉树的先序遍历序列**相同。\n\n#### 树的后根遍历\n\n后根遍历：若树非空，先依次对每棵子树进行后根遍历，最后再访问根结点。\n\n树的后根遍历也叫做深度优先遍历。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-201.png\" style=\"zoom:42%;\" />\n\n**树的后根遍历与这棵树对应的二叉树的中序遍历序列相同**。\n\n#### 树的层次遍历\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-202.png\" style=\"zoom:42%;\" />\n\n不难发现，对于层次遍历来说，我们在探索这些结点的时候，是尽可能的横向在探索，也就是探索的范围尽可能的广，所以对**树的层次遍历**也叫**广度优先遍历**。\n\n那么与之相对的，树的**先根遍历**和**后根遍历**，我们在探索结点的时候，是尽可能的往深处探索，所以**后根遍历和先根遍历也叫深度优先遍历**。\n\n#### 森林的先序遍历\n\n先序遍历森林：\n\n- 若森林为空，则按如下规则进行遍历\n- 访问森林中第一棵树的根结点，先序遍历第一棵树中根结点的子树森林，先序遍历除去第一棵树之后剩余的树构成的森林。(效果等同于依次对各个树进行先根遍历)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-203.png\" style=\"zoom:42%;\" />\n\n- 或者将其转化为对应的二叉树，先序遍历森林效果等同于依次对二叉树的先序遍历\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-204.png\" style=\"zoom:42%;\" />\n\n#### 森林的中序遍历\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-205.png\" style=\"zoom:42%;\" />\n\n另一种方法就是将其转换成与之对应的二叉树，中序遍历森林效果等同于依次对二叉树的中序遍历\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-206.png\" style=\"zoom:42%;\" />\n\n#### 总结\n\n| 树       | 森林     | 二叉树   |\n| -------- | -------- | -------- |\n| 先根遍历 | 先序遍历 | 先序遍历 |\n| 后根遍历 | 中序遍历 | 中序遍历 |\n\n> 考试中，一般只涉及到森林的先序、中序遍历序列的求解，此时，我们将其转化为对各个树的先根、后根遍历即可很快得出其序列。\n>\n> 但是万一考察到了对森林的代码题、算法题，那么也不要慌张，将森林转化为与之对应的二叉树，然后对二叉树进行相关代码、算法的书写即可。对于二叉树的代码我们应该是很熟悉的。\n\n### 习题\n\n- 利用二叉链表存储森林时，根结点的右指针是\n\n  A 指向最左兄弟\n  B 指向最右兄弟\n  C 一定为空\n  D 不一定为空 →D\n\n- 【2009】将森林转换为对应的二叉树，若在二叉树中，结点 u 是结点 v 的父结点的父结点，则在原来的森林中，u 和 v 可能具有的关系是→①②\n  ① 父子关系\n  ② 兄弟关系\n  ③ u 的父结点与 v 的父结点是兄弟关系\n\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-101.png\" style=\"zoom: 33%;\" />\n  >\n  > 第三个说的是在森林当中u的父节点和v的父节点是兄弟关系，而不是说在二叉树中u的父节点和v的父节点是森林关系\n\n- 【2011】已知一棵有2011个结点的树，其叶结点个数为116，该树对应的二叉树中无右孩子的结点个数-->1896\n\n  > 树——>二叉树，大孩子变左孩子，兄弟变右孩子\n  > 因此对应的二叉树没有右孩子，说明该节点在树里右边没有兄弟，也就是说，该节点是其父节点最右边的孩子。有多少个有孩子的节点，就有多少个“最右的孩子节点”，因此2011-116=1895\n  > 此外，对于根节点而言，它没有父节点当然也没有兄弟，因此也是没有右孩子的。所以+1=1896\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-177.png\" style=\"zoom:30%;\" />\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-178.png\" style=\"zoom:30%;\" />\n\n- 【2014】将森林 F 转换为对应的二叉树 T，F 中叶结点的个数等于→C\n\n  A T 中叶结点的个数\n  B T 中度为 1 的结点的个数\n  C T 中左孩子指针为空的结点个数\n  D T 中右孩子指针为空的结点个数 \n\n  > 在森林转换为二叉树时候。 \n  >\n  > 左指针指向该节点的孩子， 有指针指向该节点的兄弟节点。 \n  >\n  > 如果该节点左指针为NULL,那么说明在原来森林中， 该节点也没有孩子——是叶子节点。 \n  >\n  > 如果该节点右指针为NULL， 那么说明咋原来森林中， 该节点没有右边的兄弟节点。 \n  >\n  > 因此， 森林中叶子节点等于二叉树中左指针为NULL的个数。  选C\n\n- 【2016】若森林F有15条边、25个结点，则F包含树的个数是-->10\n\n  > 森林不一定是二叉树，三叉。。有多个孩子节点。\n  >\n  > 当一棵树时，假设5个结点，得到4条边，形成一棵树。5-4=1； \n  >\n  > 形成两棵树的情况下，浪费一个结点，得到3条边，形成两棵树。5-3=2； \n  >\n  > 因此递推出关系：一棵树的边数为15，有25个结点，形成25-15=10棵。\n\n- 【2019】若将一棵树T转化为对应的二叉树BT，则下列对BT的遍历中，其遍历序列与T的后根遍历序列相同的是-->B\n\n  A. 先序遍历   B. 中序遍历\n\n  C. 后序遍历   D. 按层遍历\n\n  > 后根遍历树可分为两步：① 从左到右访问双亲结点的每个孩子（转化为二叉树后就是先访问根结点再访问右子树）；② 访问完所有孩子后再访问它们的双亲结点（转化为二叉树后就是先访问左子树再访问根结点）因此树T的后根序列与其相应的二叉树BT的中序遍历序列相同。\n\n- 【2020】已知森林 F 及与之对应的二叉树 T，若 F 的先根遍历序列是 a, b, c, d, e, f，中根遍历序列是 b, a, d, f, e, c，则 T 的后根遍历序列是？→ b, f, e, d, c, a \n\n  > 由先根遍历序列a,b,c,d,e,f和中根遍历序列b,a,d,f,e,c可知，a为T的根，{b}为a的左子树结点，{dfec}为a的右子树结点。由先根遍历序列c,d,e,f和中根遍历序列d,f,e,c可知a的右子树为c，c的左子树中的结点有{d,e,f}，右子树为空。由先根遍历序列d,e,f和中根遍历序列d,f,e可知c的左子树为d，d的左子树为空，右子树的结点有{e,f}。由先根遍历序列e,f和中根遍历序列f,e可知d的右子树为e，e的右子树为空，左子树的结点有{f}。所以，T的后遍历序列为：bfedca\n\n- 【2021】某森林F对应的二叉树为T，若T的先序遍历序列是a,b,d,c,e,g,f,中序遍历序列是b,d,a,e,g,c,f,则F中树的棵树是-->3\n\n  > 先根据先序遍历序列和中序遍历序列还原二叉树T如下：\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-102.png\" style=\"zoom:50%;\" />\n  >\n  > 由森林转化成二叉树的规则可知，森林中每棵树的根结点以右子树的方式相连，所以T中的结点a,c,f为F中树的根结点，森林F有三棵树\n\n- 综合题【2016】若一棵非空k(k>=2)叉树T中的每个非叶结点都有k个孩子，则称T为正则k叉树。请回答下列问题并给出推导过程。\n\n  （1）若 T 有 m 个非叶结点，则 T 中的叶结点有多少个？ \n\n  （2）若 T 的高度为 h（单结点的树 h=1），则 T 的结点数最多为多少个？最少为多少个？\n\n  > （1）根据定义，正则 k 叉树中仅含有两类结点；叶结点（个数记为 n0）和度为 k 的分支结点（个数记为 n1）。树 T 中的结点总数n=n0+nk=n0+m。树中所含的边数e=n-1，这些边均为m个度为k的结点发出的，即e=m×k。整理得：n0+m=m ×k+1，故 n0=（k-1）×m+1\n  >\n  > （2）高度为 h 的正则 k 叉树 T 中，含最多结点的树形为：除第 h 层外，第 1 到第 h-1 层的结点都是度为 k 的分支 结点；而第 h 层均为叶结点，即树是“满”树。此时第 j（1≤j≤h）层结点数为 k j-1，结点总数 M1为：\n  >\n  > $$\n  > M1=\\sum_{j=1}^hk^{j-1}=\\frac{k^h-1}{k-1}\n  > $$\n  > 含最少结点的正则 k 叉树的树形为：第 1 层只有根结点，第 2 到第 h-1 层仅含 1 个分支结点和 k-1 个叶结点，第 h 层有 k 个叶结点。即除根外第 2 到第 h 层中每层的结点数均为 k，故 T 中所含结点总数 M2 为： M2=1+(h-1)×k\n\n## 5.5 树与二叉树的应用\n\n### 哈夫曼树和哈夫曼编码\n\n#### 带权路径长度\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-135.png\" style=\"zoom:55%;\" />\n\n结点的权：有某种现实含义的数值(如：表示结点的重要性等)\n\n结点的带权路径长度：从树的根到该结点的路径长度(经过的边数)与该结点上权值的乘积。\n\n- 例如上图结点为3的带权路径长度 = 3 × 3 = 9\n\n树的带权路径长度：树中所有**叶结点**的带权路径长度之和\n$$\nWPL=\\sum_{i=1}^{n}{w_il_i}\n$$\n\n#### 哈夫曼树的定义\n\n在含有n个带权叶节点的二叉树中，其中**带权路径长度（WPL）最小的二叉树**称为**哈夫曼树**，也称**最优二叉树**。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-197.png\" style=\"zoom:55%;\" />\n\n像这个例子中，我们给出了四个叶子结点，它们的权值分别为1、3、4、5。\n\n我们可以构造各种形态的二叉树，把这些结点依次放到不同的位置，并保证这四个为叶子结点。\n\n那么这些不同的二叉树，其带权路径长度WPL有可能相同，也有可能不同。但是对于这四个叶子结点，无论如何改变二叉树的形态，其WPL是不可能小于25的。也就是说，25就是有可能出现的最小的树的带权路径长度。\n\n因此，上图中间的那两棵树，就是哈夫曼树。\n\n#### 哈夫曼树的构造(王道)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-147.png\" style=\"zoom:80%;\" />\n\n对于哈夫曼树并不唯一，如上图情况，我们还可以构造一个与之不同的哈夫曼树，如下所示：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-199.png\" style=\"zoom:55%;\" />\n\n而其WPL依然是最小值31。\n\n**这里的构造可能对于初学者不好理解，推荐听青岛大学王卓老师的课**\n\n#### 哈夫曼树的构造(王卓)\n\n路径：**从树中的一个结点到另一个结点之间的分支构成这两个结点间的路径**\n\n结点的路径长度：**两结点间路径上的分支数**\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-137.png\" style=\"zoom:80%;\" />\n\n树的路径长度：从树根到每一个结点的路径长度之和。记作TL\n\n<font color='orange'>结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树。</font>\n\n权：将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。\n\n结点的带权路径长度：从**根**结点到该结点之间的**路径长度**与该节点的权的**乘积**。\n\n树的带权路径长度：树中所有**叶子结点**的**带权路径长度之和**。记作WPL(Weighted Path Length)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-138.png\" style=\"zoom:67%;\" />\n\n哈夫曼树：最优树(带权路径长度(WPL)最短的树)\n\n注意：\"带权路径长度最短\"是在\"度相同\"的树中比较而得的结果，因此有最优二叉树、最优三叉树之称等等。\n\n哈夫曼树：最优二叉树(带权路径长度(WPL)最短的二叉树)\n\n------\n\n构造哈夫曼树的方法：\n\n1. 根据n个给定的权值{W1,W2,W3,…Wn}构成n棵二叉树的森林F={T1,T2,…Tn},其中Ti只有一个带权为Wi的根节点\n2. 在F中选取两棵根节点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根节点的权值为其左右子树上根节点的权值之和。\n3. 在F中删除这两棵树，同时将新的到的二叉树加入森林中。\n4. 重复2和3，直到森林中只有一棵树为止，这颗树即为哈夫曼树。\n\n口诀：1.构造森林全是根，2.选用两小造新树，3.删除两小添新人，4.重复2、3剩单根\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-139.png\" style=\"zoom:80%;\" />\n\n1. 构造森林全是根。有几个结点就有几个根节点，从而组成森林。\n   - 例如上方有4个结点，则将其都作为根节点组成森林。\n2. 选择两个权值最小的结点，将其权值加和，得到的权值为父结点，两个权值最小的结点为左右子树。\n   - 例如上方权值最下的两个结点为 2 和 4，将其权值加和为6，则 6 为父结点， 2 和 4 为左右子树。\n3. 删除刚才选择的那两个权值最小的结点，将剩余结点与第二步得到的父结点排成一排结成森林。\n   - 删除2和4结点，将 7、5、6三个结点作为根组成森林\n4. 继续选择两个权值最小的结点，将其权值加和，得到的权值为父结点，两个权值最小的结点为左右子树。\n   - 继续选择 5、6 两个结点，权值加和为11，则 11 为父结点，5、6为左右子树。\n\n> 包含n个叶子结点的哈夫曼树中共有 2n-1 个结点。(n个结点，两两合并，总共合并n-1次，产生n-1个新结点)\n>\n> 哈夫曼树的结点的度为0或2，没有度为1的结点。\n>\n> 度为1的结点是n个，度为2的结点是 n-1 个\n\n### 哈夫曼树的应用\n\nhttps://www.cnblogs.com/wkfvawl/p/9783271.html#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81\n\n#### 哈夫曼编码(王道)\n\n如电报——点、划两个信号（二进制的0、1）\n\n**固定长度编码**--每个字符用相等长度的二进制表示\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-149.png\" style=\"zoom:80%;\" />\n\n刚才我们算的所有答案的二进制长度，其实就是算了这棵树的带权路径长度。\n\n那么接下来要思考，还有没有比这种编码方案更优秀的方案？也就是要让它们之间传递的二进制长度的这个bit信息尽可能的少。就是要尽可能追求我们最终构造的这棵编码树，它的带权路径长度尽可能的小。\n\n那么就又回到了我们哈夫曼树的构造问题了。给出四个叶子结点以及权值，构造哈夫曼树。\n\n**可变长度编码**--允许对不同字符用不等长的二进制位表示\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-150.png\" style=\"zoom:80%;\" />\n\n> 到这里，有人会有疑问了：既然C是0，A是10，我想要把A与C区分开来，A是1的话，也可以区分啊？好的，那么我们来试一下：\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-167.png\" style=\"zoom:33%;\" />\n\n> 也就是说，不同的字符结点不一定是叶子结点。\n>\n> 并且C——0；A——1；B——111；D——110。\n>\n> 那么我们尝试发送一下：CAAABD这串答案。\n>\n> 发送方：0111111110\n>\n> 接收方翻译：CBBD。\n>\n> 会发现，对这个二进制码的解码发生错误，有歧义。\n\n所以，对于一个字符集，我们若要设计一系列**可变长度编码**的话，所有字符对应到编码树里面，只能当做叶子结点，不能当做某一个分支结点。\n\n换一个角度来说，这种编码方式，没有一个编码是另一个编码的前缀。则称这样的编码为**前缀编码**。前缀码解码无歧义，而非前缀编码在解码的时候有歧义。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-151.png\" style=\"zoom:80%;\" />\n\n由哈夫曼树得到**哈夫曼编码**--字符集中的每个字符作为一个叶子结点，各个字符出现的频度作为结点的权值，根据之前结点的方法构造哈夫曼树\n\n左分支看成0，右分支看成1。（当然，反过来也无所谓）\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-152.png\" style=\"zoom:80%;\" />\n\nhttps://blog.csdn.net/Bitter_Li/article/details/120939587\n\n#### 哈夫曼编码(王卓)\n\n1. 统计字符集每个字符在电文中出现的平均概率(概率越大，要求编码越短)\n2. 利用哈夫曼树的特点：权越大的叶子离根越近，将每个字符的概率值作为权值，构造哈夫曼树。则概率越大的结点，路径越短。\n3. 在哈夫曼树的每个分支上标上0或1，结点的左分支标0，右分支标1，把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码。\n\n**例题**：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-140.png\" style=\"zoom: 67%;\" />\n\n1. 构造哈夫曼树\n2. 左分支标0，右分支标1，把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-141.png\" style=\"zoom:80%;\" />\n\n### 并查集\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-208.png\" style=\"zoom:50%;\" />\n\n#### 逻辑结构——集合\n\n之前我们学习的逻辑结构有线性结构、树型结构和图结构。**集合**是我们没有学过的。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-209.png\" style=\"zoom: 67%;\" />\n\n对于一个全集S，我们可以按照某些想要的维度进行分类，将S划分为几个不同的子集。\n\n比如根据不同人喜欢吃的水果不一样进行划分。\n\n注意:划分后的子集是<font color='red'>互不相交</font>的。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-210.png\" style=\"zoom:60%;\" />\n\n集合这种逻辑结构之下，两个元素之间的关系要么从属于同一集合、要么从属于不同集合。\n\n<font color='cornflowerblue'>怎么用代码表示这种互不相交的集合关系呢？</font>\n\n联想一下树、森林这种表示方式，用这种思路来表达出各个集合是否属于同一子集。同属于一个集合的元素可以在物理上将它们组织成一棵树。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-211.png\" style=\"zoom:60%;\" />\n\n用互不相交的树，表示多个”集合“。\n\n#### 为什么叫做并查集\n\n<font color='cornflowerblue'>如何“查”到一个元素到底属于哪一个集合？</font>\n\n从指定元素出发，一路向北，找到根节点，通过根节点来判断集合。\n\n<font color='cornflowerblue'>如何判断两个元素是否属于同一集合？</font>\n\n分别查到两个元素的根，判断根节点是否相同即可。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-212.png\" style=\"zoom:60%;\" />\n\n<font color='orange'>如何把两个集合“并”为一个集合？</font>\n\n让一棵树成为另一棵树的子树即可。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-213.png\" style=\"zoom:60%;\" />\n\n想到这，应该知道为什么这个数据结构要叫做”并查集“了。(对集合实现并、查操作)\n\n#### 存储结构\n\n##### 引言\n\n那么应该用什么样的存储结构来实现上述操作呢？——树的双亲表示法更适合\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-223.png\" style=\"zoom:55%;\" />\n\n容易通过数组来找到双亲结点，并且能通过一棵树根节点的parent指针指向另一棵树的根节点的编号来完成”并“操作。\n\n##### 并查集的存储结构\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-229.png\" style=\"zoom:55%;\" />\n\n对于n个数据元素，只需声明一个长度为n的int型数组S，即可表示集合关系。本质上就是树的双亲表示法。\n\n#### 基本操作\n\n- 初始化\n\n  刚开始并不知道哪些数据元素是属于一个子集的，所以都初始化为各自独立的n个子集，将数组的值全部赋值为-1。\n\n  ```C\n  #define SIZE 13\n  int UFsets[SIZE];//集合元素数组\n  //初始化并查集\n  void Initial(int S[]){\n      for(int i=0;i<SIZE;i++)\n          S[i]=-1;\n  }\n  ```\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-230.png\" style=\"zoom:70%;\" />\n\n- 查操作——Find\n\n  非递归形式\n\n  ```C\n  //找x所属集合(返回x所属根结点)\n  int Find(int S[],int x){\n      while(S[x]>=0)//循环寻找x的根\n          x=S[x];\n      return x;//根的s[]小于0\n  }\n  ```\n\n  递归形式\n\n  ```C\n  int Find(int S[],int x) {\n    if (S[x] == -1){\n        return x; //若当前结点为根结点则返回该结点号\n    } \n    else{\n        return Find(S[x]); //否则递归查找其双亲结点的根结点\n    }\n  }\n  ```\n\n- 并操作——Union\n\n  ```C\n  void Union(int S[],int Root1,int Root2){\n      //要求Root1和Root2是不同的集合\n      if(Root1==Root2) return;\n      //将根Root2连接到另一根Root1下面\n      S[Root2]=Root1;\n  }\n  ```\n\n  上述代码是已知两棵树的根节点的实现。如果不知道根节点呢？\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-231.png\" style=\"zoom:67%;\" />\n\n  先对给定的两个元素进行Find操作确定根节点是谁后再执行Union操作即可。\n\n#### 时间复杂度分析\n\n首先并操作不需要多说了，已知根节点后其代码只有两行，时间复杂度O(1)\n\n若结点数为n，Find最坏时间复杂度为O(n)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-232.png\" style=\"zoom:55%;\" />\n\n可以看出来，查操作的最坏时间复杂度O(n)与树的高度h相关，顺着这个思路可以知道如何进行优化操作。\n\n#### Union操作的优化\n\n优化思路:在每次Union操作构建树的时候，尽可能让树不长高\n\n- 用根节点的绝对值表示树的结点总是——表示树的大小\n- Union操作时，让小树合并到大树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-233.png\" style=\"zoom: 67%;\" />\n\n```C\nvoid Union(int S[],int Root1,int Root2){\n    if(Root1==Root2) return;\n    if(S[Root2]>S[Root1]){//Root2结点数更少\n        S[Root1]+=S[Root2];//累加结点总数\n        S[Root2]=Root1;//小树合并到大树\n    }else{\n        S[Root2]+=S[Root1];//累加结点总数\n        S[Root1]=Root2;//小数合并到大树\n    }\n}\n```\n\n合并之后，将两棵树的根节点的绝对值累加成新的总数赋予大树的根节点。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-234.png\" style=\"zoom:67%;\" />\n$$\n该方法构造的树高不超过\\lfloor log_2n\\rfloor+1\n$$\n所以Union操作优化后，Find操作最坏时间复杂度为O(log₂n)\n\n#### 总结\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-235.png\" style=\"zoom:67%;\" />\n\n### 并查集的终极优化\n\n#### Find操作的优化(压缩路径)\n\n用前面讲到的Find操作找x所属集合(返回x所属根结点的值)，如Find(S[],11)查找L所属集合。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-236.png\" style=\"zoom:67%;\" />\n\n如上图所示，L->E->B->A就是查找L的查找路径。所谓”**压缩路径**“的这种优化方式，就是让查找路径变短。\n\n压缩路径————Find操作，先找到根节点，再将查找路径上所有结点都挂到根节点下\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-237.png\" style=\"zoom:67%;\" />\n\n```C\n//先找到根节点，再进行”压缩路径“\nint Find(int S[],int x){\n    int root=x;\n    while(S[root]>=0)   root=S[root];//循环找到根\n    while(x! =root){//压缩路径\n        int t=S[x];//t指向x的父节点\n        S[x]=root; //x直接挂到根节点下\n        x=t;\n    }\n    return root;//返回根节点编号\n}\n```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-238.png\" style=\"zoom:67%;\" />\n\n每次Find操作，先找根，再”压缩路径“，可使树的高度不超过0(a(n))。a(n)是一个增长很缓慢的函数，对于常见的n值，通常a(n)<=4,因此优化后并查集的Find、Union操作时间都很低。\n\n#### 并查集优化总结\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-239.png\" style=\"zoom:67%;\" />\n\n[408快乐站](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)\n\n### 习题\n\n- 【2010】n(n>=2)个权值均不相同的字符构成哈夫曼树，关于该树的叙述中，错误的是-->A\n\n  A.该树一定是一棵完全二叉树\n\n  B.树中一定没有度为1的结点\n\n  C.树中两个权值最小的结点一定是兄弟结点\n\n  D.树中任一非叶结点的权值一定不小于下一层任一结点的权值\n\n  > A.哈夫曼树为带权路径长度最小的二叉树，不一定是完全二叉树。哈夫曼树中没有度为1的结点，B正确；构造哈夫曼树时，最先选取两个权值最小的结点作为左、右子树构造一棵新的二叉树，C正确；哈夫曼树中任一非叶结点P的权值为其左、右子树根结点权值之和，其权值不小于其左、右子树根结点的权值，在与结点P的左、右子树根结点处于同一层的结点中，若存在权值大于结点P权值的结点Q，那么结点Q的兄弟结点中权值较小的一个应该与结点P作为左、右子树构造新的二叉树。综上可知，哈夫曼树中任一非叶结点的权值一定不小于下一层任一结点的权值。\n\n- 【2014】5个字符有如下4种编码方案，不是前缀编码的是-->D\n\n  A、01,0000,0001,001,1\n\n  B、011,000,001,010,1\n\n  C、000,001,010,011,100\n\n  D、0,100,110,1110,1100\n\n  > **前缀编码**是指对字符集进行编码时，要求字符集中任一字符的编码都不是其它字符的编码的前缀。D不符合\n  >\n  > 构造方式： \n  >\n  > 1.构造**哈夫曼树**(哈夫曼树是**同权不同构**的，可以构造出不同结构的哈夫曼树但是带权路径长度是相等的)。 \n  >\n  > 2.**前缀编码**在构造好哈夫曼树的基础上，**左0右1编码**\n\n- 【2015】下列选项给出的是从根分别到达两个叶结点路径上的权值序列，属于同一棵哈夫曼树的是-->\n\n  A. 24,10,5和24,10,7\n\n  B. 24,10,5和24,12,7\n\n  C. 24,10,10和24,14,11\n\n  D. 24,10,5和24,14,6\n\n  > 首先根据两个叶子，以及访问到叶子的前一个结点，这个结点一定是叶子的父亲结点。再根据哈夫曼树的结点一定有兄弟，即不存在度为1的结点。因此可以知道兄弟的**权值**，这样，给定的一个序列就可以推出两个叶子，两个序列推出四个叶子，这样就可以根据是否选择最小的两个叶子结点组合在一起作为判据，决定这个序列是否成立了。\n  >\n  > 我们一个一个来看。\n  >\n  > 1）首先看D  这里写图片描述\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-154.png\" style=\"zoom: 23%;\" />\n  >\n  > 首先由第一个序列的10，5可以推出另一个叶子也是5，它们的父亲是10.到此为止，不能再瞎猜测其他叶子结点了。但我们知道两个叶子形成的结点有个权值为14的兄弟，但是不知道是叶子结点还是一个由叶子形成的结点，这个有待观察。\n  >\n  > 再看第二个序列，知道叶子结点6和父亲14，可以知道有个叶子兄弟是8，这个权值是14的结点有意思了，刚好可以和第一个结合成兄弟，且父亲为24，恰恰满足要求。\n  >\n  > 因此D是符合题目的树形。\n  >\n  > 2）再看C.这里写图片描述\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-155.png\" style=\"zoom:23%;\" />\n  >\n  > 同样的分析思路再过一遍。\n  > 由第一个序列中的10，10可以得到有个叶子权值是0。第二个序列的14，11知道有个叶子是4.\n  > OK，问题出来了，四个权值10，0，11，4是原始序列中的权值，按理说0，4最小，应该组合在一起，但是这里没有。所以是错误的树形。\n  > 当然需要明确的是，0和4不一定要组合在一起，要是序列中有1，那么0，1组合才是更小的。也就是说我们选择的是最小的，在不知道全局的情况下，局部的两个最小值最合理的是组合在一起。局部中不可能出现两个最小的分散的局面。这在哈夫曼树的构造中不可能出现的。\n  >\n  > 以上D,C从正反角度看了这种问题的解法。 同理B,A不再多说，给出图形如下：\n  >\n  > 3）B的树形：这里写图片描述\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-156.png\" style=\"zoom:23%;\" />\n  >\n  > 如果24是第一个序列的，就不可能指到12，所以两个序列不是同一棵树的。\n  >\n  > 4)A也是同样的问题。A的树形：\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-157.png\" style=\"zoom:23%;\" />\n\n- 若度为 m 的哈夫曼树中，叶子结点个数为 n，则非叶子结点的个数为 →（n-1)/(m-1)\n\n- 【2017】已知字符集{a,b,c,d,e,f,g,h}，若各字符的哈夫曼编码依次是0100，10，0000，0101，001，011，11，0001，则编码序列 0100011001001011110101 的译码结果是-->D\n\n  A. acgabfh    B. adbagbb\n  C. afbeagd    D. afeefgd\n\n  > 哈夫曼编码是前缀编码，各个编码的前缀各不相同，因此直接拿编码序列与哈夫曼编码一一比对即可。序列可分割为0100 011 001 001 011 11 0101，译码结果是a f e e f g d，选项D正确\n\n- 【2018】已知字符集{a,b,c,d,e,f},若各字符出现的次数分别为6，3，8，2，10，4，则对应字符集中各字符的哈夫曼编码可能是->A\n\n  A. 00, 1011, 01, 1010, 11, 100\n\n  B. 00, 100, 110, 000, 0010, 01\n\n  C. 10, 1011, 11, 0011, 00, 010\n\n  D. 0011, 10, 11, 0010, 01, 000\n\n  > 先将这串数字构造为哈夫曼树.\n  >\n  > 其实题目中，前半部分的字母已经不用看了，因为构造哈夫曼树正常是比大小，而这里比较出现次数大小。排序为2，3，4，6，8，10\n  >\n  > 哈夫曼树为\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-158.png\" style=\"zoom:23%;\" />\n  >\n  > 将每个结点左右子树设为0，1，如下\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-159.png\" style=\"zoom: 40%;\" />\n  >\n  > 将从头结点到此结点数合起来即为哈夫曼编码\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-160.png\" style=\"zoom: 40%;\" />\n  >\n  > 此时可以得到题目中几个次数的字符集，即为对应字符的哈夫曼编码\n  >\n  > - 2->1010\n  > - 3->1011\n  > - 4->100\n  > - 6->00\n  > - 8->01\n  > - 10->11\n  >\n  > 所以各字符出现的次数分别为{ 6, 3, 8, 2, 10, 4 }，则对应字符集中各字符的哈夫曼编码可能是：00, 1011, 01, 1010, 11, 100\n\n- 【2019】对n个互不相同的符号进行哈夫曼编码。若生成的哈夫曼树共有115个结点，则n的值是-->C\n\n  A.56  B.57\n  C.58  D.60\n\n  > 哈夫曼树的特点性质：（节点为的度数为0 表示 n0,以此类推）\n  > ①哈夫曼树中只存在度为2和度为0的节点，及n1=0。\n  > ②哈夫曼树中，度为0和度为2的节点关系：n2=n0-1\n  >\n  > 由以上两个性质，本题就很好解出答案：\n  > n0+n2=115 =>\n  > n0+n0-1=115 =>\n  > n0=(115+1)/2=58\n\n- 【2021】若某二叉树有5个叶结点，其权值分别为10，12，16，21，30，则其最小的带权路径长度WPL是-->200\n\n  > 首先对集合进行排序得到`{10，12，16，21，30}`\n  >\n  > 我们找到权值最小的两个结点10和12合并；得到新的森林根结点为22。现在结点集合为`{16,21,22,30}`\n  >\n  > 接着我们找到当前最小的结点16和21合并：得到新的森林根结点为37。现在结点集合为`{22,30,37}`\n  >\n  > 接着我们找到当前最小的结点22和30合并：得到新的森林根结点为53。现在结点集合为`{37,53}`\n  >\n  > 接着我们找到当前最小的结点37和53合并：得到新的森林根结点为90。现在结点集合为`{90}`；由于结点个数只剩一个，所以算法结束、构造哈夫曼树完毕\n  >\n  > 依次累加计算所有叶结点的带权路径长度 从上面构造的哈夫曼树可知所有结点的路径长度，例如结点”16“的路径长度为2\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-161.png\" style=\"zoom: 50%;\" />\n  >\n  > 所以`WPL=(16+21+30)*2+(10+12)*3=200`\n\n- 【综合2012】设有6个有序表A,B,C,D,E,F，分别含有10,35,40,50,60和200个数据元素，各表中元素按升序排列。要求通过 5 次两两合并，将 6 个表最终合并成 1 个升序表，并在最坏情况下比较的总次数达到最小。请回答下列问题。\n\n  1 ）给出完整的合并过程，并求出最坏情况下比较的总次数。\n\n  2 ）根据你的合并过程，描述 N （ N ≥ 2 ）个不等长升序表的合并策略，并说明理由。\n\n  > 1）对于长度分别为 m ， n 的两个有序表的合并，最坏情况下是一直比较到两个表尾元素，比较次数为  m+n-1  次。故最坏情况的比较次数依赖于表长，为了缩短总的比较次数，根据哈夫曼树（最佳归并树）思想的启发，可采用如图所示的合并顺序。\n  >\n  > 根据上图中的哈夫曼树， 6个序列的合并过程为：\n  >\n  > 第 1 次合并：表 A 与表 B 合并，生成含有 45 个元素的表 AB ；\n  >\n  > 第 2 次合并：表 AB 与表 C 合并，生成含有 85 个元素的表 ABC ；\n  >\n  > 第 3 次合并：表 D 与表 E 合并，生成含有 110 个元素的表 DE ；\n  >\n  > 第 4 次合并：表 ABC 与表 DE 合并，生成含有 195 个元素的表 ABCDE ；\n  >\n  > 第 5 次合并：表 ABCDE 与表 F 合并，生成含有 395 个元素的最终表。\n  >\n  > ![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-207.png)\n  >\n  > 由上述分析可知，最坏情况下的比较次数为：第1次合并，最多比较次数=10+35-1=44；第2次合并，最多比较次数=45+40-1=84  ；第3次合并，最多比较次数=50+60-1=109；第 4 次合并，最多比较次数=85+110-1=194；第5次合并，最多比较次数=195+200-1=394。故比较的总次数最多为：44+84+109+194+394=825 。\n  >\n  > 2）各表的合并策略是：在对多个有序表进行两两合并时，若表长不同，则最坏情况下总的比较次数依赖于表的合并次序。可以借用哈夫曼树的构造思想，依次选择最短的两个表进行合并，可以获得最坏情况下最佳的合并效率。\n\n- 【综合2020】若任意一个字符的编码都不是其他字符编码的前缀，则称这种编码具有前缀特性。现有某字符集(字符个数>=2)的不等长编码，每个字符的编码均为二进制的0，1序列，最长为L位，且具有前缀特性。请回答下列问题\n\n  1)哪种数据结构适宜保存上述具有前缀特性的不等长编码？\n\n  2)基于你所设计的数据结构，简述从0/1串到字符串的译码过程\n\n  3)简述判定某字符集的不等长编码是否具有前缀特性的过程\n\n  > 1)使用一棵二叉树保存字符集中各字符的编码，每个编码对应于从根开始到达某叶结点的一条路径，路径长度等于编码位数，路径到达的叶结点中保存该编码对应的字符\n  >\n  > 2)从左至右依次扫描0/1串中的各位。从根开始，根据串中当前位沿当前结点的左子指针或右子指针下移，直到移动到叶结点时为止。输出叶结点中保存的字符。输出叶结点中保存的字符。然后从根开始重复这个过程，直到扫描到0/1串结束，译码完成。\n  >\n  > 3)二叉树既可用于保存各字符的编码，又可用于检测编码是否具有前缀特性。判定编码是否具有前缀特性的过程，也是构建二叉树的过程。初始时，二叉树中仅含有根结点，其左子指针和右子指针均为空。\n  >\n  > 依次读入编码C，建立/寻找从根开始对应于该编码的一条路径，过程如下:\n  >\n  > 对每个编码，从左至右扫描C的各位，根据C的当前位(0或1)沿结点的指针(左子指针或右子指针)向下移动。当遇到空指针时，创建新结点，让空指针指向该新结点并继续移动。沿着指针移动的过程中，可能遇到三种情况:\n  >\n  > ①若遇到了叶结点(非根)，则表明不具有前缀特性，返回。\n  >\n  > ②若在处理C的所有位的过程中，均没有创建新结点，则表明不具有前缀特性，返回。\n  >\n  > ③若在处理C的最后一个编码位时创建了新结点，则继续验证下一个编码。\n  >\n  > 若所有编码均通过验证，则编码具有前缀特性。\n","tags":["408数据结构"],"categories":["408数据结构"]},{"title":"第五章 树与二叉树(中)","url":"/p/48066/","content":"\n## 5.3 二叉树的遍历和线索二叉树\n\n### 二叉树的遍历\n\n**遍历**：按照某种次序把所有结点都访问一遍\n\n对于一个线性结构，如a1 a2 a3 a4 a5\n\n对其进行遍历，是很简单的，我们可以从前往后依次遍历，也可以从后往前。\n\n但是对于树形结构，我们的遍历规则就会更复杂一些。\n\n由于树这种结构呈现出了一层一层的效果，因此不难想到我们可以一层一层地访问这些结点。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-34.png\" style=\"zoom:80%;\" />\n\n这种方法叫做**层次遍历**，即基于树的层次特性确定的次序规则。\n\n而我们此节主要说的**先/中/后序遍历**是基于树的递归特性确定的次序规则。\n\n**二叉树的递归特性**：\n\n1. 要么是个空二叉树\n2. 要么就是由 “根节点 + 左子树 + 右子树” 组成的二叉树\n3. **先序遍历：根左右**\n4. **中序遍历：左根右**\n5. **后序遍历：左右根**\n\n------\n\n我们先来看一个简单的例子：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-35.png\" style=\"zoom:80%;\" />\n\n上述是最简单的二叉树遍历，我们再来看一个:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-36.png\" style=\"zoom: 80%;\" />\n\n#### 先序遍历 PreOrder\n\n先序遍历的操作过程如下：\n\n1. 若二叉树为空，则什么也不做\n2. 若二叉树非空\n   1. 访问根节点\n   2. 先序遍历左子树\n   3. 先序遍历右子树\n\n<font color='orange'>先序遍历——第一次路过时访问结点</font>\n\n先序遍历的算法实现（递归）\n\n```c\nvoid PreOrder(BiTree T) {\n  if (T != NULL){         // 如果二叉树非空，则继续\n    visit(T);             // 访问根结点内容\n    PreOrder(T->lchild);  // 访问左子树内容\n    PreOrder(T->rchild);  // 访问右子树内容\n  }\n}\n```\n\n#### 中序遍历 InOrder\n\n中序遍历的操作过程如下：\n\n1. 若二叉树为空，则什么也不做\n2. 若二叉树非空\n   1. 中序遍历左子树\n   2. 访问根节点\n   3. 中序遍历右子树\n\n<font color='orange'>中序遍历——第二次路过时访问结点</font>\n\n> 这里要提两个术语:前驱节点和后继节点\n>\n> 前驱节点：对一棵二叉树进行中序遍历，遍历后的顺序，当前节点的前一个节点为该节点的前驱节点；\n>\n> 后继节点：对一棵二叉树进行中序遍历，遍历后的顺序，当前节点的后一个节点为该节点的后继节点；\n\n中序遍历的算法实现（递归）\n\n```c\n// 中序遍历\nvoid InOrder(BiTree T){\n    if(T != NULL){\n        InOrder(T -> lchild);\t\t// 递归遍历左子树\n        visit(T);\t\t\t\t\t// 访问根节点\n        InOrder(T -> rchild);\t\t// 递归遍历右子树\n    }\n}\n```\n\n#### 后续遍历 PostOrder\n\n后序遍历的操作过程如下：\n\n1. 若二叉树为空，则什么也不做\n2. 若二叉树非空:\n   1. 后序遍历左子树\n   2. 后序遍历右子树\n   3. 访问根节点\n\n<font color='orange'>后序遍历——第三次路过时访问结点</font>\n\n```c\n// 后序遍历\nVoid PostOrder(BiTree T){\n    if(T != NULL){\n        PostOrder(T->lchild);\t\t\t// 递归遍历左子树\n        PostOrder(T->rchild);\t\t\t// 递归遍历右子树\n        visit(T);\t\t\t\t\t\t// 访问根节点\n    }\n}\n```\n\n#### 手算练习\n\n```C\n// 访问一个结点:打印字符\nVoid visit(BiTNode *p){\n    printf(\"%c\",p->data);\n}\n```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-37.png\" style=\"zoom:80%;\" />\n\n<font color='orange'>这里的遍历和我们学习栈的表达式时很有关联，我们将这里的先序遍历的表达式转换为中缀表达式和后缀表达式，分别对应的就是中序遍历和后序遍历，只是中序遍历没有添加界限符</font>\n\n------\n\n> 三种遍历算法中，递归遍历左、右子树的顺序都是固定的，只是访问根结点的顺序不同。不管采用哪种遍历算法，每个结点都访问一次且仅访问一次，故时间复杂度都是O(n)。在递归遍历中，递归工作栈的栈深恰好为树的深度，所以在最坏情况下，二叉树是有n个结点且深度为n的单支树，遍历算法的空间复杂度为O(n)。\n\n#### 求树的深度(应用)\n\n对于求树的深度，我们只需要选择左子树和右子树中深度最大的子树 + 1 就是树的深度\n\n```C\n// 求树的深度\nint treeDepth(BiTree T){\n    if(T == NULL){\t\t\t\t\t\t\t\t// 树是空树\n        return 0;\t\t\t\t\t\t\t\t// 深度为0\n    }else{\n        int l = treeDepth(T->lchild);\t\t\t// 求左子树的深度\n        int r = treeDepth(T->rchild);\t\t\t// 求右子树的深度\n        // 树的深度 = Max(左子树深度,右子树深度)+1\n        return l>r ? l+1 : r+1;\n    }\n}\n```\n\n#### 递归算法和非递归算法的转换\n\nhttps://blog.csdn.net/qq_53144843/article/details/121127971\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-1.jpg\" style=\"zoom: 25%;\" />\n\n上图中，用带箭头的虚线表示了这3种遍历算法的递归执行过程。其中，向下的箭头表示更深一层的递归调用，向上的箭头表示从递归调用退出返回；虚线旁的三角形、圆形和方形内的字符分别表示在先序、中序、后序遍历的过程中访问结点时输出的信息。如图，先序序列为A B D E C、中序序列为D B E A C、后序序列为D E B C A。\n\n##### 中序遍历的非递归算法\n\n借助栈，分析中序遍历的访问过程:\n\n①**沿着根的左孩子，依次入栈，直到左孩子为空**，说明已找到可以输出的结点，此时栈内元素依次为A B D。②**栈顶元素出栈并访问:若其右孩子为空，继续执行**②；**若其右孩子不空，将右子树转执行**①。栈顶D出栈并访问，它是中序序列的第一个结点:D右孩子为空，栈顶B出栈并访问；B右孩子不空，将其右孩子E入栈，E左孩子为空，栈顶E出栈并访问；E右孩子为空，栈顶A出栈并访问；A右孩子不空，将其右孩子C入栈，C左孩子为空，栈顶C出栈并访问。由此得到中序序列D B E A C。\n\n```c\nvoid InOrder2(BiTree T, SqStack S) {\n  InitStack(S); BiTree p = T;//初始化栈S；p是遍历指针\n  while (p||!IsEmpty(S)) {   //栈不空或p不空时循环\n    if (p) {                 //一路向左\n        Push(S, p);          //当前结点入栈\n        p = p->lchild;       //左孩子不空，一直向左走\n    }\n    else {                   //出栈，并转向出栈结点的右子树\n        Pop(S,p); visit(p);  //栈顶元素出栈，访问出栈结点\n        p = p->rchild;       //向右子树走，p赋值为当前结点的右孩子\n    }                        //返回while循环继续进入if-else语句\n  }\n}\n```\n\n##### 先序遍历的非递归算法\n\n先序遍历和中序遍历的基本思想是类似的，只需把访问结点操作放在入栈操作的前面。\n\n```C\nvoid InOrder2(BiTree T, SqStack S) {\n  InitStack(S); BiTree p = T;//初始化栈S；p是遍历指针\n  while (p||!IsEmpty(S)) {   //栈不空或p不空时循环\n    if (p) {                 //一路向左\n        visit(p);Push(S,p);  //访问当前结点，并入栈\n        p = p->lchild;       //左孩子不空，一直向左走\n    }\n    else {                   //出栈，并转向出栈结点的右子树\n        Pop(S,p);            //栈顶元素出栈\n        p = p->rchild;       //向右子树走，p赋值为当前结点的右孩子\n    }                        //返回while循环继续进入if-else语句\n  }\n}\n```\n\n##### 后序遍历的非递归算法\n\n> 后序遍历的非递归实现是三种遍历算法中最难的。因为后序遍历中，要保证左孩子和右孩子都已被访问并且左孩子在右孩子前访问才能访问根结点，这就为流程的控制带来了难题。\n\n后序非递归遍历算法思想:后序非递归遍历二叉树是先访问左子树，再访问右子树，最后访问根结点。结合图来分析:①**沿着根的左孩子，依次入栈，直到左孩子为空**。此时栈内元素依次为A B D。②**读栈顶元素:若其右孩子不空且未被访问过，将右子树转执行**①；**否则，栈顶元素出栈并访问**。栈顶D的右孩子为空，出栈并访问，它是后序序列的第一个结点；栈顶B的右孩子不空且未被访问过，E入栈，栈顶E的左右孩子均为空，出栈并访问；栈顶B的右孩子不空但已被访问，B出栈并访问；栈顶A的右孩子不空且未被访问，C入栈，栈顶C的左右孩子均为空，出栈并访问；栈顶A的右孩子不空但已被访问，A出栈并访问。由此得到后序序列D E B C A。\n\n在上述思想中的第②步，**必须分清返回时是从左子树返回的还是从右子树返回的**，因此设定<font color='red'>一个辅助指针r</font>，指向最近访问过的结点。<font color='orange'>也可在结点中增加一个标志域</font>，记录是否已被访问。\n\n```C\nvoid PostOrder(BiTree T){\n    InitStack(S);\n    p=T;\n    r=NULL;\n    while(p||!IsEmpty(s)){\n        if(P){   //走到最左边\n            push(S,p);\n            p=p——>lchild；\n        }\n        else{   //向右\n            GetTop(S,p); //读栈顶结点(非出栈)\n            if(p->rchild&&p->rchild! =r)//若右子树存在，且未被访问过\n                p=p->rchild; //转向右\n            else{    //否则，弹出结点并访问\n                pop(S,p); //弹出结点\n                visit(p->data); //访问该结点\n                r=p;  //记录最近访问过的结点\n                p=NULL;  //结点访问完后，重置p指针\n            }\n        }//else\n    }//while\n}\n```\n\n> 注意:每次出栈访问完一个结点就相当于遍历完以该结点为根的子树，需将p置NULL。\n\n#### 层序遍历\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-38.png\" style=\"zoom: 80%;\" />\n\n算法思想：\n\n1. 初始化一个辅助队列\n\n2. 让根结点入队\n\n3. 若队列非空，则队头结点出队，访问该结点，并将其左、右孩子插入队尾(如果有的话)\n\n   - 例如 A 结点在队头，让 A 出队，并将其左、右孩子 B、C 插入队\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-39.png\" style=\"zoom:80%;\" />\n\n4. 重复 3 直至队列为空\n\n   - B 此时为队头元素，B 出队，将 B 的左右孩子 D、E 插入队尾\n   - C 此时为队头元素，C 出队，将 C 的左右孩子 F、G 插入队尾\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-40.png\" style=\"zoom:80%;\" />\n\n```c\n// 层序遍历\nvoid LevelOrder(BiTree T){\n    LinkQueue Q;\t\t\t\t// 链队列\n    InitQueue(Q);\t\t\t\t// 初始化辅助队列\n    BiTree p;\t\t\t\t\t\n    EnQueue(Q,T);\t\t\t\t// 将根结点入队\n    while(!IsEmpty(Q)){\t\t\t// 队列不为空则循环\n        DeQueue(Q,p);\t\t\t// 队头结点出队\n        visit(p);\t\t\t\t// 访问出队结点\n        if(p->lchild != NULL){\n            EnQueue(Q,p->lchild);// 左孩子入队\n        }\n        if(p->rchild != NULL){\n            EnQueue(Q,p->rchild);// 右孩子入队\n        }\n    }\n    \n}\n```\n\n> 这里使用的是链队列，因为我们无法估计一棵树到底有多少个结点，使用链队列方便我们对空间进行扩展。\n>\n> 对于链队列的初始化、入队出队等操作，之前讲过就不再重复了。\n\n### 由遍历序列构造二叉树\n\n> 给定一棵二叉树，它的中序遍历序列是唯一的。\n>\n> 但是给定一个中序遍历序列，我们不能确切的说，它对应的是哪棵树。同一个中序遍历序列可能对应多种二叉树形态。\n>\n> 前序遍历、后序遍历、层序遍历同理。\n>\n> 因此，若只给出某一种遍历序列，就让逆推出二叉树，是不可能的。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-41.png\" style=\"zoom:67%;\" />\n\n<font color='cornflowerblue'>结论：一个中序/前序/后序/层次遍历序列可能对应多种二叉树形态，若只给出一棵二叉树的 前/中/后/层 序遍历序列中的一种，不能唯一确定一棵二叉树</font>\n\n<font color='orange'>怎样可以唯一确定一棵二叉树呢？</font>\n\n若要由二叉树的遍历序列构造二叉树，则\n\n- 前序 + 中序 遍历序列\n- 后序 + 中序 遍历序列\n- 层序 + 中序 遍历序列\n\n<font color=\"red\">注意：前序、后序、层序序列的两两组合无法唯一确定一棵二叉树，一定要有中序遍历序列，才能推出二叉树</font>\n\n#### 前序+中序遍历序列\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-42.png\" style=\"zoom:80%;\" />\n\n我们来看一个例子：\n\n- 已知前序遍历序列为：A D B C E\n- 已知中序遍历序列为：B D C A E\n\n由中序遍历序列首先推出根节点为 A ，(B D C) 均为左子树，E 为右子树。如下图\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-43.png\" style=\"zoom:50%;\" />\n\n由前序遍历序列推出左子树的根节点为 D，则由中序序列推出结点 D 的左子树为 B，右子树为 C\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-176.png\"  />\n\n------\n\n再来看一个复杂一点的例子\n\n- 已知前序遍历序列为：D A E F B C H G I\n- 已知中序遍历序列为：E A F D H C B G I\n\n由前序遍历序列推出 D 为根结点，则由中序遍历序列可知 D 的左子树为 (D A F)，右子树为(H C B G I)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-45.png\" style=\"zoom:50%;\" />\n\n根据前序遍历序列 A 为左子树的根节点，根据中序遍历序列 A 的左子树为 E，右子树则为 F\n\n根据前序遍历序列 B 为右子树的根节点，根据中序遍历序列 B 的左子树为(H C)，右子树为(GI)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-46.png\" style=\"zoom:50%;\" />\n\n根据前序遍历序列 C 为 根，根据中序遍历序列 C 的左子树为 H\n\n根据前序遍历序列 G 为根，根据中序遍历序列 G 的右子树为 I\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-47.png\" style=\"zoom:50%;\" />\n\n#### 后续+中序遍历序列\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-48.png\" style=\"zoom: 80%;\" />\n\n我们来看一个例子：\n\n- 已知后序遍历序列：E F A H C I G B D (左 右 根)\n- 已知中序遍历序列：E A F D H C B G I (左 根 右)\n\n根据后序遍历序列 D 为根节点，根据中序遍历序列 ，(E A F) 为左子树，(H C B G I) 为右子树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-49.png\" style=\"zoom: 50%;\" />\n\n根据后序遍历序列 A 为左子树的根节点，根据中序遍历序列 E 为 A 结点的左子树，F为右子树\n\n根据后序遍历序列 B 为右子树的根节点，根据中序遍历序列 (H C) 为左子树，(G I)为右子树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-50.png\" style=\"zoom:50%;\" />\n\n根据后序遍历序列 C 为根，G 为根。根据中序遍历序列 H 为左子树，I 为右子树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-51.png\" style=\"zoom:50%;\" />\n\n#### 层序+中序遍历序列\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-52.png\" style=\"zoom: 80%;\" />\n\n我们来看一个简单的例子：\n\n- 已知层序遍历序列：A B C D E (根 左子树的根 右子树的根)\n- 已知中序遍历序列：A C B E D (左 根 右)\n\n根据层序遍历序列，首先访问第一层，根为 A。格局中序遍历序列，A 的左边没有元素，则 A 的左子树为空1\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-53.png\" style=\"zoom: 50%;\" />\n\n根据层序遍历序列，访问第二层，首先出现的是 B，则 B 是右子树的根节点。根据中序遍历序列，C 为 B 的左子树，(E D) 为 B 的右子树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-54.png\" style=\"zoom:50%;\" />\n\n根据层序遍历，访问第三层，首先出现的是 C、D，则 D 为根，根据中序遍历，E 为 D 的左子树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-55.png\" style=\"zoom:50%;\" />\n\n------\n\n我们来看一个例子：\n\n- 已知层序遍历序列：D A B E F C G H I (根 左子树的根 右子树的根)\n- 已知中序遍历序列：E A F D H C B G I (左 根 右)\n\n根据层序遍历序列，访问第一层，D 为根结点，根据中序遍历序列，(E A F)为左子树，(H C B G I)为右子树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-56.png\" style=\"zoom:50%;\" />\n\n根据层序遍历序列，访问第二层，首先出现的是A、B，则A 为左子树的根节点，B 为右子树的根节点。根据中序遍历，E 为 A 的左子树，F为 A 的右子树。 (H C )为 B 的左子树，(G I) 为 B 的右子树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-57.png\" style=\"zoom:50%;\" />\n\n根据层序遍历序列，访问第三层，首先出现的是 E、F、C、G，则 根节点分别为 C、G\n\n根据中序遍历，C 的左子树为 H，G 的右子树为 \n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-58.png\" style=\"zoom:50%;\" />\n\n### 线索二叉树\n\n#### 线索二叉树的作用\n\n普通二叉树有如下两个**问题**：\n\n- 普通二叉树遍历只能从根节点开始遍历，不能从一个指定结点开始中序遍历。\n- 普通二叉树中如果只知道指向当前结点的指针，没法找到当前结点在中序遍历序列的前驱。(例如下图中只知道指向 F 结点的指针 p，如何找到结点在中序遍历序列的前驱呢？)\n\n那么我们如何解决上述问题呢？\n\n<font color='red'>思路</font>：\n\n- 从根结点出发，重新进行一次中序遍历，指针 q 记录当前访问的结点，指针 pre 记录上一个被访问的结点(前驱)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-59.png\" style=\"zoom: 80%;\" />\n\n- 下一个结点被访问(visit)之前，我们需要将 pre 前驱指针指向 q 所指向的结点，然后 q 指针指向下一个要访问的结点\n\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-60.png\" style=\"zoom: 33%;\" />\n\n- 所以现在 pre 指针所指向的结点就是 q 指针所指向结点的中序遍历的前驱。用这样的思路我们可以让 q 不断的指向后一个被访问的结点，然后 pre 也跟着依次的向后移动。\n\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-61.png\" style=\"zoom: 33%;\" />\n\n- 当 q 和 p 指向了同一个结点，也就是 q == p，那么就说明 pre 所指向的结点就是 p 所指向结点的前驱\n\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-62.png\" style=\"zoom: 33%;\" />\n\n- 继续 pre 向后移， q 也向后移。此时 pre == p，则 q 所指向的结点就是 p 所指向结点的后继\n\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-63.png\" style=\"zoom: 33%;\" />\n\n<font color='orange'>上述的操作是非常不方便的，线索二叉树就是为了解决上述问题的。</font>\n\n**n 个结点的二叉树，有 n + 1 个空链域。我们可以利用这些空链域来记录前驱、后继的信息。**\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-215.png\" style=\"zoom:55%;\" />\n\n- 如上图，D 的左子树是空链域，因为 D 没有前驱结点，是第一个结点，所以让其左子树指向NULL\n- G 的左右子树都是空链域，让左子树指向其前驱结点 D，让右子树指向其后继结点 B\n- E 的左右子树都是空链域，让左子树指向其前驱结点 B，让右子树指向其后继结点 A\n- F 的左右子树都是空链域，让左子树指向其前驱结点 A，让右子树指向其后继结点 C\n- C 的右子树是空链域，因为 C 没有后继结点，是最后一个结点，所以让其右子树指向 NULL\n\n**定义**：一个结点的左孩子指针和右孩子指针指向的是前驱和后继而不是其左右孩子的话，我们把这种类型的指针称为线索，指向前驱的是前驱线索，指向后继的是后继线索。\n\n<font color='cornflowerblue'>那么还存在一个问题，如果我们的右孩子指针指向的就是右孩子而不是后继，那么如何找后继呢？</font>\n\n#### 线索二叉树的存储结构\n\n**普通二叉树**的链式存储结点:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-65.png\" style=\"zoom: 67%;\" />\n\n```C\n// 二叉树的结点(链式存储)\ntypedef struct BiTNode {\n    ElemType data;\n    struct BiTNode *lchild,*rchild;\n}BiTNode,*BiTree;\n```\n\n**线索二叉树**的链式存储结点:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-66.png\" style=\"zoom: 67%;\" />\n\n```C\n// 线索二叉树的结点\ntypedef struct ThreadNode{\n    ElemType data;\n    struct ThreadNode *lchild,*rchild;\n    int ltag,rtag;\t\t\t\t\t\t// 左、右线索标志\n}ThreadNode,*ThreadTree;\n```\n\n##### 中序线索二叉树的存储\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-216.png\" style=\"zoom: 55%;\" />\n\n以上是中序线索二叉树。而对于先序、后序线索二叉树来说，只不过是遍历序列的顺序变了，**利用左孩子指针充当前驱线索、右孩子指针充当后继线索**的思想是一样的。\n\n> 总之，线索二叉树的思想就是利用n个结点的二叉树的n+1个空链域，把这些空链域变成**线索**，指向前驱、后继。\n>\n> 而先序/中序/后续线索二叉树的区别，仅仅是遍历出来的序列是什么的区别。\n>\n> 一些术语：\n>\n> 先/中/后序前驱、先/中/后序后继——先/中/后序线索二叉树中的**线索**\n\n#### 先序线索二叉树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-68.png\" style=\"zoom:80%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-69.png\" style=\"zoom: 67%;\" />\n\n#### 后序线索二叉树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-217.png\" style=\"zoom:55%;\" />\n\n#### 三种线索二叉树的对比\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-218.png\" style=\"zoom:55%;\" />\n\n- 中序线索二叉树 ➡ 线索指向中序前驱、中序后继\n- 先序线索二叉树 ➡ 线索指向先序前驱、先序后继\n- 后序线索二叉树 ➡ 线索指向后序前驱、后序后继\n\n### 二叉树的线索化\n\n#### 中序线索化\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-72.png\" style=\"zoom: 50%;\" />\n\n中序遍历二叉树，<font color='orange'>一边遍历一边线索化</font>\n\n- 首先中序遍历左子树，首先访问到的是 D 结点，D 结点没有前驱，所以将 pre 指针指向NULL，并将标志修改为 1 (代表这个孩子指针是线索)\n\n- 之后访问下一个结点，pre 指向 q 指向的结点，q 指向下一个结点\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-73.png\" style=\"zoom:50%;\" />\n\n- 此时 q 指向的结点为 G，判断左子树，如果为空，则建立前驱线索并修改标志为 1 ，判断其右子树，如果为空，则建立后继线索并修改标志为 1\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-74.png\" style=\"zoom:50%;\" />\n\n- 当访问最后一个结点时，pre 和 q 均指向最后一个结点，要检查 pre-> rchild 是否为 NULL，如果是，则令标志为 1\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-75.png\" style=\"zoom:50%;\" />\n\n  ```C\n  // 线索二叉树的结点\n  typedef struct ThreadNode{\n      ElemType data;\n      struct ThreadNode *lchild,*rchild;\n      int ltag,rtag;\t\t\t\t\t\t// 左、右线索标志\n  }ThreadNode,*ThreadTree;\n  \n  // 中序遍历二叉树,一边遍历一边线索化\n  void InThread(ThreadTree T){\n      if(T != NULL){\n          InThread(T->lchild);\t\t// 中序遍历左子树\n          visit(T);\t\t\t\t\t// 访问根节点\n          InThread(T->rchild);\t\t// 中序遍历右子树\n      }\n  }\n  \n  // 全局变量 pre,指向当前访问结点的前驱(开始访问第一个结点,无前驱,所以指向NULL)\n  ThreadNode *pre = NULL;\n  \n  void visit(ThreadNode *q){\n      if(q->lchild == NULL){\t\t\t// 如果左子树为空,则建立前驱线索\n          q->lchild = pre;\n          q->ltag = 1;\n      }\n      if(pre != NULL && pre->rchild == NULL){\n          pre->rchild = q;\t\t\t// 建立前驱结点的后继线索\n          pre->rtag = 1;\n      }\n      pre = q;\n  }\n  \n  // 中序线索化二叉树T\n  void CreateInThread(ThreadTree T){\n      pre=NULL;\t\t\t\t\t\t// pre初始为NULL\n      if(T != NULL){\t\t\t\t\t// 非空二叉树才能线索化\n          InThread(T);\t\t\t\t// 中序线索化二叉树\n          if(pre->rchild == NULL){\n              pre->rtag=1;\t\t\t// 处理遍历的最后一个结点\n          }\n      }\n  }\n  ```\n\n#### 先序线索化\n\n先序遍历二叉树，<font color='orange'>一边遍历一边线索化</font>\n\n- 首先访问根结点，判断左右子树，发现左右子树都非空，则不操作，让 pre 指向 q所指向的结点，q指向下一结点\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-76.png\" style=\"zoom:50%;\" />\n\n- 访问结点 B，发现 B 的左右子树都非空，则不操作，让 pre 指向 q所指向的结点，q指向下一结点\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-77.png\" style=\"zoom:50%;\" />\n\n- 之后访问 D 结点，发现其左子树为空，则建立前驱线索(将其左子树指向前驱结点B)，之后我们就要先序遍历 D结点的左子树，但是发现此时左子树为 B，这样下去就会造成循环。所以我们在先序遍历二叉树时，要让左子树不是前驱线索时再进行\n\n  ```C\n  // 先序遍历二叉树,一边遍历一边线索化\n  void PreThread(ThreadTree T){\n      if(T != NULL){\n          visit(T);\t\t\t\t// 先处理根结点\n          if(T->ltag == 0){\t\t// lchild不是前驱线索\n              PreThread(T->lchild);\n          }\n          PreThread(T->rchild);\t// 先序遍历右子树\n      }\n  }\n  \n  // 全局变量 pre,指向当前访问结点的前驱\n  ThreadNode *pre = NULL;\n  void visit(ThreadNode *q){\n      if(q->lchild == NULL){\t\t\t// 如果左子树为空,则建立前驱线索\n          q->lchild = pre;\n          q->ltag = 1;\n      }\n      if(pre != NULL && pre->rchild == NULL){\n          pre->rchild = q;\t\t\t// 建立前驱结点的后继线索\n          pre->rtag = 1;\n      }\n      pre = q;\n  }\n  \n  // 先序线索化二叉树T\n  void CreateInThread(ThreadTree T){\n      pre=NULL;\t\t\t\t\t\t// pre初始为NULL\n      if(T != NULL){\t\t\t\t\t// 非空二叉树才能线索化\n          InThread(T);\t\t\t\t// 中序线索化二叉树\n          if(pre->rchild == NULL){\n              pre->rtag=1;\t\t\t// 处理遍历的最后一个结点\n          }\n      }\n  }\n  ```\n\n#### 后序线索化\n\n```C\n// 线索二叉树的结点\ntypedef struct ThreadNode{\n    ElemType data;\n    struct ThreadNode *lchild,*rchild;\n    int ltag,rtag;\t\t\t\t\t\t// 左、右线索标志\n}ThreadNode,*ThreadTree;\n\n// 后序遍历二叉树,一边遍历一边线索化\nvoid PostThread(ThreadTree T){\n    if(T != NULL){\n        PostThread(T->lchild);\t\t// 中序遍历左子树\n        PostThread(T->rchild);\t\t// 中序遍历右子树\n        visit(T);\t\t\t\t\t// 访问根节点\n        \n    }\n}\n\n// 全局变量 pre,指向当前访问结点的前驱(开始访问第一个结点,无前驱,所以指向NULL)\nThreadNode *pre = NULL;\n\nvoid visit(ThreadNode *q){\n    if(q->lchild == NULL){\t\t\t// 如果左子树为空,则建立前驱线索\n        q->lchild = pre;\n        q->ltag = 1;\n    }\n    if(pre != NULL && pre->rchild == NULL){\n        pre->rchild = q;\t\t\t// 建立前驱结点的后继线索\n        pre->rtag = 1;\n    }\n    pre = q;\n}\n\n// 后序线索化二叉树T\nvoid CreateInThread(ThreadTree T){\n    pre=NULL;\t\t\t\t\t\t// pre初始为NULL\n    if(T != NULL){\t\t\t\t\t// 非空二叉树才能线索化\n        InThread(T);\t\t\t\t// 中序线索化二叉树\n        if(pre->rchild == NULL){\n            pre->rtag=1;\t\t\t// 处理遍历的最后一个结点\n        }\n    }\n}\n```\n\n#### 总结\n\n![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-78.png)\n\n### 线索二叉树找前驱/后继\n\n#### 中序线索二叉树找中序后继\n\n例如：我们要在中序线索二叉树中找到指定结点 *p 的中序后继 next，next = p的右子树中最左下结点\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-219.png\" style=\"zoom:55%;\" />\n\n- 若 p -> rtag == 1, 说明右子树被线索化，那么右子树就是其中序后继，则 next = p -> rchild\n- 若 p-> rtag == 0,说明右子树未被线索化，右子树肯定是非空，则 p 必然有右孩子。\n\n> 由于我们是找中序后继，也就是从中序遍历来看，在访问这个结点后，访问的下一个结点是什么。而中序遍历的访问顺序是：左、根、右。所以按照中序遍历的规则，访问p结点这个根结点之后，需要再中序遍历p的右子树。那么，在p的右子树中第一个被访问的结点，就应该是p的后继。\n>\n> 假设p的右子树只有一个右孩子，也就是只有一个叶子结点，那么显然这个右孩子就是p的后继。\n>\n> 但是如果这个结点是一个分支节点，也就是再往下还有更深层的结点的话，那么要对这个右子树继续进行中序遍历（左、根、右）这样来看的话，那么这个右子树的最左下角的那个结点就应该是p的中序后继结点。\n\n```C\n// 找到以 P 为根的子树中,第一个被中序遍历的结点\nThreadNode *Firstnode(ThreadNode *p){\n    // 循环找到最左下结点(不一定是叶结点)\n    while(p->ltag == 0){\n        p = p->lchild;\n    }\n    return p;\n}\n\n// 在中序线索二叉树中找到结点 p 的后继结点\nThreadNode *Nextnode(ThreadNode *p){\n    // 右子树最左下结点(右子树当中第一个被遍历到的结点)\n    if(p->rtag == 0){\n        return Firstnode(p->rchild);\n    }else{\n        return p->rchild;\t\t// rtag == 1 直接返回后继线索\n    }\n}\n```\n\n既然我们能遍历到结点的后继结点，那么我们就可以对中序线索二叉树进行遍历\n\n```C\n// 对中序线索二叉树进行中序遍历(利用线索实现的非递归算法) \n// 传入我们要遍历的树的根节点的指针T\nvoid Inorder(ThreadNode *T){\n    for(ThreadNode *p = Firstnode(T);p != NULL;p=Nextnode(p)){\n        visit(p);\n    }\n}\n```\n\n#### 中序线索二叉树找中序前驱\n\n例如：我们要在中序线索二叉树中找到指定结点 *p 的中序前驱pre，pre= p的左子树中最右下结点\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-220.png\" style=\"zoom:55%;\" />\n\n- 若 p -> ltag == 1, 说明左子树被线索化，那么左子树就是其中序后继，则 pre = p -> lchild\n- 若 p-> ltag == 0,说明左子树未被线索化，那么左子树肯定非空，则 p 必然有左孩子。\n\n> 按照中序遍历的规则，（左、根、右），它的这个结点的前驱一定是它的左子树当中，按照中序遍历最后一个被访问的结点。\n>\n> 如果左子树只有一个叶子结点，那么显然它的这个左孩子就是它的中序前驱。\n>\n> 而如果左子树还有多层分级的话，总之，其左子树最右下的结点就是左子树当中最后一个被访问的结点。\n\n```C\n// 找到以p为根的子树中,最后一个被中序遍历的结点\nThreadNode *Lastnode(ThreadNode *p){\n    // 循环找到最右下结点(不一定是叶节点)\n    while(p->rtag == 0){\n        p = p->rchild;\n        return p;\n    }\n}\n\n// 在中序线索二叉树中找到结点p的前驱结点\nThreadNode *Prenode(ThreadNode *p){\n    // 左子树中最右下结点\n    if(p->ltag == 0){\n        return Lastnode(p->lchild);\n    }else{\n        return p->lchild;\t\t\t//ltag==1 直接返回前驱结点\n    }\n}\n```\n\n既然我们能遍历到结点的前驱结点，那么我们就可以对中序线索二叉树进行逆向中序遍历\n\n```C\n// 对中序线索二叉树进行逆向中序遍历\nvoid RevInorder(ThreadNode *T){\n    for(ThreadNode *p = Lstnode(T);p != NULL;p = Prenode(p){\n        visit(p);\n    })\n}\n```\n\n#### 先序线索二叉树找先序后继\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-221.png\" style=\"zoom:55%;\" />\n\n- 若 p -> rtag == 1, 说明右子树被线索化，那么右子树就是其先序后继，则 next= p -> rchild\n- 若 p-> rtag == 0,说明右子树未被线索化，那么右子树肯定非空，则 p 必然有右孩子。\n\n> 我们先假设它有左孩子。\n>\n> 然后按照先序遍历（根、左、右）的规则来看，p结点的后继结点肯定是它左子树当中第一个被访问的结点。也就是不论其左子树有多少层级，都是p的那一个左孩子结点。\n>\n> 再说，如果没有左孩子。\n>\n> 如果没有左孩子的话，根据根、左、右的原则，由于左为空，那么就是根、右。那么也就是它的右子树当中第一个被先序遍历的结点。也就是，无论它的右子树是叶子结点，还是多个层级的分支节点，都是p的右孩子结点。\n\n#### 先序线索二叉树找先序前驱\n\n在先序线索二叉树中找到指定结点p的**先序前驱**pre。\n\n- 若p->ltag == 1，则next = p->lchild。\n- 若p->ltag == 0，（说明p一定有左孩子）。\n\n> 按照先序遍历的规则（根、左、右）可知，p的左子树、右子树，都只可能是p的后继，而不可能是p的前驱。因此，我们不可能在它的左右子树当中，找到它的前驱。\n>\n> 而我们的线索二叉树，它只有指向它的孩子结点的指针，不可能往上找。\n>\n> 所以在这种情况下，我们是找不到p的先序前驱的。\n>\n> 除非，用从头遍历的土办法，来重新进行一次完整的先序遍历来找到p的前驱。\n\n> 但是我们说过，二叉链表其实我们可以在某些应用场景下，根据需要，把它改为三叉链表，即增加一个指向其父节点的指针。\n>\n> 那么在这种能找到它的父节点的情况下，我们再看，能不能找到它的先序前驱。\n>\n> 第一种情况：**能找到p的父节点，且p是左孩子**\n>\n> 按照先序遍历的规则（根、左、右）来看，p结点一定是在它的父节点被访问过之后，第一个被访问到的。因此**p的父节点一定是p的先序前驱**。\n>\n> 第二种情况：**能找到p的父节点，且p是右孩子，其左兄弟为空**\n>\n> 也就是p的父节点的左孩子为空。那么按照先序遍历的规则就应该是：根、右。因此，**p的父节点一定是它的先序前驱**。\n>\n> 第三种情况：**能找到p的父节点，且p是右孩子，其左兄弟非空**\n>\n> 按照先序遍历的规则（根、左、右），p这个结点的先序前驱，一定是它的左兄弟子树，按照先序遍历的顺序**最后一个被访问到的结点，也就是最右下的结点**。即**p的先序前驱为其左兄弟子树中最后一个被先序遍历访问的结点**。\n>\n> 第四种情况：**如果p没有父节点，也就是p是根结点，则p没有先序前驱**。\n\n#### 后序线索二叉树找后序前驱\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-163.png\" style=\"zoom: 50%;\" />\n\n在后序线索二叉树中找到指定结点p的**后续前驱**pre。\n\n- 若p->ltag == 1，则pre = p->lchild。\n- 若p->ltag == 0（说明它一定有左孩子，但是不一定有没有右孩子）\n\n> 先讨论假设它有右孩子的情况：\n>\n> 按照后序遍历的规则（左、右、根），可以看到，p的后序前驱，是p的右子树中，按照后序遍历的规则被访问到的最后一个结点，也就是右孩子结点本身。因此，**若p有右孩子，则后序前驱为其右孩子**。\n>\n> 假设它没有右孩子：\n>\n> 按照后序遍历的规则（左、根），可以看到，p的后序前驱，是p的左子树中，按照后序遍历的规则被访问到的最后一个结点，也就是左孩子本身。因此，**若p没有右孩子，则后序前驱为其左孩子**。\n\n#### 后序线索二叉树找后序后继\n\n在后序线索二叉树中找指定结点p的**后序后继**next。\n\n- 若p->rtag == 1，则next = p->rchild。\n- 若p->rtag == 0，（说明其一定有右孩子）\n\n> 按照后序遍历的规则（左、右、根）来看，p的左右子树均只有可能是它的前驱，而不可能是它的后继。\n>\n> 因此，后序遍历中，左右子树中的结点只可能是p的前驱，不可能是后继。\n>\n> 因此我们只能利用土办法，即从头到尾重新进行一次完整的后序遍历，才有可能找到它的后序后继。\n\n> 但是，还可以改用三叉链表找到父节点的方式来完成。\n>\n> 第一种情况，**能找到p的父节点，且p是右孩子**：\n>\n> 按照后序遍历的规则（左、右、根），无论p结点下面还有没有孩子，p结点一定是最后一个被访问的结点。而在访问过p结点之后，下一个一定紧接着是访问它的父节点。因此，**p的后序后继为p的父节点**。\n>\n> 第二种情况，**能找到p的父节点，且p是左孩子，其右兄弟为空**：\n>\n> 按照后序遍历的规则（左、根）。显然，无论如何，在访问完p结点之后，一定会紧接着访问它的父节点。因此，**p的后序后继为p的父节点**。\n>\n> 第三种情况，**能找到p的父节点，且p是左孩子，其右兄弟非空**：\n>\n> 按照后序遍历的规则（左、右、根）来看，p的后继，就应该是它的右兄弟子树当中，按照后序遍历第一个被访问的结点，也就是右兄弟子树最左下的结点。因此，**p的后序后继为右兄弟子树中第一个被后序遍历到的结点**。\n>\n> 第四种情况，**如果p是根结点，则p没有后序后继**。\n\n#### 总结\n\n对以上所有情况的讨论，我们只需要理解其逻辑过程，而不要去背结论\n\n|        | 中序线索二叉树 | 先序线索二叉树 | 后序线索二叉树 |\n| ------ | -------------- | -------------- | -------------- |\n| 找前驱 | ✔              | ×              | ✔              |\n| 找后继 | ✔              | ✔              | ×              |\n\n对先序线索二叉树来说，找先序前驱是不可以的；同样地，对于后续线索二叉树来说，找后序后继是不可以的。除非采用**三叉链表**，或者用**土办法**从整棵树的根结点重新进行完整的遍历来寻找其**父节点**。\n\n也就是，对于先序线索二叉树来说，给你一个结点，你只能从这个结点开始向后进行先序遍历。\n\n对于后续线索二叉树来说，给你一个结点，你只能从这个结点开始进行逆向的后序遍历。\n\n### 习题\n\n- 在二叉树中有两个结点 m 和 n，若 m 是 n 的祖先，则使用什么遍历方法可以找到 m 到 n 的路径 → 后序遍历\n\n- 在二叉树的前序序列、中序序列和后序序列中，所有叶子结点的先后顺序相同吗？若不全相同，则哪几种遍历方式的先后顺序相同 → 完全相同\n\n- 【2009】给定二叉树如右图所示。设N代表二叉树的根，L代表根结点的左子树，R代表根结点的右子树。若遍历后的结点序列是(3, 1, 7, 5, 6, 2, 4)，则其遍历方式是-->RNL\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-82.png\" style=\"zoom:85%;\" />\n\n  > 分析遍历后的结点序列，可以看出根结点是在中间访问，而右子树结点在左子树之前，即遍历的方式是 RNL 。本题考查的遍历方法并不是二叉树的 3 种基本遍历方法，对于考生而言，重要的是要掌握遍历的思想。\n  >\n  > - 前序遍历：根结点 -> 左子树 -> 右子树\n  > - 中序遍历：左子树 -> 根结点 -> 右子树\n  > - 后序遍历：左子树 -> 右子树 -> 根结点\n\n- 【2011】若一棵二叉树的前序遍历序列和后序遍历序列分别为{ 1, 2, 3, 4}和{4, 3, 2, 1}，则该二叉树的中序遍历序列不会是→C\n\n  A. 1234   B. 2341\n  C. 3241   D. 4321\n\n  > 前序序列为NLR，后序序列的逆序为LRN，要使NLR=NRL（后序序列的反序），则L或R为空，这样的二叉树每层就只有一个结点，高度为4。1为根结点，由于根结点只有左孩子或右孩子，因此在中序序列中，1或在序列首或在序列尾，ABCD皆满足。仅考虑以1的孩子结点2为根的子树，同理在中序序列中，2或在序列首或在序列尾，ABD皆满足，C不满足。\n\n- 【2012】若一棵二叉树的前序遍历序列为{ a, e, b, d, c}，后序遍历序列为{ b, c, d, e, a}，则根结点的孩子结点 → 只有 e\n\n  > 由先序遍历第一个结点为a,则可知道树的根节点为a。后序遍历序列中根节点会把序列分为左右两段，左段为左子树上结点，右段为右子树上结点，所以由后序遍历序列可知b,c,d,e均为a结点的左子树上的点，a不存在右子树。再由先序遍历序列知道e为根结点a的左孩子结点。即根节点的孩子结点只有e，且为左孩子。\n\n- 【2013】若X是后序线索二叉树中的叶结点，且X存在左兄弟结点Y，则X的右线索指向的是-->A\n\n  A. X的父结点\n  B. 以Y为根的子树的最左下结点\n  C. X的左兄弟结点Y\n  D. 以Y为根的子树的最右下结点\n\n  > 根据题意，x存在左兄弟结点y,说明x是右边的那个结点\n  >\n  > 由于是后序线索二叉树，后序遍历的规则是DLR，X的后继就是其双亲结点\n  >\n  > 因此右线索指向的是：X的父结点\n\n- 【2014】若对下图所示的二叉树进行中序线索化，则结点X的左、右线索指向的结点分别是-->b，a\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-84.png\" style=\"zoom: 80%;\" />\n\n  > 中序线索化即根据中序遍历的顺序，找出该字母的前驱和后继。中序遍历结果为debxac。x的前驱是b，后继是a。所以结点x的左、右线索指向的结点分别是b，a。\n\n- 【2015】先序序列为a,b,c,d的不同二叉树的个数是-->14\n\n  > 根据二叉树前序遍历和中序遍历的递归算法中递归工作栈的状态变化得出：前序序列和中序序列的关系相当于以前序序列为入栈次序，以中序序列为出栈次序。因为前序序列和中序序列可以唯一地确定一棵二叉树，所以题意相当于“以序列 a,b,c,d 为入栈次序，则出栈序列的个数为？”，对于 n 个不同元素进栈，出栈序列的个数为14\n\n- 【2017】某二叉树的树形如图所示，其后序序列为e,a,c,b,d,g,f，树中与结点a同层的结点是-->d\n\n  ![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-85.png)\n\n  > 后序序列是先左子树，接着右子树，最后父结点，递归进行。根结点左子树的叶结点首先被访问，它是e。接下来是它的父结点a,然后是a的父结点c。接着访问根结点的右子树。它的叶结点b首先被访问，然后是b的父结点d，再后是d的父结点g,最后是根结点f,如右图所示。因此d与a同层。\n\n- 【2017】要使一棵非空二叉树的先序序列与中序序列相同，其所有非叶结点须满足的条件是-->B\n\n  A. 只有左子树\n  B. 只有右子树\n  C. 结点的度均为1\n  D. 结点的度均为2\n\n  > 先序序列是先父结点，接着左子树，然后右子树。中序序列是先左子树，接着父结点，然后右子树，递归进行。如果所有非叶结点只有右子树，先序序列和中序序列都是先父结点，然后右子树，递归进行，因此B正确。\n\n- 线索二叉树是一种什么结构？「逻辑、逻辑和存储、物理、线性」?→ 物理\n\n- 一棵左子树为空的二叉树在先序线索化后，其中空的链域的个数是 →2 个\n\n- 【2010】下列线索二叉树中(用虚线表示线索)，符合后序线索树定义的是-->D\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-83.png\" style=\"zoom:67%;\" />\n\n  > 题中所给二叉树的后序序列为dbca。结点d无前驱和左子树，左链域空，无右子树，右链域指向其后继结点b；结点b无左子树，左链域指向其前驱结点d；结点c无左子树，左链域指向其前驱结点b，无右子树，右链域指向其后继结点a。\n\n- 二叉树在线索化后，仍不能有效求解的问题是？→D\n\n  A 先序线索二叉树中求先序后继\n  B 中序线索二叉树中求中序后继\n  C 中序线索二叉树中求中序前驱\n  D 后序线索二叉树中求后序后继 \n\n- （ ）的遍历仍需要栈的支持→C\n\n  A 前序线索树\n  B 中序线索树\n  C 后序线索树\n  D 所有线索树 \n\n- 综合【2014】二叉树的带权路径长度(WPL)是二叉树中所有叶结点的带权路径长度之和。给定一棵二叉树T，采用二叉链表存储，结点结构为\n\n  | left | weight | right |\n  | ---- | ------ | ----- |\n\n  其中叶节点的weight域保存该结点的非负权值。设root为指向T的根节点的指针，设计求T的WPL的算法。要求：\n\n  （1）给出算法的基本设计思想；\n\n  （2）使用C或C++语言，给出二叉树结点的数据类型定义；\n\n  （3）根据设计思想，采用C或C++语言描述算法，关键之处给出注释。\n\n  > (1)算法的基本设计思想： \n  >\n  > ① 基于先序递归遍历的算法思想是用一个static变量记录wpl，把每个结点的深度作为递归函数的一个参数传递，算法步骤如下： \n  >\n  > 若该结点是叶子结点，那么变量wpl加上该结点的深度与权值之积； \n  >\n  > 若该结点非叶子结点，那么若左子树不为空，对左子树调用递归算法，若右子树不为空，对右子树调用递归算法，深度参数均为本结点的深度参数加1；\n  >\n  > 最后返回计算出的wpl即可。 \n  >\n  > ② 基于层次遍历的算法思想是使用队列进行层次遍历，并记录当前的层数， \n  >\n  > 当遍历到叶子结点时，累计wpl； \n  >\n  > 当遍历到非叶子结点时对该结点的把该结点的子树加入队列； \n  >\n  > 当某结点为该层的最后一个结点时，层数自增1； \n  >\n  > 队列空时遍历结束，返回wpl。\n  >\n  > (2)算法中使用的二叉树结点的数据类型定义如下：\n  >\n  > ```C\n  > typedef struct BiTNode{\n  > int weight;\n  > struct BiTNode *lchild,*rchild;\n  > }BiTNode,*BiTree;\n  > ```\n  >\n  > (3)代码实现\n  >\n  > ```C\n  > int WPL(BitNode root)\n  > {\n  > return wplPreOrder(root,0);\n  > }\n  > int wplPreOrder(BitNode root,int deep)\n  > {\n  > static int wpl=0;\n  > if(root->left= =NULL && root->right= =NULL)//若为叶结点，则累积WPL\n  > {\n  >   wpl+=deep*root->weight;\n  > }\n  > if(root->left! =NULL)\n  > {\n  >   wplPreOrder(root->left,deep+1);//如果左子树不为空，则对左子树进行递归遍历\n  > }\n  > if(root->right! =NULL)\n  > {\n  >   wplPreOrder(root->right,deep+1);//如果右子树不为空，则对右子树进行递归遍历\n  > }\n  > return wpl;//返回WPL值\n  > }\n  > ```\n","tags":["408数据结构"],"categories":["408数据结构"]},{"title":"第五章 树与二叉树(上)","url":"/p/63944/","content":"\n## 5.1 树的基本概念\n\n### 树的定义\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-1.png\" style=\"zoom:67%;\" />\n\n空树：结点数为 0 的树\n\n非空树的特性:\n\n- 有且仅有一个根结点\n- 没有后继的结点称为叶子结点(或者终端结点)\n- 有后继的结点称为分支结点(或者非终端结点)\n- 除了根节点外，任何一个结点都有且仅有一个前驱\n- 每个结点可以有 0 个或多个后继结点。\n\n**除了根结点外，任何一个结点都有且仅有一个前驱**\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-2.png\" style=\"zoom:67%;\" />\n\n树是 n(n≥0) 个结点的有限集合，n = 0 时，称为空树，这是一种特殊情况。在任意一棵非空树中应满足：\n\n1. 有且仅有一个特定的称为根的结点。\n2. 当 n > 1 时，其余结点可分为 m(m>0) 个互不相交的有限集合T1,T2,…Tm，其中每个集合本身又是一棵树，并且称为根结点的子树。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-3.png\" style=\"zoom:67%;\" />\n\n### 基本术语\n\n- 根结点：非空树种无前驱结点的结点\n- 结点的度：结点拥有的子树数\n- 树的度：树内各结点的度的最大值\n- 叶子（终端结点）：没有后继元素（度 = 0）\n- 分支结点（非终端结点）：度 != 0；\n- 内部结点：根结点以外的分支结点\n- 孩子，双亲：结点的子树的根称为该结点的孩子，该结点称为孩子的双亲\n- 兄弟结点：有共同的双亲\n- 堂兄弟：双亲在同一层的结点\n- 结点的祖先：从根到该结点所经分支上的所有结点\n- 结点的子孙：以某结点为根的子树中的任一结点\n- 树的深度：树中结点的最大层次\n- 有序树：树中结点的各子树从左至右有次序（最左边为第一个孩子）\n- 无须树：树中结点的各子树无次序\n- 森林：是m（m≥0）棵互不相交的树的集合，把根结点删除，树就变成了森林，一棵树可以看成是一个特殊的森林，给森林中的各子树加上一个双亲结点，森林就变成了树（树一定是森林，森林不一定是树）\n\n### 结点之间的关系描述\n\n如图就是一棵树的结构：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-4.png\" style=\"zoom: 50%;\" />\n\n- 结点：树的结点包含**一个数据元素和若干指向其子树的分支。**\n- 祖先结点：从根结点到该结点**所经过分支上的所有结点**。例如图中 K 的祖先结点有 E、B、A\n- 子孙结点：以某结点为根的子树中的任一结点都称为该结点的子孙。例如图中 A 的子孙结点是下面所有结点。\n- 双亲结点：一个结点的直接前驱就是它的双亲结点。例如图中 B、C、D 的双亲结点是 A\n- 孩子结点：一个结点的直接后继就是孩子结点。例如图中 A 的孩子结点是 B、C、D\n- 兄弟结点：具有相同**双亲结点** (即同一个前驱)的结点称为兄弟结点。例如图中 B、C、D 为兄弟结点\n- 两个结点之间的路径：只能**从上往下** 。例如结点 A 和结点 E 之间有路径，结点 E 与 结点 G 之间没有路径。\n- 两个结点之间的路径长度：一个结点到另一个结点之间经过了几条边。例如 A 到 E 的路径长度为 2\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-5.png\" style=\"zoom:50%;\" />\n\n`属性`：\n\n- 结点的层次(深度) ： 从上往下数，默认从 1 开始(有的教材默认从 0 开始，也不要奇怪，见题拆题)\n  - 深度为 1 是 A 结点\n  - 深度为 2 是 B、C、D结点\n  - 深度为 3 是 E、F、F、H、I、J 结点\n  - 深度为 4 是 K、L、M 结点\n- 结点的高度：从下往上数，默认从 1 开始\n  - 高度为 1 是 K、L、M 结点\n  - 高度为 2 是 E、F、F、H、I、J 结点\n  - 高度为 3 是 B、C、D结点\n  - 高度为 4 是 A 结点\n- 结点的度：有几个孩子(分支) 就有几个度\n  - 结点 B 有两个分支，结点 B 的度为 2\n  - 结点 C 有一个分支，结点 C 的度为 1\n  - 结点 D 有三个分支，结点 D 的度为 3\n  - 结点 M 是叶子结点，结点 M 的度为 0\n- 树的度：各结点的度的最大值。也就是树中分支数最多\n  - 结点 A 、D 的分支最多为 3 ，所以树的度为 3\n\n### 有序树、无序树、森林\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-6.png\" style=\"zoom:67%;\" />\n\n- 有序树：树中各子树从左到右是有次序的，不能互换，互换会导致含义发生错误。\n- 无序树：树种各子树从左到右是无次序的，可以更换\n- 森林：森林是 m(m≥0) 棵互不相交的树的集合\n\n### 树的性质\n\n- 树中的结点数等于所有结点的度数之和加1 \n\n- 度为m的树中第i层上至多有\n  $$\n  m^{i-1}\n  $$\n  个结点（i≥1）\n\n- 高度为h的m叉树至多有\n  $$\n  (m^h-1)/(m-1)\n  $$\n   个结点\n\n- 具有n个结点的m叉树的最小高度为\n  $$\n  \\lceil  \\log_m{(n(m-1)+1)} \\rceil\n  $$\n  \n\n### 树常考性质\n\n#### 结点数 = 总度数 + 1\n\n结点的度 = 结点有几个孩子(分支)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-7.png\" style=\"zoom:50%;\" />\n\n#### 度为 m 的树和 m 叉树\n\n- 度为 m 的树：各结点的度的最大值为 m\n- m 叉树：每个结点最多只能有 m 个孩子的树\n\n| 度为 m 的树                      | m 叉树                        |\n| :------------------------------- | :---------------------------- |\n| 任意结点的度 ≤ m(最多m个孩子)    | 任意结点的度 ≤ m(最多m个孩子) |\n| 至少有一个结点度 = m (有m个孩子) | 允许所有结点的度都 < m        |\n| 一定是非空树，至少有 m+1 个结点  | 可以是空树                    |\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-8.png\" style=\"zoom:67%;\" />\n\n#### 度为 m 的树第 i 层至多有 m^(i-1) 个结点(i ≥ 1)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-9.png\" style=\"zoom:67%;\" />\n\n所以，第i层：m^(i-1)个结点\n\n同理，**我们也可以说m叉树的第i层至多有m^(i-1)个结点（i≥1）**\n\n> 因为不管是度为m的树，还是m叉树，本质上都是在说每个节点最多允许有m个孩子。\n\n#### 高度为 h 的 m 叉树至多有 (m^h -1)/(m-1) 个结点\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-10.png\" style=\"zoom:67%;\" />\n\n#### 高度为 h 的 m 叉树至少有 h 个结点\n\n> 对于**m叉树**，我们只是规定了每个结点的孩子结点的上限是多少个，没有规定它的下限。\n\n所以高度为h的m叉树，结点最少的情况，就是从根结点一直往下，每一个结点都只有一个孩子的情况。所以至少有h个结点。\n\n**对于高度为h、度为m的树，至少有h+m-1个结点。**\n\n这是因为，首先我们让它从根结点一路向下，每一个结点都只有一个孩子。但是由于度为m的树，要保证至少有一个结点有m个孩子，所以还要加上m-1。即h+m-1。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-11.png\" style=\"zoom: 67%;\" />\n\n#### 具有n个结点的m叉树的最小高度\n\n对于n个结点的m叉树，想让它的高度最小，那么就想尽可能的让每一个结点都有尽可能多的孩子，也就是会有m个孩子。这样一来，这个树就会往宽处达到最宽，高度从而就最小了。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-12.png\" style=\"zoom:67%;\" />\n\n**总结**\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-13.png\" style=\"zoom:67%;\" />\n\n### 习题\n\n- 思考：树中的结点数等于→所有结点的度数之和+1\n\n- 树的路径长度是从树根到每个结点的路径长度的什么→总和，注意与哈夫曼树的带权路径长度的区别\n\n- 【2010】在一棵度为4的树T中，若有20个度为4的结点，10个度为3的结点，1个度为2的结点，10个度为1的结点，则树T的叶节点个数为多少 ?→82\n\n  > 任何一棵树中，结点个数比分支个数多一 \n  >\n  > 分支个数等于20x4+10x3+1x2+10x1=122 \n  >\n  > 所以这棵树一共有123个结点 \n  >\n  > 度不为零的结点数目为20+10+1+10=41 \n  >\n  > 所以叶子结点也就是度为零的结点个数为123-41=82\n\n## 5.2 二叉树的概念\n\n### 二叉树的定义\n\n每个结点至多只有两棵子树，且子树有左右之分\n\n二叉树是 n (n≥0) 个结点的有限集合。\n\n- 或者为空二叉树，即 n = 0\n- 或者由一个根节点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-14.png\" style=\"zoom:67%;\" />\n\n特点：\n\n1. 每个结点至多只有两棵子树\n2. 左右子树不能颠倒(二叉树是有序树)\n\n### 几个特殊的二叉树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-15.png\" style=\"zoom:67%;\" />\n\n#### 满二叉树\n\n满二叉树：**一棵高度为 h，且含有 2^h -1 个结点的二叉树**，即树中的每层都含有最多的结点。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-16.png\" style=\"zoom: 50%;\" />\n\n特点：\n\n1. 只有最后一层有叶子结点\n2. 不存在度为 1 的结点\n3. 按层序从 1 开始编号，结点 i 的左孩子为 2i，右孩子为 2i+1，结点 i 的父节点为 [ i / 2] (如果有的话) **[ i / 2 ]向下取整**。<font color='orange'>这个特性是很重要的，可以通过这个特性，使得我们能够用顺序存储的方式来存储这些结点。</font>\n\n#### 完全二叉树\n\n完全二叉树：当且仅当其每个结点都与高度为 h 的满二叉树中编号为 1~n 的结点一一对应时，称为完全二叉树。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-17.png\" style=\"zoom: 50%;\" />\n\n> 可以这么理解：满二叉树已经满了，不可能再有更多的结点。\n>\n> 而完全二叉树是什么呢？就是在满二叉树的基础上，可以把一些编号更大的结点，依次给去掉。（如此处将13、14、15去掉）\n>\n> 若只把结点13去掉，则其后面的14、15的编号，要改为13、14。这样一来，其每个结点的编号就不与满二叉树一一对应了，就不是完全二叉树了。\n\n可见，**满二叉树是一种特殊的完全二叉树**。**而完全二叉树不一定是满二叉树**。\n\n那么，由于我们将最后一层编号更大的结点去除了，那么就会在倒数第二层，出现叶子结点。而且不难理解，完全二叉树只有最后两层可能有叶子结点。且最多只有一个度为1的结点。\n\n特点：\n\n1. 只有最后两层可能有叶子结点。\n\n2. 同时只有一个度为 1 的结点\n\n3. 按层序从 1 开始编号，结点 i 的左孩子为 2i，右孩子为 2i+1，结点 i的父节点为 ⌊i/2⌋ (如果有的话) \n\n4. i ≤ ⌊n/2⌋ 为分支结点, i > ⌊n/2⌋为叶子结点\n\n5. 在完全二叉树中,如果某结点只有一个孩子,那么一定是左孩子\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-18.png\" style=\"zoom:67%;\" />\n\n<font color='red'>上图右下角纠正:如果结点是右孩子，那么就不是完全二叉树</font>\n\n#### 二叉排序树\n\n**二叉排序树**：一棵二叉树或者空二叉树，或者具有如下性质的二叉树:\n\n- 左子树上所有结点的关键字均**小于根结点**的关键字\n- 右子树上所有结点的关键字均**大于根节点**的关键字\n- 左子树和右子树又各是一棵二叉排序树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-19.png\" style=\"zoom:67%;\" />\n\n**二叉排序树用于元素的排序、搜索**\n\n#### 平衡二叉树\n\n平衡二叉树：树上任一结点的**左子树**和**右子树**的**深度之差不超过 1**\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-20.png\" style=\"zoom:67%;\" />\n\n可以看出，**平衡二叉树能有更高的搜索效率**。\n\n其实平衡二叉树，就是希望一棵树在生长的时候，尽可能的往宽处长，而高度是在当前状态下的最小高度。这样一来，我们在向下搜索的过程中，搜索的次数也便是最少的了。\n\n#### 总结\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-21.png\" style=\"zoom: 80%;\" />\n\n### 二叉树的性质\n\n- 非空二叉树上的叶子结点数等于?→ 度为 2 的结点数加 1，即\n  $$\n  n_0=n_2+1\n  $$\n\n- 非空二叉树上第 k 层上至多有多少个结点，总共至多有多少个结点\n  $$\n  2^{k-1}\n  $$\n   个结点\n\n- 高度为 h 的二叉树至多有多少个结点?→\n  $$\n  2^h-1\n  $$\n   个结点\n\n- 对完全二叉树按从上到下、从左到右的顺序依次编号 1，2，...，n，则有以下关系\n\n  - ① 当 i >1 时，结点 i 的双亲的编号为 ⌊i/2⌋，即当 i 为偶数时，其双亲编号为 i/2，它是双亲的左孩子；当 i 为奇数时，其双亲的编号为 (i-1) / 2，它是双亲的右孩子\n\n  - ② 当 2i ≤ n 时，结点 i 的左孩子编号为 2i，否则无左孩子\n\n  - ③ 当 2i + 1 ≤ n 时，结点 i 的右孩子编号为 2i，否则无右孩子\n\n  - ④ 结点 i 所在的层次（深度）为 \n    $$\n    \\lfloor \\log_2 i\\rfloor+1\n    $$\n\n- 具有 n 个（n > 0）结点的完全二叉树的高度为\n  $$\n  \\lceil\\log_2(n+1)\\rceil或\\lfloor\\log_2n\\rfloor+1\n  $$\n\n### 二叉树常考性质\n\n#### 叶子结点比二分支结点多一个\n\n设非空二叉树中度为 0、1 和 2 的结点个数分别为 n0 、n1 、n2 ，则 n0 = n2 + 1\n\n(叶子结点比二分支结点多一个)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-22.png\" style=\"zoom: 80%;\" />\n\n#### 二叉树第 i 层至多有 2^(i-1) 个结点(i≥1)\n\n之前讨论过的 m叉树 第 i 层至多有 m^(i-1) 个结点(i≥1)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-23.png\" style=\"zoom: 67%;\" />\n\n#### 高度为 h 的二叉树至多有 2^h -1 个结点(满二叉树)\n\n之前讨论过的 高度为 h 的 m 叉树至多有 (m^h -1) / (m-1) 个结点\n\n### 完全二叉树常考性质\n\n#### 具有n个(n>0)结点的完全二叉树的高度\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-24.png\" style=\"zoom: 80%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-25.png\" style=\"zoom: 80%;\" />\n\n#### 对于完全二叉树，可以由结点数n推出度为 0、1和2的结点个数\n\n对于完全二叉树，可以由结点数n推出度为 0、1和2的结点个数，n0、n1和n2\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-26.png\" style=\"zoom: 80%;\" />\n\n### 二叉树的存储结构\n\n#### 顺序存储结构\n\n```C\n#define MaxSize 100\nstruct TreeNode {\n    ElemType value;\t\t\t// 结点中的数据元素\n    bool isEmpty;\t\t\t// 结点是否为空\n}\nTreeNode t[MaxSize];\n//定义一个长度为MaxSize的数组t，按照从上至下、从左至右的顺序依次存储完全二叉树中的各个结点 \n//在初始化这个数组的时候，我们要把所有的元素的结点先初始化为空。\nfor(int i=0; i<MaxSize;i++){\n    t[i].isEmpty = true;\t\t// 初始化时所有结点标记为空\n}\n```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-27.png\" style=\"zoom: 80%;\" />\n\n**几个重要常考的基本操作**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-28.png\" style=\"zoom:80%;\" />\n\n上述是完全二叉树的存储，那么对于一棵不是完全二叉树而言又如何存储呢？**如果不是完全二叉树，依然按层序将各结点顺序存储，那么无法从结点编号反映出结点点的逻辑关系**。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-29.png\" style=\"zoom:80%;\" />\n\n所以对于二叉树的顺序存储中，**一定要把树的结点编号与完全二叉树对应起来**。这样我们就可以通过结点编号来算出左孩子、右孩子、父节点，但是无法通过结点编号 i 与结点总数 n 作比较，来进行判断。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-30.png\" style=\"zoom:80%;\" />\n\n我们可以看到，这样存储的话会浪费很多存储单元，**所以对于二叉树的顺序存储结构，只适合存储完全二叉树。**\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-31.png\" style=\"zoom:67%;\" />\n\n#### 链式存储结构\n\n```c\n// 二叉树的结点(链式存储)\ntypedef struct BiTNode{\n    ElemType data;\t\t\t\t\t// 数据域\n    struct BiTNode *lchild,*rchild; // 左、右孩子指针\n}BiTNode,*BiTree;\n```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-32.png\" style=\"zoom:80%;\" />\n\n如果一个结点没有左孩子，我们可以将对应的指针设为 null。\n\n思考：<font color='cornflowerblue'>在含有 n 个结点的二叉链表中，含有多少个空链域？</font>→n+1个空链域\n\n若共有n个结点，会有2n个指针，除了根结点之外，其他结点头上都会连一个指针，也就是说有n-1结点的头上也会连接有一个指针(除了头结点外，每个结点被指1次)，所以这2n个指针中会有(2n-(n-1))= n+1个指向 null。即**n个结点的二叉链表共有n+1个空链域**。\n$$\n1n_0+1n_1+1n_2=n \\quad结点数之和\n$$\n\n$$\n0n_0+1n_1+2n_2=n-1 \\quad度和结点关系\n$$\n\n$$\n2n_0+1n_1+0n_2=? \\quad求空链域\n$$\n\n> 实际上，这些空链域可以被利用起来，**用于构造线索二叉树**（这是之后会学到的内容）\n\n**初始化一个二叉树**\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-33.png\" style=\"zoom: 50%;\" />\n\n由于每个节点都有两个指针，我们也把这种实现叫做二叉链表。\n\n```C\nstruct ElemType{\n    int value;\n};\n\n// 二叉树的结点(链式存储)\ntypedef struct BiTNode{\n    ElemType data;\t\t\t\t\t// 数据域\n    struct BiTNode *lchild,*rchild; // 左、右孩子指针\n}BiTNode,*BiTree;\n\n// 定义一棵空树\nBiTree root = NULL;\n\n// 插入根节点\nroot = (BiTree) malloc(sizeof(BiTNode));\nroot->data = {1};\t\t\t\t\t\t\t// 根节点数据域为 1\nroot->lchild = NULL;\t\t\t\t\t\t// 根节点左孩子指向NULL\nroot->rchild = NULL;\t\t\t\t\t\t// 根节点右孩子指向NULL\n\n// 插入新结点\nBiTNode *p = (BiTNode *)malloc(sizeof(BiTNode));\np->data = {2};\t\t\t\t\t\t\t\t// 新节点数据域为 2\np->lchild = NULL;\t\t\t\t\t\t\t// 新节点左孩子为NULL\np->rchild = NULL;\t\t\t\t\t\t\t// 新节点右孩子为NULL\nroot->lchild = p;\t\t\t\t//新节点作为根结点的左孩子\n```\n\n根据链式存储我们要找到指定结点 p 的左/右孩子，只需要查看结点 p 的左右孩子指针指向的结点即可。\n\n<font color='cornflowerblue'>可是如何找到指定结点 p 的父结点呢？</font>就只能从根节点开始遍历寻找，看看哪一个结点的左孩子或者右孩子是指向p结点的。显然，若整个树很大，那么这一操作还是很耗时的。因此，若你的应用场景当中，经常需要找某结点的父节点的话，你可以再给结点添加一个指针域，用来存放该结点的父节点指针。(考研一般不喜欢这么考)\n\n再来看看三叉链表，它的结点类型定义如下\n\n```c\n// 二叉树的结点(链式存储)\ntypedef struct BiTNode{\n    ElemType data;\t\t\t\t\t// 数据域\n    struct BiTNode *lchild,*rchild; // 左、右孩子指针\n    struct BiTNode *parent;\t\t\t// 父结点指针\n}BiTNode,*BiTree;\n```\n\n### 习题\n\n- 设二叉树有2n个结点，且m<n，则不可能存在（）的结点→C\n\n  A n个度为0\n  B 2m个度为0\n  C 2m个度为1\n  D 2m个度为2\n\n- 【2009】已知一棵完全二叉树的第6层（设根为第1层）有8个叶结点，则完全二叉树的结点个数最多是?→111\n\n  > 完全二叉树比满二叉树只是在最下面一层的右边缺少了部分叶结点，而最后一层之上是个满二叉树，并且只有最后两层有叶结点。第6层有叶结点则完全二叉树的高度可能为6或7，显然树高为7时结点更多。若第6层上有8个叶结点，则前六层为满二叉树，而第7层缺失了8×2=16个叶结点，故完全二叉树的结点个数最多为(27-1)-16=111个结点。\n  >\n  > 若问最少那么就六层树，树才只有六层并且叶子节点在第六层的前面。最少就是前五层满2＾5－1＋8＝39个。\n\n- 【2011】若一棵完全二叉树有768个结点，则该二叉树中叶结点的个数为→384\n\n  > 完全二叉树，只有在第一层和叶节点层上节点个数可能是奇数个，根节点本来就是奇数的，所以总数为偶数时应该先减一得到叶节点是否包含无兄弟的叶子。显然此题包含一个只有左子节点的节点，既n1等于1。n=n0+n1+n2。768-1-1=2n2。n2=383所以n0=n2+1=384\n\n- 【2018】设一棵非空完全二叉树T的所有叶结点均位于同一层，且每个非叶结点都有2个子节点。若T有k个叶结点，则T的结点总数是→2k-1\n\n  > 一棵非空完全二叉树T的所有叶结点均位于同一层，且每个非叶结点都有2个子结点就是满二叉树。\n  >\n  > 则有 k = 2^(h-1)， T的结点总数n=2^(h-1)-1+k = 2k-1\n\n- 【2020】对于任意一棵高度为5且有10个结点的二叉树，若采用顺序存储结构保存，每个结点占1个存储单元（仅存放结点的数据信息），则存放该二叉树需要的存储单元数量至少是→31\n\n  > 因为是顺序存储结构保存，所以需要的存储单元是给定高度的全部结点都要考虑。\n  > 高度为5的满二叉树共有：\n  > 25-1=31个结点\n  > 31*1个存储单元=31；\n","tags":["408数据结构"],"categories":["408数据结构"]},{"title":"第四章 串","url":"/p/17647/","content":"\n## *4.1 串的定义和实现\n\n### 什么是串\n\n字符串，简称串，是由零个或多个字符组成的<font color='orange'>有限序列</font>。一般记为 S = ‘a1a2…an’(n≥0)\n\n其中，S 是串名，单引号括起来的字符序列是串的值，ai 可以是字母、数字或其他字符；串中字符的个数 n 称为串的长度。n = 0 时的串称为空串。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-42.png\" style=\"zoom:55%;\" />\n\n串是一种<font color='orange'>特殊</font>的<font color='orange'>线性表</font>，数据元素之间呈<font color='orange'>线性关系</font>\n\n它们的区别是:\n\n- 普通的线性表里面可以存放各种各样的数据类型，是不做限制的。串的数据对象限定为字符集(如中文字符、英文字符、数字字符、标点字符等)\n\n- 普通的线性表，我们在进行增删改查等基本操作时，一般是对线性表中的某**一个数据元素**进行操作。\n\n  而我们对串的基本操作，如增删改查等，**通常以子串为操作对象**。也就是一次是对一堆字符进行操作的。\n\n### 串的存储结构\n\n#### 串的顺序存储\n\n结构类型定义（本质上就是字符数组）\n\n**静态数组实现**:定长顺序存储\n\n```c\n#define MAXLEN 255\t\t\t// 预定义最大串长为255\ntypedef struct{\n    char ch[MAXLEN];\t\t// 每个分量存储一个字符\n    int lenght;\t\t\t\t// 串的实际长度\n}SString;\t\t\n```\n\n<font color='orange'>静态数组的缺点</font>就是它的**缺点**：长度不可变。\n\n用静态数组实现串，因此它也叫**串的定长顺序存储**。\n\n顺序存储在内存中有如下四种方案：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-43.png\" style=\"zoom:55%;\" />\n\n- 方案一：会在串的末尾增添一个存储单元，用来存储串的长度变量 Length\n\n\n- 方案二：让 ch[0] 的位置来存储串的长度变量 Length，这样做的优点是字符的位序就和数组下标相同。但缺点是 ch[0] 相当于一个存储单元 1B，这样也只能存储 0~255 的数字范围\n\n\n- 方案三：去掉 Length 变量，在串末尾插入 \\0 表示结尾。缺点是如果经常需要访问串的长度，那么每次都需要对串进行遍历\n\n由方案一和方案二，我们可以想到一个两者兼备的方案，如下方案四所示。\n\n\n- 方案四：是王道书上的，ch[0] 位置不存储元素，并在串的末尾增添一个存储单元，用来存储串的长度变量 Length。这样既保证了字符的位序就和数组下标相同，也可以记录串的长度\n\n**动态数组实现**:堆分配存储\n\n```C\ntypedef struct{\n    char *ch;\t\t\t\t// 按串长分配存储区,ch指向串的基地址\n    int lenght;\t\t\t\t// 串的长度\n}HString;\n\nS.ch = (char *)malloc(MAXLEN * sizeof(char));\t\t\t// 用完需要手动 free\nS.lenght = 0;\n```\n\nmalloc方式申请的存储空间，在内存中是在堆区当中的，因此这种方法实现的，叫**堆分配存储**。同时，堆区中分配的内存空间需要手动的free释放。\n\n<font color='orange'>这两种方式的优缺点，和顺序表的不同实现方式的优缺点是一样的。</font>\n\n#### 串的链式存储\n\n用一个结点存字符，再用一个指针指向下一个结点。\n\n- char 的大小只有 1B，指针大小 4B\n- 这就意味着我们使用 1 个字节的大小来存储信息，还要使用 4 个字节的大小来存储辅助信息。\n\n和线性表的链式存储的一样的，只不过我们每个结点保存的数据的类型为`char`。\n\n```C\ntypedef struct StringNode{\n    char ch;\t\t\t\t// 每个结点存1个字符\n    struct StringNode *next;\n}StringNode,*String;\n```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-3.png\" style=\"zoom: 67%;\" />\n\n这种情况，我们把它称为**存储密度低**。即实际存储的信息比例很小。\n\n如何解决存储密度低的问题呢？<font color='cornflowerblue'>我们可以让每个结点存多个字符</font>\n\n```C\ntypedef struct StringNode{\n    char ch[4];\t\t\t\t// 每个结点存多个字符\n    struct StringNode *next;\n}StringNode,*String;\n```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-4.png\" style=\"zoom: 55%;\" />\n\n> 此处写的是4个，实际也可以更多。\n>\n> 那么这样一来，每个结点中，实际存放的信息所占大小就是4B，因此存储密度就会提高。\n>\n> 因此，若使用链式存储来实现串的话，一般推荐采用这种方式。\n>\n> 通过这种方式实现，若最后一个结点存不满字符，那么你可以用一些特殊字符（如#，也可以用我们上面提到的'\\0'）将其填充进去。\n\n### 串的基本操作\n\n可以看下面两个链接\n\n[c 语言的库：<cstring>](https://cplusplus.com/reference/cstring/)\n\n[c++的库：<string>](https://cplusplus.com/reference/string/string/)\n\n主要包括构造、销毁、清空、求串长、求字串等\n\n 基本操作\n\n  - StrAssign(&T, chars)：串赋值。把串T赋值为chars\n  - StrCompare(S, T)：串比较。若S>T，返回值>0;....\n  - StrLength(S)：求串长。返回串S的元素个数\n  - Concat(&T, S1, S2)：串连结。用T返回由S1和S2联接而成的新串\n  - SubString(&Sub, S, pos, len)：求子串。用Sub返回串S的第pos个字符起长度为len的字串。\n  - StrCopy(&T, S)：串拷贝。由串S复制得到串T。\n  - StrEmpty(S)：串判空。若S为空串，则返回TRUE，否则返回FALSE。\n  - ClearString(&S)：清空串\n  - Index(S,T,pos)：子串的位置。用Sub返回串S的第pos个字符起长度为len的子串。\n  - Repalce(&S, T, V)：串替换\n  - StrInsert(&S, pos, T)：子串插入\n  - StrDelete(&S, pos, len)：子串删除\n  - DestoryString(&S)：串销毁 \n\n#### 求字串\n\n`SubString(&Sub,S,pos,len)` 求子串。用 Sub 返回串 S 的第 pos 个字符起长度为 len 的子串\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-5.png\" style=\"zoom: 60%;\" />\n\n```C\n#define MAXLEN 255\t\t\t// 预定义最大串长为255\ntypedef struct{\n    char ch[MAXLEN];\t\t// 每个分量存储一个字符\n    int length;\t\t\t\t// 串的实际长度\n}SString;\t\t\n\n// 求子串\nbool SubString(SString &Sub,SString S,int pos,int len){\n    // 子串范围越界\n    if(pos+len-1 > S.length){\n        return false;\n    }\n    for(int i=pos; i<pos+len; i++){\n        Sub.ch[i-pos+1] = S.ch[i];\n    }\n    Sub.length = len;\n    return true;\n}\n```\n\n#### 比较操作\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-6.png\" style=\"zoom: 60%;\" />\n\n`StrCompare(S,T)` 比较两个串操作。若 S > T，则返回值 > 0；若 S = T，则返回值 = 0；若 S < T，则返回值 < 0\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-7.png\" style=\"zoom:55%;\" />\n\n```C\n// 比较两个串操作。若 S > T，则返回值 > 0；若 S = T，则返回值 = 0；若 S < T，则返回值 < 0\nint StrCompare(SString S,SString T){\n    for(int i=1; i<=S.length && i<= T.length; i++){\n        if(S.ch[i] != T.ch[i]){\n            return S.ch[i] - T.ch[i];\n        }\n    }\n    // 扫描过的所有字符都相同,则长度更长的串更大\n    return S.lenth - T.length;\n}\n```\n\n#### 定位操作\n\n`Index(S,T)`： 定位操作。若主串 S 中存在与串 T 值相同的子串，则返回它在主串 S 中第一次出现的位置，否则函数值为 0\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-8.png\" style=\"zoom:67%;\" />\n\n其实在此处，我们可以通过使用之前实现的求子串操作`SubString(&Sub, S, pos, len)`来帮助我们完成，将要检查的子串T，和主串S的所有子串依次对比即可，而且，比较两个串是否相等，也可以使用我们之前已经实现的比较操作（StrCompare(S, T)）来完成。\n\n我们可以在主串 S 中从第一个元素开始取下长度为 3 的子串，然后对比这个子串与串 T 看是否相等，如果不相等，可以再在主串 S 中从第二个元素开始取下长度为 3 的子串，然后对比这个子串与串 T 看是否相等，如果相等，那么我们只需要返回这个子串的第一个字符的位序。\n\n```C\nint Index(SString S,SString T){\n    int i=1; \n    int n=StrLength(S);\t\t\t\t// 求S串长,返回串中元素的个数\n    int m=StrLength(T);\t\t\t\t// 求T串长,返回串中元素的个数\n    SString sub;\t\t\t\t\t// 用于暂存子串\n    while(i <= n-m+1){\n        SubString(sub,S,i,m);\t\t// 取子串,用 Sub 返回串 S 的第 i 个字符起长度为 m 的子串。\n        if(StrCompare(sub,T) != 0){ // 对比\n            i++;\n        }else{\n            return i;\t\t\t\t// 返回子串在主串中的位置\n        }\n    }\n    return 0;\t\t\t\t\t\t// S中不存在与Tx\n}\n```\n\n## 4.2 串的匹配模式\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-9.png\" style=\"zoom:60%;\" />\n\n统一一些术语:\n\n- 从哪个字符串里面进行搜索，那个字符串就叫**主串**。\n- 你输入的内容，叫模式串。\n  - 为什么叫模式串，不叫子串？因为子串必定是能够在主串中找到的一个串。而模式串只是我们试图去搜索的一个串，并不一定能够找到，因此叫模式串而不能叫子串。\n\n- **串的模式匹配**：在主串中找到与模式串相同的子串，并返回其所在位置\n\n### 简单的模式匹配算法--BF算法\n\n也叫朴素模式匹配算法，其核心思想就是:<font color='red'>暴力求解</font>\n\n之所以叫做朴素模式匹配算法，是因为我们这里不会用其他串的基本操作，而是通过访问数组元素的方式来实现这个过程。\n\n在主串当中找出所有有可能与模式串相匹配的子串，然后将每个子串与模式串一一进行对比。这样肯定就没有遗漏地进行一遍对比。\n\n> 因此，如果主串长度为n，模式串长度为m，则\n>\n> 朴素模式匹配算法：将**主串中所有长度为m的子串**依次与模式串对比，直到找到一个完全匹配的，或直到所有的子串都不匹配为止。\n>\n> 问题：在长度为n的主串当中，长度为m的子串共有多少个？\n>\n> 答：共有`n-m+1`个。\n\n到这里，事实上我们已经发现了，这一系列操作，是和之前我们学过的串的定位操作`Index(S, T)`是一致的，只是换了个马甲。\n\n因此，我们所谓的朴素模式匹配算法，就可以使用之前的串定位操作来进行实现，如下。\n\n```C\n//和上节写过的那个定位操作是一模一样的内容\nint Index(SString S, SString T){\n\tint i=1,n = StrLength(S),m = StrLength(T);\n\tSString sub;\t//用于暂存子串\n\twhile(i <= n-m+1) {\n\t\tSubString(sub, S, i, m);//取出从位置i开始，长度为m的子串\n\t\tif(StrCompare(sub, T) != 0) ++i;\n\t\telse return i;\t//返回子串在主串中的位置 \n\t}\n\treturn 0;\t//没有匹配到 \n}\n```\n\n接下来，我们不借助字符串的基本操作，而是**直接通过数组下标来实现朴素模式匹配算法**。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-10.png\" style=\"zoom: 69%;\" />\n\n1.我们会使用 k 来记录当前检查的子串的起始位置，然后比对这个子串与模式串，如果不能匹配，就让 k++（这里在比对时，只要有一个字符不同，就可以停止检查当前子串）\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-11.png\" style=\"zoom: 42%;\" />\n\n2.如果对比的子串和模式串不相等，让 k 的值 ++，也就是对比下一个子串，然后让 i 和 j 分别指向子串和模式串的第一个字符\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-12.png\" style=\"zoom:41%;\" />\n\n3.循环执行操作 2，当被比对的子串和模式串的第一个值相同，这个时候让 i 和 j 的值同时向后移，对比第二个字符，第二个字符也相等，那继续让 i 和 j 的值向后移，对比第三个字符\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-13.png\" style=\"zoom:41%;\" />\n\n```C\nint Index(SString S,SString T){\n    int k=1;\n    int i=k,j=1;\n    while(i<=S.length && j <= T.length){\n        if(S.ch[i] == T.ch[j]){\t\t\t\t// 当对比的子串和模式串的第一个字符相等\n            ++i;\t\t\t\t\t\t\t// 让 i 和 j 向后移\n            ++j;\t\t\t\t\t\t\t// 继续比较后继字符\n        }else{\n            k++;\t\t\t\t\t\t\t// 检查下一个子串\n            i=k;\t\t\t\t\t\t\t// i 指向被对比子串的第一个字符\n            j=1;\t\t\t\t\t\t\t// j 指向模式串的第一个字符\n        }\n    }\n    if(j>T.length){\n        return k;\n    }else{\n        return 0;\n    }\n}\n```\n\n王道课本代码是这样的:\n\n```c\nint Index_BF(SString S, SString T) {\nint i = 1, j = 1;\nwhile (i <= S.length && j <= T.length) {\nif (S.ch[i] == T.ch[j]) {// 比较成功则继续匹配下一个字符串\n    ++i;\n    ++j;\n}\nelse { // 比较不成功则回溯\n    i = i-j+2;\n    j++;\n}\n}\nif (j > T.length)  return  i-T.length;  // 看下文注释\nelse return 0;\n}\n\n/*\nj >= T.length 是错误的，举个反例：\nS = {\"abcdef\"}; T = {\"fg\"}\nwhen i = 6;\nS.ch[i] = T.ch[j] = 'f';\nThen i=7; j=2;\n此时不符合循环条件跳出。明显j = 2匹配成功了\n*/\n```\n\n<font color='purple'>算法性能分析</font>:\n\n若模式串长度为 m，主串长度为 n，则匹配成功的最好时间复杂度为：O(m)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-14.png\" style=\"zoom:50%;\" />\n\n若模式串长度为 m，主串长度为 n，则匹配失败的最好时间复杂度为：O(n-m+1) = O(n-m) ≈ O(n)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-15.png\" style=\"zoom: 36%;\" />\n\n最坏情况：每个子串的前 m-1 个字符都和模式串匹配，只有第 m 个字符不匹配\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-16.png\" style=\"zoom:73%;\" />\n\n<font color='orange'>再回顾一下</font>:\n\n- 串的模式匹配：在主串中找到与模式串相同的子串，并返回其所在位置。\n- 朴素模式匹配算法(简单模式匹配算法)思想：将主串中的模式串长度相同的子串搞出来，挨个与模式串对比，当子串与模式串某个对应字符不匹配时，就立即放弃当前子串，转而检索下一个子串\n- 若模式串长度为 m，主串长度为 n，则直到匹配成功/匹配失败最多需要 (n-m+1)*m 次比较\n\n### 改进的模式匹配算法——KMP 算法\n\nKMP 算法：朴素模式匹配算法的优化\n\nKMP 算法之所以叫做 KMP 算法，是因为发明它的三个人的名字第一个开头字母组成的。✌️\n\n朴素模式匹配算法的缺点：**当某些子串与模式串能部分匹配时，主串的扫描指针 i 经常回溯，导致时间开销增加**。这是为什么呢。因为我们在进行匹配之前，并不知道主串里面有什么，我们只能根据下标、模式串串长，进行一个一个的对比。即使是上一轮中对比过的相等的字符，我们也并没有记录。总之每次循环前，主串中有什么内容，都是我们不知道的，我们**只知道开始匹配的下标位置，与要匹配的长度**。\n\n但是实际上，由于上一轮循环，对于字符的逐个对比，到某个字符匹配失败时结束，这一过程当中，我们必然能够通过一部分“i指向的字符与j指向的字符相等”，来得知主串当中有哪些字符。即，在遇到不匹配的字符之前的字符，一定是和模式串一致的字符。\n\n因此，对于主串中的信息，虽然刚开始我们一无所知。但是通过模式串的部分匹配，我们可以确定主串里面前边一小部分到底是什么内容。内容就是模式串失配位置前的所有字符。\n\n那么，根据模式串失配位置前的内容，映射到主串相应位置，之后去执行朴素模式匹配的话，它会寻找到某个位置之后再进行真正的匹配。\n\n而且从逻辑上来讲，这一操作过程与主串是什么无关，只是与模式串本身的信息内容、失配位置相关。\n\n<font color='red'>改进思路</font>：主串指针不回溯，只有模式串指针回溯\n\n------\n\n我们来看一个例子，例如指向模式串的指针 j = 6 时发生了不匹配\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-17.png\" style=\"zoom: 67%;\" />\n\n那么也就是说，前 5 个字符都与模式串匹配上了，这个时候我们让模式串回溯到起始位置，只需要比较子串的最后一个字符与模式串的起始字符是否相同\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-18.png\" style=\"zoom: 67%;\" />\n\n如果子串的最后一个字符与模式串的起始字符相同，我们让指向子串和模式串的指针 i++，j++，从而比较第二个字符是否相同\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-19.png\" style=\"zoom:67%;\" />\n\n如果子串的最后一个字符与模式串的起始字符不相同，我们让指向子串的 i 后移，检查后继元素是否与模式串的起始元素相同，而指向模式串的指针 j 依然是 1\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-20.png\" style=\"zoom:67%;\" />\n\n那如果指向模式串的指针 j = 5 时发生了不匹配，如图:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-21.png\" style=\"zoom:67%;\" />\n\n那么说明我们前4个字符都匹配上了，并且此时子串有第二个 g 开头，我们只需要比对模式串的第二个字符，看子串的 ？号处的字符是否与 o 相同，所以我们让指向模式串的指针 j 回到 2\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-22.png\" style=\"zoom:67%;\" />\n\n如果说指向模式串的指针 j = 3 时不匹配\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-23.png\" style=\"zoom:67%;\" />\n\n让指向模式串的指针 j 回到1\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-24.png\" style=\"zoom:67%;\" />\n\n<font color='red'>总结</font>：当我们的指针 j 扫描到某一个字符时，如果发生了不匹配，那么说明前面的字符和我们的主串是能够完全匹配上的，那我们就可以利用模式串前缀的信息，就可以分析出指针 j 接下来应该指向什么位置。\n\n------\n\n我们将 j 应该指向什么位置的信息放在一个数组里，数组名字叫 **next**\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-25.png\" style=\"zoom:67%;\" />\n\n这个数组的意思是当指针 j 指向的位置发生不匹配，那么它应该回到某一个位置。这里我们发现当 j = 1时发生不匹配，应该让 j 仍然是1，但是 next 数组里面让 j 回到 0，这是为了写代码的时候考虑。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-26.png\" style=\"zoom: 33%;\" />\n\n------\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-44.png\" style=\"zoom:67%;\" />\n\n```c\nint Index_KMP(SString S,SString T,int next[]){\n    int i=1;j=1;\n    while(i<=S.length && j<= T.length){\n        if(j==0 || S.ch[i] == T.ch[j]){\n            ++i;\n            ++j;\t\t\t\t\t\t\t\t// 继续比较后继字符\n        }else{\n            j=next[j];\t\t\t\t\t\t\t// j指回相应位置,模式串向右移动\n        }\n    }\n    if(j>T.length){\n        return i-T.length;\t\t\t\t\t\t// 匹配成功\n    }else{\n        return 0;\n    }\n}\n```\n\nKMP算法，最坏时间复杂度O(m+n)；其中，求next数组时间复杂度O(m),模式匹配过程最坏时间复杂度O(n)。\n\n### 求next数组🔥(王卓)\n\n**所以其实 KMP 算法的关键在于我们需要先搞出一个和模式串相对应的数组 next。**\n\n我们先来观察几个例子:\n\n当 j = 6 时，匹配失败，我们要让模式串向右移动到 j = 3\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-27.png\" style=\"zoom:64%;\" />\n\n当 j = 7 时，匹配失败，我们要让模式串向右移动到 j = 5\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-28.png\" style=\"zoom: 55%;\" />\n\n当 j = 5时匹配失败，我们要让模式串向右移动到 j = 4\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-29.png\" style=\"zoom:59%;\" />\n\n当 j = 5 时匹配失败，我们要让模式串向右移动到 j = 1\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-30.png\" style=\"zoom:58%;\" />\n\n当 j = 1 时就发生匹配失败，我们让 j = 0\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-31.png\" style=\"zoom:60%;\" />\n\n串的前缀：包含第一个字符，且不包含最后一个字符的子串\n\n串的后缀：包含最后一个字符，且不包含第一个字符的子串\n\n<font color='orange'>当第 j 个字符匹配失败，由前 1 ~ j-1 个字符组成的串记为 S，则： next[j] = S的最大公共前后缀长度 +1</font>\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-32.png\" style=\"zoom:65%;\" />\n\n```cpp\nvoid Get_next(SString T, int next[]){\n    int i = 1, j = 0;\n    next[1] = 0;\n    while (i < strlen(T)) {\n        if (j == 0 || T.ch[i] == T.ch[j]) {\n            ++i; ++j;\n            next[i] = j;\n        }\n        else j = next[j]; // 隐含着非常厉害的递归思想\n    }\n    return 0;\n}\n```\n\n时间复杂度O(m+n) ，其中O(m) 来自于求next数组，O(n) 来自KMP算法的里层循环（普通模式匹配算法的时间复杂度是O(mn)\n\n------\n\n### 求next数组(王道)\n\n这个有两种方法：一种是王道讲的这个；一种是王卓上面讲的，根据当前要判断的元素的前面的模式串的子串中公共前后缀的长度加1来确定当前next数组的值（不过要注意模式串下标，有的题目是j从0开始，然后这里需要加1是因为next数组第一个是0，第二个是1）。\n\n------\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-45.png\" style=\"zoom:67%;\" />\n\n- 首先分析next[1]\n\n  > next[1]的含义是，当模式串的第一个字符发生失配时，模式串指针j应该指向什么位置？\n  >\n  > 应该是让j=0，然后执行i++,j++。\n\n  对于任何一个模式串都是一样的，第一个字符不匹配时，只能匹配下一个子串。因此，**next[1]均直接写0**即可。\n\n- 分析next[2]\n\n  > next[2]的含义是，如果第二个字符发生失配，接下来指针j应该指向哪？\n  >\n  > 对于这个例子来说，我们应该让j=1。\n\n  事实上，对于任何一个模式串都一样，第2个字符不匹配时，应该尝试匹配模式串的第1个字符。因此，**next[2]均直接写1**即可。\n\n- 分析next[3]\n\n  > 在不匹配位置前边，画一个分界线。然后，让模式串一步一步往后退，直到在分界线之前“能对上”，或模式串完全跨过分界线。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-46.png\" style=\"zoom:67%;\" />\n\n  分界线右边的内容是未知的，模式串一步一步右移，观察分界线左边能不能匹配得上\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-47.png\" style=\"zoom:67%;\" />\n\n  即此模式串对应的`next[3] = 1`。\n\n- 分析next[4]\n\n  同理可知，`next[4] = 1`。\n\n- 分析next[5]\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-48.png\" style=\"zoom:67%;\" />\n\n  同理可知，`next[5] = 2`。\n\n- 分析next[6]\n\n  同理可知，`next[6] = 1`。\n\n#### 练习1\n\n<font color='green'>这里直接用算法算</font>\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-33.png\" style=\"zoom:67%;\" />\n\n如题:\n\n1. next[1] == 0\n2. next[2] 的意思是当我们匹配到第二个字符的时候发现匹配失败，那么前 1~(2-1) 个字符组成的串记为S，也就是串S此时只有一个字符为a，`'a'` 的前缀是空集，后缀也是空集，所以最长相等前后缀长度+1 = 1，所以 next[2] = 1(**其实，无脑写1即可**)\n3. next[3] 的意思是当我们匹配到第三个字符的时候发现匹配失败，那么前 1~(3-1) 个字符组成的串记为S，也就是串S此时为 `'ab'` ,前缀为{a}，后缀为{b},所以最长相等前后缀长度+1 = 1,所以 next[3] = 1\n4. next[4] 的意思是当我们匹配到第四个字符的时候发现匹配失败，那么前 1~(4-1) 个字符组成的串记为S，也就是串S此时为 `'aba'` ,前缀为{a,ab}，后缀为{a,ba},所以最长相等前后缀长度+1 = 2,所以 next[4] = 2\n5. next[5] 的意思是当我们匹配到第五个字符的时候发现匹配失败，那么前 1~(5-1) 个字符组成的串记为S，也就是串S此时为 `'abab'` ,前缀为{a,ab,aba}，后缀为{b,ab,bab},所以最长相等前后缀长度+1 = 3,所以 next[3] = 3\n6. next[6] 的意思是当我们匹配到第六个字符的时候发现匹配失败，那么前 1~(6-1) 个字符组成的串记为S，也就是串S此时为 `'ababa'` ,前缀为{a,ab,aba,abab}，后缀为{a,ba,aba,baba},所以最长相等前后缀长度+1 = 4,所以 next[6] = 4\n\n所以答案为：\n\n| 序号j   | 1    | 2    | 3    | 4    | 5    | 6    |\n| ------- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 模式串  | a    | b    | a    | b    | a    | a    |\n| next[j] | 0    | 1    | 1    | 2    | 3    | 4    |\n\n#### 练习2\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-34.png\" style=\"zoom:67%;\" />\n\n如题:\n\n1. next[1] == 0\n2. next[2] 的意思是当我们匹配到第二个字符的时候发现匹配失败，那么前 1~(2-1) 个字符组成的串记为S，也就是串S此时只有一个字符为a，`'a'` 的前缀是空集，后缀也是空集，所以最长相等前后缀长度+1 = 1，所以 next[2] = 1\n3. next[3] 的意思是当我们匹配到第三个字符的时候发现匹配失败，那么前 1~(3-1) 个字符组成的串记为S，也就是串S此时为 `'aa'` ,前缀为{a}，后缀为{a},所以最长相等前后缀长度+1 = 1,所以 next[3] = 2\n4. next[4] 的意思是当我们匹配到第四个字符的时候发现匹配失败，那么前 1~(4-1) 个字符组成的串记为S，也就是串S此时为 `'aaa'` ,前缀为{a,aa}，后缀为{a,aa},所以最长相等前后缀长度+1 = 3,所以 next[4] = 3\n5. next[5] 的意思是当我们匹配到第五个字符的时候发现匹配失败，那么前 1~(5-1) 个字符组成的串记为S，也就是串S此时为 `'aaaa'` ,前缀为{a,aa,aaa}，后缀为{a,aa,aaa},所以最长相等前后缀长度+1 = 4,所以 next[5] = 4\n\n答案为:\n\n| 序号j   | 1    | 2    | 3    | 4    | 5    |\n| ------- | ---- | ---- | ---- | ---- | ---- |\n| 模式串  | a    | a    | a    | a    | b    |\n| next[j] | 0    | 1    | 2    | 3    | 4    |\n\n#### 小结\n\n朴素模式匹配算法的缺点：当某些子串与模式串能部分匹配时，主串的扫描指针i经常回溯，导致时间开销增加。最坏的时间复杂度O(nm)\n\nKMP算法：当子串和模式串不匹配时，主串指针i不回溯，模式串指针 j=next[j] ，算法的平均时间复杂度：`O(n+m)`\n\nnext数组手算方法：当第j个字符匹配失败，由前 `1~j-1` 个字符组成的串记为S，则：`next[j]=S的最长相等前后缀长度+1`\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-35.png\" style=\"zoom:67%;\" />\n\n**感兴趣看**:\n\n[从BF算法到KMP算法](https://blog.csdn.net/ns_code/article/details/19286279)\n\n[字符串 模式匹配](https://www.cnblogs.com/jingmoxukong/p/4343770.html)\n\n### KMP 算法优化-nextval数组\n\n#### 举例说明\n\n<font color='purple'>举个例子</font>\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-49.png\" style=\"zoom:67%;\" />\n\n当第三个元素不匹配时，让j指针指回next[3]，即从模式串T第一个字符开始匹配\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-50.png\" style=\"zoom:67%;\" />\n\n主串前面两个元素是已经确定的了，第三个元素虽然具体不知道是什么，也可以肯定不是a，但此时查找next[3]为1，而模式串的第一个元素也还是a，根据前一节讲过的KMP算法，是会让模式串的第一个元素跟主串第三个元素比较的，就有点多余了，增加了时间复杂度\n\n所以改良一下，完全可以让j直接等于0,next[3]=next[1]\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-51.png\" style=\"zoom:80%;\" />\n\nj指向0的时候，i、j再同时++\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-52.png\" style=\"zoom:67%;\" />\n\n------\n\n==再举个例子==\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-53.png\" style=\"zoom:67%;\" />\n\n根据KMP算法应该让j=2，但同样的问题，匹配到5这个字符时发现匹配失败，虽然不知道主串i指针指向的元素是什么，但确定的是一定不是b，因为模式串中2这个字符和5这个字符是一样的\n\n这次再匹配失败后，j的值应该改成next[2]。与其多比较一次，不如直接让next[5]=next[2]=1\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-54.png\" style=\"zoom:67%;\" />\n\n------\n\n<font color='cornflowerblue'>那么是不是所有next数组的值都可被优化呢？</font>\n\n==来看这样一个例子==\n\n假设模式串匹配到第6个字符时才发现匹配失败，那么能确定是主串中i指向的字符一定不是c\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-55.png\" style=\"zoom:67%;\" />\n\n原本next[6]对应的是3，即应将j指向3，从3开始往后匹配。此时只知道主串匹配失败的字符一定不是c，但有可能是a，所以next[6]=3是有必要的。\n\n#### 优化\n\nKMP原本是根据模式串T，求出next数组，再利用next数组进行匹配，主串不回溯而模式串回溯。\n\n对KMP算法的优化本质是只是优化了next数组，将next数组按照上述思想优化成nextval数组，用nextval数组替代next数组\n\n```C\nvoid Get_next(SString T, int next[]){\n    int i = 1, j = 0;\n    nextval[1] = 0;\n    while (i < strlen(T)) {\n        if (j == 0 || T.ch[i] == T.ch[j]) {\n            ++i; ++j;\n            if(T.ch[i]! =T.ch[j]) nextval[i]=j;\n            else nextval[i] = nextval[j];\n        }\n        else j = nextval[j];\n    }\n    return 0;\n}\n```\n\n#### 练习1：求nextval数组\n\n[KMP算法的优化与详解](https://www.cnblogs.com/cherryljr/p/6519748.html)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-56.png\" style=\"zoom:67%;\" />\n\n首先nextval[1]无脑写0，然后从前往后依次求nextval[]，如果当前的next[j]所指的字符和目前j所指的字符不相等，nextval[j]=next[j]。反之，则nextval[j]=nextval[next[j]]。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-36.png\" style=\"zoom:50%;\" />\n\n例如，对于上述模式串`\"aaaab\"`,它的next数组如图，其nextval数组分析如下：\n\n1. nextval[1] == 0\n2. nextval[2] ,第二个字符的next[2] == 1，但是由于第二个字符与第一个字符是相同的，所以将第一个字符的 nextval[1] 赋值给第二个字符的nextval[2] == 0\n3. nextval[3] ,第三个字符的next[3] == 2，但是由于第三个字符与第二个字符是相同的，所以将第二个字符的 nextval[2] 赋值给第三个字符的 nextval[3] == 0\n4. nextval[4] ,第四个字符的next[4] == 3，但是由于第四个字符与第三个字符是相同的，所以将第三个字符的 nextval[3] 赋值给第四个字符的 nextval[4] == 0\n5. nextval[5] ,第五个字符的next[5] == 4，第五个字符b与第四个字符不相同，所以让其保持以前的 next 值不变，则nextval[5] = next[5] =4\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-37.png\" style=\"zoom:50%;\" />\n\n获得 nextval 函数\n\n```c\nvoid Get_next(SString T, int nextval[]){\nint i = 1, j = 0;\nnextval[1] = 0;\nwhile (i < strlen(T)) {\nif (j == 0 || T.ch[i] == T.ch[j]) {\n    i++;j++;\n    if(T.ch[i] != T.ch[j]) nextval[i] = j;\n    else nextval[i] = nextval[j];\n}\nelse j = nextval[j]; // 隐含着非常厉害的递归思想\n}\nreturn 0;\n}\n```\n\n**总结**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-38.png\" style=\"zoom:67%;\" />\n\n若题目中需要求 nextval 数组，那我们需要先手算出 next 数组，然后令 nextval[1] = 0,之后从左向右算出 nextval 值\n\n###   习题\n\n  - 思考：手算next数组→①next[ 1 ] = 0②next[ 2 ] = 1③next[ i ] = 前缀 和 后缀 最大交集 + 1\n\n  - 思考：` {aba} ` 的前缀和后缀分别是什么?→前缀{a, ab}（没有b，必须连续且包含第一个字符），后缀{a, ba}（必须连续且包含最后一个字符）\n\n  - 思考：模式串为` a b a b a a ` 求next数组→0 1 1 2 3 4\n\n  - 思考：模式串为` a a a a b `，求next和nextval数组?→0 1 2 3 4；0 0 0 0 4\n\n  - 5 和 7，串 ` a b a b a a a b a b a a ` 的next数组和nextval值为?→011234223456 ；010104210104\n\n    > 1、前两位：next数组前两位规定是0，1 即前两位ab对应的next数组为01，则：\n    >\n    > | 模式串   | a    | b    | a    | b    | a    | a    | a    | b    | a    | b    | a    | a    |\n    > | :------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n    > | 下标     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |\n    > | next数组 | 0    | 1    |      |      |      |      |      |      |      |      |      |      |\n    >\n    > 2、接下来看第三位，按照next数组求解方法。第三位a的前一位为第二位的b，b的next值为1对应内容为a，b与a不同，向前继续寻找next值对应的内容来与前一位进行比较。因为找到第一位都没有找到与前一位相等的内容，所以第三位a的next值为1，则：\n    >\n    > | 模式串   | a    | b    | a    | b    | a    | a    | a    | b    | a    | b    | a    | a    |\n    > | :------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n    > | 下标     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |\n    > | next数组 | 0    | 1    | 1    |      |      |      |      |      |      |      |      |      |\n    >\n    > 3、接下来看第四位b，b的前一位a的next值1对应内容为a，相同，所以该位b的next值就是前一位a的next值加上1，即为2\n    >\n    > | 模式串   | a    | b    | a    | b    | a    | a    | a    | b    | a    | b    | a    | a    |\n    > | :------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n    > | 下标     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |\n    > | next数组 | 0    | 1    | 1    | 2    |      |      |      |      |      |      |      |      |\n    >\n    > 4、接下来看第五位a，a的前一位b的next值2对应内容为b，相等，所以该位a的next值就是前一位b的next值加上1，即为3\n    >\n    > | 模式串   | a    | b    | a    | b    | a    | a    | a    | b    | a    | b    | a    | a    |\n    > | :------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n    > | 下标     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |\n    > | next数组 | 0    | 1    | 1    | 2    | 3    |      |      |      |      |      |      |      |\n    >\n    > 5、接下来看第六位a，a的前一位a的next值3对应内容为a，相等，所以该位a的next值就是前一位a的next值加上1，即为4\n    >\n    > | 模式串   | a    | b    | a    | b    | a    | a    | a    | b    | a    | b    | a    | a    |\n    > | :------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n    > | 下标     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |\n    > | next数组 | 0    | 1    | 1    | 2    | 3    | 4    |      |      |      |      |      |      |\n    >\n    > 6、接下来看第七位a，a的前一位a的next值4对应内容为b，不相等，向前继续寻找next值对应的内容来与前一位进行比较，b的next值2对应的内容为b，依旧不相等，继续向前寻找，第二位b的next值1对应内容为a，相等。因为是在第二位b处实现的相等，所以第七位a的next值为第二位b的next值上加1，即为2\n    >\n    > | 模式串   | a    | b    | a    | b    | a    | a    | a    | b    | a    | b    | a    | a    |\n    > | :------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n    > | 下标     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |\n    > | next数组 | 0    | 1    | 1    | 2    | 3    | 4    | 2    |      |      |      |      |      |\n    >\n    > 7、看第八位b，b的前一位a的next值2对应内容为b，不相等，向前继续寻找next值对应的内容来与前一位进行比较，b的next值1对应的内容为a，相等。因为是在第二位b处实现的相等，所以第八位a的next值为第二位b的next值上加1，即为2：\n    >\n    > | 模式串   | a    | b    | a    | b    | a    | a    | a    | b    | a    | b    | a    | a    |\n    > | :------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n    > | 下标     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |\n    > | next数组 | 0    | 1    | 1    | 2    | 3    | 4    | 2    | 2    |      |      |      |      |\n    >\n    > 8.看第九位，前一位b的next值2对应内容为b，相等，所以此处next值为3：\n    >\n    > | 模式串   | a    | b    | a    | b    | a    | a    | a    | b    | a    | b    | a    | a    |\n    > | :------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n    > | 下标     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |\n    > | next数组 | 0    | 1    | 1    | 2    | 3    | 4    | 2    | 2    | 3    |      |      |      |\n    >\n    > 9.第十位同理上面第8可得，为4：\n    >\n    > | 模式串   | a    | b    | a    | b    | a    | a    | a    | b    | a    | b    | a    | a    |\n    > | :------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n    > | 下标     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |\n    > | next数组 | 0    | 1    | 1    | 2    | 3    | 4    | 2    | 2    | 3    | 4    |      |      |\n    >\n    > 10、第十一位a的前一位b的next值4对应内容为b，相等，所以此处next值为5\n    >\n    > | 模式串   | a    | b    | a    | b    | a    | a    | a    | b    | a    | b    | a    | a    |\n    > | :------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n    > | 下标     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |\n    > | next数组 | 0    | 1    | 1    | 2    | 3    | 4    | 2    | 2    | 3    | 4    | 5    |      |\n    >\n    > 11.最后，第十二位也是同理可以得到next值位6：\n    >\n    > | 模式串   | a    | b    | a    | b    | a    | a    | a    | b    | a    | b    | a    | a    |\n    > | :------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n    > | 下标     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |\n    > | next数组 | 0    | 1    | 1    | 2    | 3    | 4    | 2    | 2    | 3    | 4    | 5    | 6    |\n    >\n    > 另一种解法:\n    >\n    > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-40.png\"  />\n    >\n    > nextval数组\n    >\n    > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-39.png\" style=\"zoom: 67%;\" />\n\n  - 【2015】已知字符串S为'abaabaabacacaabaabcc'，模式串t为'abaabc'。采用KMP算法进行匹配，第一次出现\"失配\"(S[i]!=t[j])时，i=j=5，则下次开始匹配时，i和j的值分别是-->i=5,j=2\n\n    > 由题中“失配s[i]≠t[j]时，i=j=5”，可知题中的主串和模式串的位序都是从0开始的（要注意灵活应变）。按照next数组生成算法，对于t有：\n    >\n    > | 编号 | 0    | 1    | 2    | 3    | 4    | 5    |\n    > | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n    > | t    | a    | b    | a    | a    | b    | c    |\n    > | next | -1   | 0    | 0    | 1    | 1    | 2    |\n    >\n    > 依据KMP算法“当失配时，i不变，j回退到next[j]的位置并重新比较”，当失配s[i]≠t[j]时，i=j=5，由上表不难得出next[j]=next[5]=2（位序从0开始）。从而最后结果应为：i=5（i保持不变），j=2。\n\n  - 【2019】设主串` a b a a b a a b c a b a a b c ` ，模式串 S = ` a b a a b c `，采用KMP算法进行模式匹配，到匹配成功时为止，在匹配过程中进行的单个字符间的比较次数是?→10次\n\n    > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-41.png\" style=\"zoom: 67%;\" />\n","tags":["408数据结构"],"categories":["408数据结构"]},{"title":"第三章 栈、队列和数组(下)","url":"/p/58315/","content":"\n## 3.3 栈和队列的应用\n\n### 栈在括号匹配中的应用\n\n#### 问题分析\n\n在我们写代码的过程中，不论是大括号、小括号，还是中括号，它们总是成双成对的出现的。\n\n我们如果只写了左括号，而没有写与它对应的右括号，那么编辑器就会检测出来错误。\n\n此外，左括号、右括号除了在数量上要匹配以外，在形状上也要匹配。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-53.png\" style=\"zoom:67%;\" />\n\n**遇到左括号就入栈，遇到右括号就出栈**\n\n例如：扫描下方括号，碰到左括号就将其压入栈底，碰到右括号就将其出栈匹配\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-54.png\" style=\"zoom: 50%;\" />\n\n\n\n这里的算法演示动画非常好理解：[王道考研 栈在括号匹配中的应用](https://www.bilibili.com/video/BV1b7411N798?p=26)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-55.png\" style=\"zoom: 50%;\" />\n\n**流程图**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-56.png\" style=\"zoom: 75%;\" />\n\n#### 算法实现\n\n```C\n// 考试中可直接食用基本操作,建议简要说明接口\n#define MaxSize 10\t\t\t\t\t\t\t// 定义栈中元素的最大个数\ntypedef struct{\t\t\t\t\t\t\t    \n    char data[MaxSize];\t\t\t\t\t\t// 静态数组存放栈中元素\n    int top;\t\t\t\t\t\t\t\t// 栈顶指针\n}SqStack;\n\n// 初始化栈\nvoid InitStack(SqStack &S)\n// 判断栈是否为空\nbool StackEmpty(SqStack &S)\n// 新元素入栈\nbool Push(SqStack &S,char x)\n// 栈顶元素出栈,用x返回\nbool Pop(SqStack &S,char &x)\n    \n// 字符数组(存储括号字符)和字符数组长度  \nbool bracketCheck(char str[],int length){\n    SqStack S;\n    InitStack(S);\t\t\t\t\t\t\t// 初始化一个栈\n    for(int i =0; i < length;i++){\n        if(str[i] == '(' || str[i] == '[' || str[i] == '{'){\n            Push(S.str[i]);\t\t\t\t\t// 扫描到左括号,入栈\n        }else{\n            if(StackEmpty(S)){\t\t\t\t// 扫描到右括号,且当前栈空\n                return false;\t\t\t\t// 匹配失败\n            }\n            char topElem;\n            Pop(S,topElem);\t\t\t\t\t// 栈顶元素出栈\n            if(str[i]==')' && topElem!= '('){\n                return false;\n            }\n            if(str[i]==']' && topElem!= '['){\n                return false;\n            }\n            if(str[i]=='}' && topElem!= '{'){\n                return false;\n            }\n        }\n    }\n    return StackEmpty(S);\t\t\t\t\t// 检索完全部括号后,栈空说明匹配成功\n}\n```\n\n> **注意一个小问题**：\n>\n> 由于我们要写的是括号匹配的算法实现，使用栈这种数据结构。\n>\n> 关键是要说明其中通过栈进行括号匹配的算法逻辑。\n>\n> 那么其中，栈的初始化、判空、入栈、出栈等操作，就可以不写详细细节，而直接使用。但是还是要简要声明操作函数的接口。用注释讲明其大概作用\n\n这种方法是用**顺序存储**的方式，有可能存满。其实实际开发的时候还是使用链栈为好。但是在考试的时候，使用顺序栈去写会更简单，也没什么问题。\n\n### 栈在表达式求值中的应用\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-57.png\" style=\"zoom:67%;\" />\n\n**前缀表达式**：前缀表达式(也叫波兰表达式)，运算符在两个操作数**前面**\n\n**后缀表达式**：后缀表达式(也叫逆波兰表达式)，运算符在两个操作数**后面**\n\n**中缀表达式**：运算符在两个操作数中间\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-58.png\" style=\"zoom:67%;\" />\n\n<font color='cornflowerblue'>这里做一下解释：例如中缀表达式为：a + b - c</font>\n\n**后缀表达式计算**：\n\n- 我们可以先计算 a + b，转换为后缀表达式为 ab+，再将 ab+ 作为一个整体与 c 进行减法操作，(ab+)-c\n\n  转换为后缀表达式为 ab+c-\n\n- 我们也可以先计算 b - c，转换为后缀表达式为 bc-，再将 bc- 作为一个整体与 a 进行加法操作，a+(bc-)\n\n  转换为后缀表达式为 abc-+\n\n> 这两个后缀表达式的结果，肯定都是正确的，表达的都是同一个中缀表达式。\n>\n> 但是，如果我们要用计算机来实现中缀转后缀的算法的话，我们只应该得到一种输出结果（因为算法应该具有确定性，即同样的输入只能得到同样的输出），那么实际上，用算法实现的结果，应该是前一种后缀表达式的结果。\n>\n> 以下几种情况同理。**那么，怎样能够保证得到的是前一种后缀表达式的结果呢？**接下来要提到“左优先“原则。\n\n**前缀表达式计算**：\n\n- 我们可以先计算 a + b，转换为前缀表达式为 +ab，再将 +ab 作为一个整体与 c 进行减法操作，(+ab)-c\n\n  转换为前缀表达式为 -+abc\n\n- 我们也可以先计算 b - c,转换为前缀表达式为 -bc，再将 -bc 作为一个整体与 a 进行加法操作，a+(-bc)\n\n  转换为前缀表达式为 +a-bc\n\n<font color='orange'>这里做一下解释：例如中缀表达式为：a + b - c * d</font>\n\n**后缀表达式计算**：\n\n- 我们可以先计算 a + b，转换为后缀表达式为 ab+，再接着计算 c * d，转换为后缀表达式为 cd* ，接着让 ab+ 和 cd * 分别作为两个整体进行减法操作，(ab+)-(cd*) 转换为后缀表达式为 ab+cd *-\n\n**前缀表达式计算**：\n\n- 我们可以先计算 a + b，转换为前缀表达式为 +ab，再接着计算 c * d，转换为前缀表达式为 *cd，接着让 +ab 和 cd * 分别作为两个整体进行减法操作，(+ab)-(*cd) 转换为前缀表达式为 -+ab *cd\n\n#### 中缀表达式转后缀表达式\n\n**方法**：\n\n1. 确定中缀表达式中各个运算符的运算顺序\n2. 选择下一个运算符，按照 [**左操作数 右操作数 运算符**] 的方式组合成一个新的操作数\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-59.png\" style=\"zoom: 85%;\" />\n\n- 左优先原则：只要左边的运算符能先计算，就优先算左边的。\n\n- 我们知道运算符的运算顺序不唯一，对应的后缀表达式也不唯一。但是如果我们遵从左优先原则，那么就可以保证对应的后缀表达式唯一，而且机算也是按照左优先原则，这样我们就可以保证手算和机算的结果相同。\n\n- 例如如下案例：\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-60.png\" style=\"zoom:69%;\" />\n\n##### 后缀表达式的手算\n\n<font color='orange'>我们将中缀表达式转换为后缀表达式，我们怎么计算这个后缀表达式呢？</font>\n\n<font color='cornflowerblue'>计算方法：从左往右扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对应运算，合体为一个操作数。</font>\n\n我们来看一个例子\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-61.png\" style=\"zoom:67%;\" />\n\n如上图后缀表达式\n\n- 我们从左向右扫描，先扫描到 ➕ 号，我们让 ➕ 号前面最近的两个操作数执行 ➕ 运算，合体为 2，于是变为 \n  - 15 7 2 ➖ ➗ 3 ✖ 2 1 1 ➕ ➕ ➖\n- 我们继续将上述后缀表达式从左向右扫描，先扫描到 ➖ ，我们让 ➖ 前面最近的两个操作数执行 ➖ 运算，合体为 5\n  - 15 5 ➗ 3 ✖ 2 1 1 ➕ ➕ ➖\n- 我们继续将上述后缀表达式从左向右扫描，先扫描到 ➗，我们让 ➗ 前面最近的两个操作数执行 ➗ 运算，合体为 3\n  - 3 3 ✖ 2 1 1 ➕ ➕ ➖\n- 我们继续将上述后缀表达式从左向右扫描，先扫描到 ✖，我们让 ✖ 前面最近的两个操作数执行 ✖ 运算，合体为 9\n  - 9 2 1 1 ➕ ➕ ➖\n- 我们继续将上述后缀表达式从左向右扫描，先扫描到 ➕，我们让 ➕ 前面最近的两个操作数执行 ➕ 运算，合体为 2\n  - 9 2 2 ➕ ➖\n- 我们继续将上述后缀表达式从左向右扫描，先扫描到 ➕，我们让 ➕ 前面最近的两个操作数执行 ➕ 运算，合体为 4\n  - 9 4 ➖\n- 最后从左向右扫描，扫描到 ➖，我们让 ➖ 前面最近的两个操作数执行 ➖ 运算，合体为 5\n  - 5\n- 所以最终结果为 5\n\n##### 后缀表达式的机算\n\n我们让运算符前面最近的两个操作数执行对应运算，最后出现的操作数最先被运算，这符合栈**后进先出**的特点，所以我们机算后缀表达式是用栈实现的。步骤如下:\n\n①从左往右扫描下一个元素，直到处理完所有元素。\n\n②若扫描到操作数，则压入栈，并回到①；否则执行③。\n\n③若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到①。\n\n例如：\n\n1. 我们扫描如图的后缀表达式，扫描到 A，压入栈，扫描到 B，压入栈\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-62.png\" style=\"zoom:67%;\" />\n\n2. 扫描到运算符 +，弹出两个栈顶元素 B、A，执行 + 运算，A + B，再将运算结果压入栈顶\n\n   - 注意,<font color='orange'>先出栈的是右操作数</font>，这里 B 先出栈，所以 B 为右操作数\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-63.png\" style=\"zoom:67%;\" />\n\n3. 接着继续从左向右扫描，扫描到 C，压入栈，扫描到 D，压入栈。\n\n   扫描到运算符 *，弹出两个栈顶元素 D、C，执行 * 运算，C * D，再将运算结果压入栈顶\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-64.png\" style=\"zoom:67%;\" />\n\n4. 接着继续从左向右扫描，扫描到 E，压入栈中。\n\n   扫描到运算符 / ，弹出栈顶元素 E、C*D，执行 / 运算，(C * D)/E，再将结果压入栈顶\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-65.png\" style=\"zoom:67%;\" />\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-66.png\" style=\"zoom:67%;\" />\n\n5. 接着扫描到运算符 -，弹出两个栈顶元素 (C * D)/E 、A+B，执行 - 操作，(A+B)-((C*D)/E)\n\n   将运算结果压入栈顶\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-67.png\" style=\"zoom:67%;\" />\n\n6. 接着从左向右扫描，扫描到 F ，压入栈\n\n   扫描到运算符 +，弹出两个栈顶元素 F、(A+B)-((C*D)/E)，执行 + 操作，(A+B)-((C * D)/E) + F\n\n   将结果压入栈顶\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-68.png\" style=\"zoom:67%;\" />\n\n7. 若表达式合法，则最后栈中只会留下一个元素，就是后缀表达式的最终结果\n\n> 由于本例中的元素均设成未知数，所以最后计算出的后缀表达式的结果是一个中缀表达式。若有具体数的话则栈中只会有一个元素，即为运算结果。这种后缀表达式的机算方式可以粗略理解为将后缀转中缀后再计算。\n\n<font color='red'>所以其实人喜欢看中缀表达式，计算机更喜欢看后缀表达式。</font>\n\n#### 后缀表达式转中缀表达式\n\n<font color='cornflowerblue'>我们知道了中缀表达式转换后缀表达式，那么后缀表达式如何转换为中缀表达式呢？</font>\n\n从左往右扫描，每遇到一个运算符，就让<font color='orange'>运算符插入前面最近的两个操作数之间，然后操作数两边带上括号</font>\n\n我们来看一个例子:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-69.png\" style=\"zoom:67%;\" />\n\n如上图后缀表达式:\n\n1. 从左向右扫描，先扫描到运算符 ➕ ，变为栈在递归中的应用\n   - 15 7 (1+1) ➖ ➗ 3 ✖ 2 1 1 ➕ ➕ ➖\n2. 接着继续从左到右扫描，先扫描到运算符 ➖\n   - 15 (7-(1+1)) ➗ 3 ✖ 2 1 1 ➕ ➕ ➖\n3. 接着继续从左到右扫描，先扫描到运算符 ➗\n   - ( 15 ÷ (7-(1+1)) ) 3 ✖ 2 1 1 ➕ ➕ ➖\n4. 接着继续从左到右扫描，先扫描到运算符 ✖\n   - (( 15 ÷ (7-(1+1)) ) * 3) 2 1 1 ➕ ➕ ➖\n5. 接着继续从左到右扫描，先扫描到运算符 ➕\n   - (( 15 ÷ (7-(1+1)) ) * 3) 2 (1+1) ➕ ➖\n6. 接着继续从左到右扫描，先扫描到运算符 ➕\n   - (( 15 ÷ (7-(1+1)) ) * 3) (2+(1+1)) ➖\n7. 接着继续从左到右扫描，先扫描到运算符 ➖\n   - (( 15 ÷ (7-(1+1)) ) * 3) - (2+(1+1))\n\n#### 中缀表达式转前缀表达式\n\n- ①确定中缀表达式中**各个运算符的运算顺序**。\n\n- ②选择下一个运算符，按照「**运算符 左操作数 右操作数**」的方式组合成一个新的操作数。\n\n- ③如果还有运算符没被处理，就继续②。\n\n注意:\n\n- 中缀表达式转后缀表达式是 **左优先** 原则\n\n- 中缀表达式转前缀表达式是 **右优先** 原则\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-70.png\" style=\"zoom: 50%;\" />\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-71.png\" style=\"zoom: 50%;\" />\n\n右优先原则：只要右边的运算符能先机算，就优先算右边的\n\n##### 前缀表达式的机算\n\n用栈实现前缀表达式的计算：\n\n- ①**从右往左**扫描下一个元素，直到处理完所有元素。\n\n- ②若扫描到操作数，则压入栈，并回到①；否则执行③。\n\n- ③若扫描到运算符，则弹出两个栈顶元素，执行响应运算，运算结果压回栈顶，回到①。\n\n**注意**：先出栈的是“左操作数”。\n\n#### 中缀表达式转后缀表达式机算\n\n初始化一个栈，用于<font color='orange'>保存暂时还不能确定运算顺序的运算符</font>。\n\n从左到右处理各个元素，直到末尾。可能遇到三种情况：\n\n1. 遇到**操作数**。直接加入后缀表达式\n2. 遇到**界限符**。遇到左括号 `(` 直接入栈；遇到右括号 `)` 则依次弹出栈内运算符并加入后缀表达式，直到弹出左括号`(` 为止。注意：左括号`(` 不加入后缀表达式。\n3. 遇到**运算符**。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到 `(` 或栈空则停止。之后再把当前运算符入栈。\n\n按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。\n\n------\n\n我们来看一下例子：\n\n1. 如下图的中缀表达式转后缀表达式，从左到右扫描\n\n   - 先扫描到操作数 A，直接加入后缀表达式\n   - 再扫描到运算符 ➕，由于栈是空栈，所以将运算符 ➕ 入栈\n   - 再扫描到操作数 B，直接加入后缀表达式\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-72.png\" style=\"zoom:70%;\" />\n\n2. 继续从左到右扫描\n\n   - 扫描到运算符 ➖，此时栈中有运算符 ➕，加号和减号的运算符优先级相同，则弹出 ➕，并加入后缀表达式，此时后缀表达式为 AB+，此时栈空，将运算符 ➖ 入栈\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-73.png\" style=\"zoom:70%;\" />\n\n3. 继续从左到右扫描\n\n   - 扫描到操作数 C，直接加入后缀表达式，此时后缀表达式为 AB+C\n   - 扫描到运算符 `*` ，栈中此时只有 ➖ 减法运算符，没有比乘法运算符优先级高的，所以将 `*` 压入栈中\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-74.png\" style=\"zoom:70%;\" />\n\n4. 继续从左到右扫描\n\n   - 扫描到操作数 D，直接加入后缀表达式，此时后缀表达式为 AB+CD\n   - 扫描到运算符`/`，此时栈中有 `*` `-` 两个运算符，乘法运算符和除法运算符优先级相同，所以将 `*` 乘法运算符弹出，并加入后缀表达式，此时后缀表达式为 AB+CD*\n   - 此时栈中只剩下 `-` 减法运算符，没有比 `/` 除法运算符优先级更高或相同的了，所以将 `/` 除法运算符压入栈中\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-75.png\" style=\"zoom:70%;\" />\n\n5. 继续从左到右扫描\n\n   - 扫描到操作数 E，直接加入后缀表达式，此时后缀表达式为 AB+CD*E\n   - 扫描到运算符 ➕，此时栈中有 `/` `-` 两个运算符，依次弹出栈中优先级高于或等于 ➕ 加号运算符的所有运算符，所以将 `/` `-` 依次弹出并加入后缀表达式，此时后缀表达式为 AB+CD*E/-\n\n6. 继续从左到右扫描\n\n   - 扫描到操作数 F，直接加入后缀表达式，此时后缀表达式为 AB+CD*E/-F\n   - 扫描完成，将栈中剩余运算符弹出栈并加入后缀表达式，所以弹出 ➕ 运算符并加入后缀表达式，最终后缀表达式为AB+CD*E/-F+\n\n------\n\n**我们接着来看一个带有界限符的例子**：\n\n1. 如下图的中缀表达式转后缀表达式，从左到右扫描\n\n   - 扫描到操作数 A， 直接加入后缀表达式。\n   - 扫描到运算符 ➕，此时栈为空，所以入栈。\n   - 扫描到操作数 B，直接加入后缀表达式。\n   - 扫描到运算符 `*` ，此时栈中只有加法运算符 ➕，没有比 `*` 乘法运算符优先级更高或相同的，所以将 `*` 入栈。\n   - 扫描到左括号 `(` ，直接入栈。\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-76.png\" style=\"zoom:67%;\" />\n\n2. 继续从左到右扫描\n\n   - 扫描到操作数 C，直接加入后缀表达式。\n   - 扫面描到运算符 ➖，此时本该依次弹出运算符高于或等于 ➖ 运算符的所有运算符，但是由于碰到了左括号`(` ，所以停止进行弹出。将 ➖ 减法运算符压入栈中。\n   - 扫描到操作数 D，直接加入后缀表达式。\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-77.png\" style=\"zoom: 67%;\" />\n\n3. 继续从左到右扫描\n\n   - 扫描到右括号 `)` ，则依次弹出栈内运算符并加入后缀表达式，直到遇到左括号 `(` 为止。\n   - 所以先弹出 ➖ 运算符，加入后缀表达式。\n   - 再弹出左括号`(` ，但是**左括号不加入后缀表达式**。\n   - 所以此时后缀表达式为 ABCD-。\n   - 此时栈中运算符有 `*` `+`。\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-78.png\" style=\"zoom:67%;\" />\n\n4. 继续从左到右扫描\n\n   - 扫描到 ➖ 运算符，依次弹出优先级高于或者等于 ➖ 运算符并加入后缀表达式中\n   - 所以将 `*` `+` 运算符弹出并加入后缀表达式，此时后缀表达式为 ABCD-*+\n   - 然后将扫描到的 ➖ 运算符加入栈中\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-79.png\" style=\"zoom:67%;\" />\n\n5. 继续从左到右扫描\n\n   - 扫描到操作数 E，直接加入后缀表达式\n   - 扫描到运算符 `/` ，栈中没有优先级高于或者等于 `/` 除法运算符的，所以将 `/` 压入栈\n   - 扫描到 F，直接加入后缀表达式，此时后缀表达式为 ABCD-*+EF\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-80.png\" style=\"zoom:67%;\" />\n\n6. 最后将栈中剩余运算符依次弹出，并加入后缀表达式\n\n   - 所以最终的后缀表达式为：ABCD-*+EF/-\n\n#### 中缀表达式的计算(用栈实现)\n\n用栈实现中缀表达式的计算\n\n初始化两个栈，**操作数栈**和**运算符栈**。\n\n- 若扫描到操作数，则压入操作数栈\n- 若扫描到运算符或界限符，则按照 “中缀转后缀” 相同的逻辑压入运算符栈(<font color='orange'>期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈</font>)\n\n------\n\n我们来看一个例子:\n\n1. 我们从左向右扫描中缀表达式\n\n   - 扫描到操作数 A，压入操作数栈\n   - 扫描到运算符 ➕，此时栈为空，则压入栈\n   - 扫描到操作数 B，压入操作数栈\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-81.png\" style=\"zoom:67%;\" />\n\n2. 继续从左向右扫描\n\n   - 扫描到运算符 ➖，弹出栈中优先级高于或等于 ➖ 运算符的所有运算符\n     - 所以弹出 ➕ 运算符，并将扫描到的运算符 ➖ 压入运算符栈\n   - 每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈\n     - 所以弹出 B、A，运算结果为 A + B，然后将运算结果压回操作数栈。\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-82.png\" style=\"zoom:67%;\" />\n\n3. 继续从左向右扫描\n\n   - 扫面描到操作数 C，压入操作数栈中\n   - 扫描到运算符 `*` ，运算符栈中没有优先级高于或者等于 `*` 乘法运算符的，所以将 `*` 压入运算符栈\n   - 扫描到操作数 D，压入操作数栈中\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-83.png\" style=\"zoom:67%;\" />\n\n4. 继续从左向右扫描\n\n   - 扫描到运算符 `/`，弹出运算符优先级高于或者等于 `/` 除号运算符的所有运算符，并将扫描到的 `/` 压入运算符栈\n   - 运算符栈中此时有 `*` `-` 两个运算符，所以弹出 `*` 乘法运算符\n   - 每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈\n   - 所以弹出 D、C 两个操作数，并执行 * 运算，运算结果为 C * D，将运算结果压入操作数栈中\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-84.png\" style=\"zoom:67%;\" />\n\n5. 继续从左向右扫描\n\n   - 扫描到操作数 E，直接压入操作数栈\n   - 扫描到运算符 ➕，弹出运算符优先级高于或者 ➕ 加法运算符的所有运算符，并将扫描到的运算符 ➕ 压入运算符栈\n   - 所以将 / 除法运算符弹出，一个运算符弹出则需要两个操作数栈的栈顶元素弹出，运算结果为 (C*D)/E，然后将运算结果压入操作数栈\n   - 之后将 - 减法运算符弹出，一个一个运算符弹出则需要两个操作数栈的栈顶元素弹出，运算结果为 (A+B)-((C*D)/E) ,然后将运算结果压入操作数栈\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-85.png\" style=\"zoom:67%;\" />\n\n6. 继续从左向右扫描\n\n   - 扫描到操作数 F，直接压入操作数栈\n   - 扫描中缀表达式完成，运算符栈中还有 ➕ 运算符，弹出 ➕ 运算符，对应弹出两个操作数栈的栈顶元素进行计算，则最终结果为 (A+B)-((C*D)/E)+F\n\n### 栈在递归中的应用\n\n**函数调用的特点**：最后被调用的函数最先执行结束(LIFO)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-86.png\" style=\"zoom:75%;\" />\n\n例如，对于上述函数调用\n\n1. 开始运行main函数，将main函数里面的返回地址、实参、局部变量先压入栈中\n2. 执行func1函数，将其返回地址、实参、局部变量再压入栈中\n3. 执行func2函数，将其返回地址、实参、局部变量再压入栈中\n\n------\n\n计算正整数的阶乘n！\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-87.png\" style=\"zoom:67%;\" />\n\n```C\n// 计算正整数的阶乘n！\nint factorial(int n){\n    if(n==0 || n==1){\n        return 1;\n    }else{\n        return n*factorial(n-1);\n    }\n}\n\nvoid main(){\n    int x = factorial(10);\n    printf(x);\n    \n    return 0;\n}\n```\n\n递归算法可以把原始问题转换为属性相同，但规模较小的问题\n\n每进入一层递归，就将递归调用所需信息压入栈顶；每退出一层递归，就从栈顶弹出相应信息\n\n**缺点**：太多层递归可能会导致栈溢出\n\n### 队列在层次遍历中的应用\n\n树的层次遍历(在\"树\"章节)\n\n图的层次遍历(在\"图\"章节)\n\n### 队列在操作系统中的应用\n\n多个进程争抢着使用有限的系统资源时，FCFS(First Come First Service,**先来先服务**)是一种常用策略\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-88.png\" style=\"zoom:67%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-89.png\" style=\"zoom:67%;\" />\n\n### 习题\n\n- 【2009】为解决计算机主机与打印机之间速度不匹配的问题，通常设置一个打印数据缓冲区，主机将要输出的数据依次写入该缓冲区，而打印机则依次从该缓冲区中取出数据。该缓冲区的逻辑结构应该是→B\n\n  A 栈\n  B 队列\n  C 树\n  D 图 \n\n  > 这是典型的一种队列结构，一端放入另一端依次取出，也就是先进入的先取出\n\n- 执行什么操作时，需要使用队列作为辅助存储空间→B\n\n  A 查找散列（哈希）表\n  B 广度优先搜索图\n  C 前序（根）遍历二叉树\n  D 深度优先搜索图 \n\n- 【2012】已知操作符包括+、-、_、/、(和)。将中缀表达式`a + b - a * ( ( c + d) / e - f ) + g `转换为等价的后缀表达式`a b + a c d + e / f - * - g + `时，用栈来存放暂时还不能确定运算次序的操作符。若栈初始为空，则转换过程中同时保存在栈中的操作符的最大个数是 →5\n\n  > 写成伪代码是这样：\n  >\n  > ```C\n  > stack 操作符栈;\n  > for i=1 to n{\n  > \tif 当前操作符是操作数\n  > \t\t直接打印;\n  > \telse if 当前操作符是操作符{\n  > \t\tif 当前操作符是'('\n  > \t\t\t压入栈内;\n  > \t\telse if 当前操作符是')'\n  > \t\t\t不断弹出并打印栈顶元素直至栈顶为'(';\n  > \t\t\t弹出栈顶;\n  > \t\telse if 当前操作符优先级高于栈顶操作符 || 栈为空\n  > \t\t\t压入栈内;\n  > \t\telse\n  > \t\t\t不断弹出并打印栈顶元素直至栈顶优先级不大于当前元素;\n  > \t\t\t当前操作符入栈;\n  > \n  > \t}\n  > }\n  > 打印栈中剩余操作符; \n  > ```\n  >\n  > 优先级从低至高：(、+、-、*、/、^\n  >\n  > 回到本题，流程如下：（数字标明当前栈中元素个数）\n  >\n  > 1. 遇+，入栈，1个\n  > 2. 遇-，-的优先级不大于+，弹出+，压入-，1个\n  > 3. 遇 *， * 的优先级大于-，入栈，2个\n  > 4. 遇(，入栈，3个\n  > 5. 遇(，入栈，4个\n  > 6. 遇+，+的优先级大于(，入栈，5个\n  > 7. 遇)，弹出+，弹出(，3个\n  > 8. 遇/，/的优先级大于(，入栈，4个\n  > 9. 遇-，-的优先级不大于/，弹出/，压入-，4个\n  > 10. 遇)，弹出-，弹出(，2个\n  > 11. 遇+，+的优先级不大于*，弹出 *，压入+，2个\n  >\n  > 操作符遍历完毕，栈中最后自底而上为-和+，依次弹出。\n  >\n  > 综上，栈中元素最多的时候有5个\n\n- 【2014】假设栈初始为空，将中缀表达式 `a / b + ( c * d - e * f ) / g` 转化为等价 的后缀表达式的过程中，当扫描到 f 时，栈中的元素依次是 →`+ ( - *`\n\n  > 将中缀表达式转换为后缀表达式的算法思想如下：从左向右开始扫描中缀表达式；  \n  >\n  > 遇到数字时，加入后缀表达式；遇到运算符时：  \n  >\n  > a. 若为'('，入栈；  \n  >\n  > b. 若为')'，则依次把栈中的的运算符加入后缀表达式中，直到出现'('，从栈中删除'(' ；  \n  >\n  > c. 若为除括号外的其他运算符，当其优先级高于除'('以外的栈顶运算符时，直接入栈。否则从栈顶开始，依次弹出比当前处理的运算符优先级高和优先级相等的运算符，直到一个比它优先级低的或者遇到了一个左括号为止。  \n  >\n  > 当扫描的中缀表达式结束时，栈中的所有运算符依次出栈加入后缀表达式。\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-90.png\" style=\"zoom:67%;\" />\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-91.png\" style=\"zoom: 80%;\" />\n  >\n  > 由此可知，当扫描到f 的时候，栈中的元素依次是+(-*，选B。 \n  >\n  > 在此，再给出中缀表达式转换为前缀或后缀表达式的一种手工做法，以上面给出的中缀表达式为例： \n  >\n  > 第一步：按照运算符的优先级对所有的运算单位加括号。式子变成了：`((a/b)+(((c*d)-(e*f))/g))` \n  >\n  > 第二步：转换为前缀或后缀表达式。 \n  >\n  > 前缀：把运算符号移动到对应的括号前面，则变成了：`+(/(ab)/(-(*(cd)*(ef))g))` 把括号去掉：`+/ab/-*cd*efg` 前缀式子出现。 \n  >\n  > 后缀：把运算符号移动到对应的括号后面，则变成了：`((ab)/(((cd)*(ef)*)-g)/)+` 把括号去掉：`ab/cd*ef*-g/+` 后缀式子出现。 \n  >\n  > 当题目要求直接求前缀或后缀表达式时，这种方法会比上一种快捷得多。\n\n- 【2015】已知程序如下\n\n  ```C\n  int S(int n)\n  {\n      return (n<=0)?0:s(n-1) +n;\n  }\n  void main()\n  {\n      cout<<S(1);\n  }\n  ```\n\n  程序运行时使用栈来保存调用过程的信息，自栈底到栈顶保存的信息依次对应的是->\n\n  main()→S(1)→S(0)\n\n  > 1.程序执行顺序main()->S(1)->S(2)。 \n  >\n  > 2.函数在调用过程中PC（程序计数器）的操作是保护现场->将所有数据拷贝到栈->跳转到子函数 \n  >\n  > 3.根据栈的数据结构的特点（首先栈的数据结构是处理函数调用这个情况最好的办法），先入后出，因此，栈底为main()，栈顶为S(1)\n\n## 3.4 特殊矩阵和压缩存储\n\n### 数组的存储结构\n\n#### 一维数组的存储结构\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-92.png\" style=\"zoom:67%;\" />\n\n各数组元素大小相同，且物理上连续存放。\n\n因此，只需要知道其起始地址，就可以知道任何一个数组下标所对应元素的存放地址是多少。\n\n#### 二维数组的存储结构\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-93.png\" style=\"zoom:67%;\" />\n\n在内存空间中存储时，由于要进行线性存储，因此要将逻辑上的非线性给改变为线性的存储模式。因此，有两种存储策略：**行优先存储**、**列优先存储**。\n\n- 行优先：先存行，一行存完存第二行\n- 列优先：先存列，一列存完存第二列\n\n<font color='orange'>我们采用行优先或者列优先的存储方式存放二维数组，这样我们就可以通过二维数组的行号和列号来计算出这个元素所对应的存储地址。</font>\n\n##### 行优先\n\n我们来看行优先的一个例子\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-94.png\" style=\"zoom:70%;\" />\n\n(i*N+j)指的是 b[i] [j] 之前有多少个元素，每个元素再乘存储空间，就是 b[i] [j] 元素前面的存储空间\n\n再加上起始地址 LOC，就得到 b[i] [j] 的存储地址\n\n##### 列优先\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-95.png\" style=\"zoom:70%;\" />\n\n(j*M+i)指的是 b[i] [j] 之前有多少个元素, 每个元素再乘存储空间，就是 b[i] [j] 元素前面的存储空间\n\n再加上起始地址 LOC，就得到 b[i] [j] 的存储地址\n\n> M行N列的二维数组`b[M][N]`中，\n>\n> - 若按行优先存储，则`b[i] [j]`的存储地址 =`LOC + (i*N + j) * sizeof(ElemType)`\n>\n> 即每一行有多少个元素，乘它前面有多少行，再加上它位于第几列。\n>\n> - 若按列优先存储，则`b[i] [j]`的存储地址 =`LOC + (j*M + i) * sizeof(ElemType)`\n>\n> 即每一列有多少个元素，乘它前面有多少列，再加上它位于第几行。\n\n### 矩阵的存储\n\n#### 普通矩阵的存储\n\n最容易想到的就是用一个**二维数组存储**。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-96.png\" style=\"zoom: 85%;\" />\n\n#### 对称矩阵的压缩存储\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-115.png\" style=\"zoom: 80%;\" />\n\n> 由于上三角区和下三角区的数据是完全相同的，因此我们在存储数据的时候，只需要存储主对角线及上下某一个三角区即可。\n>\n> 以只存储**主对角线**与**下三角区**为例。\n>\n> 按**行优先**原则将各元素存入一维数组中。（第一行存1个数据，第二行存2个数据，第三行存3个数据…）\n\n策略：只存储主对角线 + 下三角区\n\n- 按行优先原则将各元素存入一维数组中，共存 (1+n)*n/2 个元素，由于一维数组下标从 0 开始，所以最后一个元素下标是 (1+n) * n/2 - 1\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-116.png\" style=\"zoom: 60%;\" />\n\n<font color='cornflowerblue'>我们最终的目的是将矩阵压缩存储后怎样才能方便使用</font>，这样我们就可以建立一个映射函数，矩阵下标 -> 一维数组下标，这样我们想要访问矩阵中某一行某一列的元素时，只需要通过映射函数一转，就可以知道它存放在一维数组的哪个位置。如何做呢？\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-117.png\" style=\"zoom:60%;\" />\n\n- 按行优先的原则，a[i] [j] 是第 (1+2+…+(i-1)) + j 个元素，但是由于一维数组下标是从 0 开始的，所以对应的一维数组下标为(1+2+…+(i-1)) + j -1\n\n\n- <font color='cornflowerblue'>但是如果我们想访问上三角区的元素呢？</font>虽然上三角区并没有进行存储，但是由于对称矩阵的特性，a[i] [j] = a[j] [i]，我们可以进行转换，相当于我们访问的仍然是下三角区的元素\n\n- 按列优先的原则，第一列存储n个元素，第二列存储n-1个元素，第三列存储n-2个元素，第(j-1)列总共有[n+(n-1)+(n-2)+…+(n-j+2)]个元素，所以a[i] [j] 是第 [[n+(n-1)+(n-2)+…+(n-j+2)]+(i-j)+1] 个元素\n\n\n#### 三角矩阵的压缩存储\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/co4-35.png\" style=\"zoom:55%;\" />\n\n策略：如图\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/co4-36.png\" style=\"zoom:55%;\" />\n\n<font color='cornflowerblue'>那我们如何用呢？</font>还是建立一个映射函数，这里的映射函数与对称矩阵的映射函数一样，不同的是如果我们访问上三角区常量，我们需要将其映射为一维数组的最后一个元素，因为**一维数组最后一个元素存储常量C**。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-118.png\" style=\"zoom:55%;\" />\n\n按行优先的原则，a[i] [j]前面有 i-1 行，第一行存储n个元素，第二行存储n-1个元素，第三行存储n-3个元素，第(i-1)行存储(n-i+2)个元素，所以a[i] [j]前面共有[[n+(n-1)+(n-2)+…+(n-i+2)+(j-i)]]个元素\n\n#### 三对角矩阵的压缩存储\n\n三对角矩阵，主对角线上的元素可以不为0，主对角线上元素的上下左右相邻元素也可以不为0，但是其余元素必须为0\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-119.png\" style=\"zoom: 55%;\" />\n\n按**行优先的原则**，只存储带状部分，除了第一行和最后一行为 2 个元素，其余行均为 3 个元素，所以总共需要存储 (3n-2) 个元素,由于数组下标默认从0开始，所以最后一个数组下标为 (3n-3)\n\n> 怎么把a(i,j)映射到与之对应的一维数组下标处？\n>\n> 若|i-j| >1，其值肯定是0。反之则去数组里面找。\n>\n> 按行优先的原则，a(i,j)是一维数组中的第几个元素？\n>\n> 它是第i行，在它前面有i-1行，共3(i-1)-1个元素。而且它是第i行的第j-i+2个元素。\n>\n> 所以a(i,j)是第2i+j-2个元素。数组下标若从0开始，则以上数字均需减1。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-120.png\" style=\"zoom:55%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-121.png\" style=\"zoom:55%;\" />\n\n> 反过来考虑，假设我们已知一维数组下标k，如何得知其在矩阵中的行、列，即i、j？\n>\n> 由于数组下标是从0开始的，因此下标k的元素是第k+1个元素。\n>\n> 第k+1个元素在第几行、第几列？\n>\n> 设其在第i行、第j列。\n>\n> 前i-1行共3(i-1)-1个元素。\n>\n> 所以显然，3(i-1)-1 < k+1 ≤ 3i-1\n>\n> 根据这个不等式，将i解出即可。同时j也轻易能够得出了。\n\n#### 稀疏矩阵的压缩存储\n\n##### 顺序存储——三元组\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-122.png\" style=\"zoom:55%;\" />\n\n显然，用这种方法存储稀疏矩阵的数据的话，若要访问某一行某一列的数据，就要从头顺序的依次扫描三元组，对其行号、列号遍历，直到查找到目标。就不具备随机存取的特性了。\n\n##### 链式存储——十字链表法\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-123.png\" style=\"zoom:55%;\" />\n\n在“上侧”定义一个数组，用来存放每一列的指针，叫做**向下域**（down），指向第j列的第一个元素；\n\n在“左侧”定义一个数组，用来存放每一行的指针，叫做**向右域**（right），指向第i行的第一个元素。\n\n每个非零元素成为一个数据结点，被存放着。\n\n（也就是向下域、向右域都指向当前列/行的第一个非零数据所形成的数据结点）\n\n其中，每个非零数据结点，除存放三元组（**行，列，值**）外，还存放两个指针，分别指向**同列的下一个元素**、**同行的下一个元素**。\n\n### 习题\n\n- 【2016】有一个100阶的三对角矩阵M，其元素m{i,j}(1<=i,j<=100),按行优先依次压缩存入下标从0开始的一维数组N中。元素m{30,30} 在N中的下标是→87\n\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-111.png\" style=\"zoom: 50%;\" />\n\n- 【2017】适用于压缩存储稀疏矩阵的两种存储结构是-->A\n\n  A 三元组表和十字链表\n\n  B 三元组表和邻接矩阵\n\n  C 十字链表和二叉链表\n\n  D 邻接矩阵和十字链表\n\n  > 三元组表的结点存储了行row、列col、值value三种信息，是主要用来存储稀疏矩阵的一种数据结构。十字链表将行单链表和列单链表结合起来存储稀疏矩阵。邻接矩阵空间复杂度达O(n2)，不适于存储稀疏矩阵。二叉链表又名左孩子右兄弟表示法，可用于表示树或森林。\n\n- 【2018】设有一个12x12的对称矩阵M，将其上三角部分的元素m{i,j}(1<=i<=j<=12)按行优先存入C语言的一维数组N中，元素m{6,6}在N中的下标是-->50\n\n  > 上三角矩阵从第一行开始元素数量依次是：**12，11，10，9，8，7，6，5，4，3，2，1**，m6,6表示上三角区域的第**6**行第**1**个，所以m6,6为第51个元素，占数组位置为a[50]。\n\n- 【2020】将一个10x10对称矩阵M的上三角部分的元素m{i,j}(1<=i<=j<=10)按列优先存入C语言的一维数组N中，元素𝑚{7,2}在 N 中的下标是-->22\n\n  > 上三角矩阵列优先的存储模式：先存储具有一个元素第一列，再存储具有两个元素 的第二列，以此类推\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-109.png\"  />\n  >\n  > 𝑚{7,2} 说明 1-6 列均已存满，，故此元素是第 1+2+3+4+5+6+2 个被存储单元 \n  >\n  > 【注意】C 语言数组的下标从 0 开始 故𝑚7,2在 N 中的下标为 23-1=22，即 N[22]\n\n- 【2021】二维数组A按行优先方式存储，每个元素占用1个存储单元。若元素A[0] [0]的存储地址是100，A[3] [3]的存储地址是220，则元素 A[5] [5] 的存储地址是->300\n\n  > 二维数组A按行优先存储，每个元素占用1个存储单元，由A[0] [0]和A[3] [3]的存储地址可知A[3] [3]是二维数组A的第121个元素，假设二维数组A的每行有n个元素，则nx3+4=121,则n=39,故元素A[5] [5]的存储地址为100+39x5+6-1=300\n","tags":["408数据结构"],"categories":["408数据结构"]},{"title":"第三章 栈、队列和数组(上)","url":"/p/63528/","content":"\n## 3.1 栈 Stack\n\n### 栈的基本概念\n\n- 栈的定义\n\n  - 栈是<font color='orange'>只允许在一端进行插入或删除操作的线性表</font>。限定这种线性表只能在某一端进行插入和删除操作。\n\n    - 栈顶:线性表允许进行插入删除的那一端。\n    - 栈底:固定的，不允许进行插入和删除的另一端。\n    - 空栈:栈里没有存任何数据元素，相当于线性表的空表。\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-2.svg\"  />\n\n  - **特性**：后进先出 Last In First Out, LIFO\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-1.png\" style=\"zoom: 75%;\" />\n\n    \n\n  - 栈的数学性质：卡特兰数 Catalan Number\n\n    卡特兰数一般可用于这种结论:n个不同元素进栈，出栈元素不同排列的个数为:\n\n    - $$\n      \\frac 1{n+1}C^n_{2n}\n      $$\n\n    所以，如果像上面那样有五个元素进栈，那么所有合法的出栈顺序有:\n    $$\n    \\frac 1{5+1}C^5_{10}=42\n    $$\n    可见，即使只有5个元素进栈，合法的出栈顺序就有42种，就很多了。所以考试题基本不会让你全部写出所有的，而是以选择题的形式让你选出一个合法的出栈顺序。\n\n### 栈的基本操作\n\n- InitStack(&S)：<font color='red'>初始化</font>栈操作。构造一个空栈S，分配内存空间。\n- DestroyStack(&S)：<font color='red'>销毁</font>栈操作，并<font color='red'>释放</font>栈S所占的内存空间\n- StackEmpty(S)：判定S是否为空栈。空，则返回ture,否则返回false\n- StackLength(S)：求栈的长度 [cpp::std::stack::size](https://cplusplus.com/reference/stack/stack/size/)\n- GetTop(S, &e)：取栈顶元素 [cpp::std::stack::top](https://cplusplus.com/reference/stack/stack/top/)\n- ClearStack(&S)：栈置空操作 [cpp::std::stack::empty](https://cplusplus.com/reference/stack/stack/empty/)\n- Push(&S, e)：入栈操作（压栈）[cpp::std::stack::push](https://cplusplus.com/reference/stack/stack/push/)\n- Pop(&S, &e)：出栈操作（弹栈）\n\n### 栈的顺序存储结构\n\n- 结点的类型定义\n\n  ```C\n  #define MAXSIZE 100 //定义栈中元素的最大个数\n  typedef struct {\n    ElemType data[MAXSIZE];//静态数组存放栈中元素\n    int top;  // 栈顶指针\n  } SqStack;\n  \n  void testStack(){\n  \tSqStack S;\t//声明一个顺序栈\n  \t//......\n  }\n  ```\n\n  栈顶指针：S.top，初始时设置 S.top = -1;\n\n  栈顶元素：s.data[s.Top]；\n\n  进栈操作：栈不满时，栈顶指针先加1，再送值到栈顶元素。\n\n  出栈操作：栈非空时，先去栈顶元素值，再将栈顶指针减1。\n\n  栈空条件：S.top == -1；\n\n  栈满条件：S.top == MaxSize-1;\n\n  栈长：S.top +1 。\n\n  此类一开始分配了最大空间的顺序栈要对栈溢出有相应的处理机制。\n\n- 顺序栈的基本运算\n\n  - 初始化`InitStack(&S)`:初始化栈，构造一个空栈S，分配内存空间\n\n    初始化栈就是让栈顶指针 top 指向 -1，因为栈顶指针指向的是栈顶元素，开始的时候没有元素，所以栈顶指针指向 0 这个位置是不合适的\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-3.png\" style=\"zoom: 75%;\" />\n\n  - 判栈空`StackEmpty(S)`:如上图，由于栈空的时候，数组中是没有任何元素的。如果要让栈顶指针指向0，显然是不合适的。所以空栈让栈顶指针的值为-1。因此，判断是否栈空时，只需要判断它的栈顶指针top是否等于-1就可以。\n\n  - 进栈`Push(&S,x)`:进栈，若栈S未满，则将 x 加入使之成为新栈顶；进栈时先让栈顶指针 top 加一，之后将新元素放在 top 指针所指向的位置\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-4.png\" style=\"zoom: 75%;\" />\n\n    或者写的更简洁一点，如下。\n\n    ```C\n    //新元素入栈\n    bool Push(SqStack &S, ElemType x) {\n    \tif(S.top == MaxSize-1) return false;\t//栈满，报错\n    \tS.data[++S.top] = x;\t//合并两句 \n    \treturn true; \n    }\n    ```\n\n  - 出栈`Pop(&S,&x)`:出栈，若栈S非空，则弹出栈顶元素，并用x返回\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-5.png\" style=\"zoom:75%;\" />\n\n    同上文，此处也可以将其中两句合并成一句更简洁的写法，如下\n\n    ```C\n    //出栈操作\n    bool Pop(SqStack &S, ElemType &x) {\n    \tif(S.top == -1) return false;\t//栈空，报错\n    \tx = S.data[S.top--];\t//合并两句\n    \treturn true; \n    }\n    ```\n\n  - 读栈顶元素`GetTop(S,&x)`:读取栈顶元素，若栈 S 非空，则用 x 返回栈顶元素\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-6.png\" style=\"zoom: 75%;\" />\n\n- 另一种操作方式\n\n  **初始化**时，令栈顶指针指向0，而不是-1。\n\n  ```C\n  #define MaxSize 10\n  typedef struct {\n  \tElemType data[MaxSize];\n  \tint top;\n  }SqStack; \n  \n  //初始化栈\n  void InitStack(SqStack &S) {\n  \tS.top = 0;\t//初始指向0 \n  }\n  \n  //判断栈空\n  bool StackEmpty(SqStack S) {\n  \tif(S.top == 0) return true;//此时注意栈空条件\n  \telse return false;\n  }\n  ```\n\n  **进栈、出栈**时。\n\n  ```C\n  //新元素入栈\n  bool Push(SqStack &S, ElemType x) {\n  \tif(S.top == MaxSize) return false;\t//判断栈满的条件不同\n  \tS.data[S.top++] = x;\t//赋值操作与指针移动操作顺序不同\n  \treturn true; \n  }\n  //出栈操作\n  bool Pop(SqStack &S, ElemType &x) {\n  \tif(S.top == 0) return false;\n  \tx = S.data[--S.top];\n  \treturn true; \n  }\n  ```\n\n  > 栈顶指针为-1和0的区别\n  > 在遇到相关问题时，一定要注意看清初始化栈顶指针的值。\n  > （1）当初始化为-1时，栈顶指针指向的是当前栈中的实际位置，而当初始化为为0时，栈顶指针指向的是下一次要插入的位置。\n  > （2）在进行入栈和出栈的操作时，二者核心操作是相反的。\n  > （3）在获取栈顶元素的操作中，如果初始化栈顶为0，那么需要先对指针减1才能取到栈顶元素的值，这点与初始化栈顶为-1时的操作有所不同。并且，如果函数定义中参数使用了引用传递，那么栈顶指针还需要再加1，保持栈顶指针原来的位置。如果使用值传递，则不需要，因为值传递不会改变原来的栈。\n\n- 共享栈\n\n  **顺序栈的缺点**：栈的大小不可变。\n\n  - 可以用链式存储的方式进行存储。\n  - 也可以在初始化的时候就声明一个较大的存储空间。\n\n  > 但我们知道，若一开始就申请较大空间的话，会造成空间的浪费。但是，我们可以通过**共享栈**的方式，来提高这一大片内存空间的利用率。\n  >\n  > 共享栈的意思就是，两个栈共享同一片空间。\n\n  我们可以设置两个栈顶指针。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-7.png\" style=\"zoom:75%;\" />\n\n  如果要往0号栈存放数据元素的话，是由下到上依次递增的；\n\n  如果要往1号栈存放数据元素的话，是由上到下依次递减的。\n\n  这两个栈，从逻辑上来说是两个不同的栈，但是在物理上，它们又共享同一片存储空间。这样就提高了空间利用率。\n\n  共享栈也是会满的。判断共享栈是否满了的条件，就是看`top0 + 1 == top1`\n\n  [一文搞懂共享栈](https://www.cxymm.net/article/zag666/105600288)\n\n<font color='green'>用一个数组实现两个栈</font>\n\n**思路**:从 **两头开始向中间生长**，当两个栈的 **栈顶指针相遇** 时，表示两个栈都满了\n\n```C\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAXSIZE 100\n#define ElementType int\n#define ERROR -1\n\nstruct DStack {\n    ElementType Data[MAXSIZE];\n    int Top1;  // 栈 1 的栈顶指针\n    int Top2;  // 栈 2 的栈顶指针\n} S;\n\nvoid Push(struct DStack* PtrS, ElementType item, int Tag) {\n    /* Tag 作为区分两个堆栈的标志，取值为 1 和 2 */\n    if (PtrS->Top2 - PtrS->Top1 == 1) {\n        printf(\"栈满\\n\");\n        return;\n    }\n    if (Tag == 1) {\n        PtrS->Data[++(PtrS->Top1)] = item;\n    } else {\n        PtrS->Data[--(PtrS->Top2)] = item;\n    }\n}\n\nElementType Pop(struct DStack* PtrS, int Tag) {\n    /* Tag 作为区分两个堆栈的标志，取值为 1 和 2 */\n    if (Tag == 1) {\n        if (PtrS->Top1 == -1) {\n            printf(\"栈1空\\n\");\n            return NULL;\n        } else {\n            return PtrS->Data[(PtrS->Top1)--];\n        }\n    } else {\n        if (PtrS->Top2 == MAXSIZE) {\n            printf(\"栈2空\\n\");\n            return NULL;\n        } else {\n            return PtrS->Data[(PtrS->Top2)++];\n        }\n    }\n}\n```\n\n### 栈的链式存储结构\n\n- 采用链式存储的栈称为<font color='purple'>链栈</font>，其优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况\n\n- 结点的类型定义\n\n  ```C\n  typedef struct StackNode {\n    SElemType data;\n    struct StackNode *next;\n  } StackNode, *LinkStack;\n  ```\n\n  进栈和出栈操作就对应于单链表的插入和删除操作（只在头结点那一端进行）。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-112.png\" style=\"zoom:55%;\" />\n\n  那么对于单链表在头结点处的插入删除，我们在第二章已经讲的很详细了，这里就不再赘述。\n\n  和单链表类似。对于链栈，我们也可以实现**带头结点**的版本，和**不带头结点**的版本，道理同单链表是一样的。\n\n- 初始化\n\n  ```C\n  Stack CreateStack() {\n      /* 构建一个栈的头结点，返回指针 */\n      Stack S;\n      S = (Stack)malloc(sizeof(struct SNode));\n      S->next = NULL;\n      return S;\n  }\n  ```\n\n- 入栈\n\n  ```C\n  void Push(ElementType item, Stack S) {\n      /* 将元素 item 压入栈 S */\n      struct SNode* TmpCell;\n      TmpCell = (struct SNode*)malloc(sizeof(struct SNode));\n      TmpCell->Data = item;\n      TmpCell->next = S->next;\n      S->next = TmpCell;\n  }\n  ```\n\n- 出栈\n\n  ```C\n  ElementType Pop(Stack S) {\n      /* 删除并返回栈 S 的栈顶元素 */\n      struct SNode* FirstCell;\n      ElementType TopElem;\n      if (IsEmpty(S)) {\n          printf(\"栈空\\n\");\n          return;\n      } else {\n          FirstCell = S->next;\n          S->next = FirstCell->next;\n          TopElem = FirstCell->Data;\n          free(FirstCell);\n          return TopElem;\n      }\n  }\n  ```\n\n- 判栈空\n\n  ```C\n  int IsEmpty(Stack S) {\n      /* 判断栈 S 是否为空，若为空函数返回整数 1，否则返回 0 */\n      return (S->next == NULL);\n  }\n  ```\n\n###  习题\n\n- 【2010】若元素 abcdef 依次进栈，允许出栈、退栈操作交替进行，但不允许连续 3 次进行退栈操作，不可能得到的出栈序列是→D\n\n  A. d c e b f a\n  B. c b d a e f\n  C. b c a e f d\n  D. a f e d c b\n\n  > 选项A,可由a入栈，b入栈，c入栈，d入栈，<font color='red'>d出栈</font>，<font color='red'>c出栈</font>，e入栈，<font color='red'>e出栈</font>，<font color='red'>b出栈</font>，f入栈，<font color='red'>f出栈</font>，<font color='red'>a出栈</font>得到\n  >\n  > 选项B,可由a入栈，b入栈，c入栈，<font color='red'>c出栈</font>，<font color='red'>b出栈</font>，d入栈，<font color='red'>d出栈</font>，<font color='red'>a出栈</font>，e入栈，<font color='red'>e出栈</font>，f入栈，<font color='red'>f出栈</font>得到\n  >\n  > 选项C，可由a入栈，b入栈，<font color='red'>b出栈</font>，c入栈，<font color='red'>c出栈</font>，<font color='red'>a出栈</font>，d入栈，e入栈，<font color='red'>e出栈</font>，f入栈，<font color='red'>f出栈</font>，<font color='red'>d出栈</font>得到\n  >\n  > 选项D，可由a入栈，<font color='red'>a出栈</font>，b入栈，c入栈，d入栈，e入栈，f入栈，<font color='red'>f出栈</font>，<font color='red'>e出栈</font>，<font color='red'>d出栈</font>，<font color='red'>c出栈</font>，<font color='red'>b出栈</font>得到  但不允许连续3次退栈\n\n- 【2009】设栈S和队列Q的初始状态均为空，元素abcdefg依次进入栈S。若每个元素出栈后立即进入队列Q，且7个元素出队的顺序是bdcfeag，则栈S的容量至少是-->3\n\n  > 由于**队列的特点是先进先出**，即栈S的出栈顺序就是队Q的出队顺序。故本题只需注意栈的特点是先进后出。出入栈的详细过程见下表。\n  >\n  > | 序号 | 说明  | 栈内 | 栈外 | 序号 | 说明  | 栈内 | 栈外    |\n  > | ---- | ----- | ---- | ---- | ---- | ----- | ---- | ------- |\n  > | 1    | a入栈 | a    |      | 8    | e入栈 | ae   | bdc     |\n  > | 2    | b入栈 | ab   |      | 9    | f入栈 | aef  | bdc     |\n  > | 3    | b出栈 | a    | b    | 10   | f出栈 | ae   | bdcf    |\n  > | 4    | c入栈 | ac   | b    | 11   | e出栈 | a    | bdcfe   |\n  > | 5    | d入栈 | acd  | b    | 12   | a出栈 |      | bdcfea  |\n  > | 6    | d出栈 | ac   | bd   | 13   | g入栈 | g    | bdcfea  |\n  > | 7    | c出栈 | a    | bdc  | 14   | g出栈 |      | bdcfeag |\n  >\n  > 栈内的最大深度为3，故栈S的容量至少是3。\n  >\n  > 【另解】元素的出栈顺序是b，d，c，f，e，a，g，可推出进栈出栈顺序为Push(S,a)，Push(S,b)，Pop(S,b)，Push(S,c)，Push(S,d)，Pop(S,d)，Pop(S,c)，Push(S,e)，Push(S,f)，Pop(S,f)，Pop(S,e)，Pop(S,a)，Push(S,g)，Pop(S,g)。假设初始所需容量为0，每做一次Push进行一次“+1”操作，每做一次Pop进行一次“-1”操作，记录容量的最大值为3。\n\n- 【2011】元素a,b,c,d,e依次进入初始为空的栈中，若元素进栈后可停留、可出栈，直到所有元素都出栈，则在所有可能的出栈序列中，以元素d开头的序列个数是-->4\n\n  > 考虑到题目要求是d先出栈，所以abcd的入栈顺序已经确定，e的入栈和出栈决定有几种顺序。 \n  >\n  > 1.abcd依次入栈，d出栈，e入栈，然后剩下的出栈顺序为ecba \n  >\n  > 2.abcd依次入栈，d出栈，c出栈，e入栈，e出栈，剩下的出栈顺序ba \n  >\n  > 3.abcd依次入栈，d出栈，c出栈，b出栈，e入栈，e出栈，a出栈 \n  >\n  > 4.abcd依次入栈，d出栈，c出栈，b出栈，a出栈，e入栈，e出栈，a出栈\n\n- 【2013】一个栈的入栈序列为1,2,3,...,n,出栈序列是P1,P2,P3,...,Pn。若P2 = 3，则 P3 可能取值的个数是-->(n-1)个\n\n  > 首先，栈的先进后出原则大家应该是知道的。\n  >\n  > 根据题意 P2 = 3，可以知道P1的可能情况有三种：**1,2或4** 。（看到有些人只想到了1，2）\n  >\n  > 为啥这样想呢？这里估计还有一个关键是要**考虑到 n 的大小**。\n  >\n  > **当 n = 3 时**， P2 = 3 的话，那么 P1 有两种情况 1 和 2 。\n  >\n  > - 如果 P1 = 1 ，那么 P3 = 2 ；\n  > - 如果 P1 = 2 ，那么 P3 = 1 ；\n  >\n  > 此时的话我们就可以看到 P3 只有两种可能 1或者2       （n - 1）个。\n  >\n  > **当 n > 3 时**： P2 = 3 的话，那么 P1 有三种情况1,2和4。\n  >\n  > - 如果 P1 = 1 ，那么 P3 = 2，4，5，...  n     （n - 2）个    \n  > - 如果 P1 = 2 ，那么 P3 = 1，4，5，...  n     （n - 2）个    \n  > - 如果 P1 = 4 ，那么 P3 = 2，5，6，...  n     （n - 3）个  \n  >\n  > 此时的话我们就可以看到 P3 的情况有 1，2，4，5，... n （n - 1）个。\n  >\n  > 综上所述就是 P3 可能取值的个数是 （n - 1）个。\n\n- 【2017】下列关于栈的叙述中，错误的是->I、Ⅲ、Ⅳ\n\n  Ⅰ．采用非递归方式重写递归程序时必须使用栈 \n\n  Ⅱ．函数调用时，系统要用栈保存必要的信息 \n\n  Ⅲ．只要确定了入桟次序，即可确定出栈次序\n\n  Ⅳ．栈是一种受限的线性表，允许在其两端进行操作\n\n  > I. 尾递归可以直接使用循环\n  >\n  > II.确定了入桟次序，不能确定出栈次序\n  >\n  > IV．栈是一种受限的线性表，允许在其一端（栈顶）进行操作\n\n- 【2018】若栈S1中保存整数，栈S2中保存运算符，函数F()依次执行下述各步操作:\n\n  （1）从S1中依次弹出两个操作数a和b；\n  （2）从S2中弹出一个运算符op；\n  （3）执行相应的运算b op a；\n  （4）将运算结果压入S1中。\n\n    假定S1中的操作数依次是5,8,3,2（2在栈顶），S2中的运算符依次是*,-,+（+在栈顶） \n\n    调用3次F()后，S1栈顶保存的值是-->15\n\n  > S1第一次弹出a,b 即 2,3  S2 弹出 “ +”  操作为 b + a  即 （3 + 2） 压入 S1 现在 S1 为 5 8 5 \n  >\n  > S1第二次弹出a,b 即 5，8 S2弹出\"-\" 操作为 b - a 即（8-5）压入S1 现在 S1 为 5 3 \n  >\n  > S1第三次弹出a,b 即 3,5  S2弹出 “*” 操作为 b*a  即 5*3 压入S 现在S1 为 15\n  > 所以三次后S1 栈顶为15\n\n- 【2020】对空栈S进行Push和Pop操作，入栈序列为a,b,c,d,e，经过Push，Push，Pop，Push，Pop，Push，Push，Pop 操作后得到的出栈序列是-->b,c,e\n\n  > 根据题意，出入栈操作的过程如下:\n  >\n  > | 操作 | 栈内元素 | 出栈元素 |\n  > | ---- | -------- | -------- |\n  > | Push | a        |          |\n  > | Push | a b      |          |\n  > | Pop  | a        | b        |\n  > | Push | a c      |          |\n  > | Pop  | a        | c        |\n  > | Push | a d      |          |\n  > | Push | a d e    |          |\n  > | Pop  | a d      | e        |\n  >\n  > 所以出栈元素序列为b,c,e\n\n## 3.2 队列 Queue\n\n### 队列的基本概念\n\n### 队列的定义\n\n- 队列简称队，也是一种操作受限的线性表，<font color='orange'>只允许在表的一端进行插入，而在表的另一端进行删除</font>\n\n- 向队列中插入元素称为**入队**或**进队**\n\n- 删除元素称为**出队**或**离队**\n\n- 特性：先进先出 First In First Out, FIFO\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-8.png\" style=\"zoom: 75%;\" />\n\n### 队列常见的基本操作\n\n- InitQueue(&Q)：初始化队列。\n- DestoryQueue(&Q)：销毁队列。并释放队列Q所占用的内存空间。\n- ClearQueue(&Q)：清空队列。\n- QueueLength(Q)：求队列长度。\n- GetHead(Q,&e)：得到队头元素，若队列Q非空，则将队头元素赋值给e。\n- EnQueue(&Q, e)：入队，若队列Q未满，将e加入，使之成为新的<font color='purple'>队尾</font>font>。\n- DeQueue(&Q, &e)：出队，若队列Q非空，删除<font color='purple'>队头</font>font>元素，并用e返回。\n- QueueEmpty(Q)：判队列空，若队列Q为空返回true，否则返回false。\n\n### 队列的顺序存储结构\n\n#### 队列的顺序存储\n\n队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针：队头指针front指向队头元素。队尾指针rear指向队尾元素的下一个位置（其实和单链表有无头结点是一样的，队尾指针你想指向最后一个元素或者最后一个元素的下一位都行，注意相应的操作随之变动就行）。\n\n- **结点类型定义**\n\n  ```C\n  #define MAXSIZE 100 // 最大队列长度\n  typedef struct{\n      QElemType *base; // 初始化的动态分配存储空间\n      int front;       // 队头指针\n      int rear;        // 队尾指针\n  } SqQueue;\n  void testQueue(){\n      SqQueue Q;\t//声明一个队列（顺序存储）\n      //......\n  }\n  ```\n\n  初始状态（队空条件）：Q.front == Q.rear == 0。\n\n  进队操作：队不满时，先送值到队尾元素，再将队尾指针加1。\n\n  出队操作：队不空时，先去队头元素值，再将队头指针加1。\n\n- **初始化操作**\n\n  `InitQueue(&Q)` : 初始化队列，构造一个空队列 Q\n\n  我们可以规定，让队头指针指向队头元素；让队尾指针指向队尾元素的后一个位置（接下来应该插入数据元素的位置）。那么在初始化的时候，我们可以令队头、队尾指针均指向0。\n\n  ```C\n  #define MaxSize 10\t\t\t\t\t// 定义队列中元素的最大个数\n  typedef struct {\n      ELemType data[MaxSize];\t\t\t// 用静态数组存放队列元素\n      int front,rear;\t\t\t\t\t// 队头指针和队尾指针\n  }SqQueue;\n  \n  // 初始化队列\n  void InitQueue(SqQueue &Q){\n      // 初始时,队头、队尾指针指向0\n      Q.rear = Q.front = 0;\n  }\n  ```\n\n  - 队头指针 front 指向队头元素\n\n  - 队尾指针 rear 指向队尾元素的后一个位置(下一个应该插入的位置)\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-15.png\" style=\"zoom: 50%;\" />\n\n- **判断队列是否为空**\n\n  `QueueEmpty(Q)` : 判断队列是否为空，若队列Q为空则返回 true，否则返回 false\n\n  ```C\n  // 判断队列是否为空\n  bool QueueEmpty(SqQueue Q){\n      if(Q.rear == Q.front){\t\t\t// 队空条件\n          return true;\n      }else{\n          return false;\n      }\n  }\n  ```\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-16.png\" style=\"zoom: 50%;\" />\n\n- **入队操作**\n\n  `EnQueue(&Q,x)` : 入队，若队列 Q 未满，将 x 加入，使之称为新的队尾\n\n  只能从队尾入队。把这一次要插入的数据元素，把它放到队尾指针所指向的位置。把队尾指针加1。\n\n  ```C\n  //入队\n  bool EnQueue(SqQueue &Q, ElemType x) {\n  \tif(队列已满) return false;\t//队满则报错\n  \tQ.data[Q.rear] = x;\t//将x插入队尾\n  \tQ.rear = Q.rear + 1;\t//队尾指针后移\n  \treturn true; \n  }\n  ```\n\n  <font color='cornflowerblue'>那么我们是否可以认为，队列已满的条件，就是`rear == MaxSize`呢？</font>\n\n  并不是这样。\n\n  因为，在`rear == MaxSize`的情况下，若队头出队了一些元素，则队列显然不满。但rear仍然是等于MaxSize的。\n\n  同时，接下来的新元素，是要插入到队头元素之前的空位当中的。\n\n  <font color='cornflowerblue'>那么怎样让队尾指针指向接下来要插入的队头元素前的空位处呢？</font>\n\n  只需进行一个**取余操作**即可。\n\n  看下列图\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-17.png\" style=\"zoom:55%;\" />\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-19.png\" style=\"zoom:55%;\" />\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-20.png\" style=\"zoom:55%;\" />\n\n  所以队尾指针 rear 其实是从队头指向队尾，再从队尾指向队头，这样循环移动。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-21.png\" style=\"zoom:55%;\" />\n\n  这样使用模运算将存储空间在逻辑上变成了 “**环状**”，我们也称之为<font color='red'>循环队列</font>(稍后引出)\n\n  ```C\n  #define MaxSize 10\t\t\t\t\t// 定义队列中元素的最大个数\n  typedef struct {\n    ELemType data[MaxSize];\t\t\t// 用静态数组存放队列元素\n      int front,rear;\t\t\t\t\t// 队头指针和队尾指针\n  }SqQueue;\n  \n  // 入队\n  bool EnQueue(SqQueue &Q,ElemeType x){\n      if((Q.rear + 1)%MaxSize == Q.front){\t// 判断队满\n          return false;\t\t\t\t\t\t// 队满则报错\n      }\n      Q.data[Q.rear] = x;\t\t\t\t\t\t// 将 x 插入队尾\n      Q.rear = (Q.rear + 1)%MaxSize;\t\t\t// 队尾指针加1取模,用模运算将存储空间在逻辑上变成了\"环状\"\n      return true;\n  }\n  ```\n\n  那么此时就可以知道，队列已满的条件为：队尾指针的下一个位置是队头，即`(Q.rear + 1) % MaxSize == Q.front`。\n\n  > 此处，有些人会认为。队尾指针指向的就是“接下来应该插入元素的位置”，也就是队尾指针指向的位置是一个空闲空间。**那么为什么队尾指针所指向的位置的下一个是队头时，就判满了呢？**不是还有一个空间空间吗？如果“真正满了”的话，应该是队尾指针指向队头指针呀。\n  >\n  > 要知道，队尾指针和队头指针相等，那是我们在初始化队列的时候，让队头指针和队尾指针指向同一个位置的。此外，我们也根据队尾指针与队头指针是否指向同一个位置，来判断队列是否为空。\n\n  > 这样就没办法。所以我们必须牺牲一个存储单元。来将判满与判空区分开来。\n\n- **出队操作**\n\n  `DeQueue(&Q,&x)` : 出队，若队列 Q 非空，删除队头元素，并用 x 返回\n\n  只能从队头出队\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-110.png\" style=\"zoom: 33%;\" />\n\n  ```C\n  #define MaxSize 10\t\t\t\t\t// 定义队列中元素的最大个数\n  typedef struct {\n      ELemType data[MaxSize];\t\t\t// 用静态数组存放队列元素\n      int front,rear;\t\t\t\t\t// 队头指针和队尾指针\n  }SqQueue;\n  \n  // 出队(删除一个队头元素,并用 x 返回)\n  bool DeQueue(SqQueue &Q,ElemType &x){\n      if(Q.rear ==Q.front){\t\t\t\t\t// 判断队空\n          return false;\t\t\t\t\t\t// 队空则报错\n    }\n      X = Q.data[Q.front];\n      Q.front = (Q.front +1)%MaxSize;\t\t\t// 队头指针后移\n      return true;\t\t\t\t\n  }\n  ```\n\n- **获得队头元素值**\n\n  `GetHead(Q,&x)` ：读取队头元素，若队列Q非空，则将队头元素\n\n  ```C\n  #define MaxSize 10\t\t\t\t\t// 定义队列中元素的最大个数\n  typedef struct {\n      ELemType data[MaxSize];\t\t\t// 用静态数组存放队列元素\n      int front,rear;\t\t\t\t\t// 队头指针和队尾指针\n  }SqQueue;\n  \n  // 获得队头元素的值,用 x 返回\n  bool GetHead(SqQueue Q,ElemType &x){\n      if(Q.rear == Q.front){\t\t\t// 判断队空\n          return false;   \t\t\t// 队空则报错\n      }\n      X = Q.data[Q.front];\t\t\t// 获得队头元素值\n      return true;\n  }\n  ```\n\n- **假溢出**\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-11.png\" style=\"zoom:67%;\" />\n\n  (a)所示为队列的初始状态，有Q.front == Q.front == 0成立，该条件可以作为队列判空的条件。但能否用Q.rear == MaxSize作为队列满的条件呢？显然不能，图(d)中，队列中仅有一个元素，但仍然满足该条件，这时队列出现“上溢出”，按理说，此时就不能将其他元素加入队列。但这种溢出并不是真正的溢出，在data数组中仍然存在可以存放元素的空位置，所以这是一种“<font color='red'>假溢出</font>”。\n\n#### 循环队列\n\n为了解决顺序队列的“<font color='red'>假溢出</font>”也就是空间只能用一次，严重浪费的问题，我们引出一个**循环队列**的概念。\n\n循环队列就是将顺序队列臆造为一个环状的空间，即把存储队列元素的表从逻辑上视为一个环（用链表来的指针来向下会清晰很多），称为循环队列。当队首指针`Q.front=MaxSize-1`后，再前进一个位置就自动到0，实现上可以用取余来实现。\n\n初始时：`Q.front = Q.rear = 0`;\n\n队首指针进1：`Q.front = (Q.front+1)%MaxSize`\n\n队尾指针进1：`Q.rear = (Q.rear+1)%MaxSize`\n\n对列长度：`（Q.rear+MaxSize-Q.front）%MaxSize`\n\n出队入队时：指针都按顺时针方向进1。\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-12.png\" style=\"zoom:67%;\" />\n\n根据我们前面所述，队空的时候：`Q.front = Q.rear`；那这样的话考虑一下队满的时候咋表示，顺着思路走，位指针要指向队尾的下一个，那不就是：`Q.rear = Q.front` 。这样不就队空队满无法区分了吗？\n\n<font color='orange'>为了区分队空队满的情况</font>，有以下三种处理方式：\n\n1. 牺牲一个单元来区分队空还是队满，如队时少用一个队列单元，约定以“队头指针在队尾指针的下一位置作为队满的标志”。如图(d2)所示。\n\n   **队满**：`(Q.rear+1)%MaxSize  == Q.front`；\n\n   **队空**：`Q.front == Q.rear`。\n\n   **队列中元素个数**：`(Q.rear - Q.front + MaxSize)%MaxSize`。\n\n2. 类型中增设一个数据成员，专门记录队列中元素的个数。\n\n3. 类型中增设tag数据成员，以区分是队满还是队空。tag等于0时，若因删除导致`Q.front == Q.rear`，则为队空；tag等于1时，若因插入导致`Q.front == Q.rear`，则为队满。\n\n<font color='red'>接下来会具体谈到如何判断队列已满</font>\n\n#### 循环队列的操作\n\n- **初始化**\n\n  ```C\n  void InitQueue(SqQueue &Q){\n      Q.base = new QElemType[MAXSIZE];\n      if(!Q.base) exit(OVERFLOW);\n      Q.front = Q.rear = 0;\n      return OK;\n  }\n  ```\n\n- **判队空**\n\n  ```C\n  bool isEmpty(SqQueue Q){\n      if(Q.rear == Q.front) // 队空条件\n          return true;  \n      else \n          return false;\n  }\n  ```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-13.png\" style=\"zoom:67%;\" />\n\n- **入队**\n\n  ```C\n  bool EnQueue(SqQueue &Q, QElemType e){\n    if((Q.rear+1) % MAXQSIZE == Q.front)  //判断队满\n       return false; // 队满则报错\n    Q.base[Q.rear] = e;//新元素插入队尾\n    Q.rear = (Q.rear + 1) % MAXQSIZE;//队尾指针加1取模  用模运算将存储空间在逻辑上变成了\"环状\"\n    return true;\n  }\n  ```\n\n- **出队**\n\n  `DeQueue(&Q,&x)` : 出队，若队列 Q 非空，删除队头元素，并用 x 返回\n\n  只能从队头出队\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-22.png\" style=\"zoom:55%;\" />\n\n  ```C\n  bool DeQueue(SqQueue &Q, QElemType &e){\n  if(Q.rear == Q.front)  //判断队空\n      return false; // 队空则报错\n      e = Q.base[Q.front];\n      Q.front = (Q.front + 1) % MAXQSIZE;//队头指针后移\n      return true\n  }\n  ```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-14.png\" style=\"zoom:67%;\" />\n\n- **获得队头元素**\n\n  `GetHead(Q,&x)` ：读取队头元素，若队列Q非空，则将队头元素\n\n  ```C\n  bool GetHead(SqQueue Q, ElemType &e){\n      if(Q.rear==Q.front)\n          return false;  //队空则报错\n      e=Q.data[Q.front];//获得队头元素\n      return true;\n  }\n  ```\n\n#### 判断队列已满/已空\n\n我们前面说判断队列满的时候，不得不牺牲一个存储单元，否则就与我们的队空相互矛盾，但是有时候出题老师可不想让我们浪费这一个存储单元，所以判断队列已满/已空有两种方案\n\n- 方案一：浪费一个存储单元\n- 方案二：不浪费一个存储单元，用一个 size\n- 方案三：不浪费存储单元，用一个 tag 标记\n\n##### 方案一\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-26.png\" style=\"zoom:75%;\" />\n\n- 队列已满的条件：队尾指针的再下一个位置是队头，即 `(Q.rear+1)%MaxSize == Q.front`\n\n- 队空的条件是：队尾指针和队头指针指向相同，`Q.rear == Q.front`\n\n- 队列元素个数：`(rear + MaxSize - front)%MaxSize`\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-23.png\" style=\"zoom: 67%;\" />\n\n<font color='orange'>这种方案其实算是牺牲了一个存储空间来区分队满、队空</font>\n\n##### 方案二\n\n**但有时在题目中，不允许牺牲那一个存储空间，因此我们要另想一种方案**:\n\n在队列的结构体类型中，额外定义一个属性`int size;`，用来表示队列当前长度。刚开始我们将size设为0，之后每次插入一个元素，就size++，每删除一个元素，就size–-。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-27.png\" style=\"zoom:75%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-24.png\" style=\"zoom: 55%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-25.png\" style=\"zoom:55%;\" />\n\n虽然队头和队尾指针都指向了同一位置，但是由于 size 的存在，所以仍然可以判断队列是满的还是空的。\n\n```C\n#define MaxSize 10\t\t\t\t\t// 定义队列中元素的最大个数\ntypedef struct {\n    ELemType data[MaxSize];\t\t\t// 用静态数组存放队列元素\n    int front,rear;\t\t\t\t\t// 队头指针和队尾指针\n    int size;\t\t\t\t\t\t// 队列当前长度\n}SqQueue;\n// 初始化队列\nvoid InitQueue(SqQueue &Q){\n    Q.rear = Q.front = 0;// 初始时,队头、队尾指针指向0\n    size = 0;// 队列长度也为0\n}\n// 入队\nbool EnQueue(SqQueue &Q,ElemeType x){\n    if(Q.size == MaxSize){\t\t\t\t\t// 判断队满\n        return false;\t\t\t\t\t\t// 队满则报错\n    }\n    Q.data[Q.rear] = x;\t\t\t\t\t\t// 将 x 插入队尾\n    Q.rear = (Q.rear + 1)%MaxSize;\t\t\t// 队尾指针加1取模,用模运算将存储空间在逻辑上变成了\"环状\"\n    size++;\t\t\t\t\t\t\t\t\t// 每一次入队成功我们让队列长度 + 1\n    return true;\n}\n// 出队(删除一个队头元素,并用 x 返回)\nbool DeQueue(SqQueue &Q,ElemType &x){\n    if(Q.size == 0){\t\t\t\t\t\t// 判断队空\n        return false;\t\t\t\t\t\t// 队空则报错\n    }\n    X = Q.data[Q.front];\n    Q.front = (Q.front +1)%MaxSize;\t\t\t// 队头指针后移\n    size--;\t\t\t\t\t\t\t\t\t// 每一次出队成功我们让队列长度 - 1\n    return true;\t\t\t\t\n}\n```\n\n##### 方案三\n\n在队列的结构类型中，定义一个`int tag;`，当tag为0的时候，表示最近一次执行的操作是删除操作；当tag为1的时候，表示最近一次执行的操作是插入操作。\n\n那么，也就是每次删除操作后，都将tag置为0；每次插入操作后，都将tag置为1。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-28.png\" style=\"zoom:75%;\" />\n\n```C\n#define MaxSize 10\t\t\t\t\t// 定义队列中元素的最大个数\ntypedef struct {\n    ELemType data[MaxSize];\t\t\t// 用静态数组存放队列元素\n    int front,rear;\t\t\t\t\t// 队头指针和队尾指针\n    int tag;\t\t\t\t\t\t// 最近进行的是删除(0)/插入(1)\n}SqQueue;\n// 初始化队列\nvoid InitQueue(SqQueue &Q){\n    Q.rear = Q.front = 0;// 初始时,队头、队尾指针指向0\n    tag = 0;// 标志为0\n}\n// 入队\nbool EnQueue(SqQueue &Q,ElemeType x){\n    if(Q.front == Q.rear && tag == 1){\t\t// 判断队满,只有插入操作,才可能导致队满\n        return false;\t\t\t\t\t\t// 队满则报错\n    }\n    Q.data[Q.rear] = x;\t\t\t\t\t\t// 将 x 插入队尾\n    Q.rear = (Q.rear + 1)%MaxSize;\t\t\t// 队尾指针加1取模,用模运算将存储空间在逻辑上变成了\"环状\"\n    tag == 1;\t\t\t\t\t\t\t\t// 每次插入操作成功时,都令 tag = 1\n    return true;\n}\n// 出队(删除一个队头元素,并用 x 返回)\nbool DeQueue(SqQueue &Q,ElemType &x){\n    if(Q.front == Q.rear && tag == 0){\t\t// 判断队空,只有删除操作,才可能导致队空\n        return false;\t\t\t\t\t\t// 队空则报错\n    }\n    X = Q.data[Q.front];\n    Q.front = (Q.front +1)%MaxSize;\t\t\t// 队头指针后移\n    tag == 0;\t\t\t\t\t\t\t\t// 每次删除操作成功时,都令 tag = 0\n    return true;\t\t\t\t\n}\n```\n\n#### 其他出题方法\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-114.png\" style=\"zoom:69%;\" />\n\n还有一种出题方法，就是队尾指针 rear 指向的不是队尾元素的下一个，而是队尾元素的位置\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-113.png\" style=\"zoom: 33%;\" />\n\n- 初始化\n\n  ```C\n  // 初始化队列\n  void InitQueue(SqQueue &Q){\n      // 初始时,队头指针指向0,队尾指针指向 n - 1\n      Q.front = 0;\n      Q.rear = n - 1\n  }\n  ```\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-40.png\" style=\"zoom:55%;\" />\n\n- 入队操作\n\n  ```C\n  // 入队\n  bool EnQueue(SqQueue &Q,ElemeType x){\n      if((Q.rear + 1)%MaxSize == Q.front){\t// 判断队满\n          return false;\t\t\t\t\t\t// 队满则报错\n      }\n      Q.rear = (Q.rear + 1)%MaxSize;\t\t\t// 先将队尾指针向上移一位\n      Q.data[Q.rear] = x;\t\t\t\t\t\t// 再将 x 插入队尾\n      \n      return true;\n  }\n  ```\n\n### 队列的链式存储结构\n\n#### 队列的链式存储\n\n队列的链式表示称为**链队列**，它实际上是一个同时带有队头指针和队尾指针的单链表。 头指针指向队头结点，尾指针指向队尾结点，即单链表的最后一个结点（注意与顺序存储的不同）。\n\n**结点类型定义**\n\n```c\ntypedef struct {  //链式队列结点\n    ElemType data;\n    struct LinkNode *next;\n}LinkNode;\ntypedef struct{  //链式队列\n    LinkNode *front, *rear;  //队列的队头和队尾指针\n}LinkQueue;\n```\n\n当`Q.front == NULL && Q.rear == NULL`时，链式队列为空。\n\n出队时，首先判断队是否为空，若不空，则取出队头元素，将其从链表中华摘除，并让`Q.front = Q.front->next`；\n\n入队时，建立一个新的结点，将该结点插入到链表的尾部，并让`Q.rear = Q.rear->next`。\n\n从上述描述看出，出现了和顺序队列同样的问题，就是操作浪费空间（空间只能用一次），且耗时。\n\n#### 链式队列的基本操作\n\n##### 带头结点\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-29.png\" style=\"zoom:67%;\" />\n\n- **初始化**\n\n  先申请一个结点，然后让队头指针 front、队尾指针 rear 都指向这个结点\n\n  之后让此结点的指针域指向NULL\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-30.png\" style=\"zoom: 50%;\" />\n\n  ```C\n  // 初始化队列(带头结点)\n  void InitQueue(LinkQueue &Q){\n      // 初始时, front、rear 都指向头结点\n      Q.front = Q.rear = (LinkNode*)malloc(size(LinkNode));\n      Q.front->next = NULL;\n  }\n  ```\n\n- **判队空**\n\n  判断队列是否为空，只需要看队头指针和队尾指针是否指向相同，指向相同队列为空，指向不相同队列不为空\n\n  ```C\n  // 判断队列是否为空(带头结点)\n  bool IsEmpty(LinkQueue Q){\n      if(Q.front == Q.rear){\n          return true;\n      }else{\n          return false;\n      }\n  ```\n\n- **入队**\n\n  入队只能在队尾入队\n\n  - 先申请一个结点s，将新入队元素 x 放入这个结点中\n\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-31.png\" style=\"zoom: 50%;\" />\n\n  - 将 s 结点的指针域指向 NULL，之后将 s 结点插入到 rear 之后\n\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-32.png\" style=\"zoom: 50%;\" />\n\n  - 修改表尾指针为 s 结点\n\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-33.png\" style=\"zoom: 50%;\" />\n\n  ```C\n  // 新元素入队(带头结点)\n  void EnQue(LinkQueue &Q,ElemType x){\n      LinkNode *s =(LinkNode *)malloc(sizeof(LinkNode));\t\t\t\t// 用 malloc 申请一个新结点\n      s->data = x;\t\t\t\t\t\t\t\t\t\t\t\t\t// 将 x 放入这个结点中\n      s->next = NULL;\t\t\t\t// 插入操作在表尾进行,新插入的结点x肯定是在表尾,所以将x结点指针域设为NULL\n      Q.rear->next = s;\t\t\t\t\t\t// 新结点插入到 rear 之后\n      Q.rear = s;\t\t\t\t\t\t\t\t// 修改表尾指针\n  }\n  ```\n\n- **出队**\n\n  带头结点出队只能从队头出队\n\n  - 申请一个新结点 p 指向头结点后面的一个结点(也就是队头结点)，用变量 x 返回队头结点元素\n\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-34.png\" style=\"zoom: 50%;\" />\n\n  - 修改头结点的 next 指针，使其指向 p 结点的下一个结点\n\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-35.png\" style=\"zoom: 50%;\" />\n\n  - 如果出队的结点是最后一个结点，我们要修改队尾指针rear，让其指向头结点\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-36.png\" style=\"zoom:45%;\" />\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-37.png\" style=\"zoom:45%;\" />\n\n  - 释放 p 结点\n\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-38.png\" style=\"zoom: 50%;\" />\n\n  ```C\n  // 队头元素出队(不带头结点)\n  bool DeQueue(LinkQueue &Q,ElemType &x){\n      if(Q.front == Q.rear){\n          return false;\t\t\t\t\t\t// 空队\n      }\n      LinkNode *p = Q.front->next;\t\t\t// 申请新结点p 指向头结点的后面一个结点\n      x = p->data;\t\t\t\t\t\t\t// 用变量 x 返回队头元素\n      Q.front->next = p->next;\t\t\t\t// 修改头结点的 next 指针\n      if(Q.rear == p){\t\t\t\t\t\t// 如果此次是最后一个结点出队\n          Q.rear = Q.front;\t\t\t\t\t// 修改 rear 指针\n      }\t\t\n      free(p);\t\t\t\t\t\t\t\t// 释放结点空间\n      return true;\n  }\n  ```\n\n##### 不带头结点\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-41.png\" style=\"zoom:67%;\" />\n\n- 初始化\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-42.png\" style=\"zoom: 50%;\" />\n\n  ```C\n  // 初始化队列(不带头结点)\n  void InitQueue(LinkQueue &Q){\n      // 初始时, front、rear 都指向NULL\n      Q.front = NULL;\n      Q.rear = NULL;\n  }\n  ```\n\n- 判队列空\n\n  ```C\n  // 判断队列是否为空(不带头结点)\n  bool IsEmpty(LinkQueue Q){\n      if(Q.front == NULL){\n          return true;\n      }else{\n          return false;\n      }\n  }\n  ```\n\n- 入队操作\n\n  不带头结点的队列，第一个元素入队时需要特别处理\n\n  - 先申请一个新结点 s，将新入队元素 x 放入这个结点中，将此结点的 next 指针域 指向 NULL\n\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-43.png\" style=\"zoom: 50%;\" />\n\n  - 需要判断如果这个队列为空，那么就意味着新结点 s 是这个队列的第一个结点，需要将 front、rear 都指向这个新结点 s\n\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-44.png\" style=\"zoom: 50%;\" />\n\n  - 如果队列不为空，就是执行后插操作了\n\n\n  ```C\n  // 新元素入队(不带头结点)\n  void EnQue(LinkQueue &Q,ElemType x){\n      LinkNode *s =(LinkNode *)malloc(sizeof(LinkNode));\t\t// 申请新结点\n      s->data = x;\t\t\t\t\t\t\t\t\t\t\t// 向此结点写入数据元素 x\n      s->next = NULL;\t\t\t\t// 插入操作在表尾进行,新插入的结点x肯定是在表尾,所以将x结点指针域设为NULL\n      if(Q.front == NULL){\t\t\t\t\t// 如果队列为空\t\n          Q.front = s;\t\t\t\t\t\t// 不带头结点的队列，第一个元素入队时需要特别处理\t\n          Q.rear = s;\t\t\t\t\t\t\t// 在空队列中插入第一个元素,修改队头队尾指针\n      }else{\n          Q.rear->next = s;\t\t\t\t\t\t// 新结点插入到 rear 之后\n      \tQ.rear = s;\t\t\t\t\t\t\t\t// 修改表尾指针\n      }\n  }\n  ```\n\n- 出队操作\n\n  不带头结点出队只能从队头出队\n\n  - 首先申请新结点 p 指向此次出队的结点(队头结点)，用变量 x 返回队头元素\n\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-45.png\" style=\"zoom: 50%;\" />\n\n  - 修改队头指针 front 指向，需要将 front 、rear 指针指向 NULL(将其恢复为空队的状态)\n\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-46.png\" style=\"zoom: 50%;\" />\n\n  - 释放结点 p\n\n\n  ```C\n  // 队头元素出队(不带头结点)\n  bool DeQueue(LinkQueue &Q,ElemType &x){\n      if(Q.front == NULL){\n          return false;\t\t\t\t\t\t\t\t// 空队\n      }\n      LinkNode *p = Q.front;\t\t\t\t\t\t\t// 申请新结点 p 指向此次出队的结点\n      x = p->data;\t\t\t\t\t\t\t\t\t// 用变量 x 返回队头元素\n      Q.front = p->next;\t\t\t\t\t\t\t\t// 修改 front 指针\n      if(Q.rear == p){\n          Q.front = NULL;\t\t\t\t\t\t\t\t// front 指向 NULL\n          Q.rear = NULL;\t\t\t\t\t\t\t\t// rear 指向 NULL\n      }\n      free(P);\t\t\t\t\t\t\t\t\t\t// 释放结点空间\n      return true; \n  }\n  ```\n\n##### 队列满的条件\n\n之前顺序存储实现的队列，由于是用静态数组分配的，其空间是有限的、不可拓展的，所以其最大空间被耗尽时队满。\n\n而此处用链式存储实现的队列，它的容量是可以扩展的，一般不会队满，除非内存不足。\n\n因此，在顺序存储的队列当中，我们花了很多办法去判断队列是否已满；而在链式存储实现的队列当中，我们一般不用关心已满的问题。\n\n### 双端队列\n\n- 双端队列是指<font color='orange'>允许两端都可以进行入队和出队操作的队列</font>，其元素的逻<font color='orange'>辑结构仍是线性结构</font>font>\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-47.png\" style=\"zoom:67%;\" />\n\n- 将队列的两端分别称为前端和后端，两端都可以入队和出队\n\n- 输出受限的双端队列：允许在一端进行插入和删除，另一端只允许插入\n\n- 输入受限的双端队列：允许在一端进行插入和删除，另一端只允许删除\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-48.png\" style=\"zoom:67%;\" />\n\n> 若对于一个双端队列，我只使用其中一端的插入、删除操作，那么我的使用效果就等同于使用一个栈。\n>\n> 也就是说，栈能够实现的功能，双端队列一定能实现。\n>\n> 队列同理。\n\n**考点**\n\n此处双端队列比较喜欢考察的考点，就是**判断输出序列的合法性**。（类似于栈那里的考点）\n\n###  习题\n\n- 【2010】某队列允许在其两端进行入队操作，但仅允许在一端进行出队操作。若元素a,b,c,d,e依次入此队列后再进行出队操作，则不可能得到的出队序列是->d b c a e\n\n  > 双端队列的题可以用以下技巧： \n  >\n  > 入队顺序为a b c d e，则出队顺序必然包含在序列e d c b a b c d e中，找出选项中不符合条件的序列即可。 \n  >\n  > -  A e d c **b** **a** b **c d e** 符合      \n  > -  B e **d** c **b** **a** b **c** d **e** 符合      \n  > -  C e **d** c **b** a b **c** d e 不符合      \n  > -  D **e** d **c** **b a** b c **d** e 符合\n\n- 【2011】已知循环队列存储在一维数组A[0...n-1]中，且队列非空时front和rear分别指向队头元素和队尾元素。若初试队列为空，且要求第一个进入队列的元素存储在A[0]处，则初始时front和rear的值分别是→0，n-1\n\n  > 循环队列需要留出一个空间，方便判断队列是否为满（循环队列解决假溢出）； \n  >\n  > 常用的队列实现： \n  >\n  > 当队列为空时，front == rear；其中rear指向队尾元素的下一个位置，即下一个元素入队的位置 \n  >\n  > 入队操作：先赋值，再rear = (rear+1)%MAXSIZE；此时rear仍然指向队尾元素的下一个位置 \n  >\n  > 但是题目中！！！有一句！！！front和rear分别指向队头元素和队尾元素！！！  \n  >\n  > rear指向队尾元素！！！  \n  >\n  > 把常用的队列实现方法来了个886  \n  >\n  > 那么，在这道题中，判断队满和队空我是一时半会想不下去了。。。（front == (rear + 1)%MAXSIZE 既可以是满，也可以是空啊= =，除非说还要留一个空间出来）  \n  >\n  > 但是！！！  \n  >\n  > 这道题说，初始时队列为空，无论如何还是front == (rear + 1)%MAXSIZE.  \n  >\n  > 简单的说就是，队列是空的，rear指向队尾元素，front指向队头元素，入队了，（rear +1）%n，这个时候A[0]既是队头元素，也是队尾元素，rear = front = 0；所以是rear = n-1\n\n- 【2014】循环队列放在一维数组A[0...M-1]中，end1指向队头元素，end2指向队尾元素的后一个位置。假设队列两端均可进行入队和出队操作，队列中最多能容纳M-1个元素。初始时为空。下列判断队空和队满的条件中，正确的是-->队空：end1 == end2；                                  队满：end1 == (end2+1)mod M\n\n  > end1指向队头元素，那么可知出队的操作是先从A[end1]读数，然后end1再加1。end2指向队尾元素的后一个位置，那么可知入队操作是先存数到A[end2]，然后end2再加1。若把A[0]储存第一个元素，当队列初始时，入队操作是先把数据放到A[0]，然后end2自增，即可知end2初值为0；而end1指向的是队头元素，队头元素的在数组A中的下标为0，所以得知end1初值也为0，可知队空条件为end1==end2；然后考虑队列满时，因为队列最多能容纳M-1个元素，假设队列存储在下标为0到下标为M-2的M-1个区域，队头为A[0]，队尾为A[M-2]，此时队列满，考虑在这种情况下end1和end2的状态，end1指向队头元素，可知end1=0，end2指向队尾元素的后一个位置，可知end2=M-2+1=M-1，所以可知队满的条件为end1= =(end2+1)mod M\n\n- 用链式存储方式的队列进行删除操作时需要→D\n\n  A 仅修改头指针\n\n  B 仅修改尾指针\n\n  C 头尾指针都要修改\n\n  D 头尾指针可能都要修改\n\n  > 当队列元素>1时，删除操作只修改头指针；当队列元素=1时，删除操作头尾指针都要修改\n\n- 16 假设循环单链表表示的队列长度为n，队头固定在链表尾，若只设头指针，则进队操作的时间复杂度为→O(n)\n\n- 【2018】现有队列Q与栈S，初始时Q中的元素依次是1,2,3,4,5,6(1在队头)，s为空。若仅允许下列3种操作:①出队并输出出队元素；②出队并将出队元素入栈；③出栈并输出出栈元素，则不能得到的输出序列是-->C\n\n  A. 1, 2, 5, 6, 4, 3\n\n  B. 2, 3, 4, 5, 6, 1\n\n  C. 3, 4, 5, 6, 1, 2\n\n  D. 6, 5, 4, 3, 2, 1\n\n  > A的操作顺序为①①②②①①③③。B的操作顺序为②①①①①①③。D的操作顺序为②②②②②①③③③③③。对于C:首先输出3，说明1和2必须先依次入栈，而此后2肯定比1先输出，因此无法得到1，2的输出顺序。\n\n- 【2016】设有如下图所示的火车车轨，入口到出口之间有n条轨道，列车的行进方向均为从左至右，列车可驶入任意一条轨道。现有编号为1～9的9列列车，驶入的次序依次是8，4，2，5，3，9，1，6，7。若期望驶出的次序依次为1~9，则n至少是-->C\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-49.png\" style=\"zoom:50%;\" />\n\n  A.2       B.3\n  C.4       D.5\n\n  > 将其视为多条队列，每条队列满足：先入队的元素小于**队的元素(如果8和4在同一队列，8在4的后面），这样8入队列1，4入队列2，2入队列3，5入队列2（也可以将5入队列3，但这时剩下的元素就必须放到一个新的队列中，无法使其“至少”），3入队列3，9入队列1，这时共占了3个队列，后面还有元素1，直接再占用一个新的队列4，1从队列4出队后，6、7可以入队到队列2、3、4，综上：最少占用4个队列。其中，确保满足：1）队列中后面的元素大于前面的元素；2）确保占用最少\n\n- 【2021】初始为空的队列Q的一端仅能进行入队操作，另外一段既能进行入队操作又能进行出队操作。若Q的入队序列是1，2，3，4，5，则不能得到的出队序列是-->D\n\n  A. 5、4、3、1、2\n\n  B. 5、3、1、2、4\n\n  C. 4、2、1、3、5\n\n  D. 4、1、3、2、5\n\n  > 假设队列左端允许入队和出队，右端允许入队。对于A，依次从右端入队1,2，再从左端入队3,4,5。对于B，从右端入队1,2，然后从左端入队3，再从右端入队4，最后从左端入队5。对于C，从左端入队1,2，然后从右端入队3，再从左端入队4，最后从右端入队5。无法验证D的序列。\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-124.png\" style=\"zoom: 67%;\" />\n  \n- 综合题4【2019】请设计一个队列，要求满足：\n\n  ① 初始队列为空；\n\n  ② 入队时，允许增加队列占用空间；\n\n  ③ 出队后，出队元素所占用的空间可重复使用，即整个队列所占用的空间只增不减；\n\n  ④ 入队操作和出队操作的时间复杂度始终保持为O(1\n\n  请回答下列问题\n\n  ① 该队列是选择链式存储结构，还是应选择顺序存储结构？\n\n  ② 画出队列的初始状态，并给出判断队空和队满的条件\n\n  ③ 画出第一个元素入队后的队列状态\n\n  ④ 给出入队操作和出队操作的基本过程  \n\n  > 1）顺序存储无法满足要求②的队列占用空间随着入队操作而增加。根据要求来分析：要 求①容易满足；链式存储方便开辟新空间，要求②容易满足；对于要求③，出队后的结点并不 真正释放，用队头指针指向新的队头结点，新元素入队时，有空余结点则无须开辟新空间，赋 值到队尾后的第一个空结点即可，然后用队尾指针指向新的队尾结点，这就需要设计成一个首 尾相接的循环单链表，类似于循环队列的思想。设置队头、队尾指针后，链式队列的入队操作 和出队操作的时间复杂度均为 O(1)，要求④可以满足。 \n  >\n  > 因此，采用链式存储结构（两段式单向循环链表），队头指针为 front，队尾指针为 rear。\n  >\n  > 2）该循环链式队列的实现，可以参考循环队列，不同之处在于循环链式队列可以方便增 加空间，出队的结点可以循环利用，入队时空间不够也可以动态增加。同样，循环链式队列也 要区分队满和队空的情况，这里参考循环队列牺牲一个单元来判断。初始时，创建只有一个空 闲结点的循环单链表，头指针 front 和尾指针 rear 均指向空闲结点，如下图所示。\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-50.png\" style=\"zoom:67%;\" />\n  >\n  > 队空的判定条件：`front == rear`。 队满的判定条件：`front == rear->next`。\n  >\n  > 3）插入第一个元素后的状态如下图所示。\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-51.png\" style=\"zoom:67%;\" />\n  >\n  > 4）操作的基本过程如下:\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-52.png\" style=\"zoom: 55%;\" />\n","tags":["408数据结构"],"categories":["408数据结构"]},{"title":"第二章 线性表(下)","url":"/p/12625/","content":"\n## 2.3 线性表的链式表示\n\n**链表**——用**链式存储**方式实现的**线性表**。\n\n链表主要有四种：单链表、双链表、循环链表、静态链表。\n\n- 优点：不要求大片连续空间，改变容量方便\n- 缺点：不可随机存取，要耗费一定空间存指针域\n\n### 单链表的定义\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-6.png\" style=\"zoom: 75%;\" />\n\n- 线性表的链式存储又称**单链表**，它是指通过一组任意的存储单元来存储线性表中的数据元素。为了建立数据元素之间的线性关系，对每个链表结点，<font color='red'>除存放元素自身的信息外，还需要存放一个指向其后继的指针</font>。\n\n**单链表的代码实现**:\n\n```C\nstruct LNode{\t\t//单链表结点的结构类型 \n\tElemType data;\t//数据域 \n\tstruct LNode *next;\t//指针域 \n}; \n\nstruct LNode *p = (struct LNode *)malloc(sizeof(struct LNode));\t//增加一个新的结点\n```\n\n此处，我们发现，每次定义一个新结点，都要将它定义为`struct LNode`的类型。\n\n于是我们直接将原结构类型`struct LNode`使用typedef重命名一下，以简化。\n\n#### typedef的使用问题\n\n> typedef <数据类型> <别名>\n>\n> 例如：  typedef int zhengshu;  typedef int * zhengshuzhizhen;\n>\n> 这样以后，原本的  int a = 1;   int * p;\n>\n> 就可以写为  zhengshu a = 1;  zhengshuzhizhen p;\n\n**于是就有了如下的类型定义代码**\n\n**结点的类型定义**\n\n```C\ntypedef struct LNode{\t\t\t\t//定义单链表结点类型\n    ElemType data;\t\t\t\t\t//定义单链表结点类型(数据域)\n    struct LNode * next;\t\t\t//每个节点存放一个数据元素(指针域)\n}LNode,*LinkList;\t\t\t\t\t//LinkList为指向结构体LNode的指针类型\n//增加一个新的结点:在内存中申请一个结点所需空间,并用指针p指向这个结点\nLNode *p =(LNode *)malloc(sizeof(LNode));\n\n// 上述定义代码等价于\nstruct LNode{\n    ElemType data;\n    struct LNode *next;\n};\ntypedef struct LNode LNode;\t\t\t//struct LNode = LNode\ntypedef struct LNode * LinkList;\t//struct LNode *= LinkList \n\n//增加一个新的结点:在内存中申请一个结点所需空间,并用指针p指向这个结点\nstruct LNode *p =(struct LNode *)malloc(sizeof(struct LNode))\n```\n\n通常只需声明一个头指针L来表示一个单链表，指向单链表的第一个结点\n\n`LNode *L;\t\t//声明一个指向单链表的第一个结点的指针`\n这样一来，我就可以这样写我的代码:\n`LinkList L;   //声明一个指向单链表的第一个结点的指针`\n\n<font color='orange'>但是，也并不是说，写LNode 的地方，都要写作LinkList。因为，代码不论怎么写，始终是为了简洁性、可读性的。看下面这个例子：</font>\n\n```C\ntypedef struct LNode{\n\tElemType * data;\n\tstruct LNode * next;\n}LNode, *LinkList;\n\n//单链表查找某元素\nLNode * GetElem(LinkList L, int i){\t//函数返回值LNode *是想强调其返回结果是一个结点；\n    \t\t\t\t\t\t\t\t//参数L类型LinkList是想强调这是一个单链表（头结点代表单链表）\n\tint j = 1;\n\tLNode *p = L->next;\n\tif(i==0) return L;\n\tif(i<1) return NULL;\n\twhile(p!=NULL && j<i){\n\t\tp = p->next;\n\t\tj++;\n\t}\n\treturn p;\t//最终返回一个结点，类型为LNode *\n}\n```\n\n> 注意：此段代码中，并没有将LNode *全部写为LinkList。可以注意到，在我使用LNode *的地方，我往往是想要强调这是一个结点(例如函数返回值LNode *，例如其中用来索引的指针p是LNode *)，而在使用LinkList的地方，我想要强调的是这是一个单链表（例如函数的参数L是LinkList，它虽然是一个头结点，但它根本上是代表着一个单链表）\n\n**总之，这种重命名的方法（typedef），以及对重命名之后的别名的使用（是有所强调的，而不是一概而论的），希望能够好好体会。**\n\n#### 不带头结点的单链表\n\n```C\ntypedef struct{\t\t//定义单链表结点的结构类型\n\tElemType data;\t\t//数据域 \n\tstruct LNode *next;\t//指针域 \n}LNode, *LinkList;\n\n//初始化一个空的单链表（不带头结点）\nbool InitList(LinkList &L) {\n\tL = NULL;\t//空表，暂时还没有任何结点\t//初始并设为空，防止脏数据\n\treturn true; \n}\n\nvoid test(){\n\tLinkList L;\t//声明一个指向单链表的指针\t//（1）\n\tInitList(L);\t//初始化一个空表\n\t//...... \n}\n```\n\n**注意：**（1）处并没有创建一个结点。\n\n要始终去体会，**别名的使用是在含义上有所强调的**，而不仅仅是理论上来说代码能否编译问题\n\n#### 带头结点的单链表\n\n单链表第一个结点之前附加一个结点，称为头结点。\n\nhttps://blog.csdn.net/zhenyusoso/article/details/6092843\n\n引入头结点后，可用带来两个优点:\n\n1. 由于第一个数据结点的位置被存放在头结点的指针域中，因此在链表的第一个位置上的操作和在表的其他位置上的操作一致，无须进行特殊处理。\n2. 无论链表是否为空，其头指针都指向头结点的非空指针(空表中头结点的指针域为空)，因此空表和非空表的处理也就得到了统一。\n\n```C\ntypedef struct LNode{\n\tElemType data;\n\tstruct LNode *next;\n}LNode, *LinkList;\n\n//初始化一个单链表（带头结点） \nbool InitList(LinkList &L){\n\tL = (LNode *)malloc(sizeof(LNode));\t//分配一个头结点\n\tif(L == NULL)  return false;\t//内存不足，分配失败\n\tL->next = NULL;\t//头结点之后暂时还没有结点\n\treturn true; \n}\n\nvoid test(){\n\tLinkList L;\t//声明一个指向头结点的指针\n\tInitList(L);\t//初始化一个空表\n\t//...... \n}\n```\n\n**注意**：此头结点的数据域是不存储数据元素的，只有指针域有意义。这是为了方便后续的链表操作。\n\n```C\n//判断单链表是否为空（带头结点） \nbool Empty(LinkList L) {\n\tif(L->next == NULL) return true;\n\telse return false;\n}\n\n```\n\n#### 不带/带头结点的区别\n\n- 不带头结点，写代码更麻烦。对第一个数据结点和后续数据结点的处理需要用不同的代码逻辑。对空表和非空表的处理需要用不同的代码逻辑。\n- 带头结点，写代码更方便。一般都是带头结点的。\n- 不带头结点，头指针L所指向的下一个结点，就是实际用于存放数据的结点。而带头结点，头指针所指向的结点，也就是头结点，是不存放实际的数据元素的，而头结点指向的下一个结点才会用于存放数据。\n- 不带头结点，空表判断：`L==NULL`；带头结点，空表判断：`L->next==NULL`\n\n### 单链表上基本操作的实现\n\n#### 采用头插法建立单链表\n\n- 头插法建立单链表时，读入数据的顺序与生成的链表中的元素的顺序是相反的。每个结点插入的时间为O(1),设单链表长n,时间复杂度O(n)。\n- <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-9.png\"  />\n\n```c\nLinkList List_HeadInsert(LinkList &L){//逆向建立单链表\n    LNode *s; int x;\n    L=(LinkList)malloc(sizeof(LNode));//创建头结点；\n    L->next=NULL;                    //初始为空链表[*]\n    scanf(\"%d\",&x);                   //输入结点的值\n    while(x! = 9999){                 //输入9999表示结束\n        s=(LNode*)malloc(sizeof(LNode));//创建新结点\n        s- >data=x;\n        s- >next=L- >next;\n        L- >next=s;                   //将新结点插入表中，L为头指针\n        scanf(\"%d\",&x);\n    }\n    return L;\n}\n```\n\n[头插法创建单链表（带源码+解析）](http://data.biancheng.net/view/93.html)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-8.png\" style=\"zoom: 75%;\" />\n\n> 注意:在代码[\\*]处，初始化空链表的时候，必须将L的next置为NULL。否则插入若干数据结点后，表尾的next会是一个脏数据，而不是NULL。而尾插法为什么不用，是因为尾插法在最后执行了尾结点指针域置空的操作。但总之，你只要是初始化单链表，都先把头指针指向NULL，这是一个好习惯。\n\n> **重要应用：链表的逆置**！！[B站-链表逆置的两种方法](https://www.bilibili.com/video/BV1yU4y1U7L2?spm_id_from=333.337.search-card.all.click&vd_source=278af11bcc7fe34571197ce600d488f4)\n>\n> 在使用头插法插入数据的时候，你依次插入a、b、c。那么在此单链表中，从头结点开始，依次为：c、b、a。于是这里引起了一个重要的应用，**链表的逆置**。\n>\n> 也就是再建立一个新的链表，之后将原来的链表从头到尾依次头插法插入新链表中，新链表就是原链表的逆置。\n>\n> 当然，你也可以不建立新链表，而是在原链表，直接依次对每个结点，向原链表的头结点后执行头插，最终得到的结果也是原链表的逆置。\n\n#### 采用尾插法建立单链表\n\n- 时间复杂度O(n)\n\n- **头插法**建立单链表的算法虽然简单，但生成的链表中结点的次序和输入数据的顺序**不一致**。若希望两者次序一致，可采用尾插法。该方法是将新结点插入到当前链表的表尾上，为此必须增加一个尾指针r,使其始终指向当前链表的尾结点，如图所示。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-10.png\"  />\n\n**初始化单链表后，向单链表末尾进行后插操作**\n\n```C\n//在第i个位置插入元素e（带头结点）\nbool ListInsert(LinkList &L, int i, ElemType e) {\n\tif(i<1) return false;\n\tLNode *p;\t//指针p指向当前扫描到的结点\n\tint j=0;\t//当前p指向的是第几个结点\n\tp = L;\t//L指向头结点\n\twhile(p!=NULL && j<i-1) {\t//循环找到第i-1个结点 \n\t\tp = p->next;\n\t\tj++;\n\t}\n\tif(p == NULL) return false;\t//i值不合法\n\tLNode *s = (LNode *)malloc(sizeof(LNode));\n\ts->data = e;\n\ts->next = p->next;\n\tp->next = s;\t//将结点s连到p之后 \n\treturn true;\n}\n```\n\n> 但是此时有一个问题。即每次向表尾插入一个元素，都要从表头开始循环，找到表尾结点。那么若要插入n个元素进去，则时间复杂度为O(n²)。\n>\n> 但是实际上，我们每次向表尾插入新的元素，没有必要每次都从表头再全部遍历一次。我们可以设立一个表尾指针r，专门用于指向表尾。之后若要插入新元素，对表尾指针r做一个后插操作即可。\n>\n> 如何对表尾指针r做后插操作，见指定结点的后插操作。\n\n```c\nLinkList List_TailInsert(LinkList &L){//正向建立单链表\n    int x;                            //设元素类型为整型\n    L=(LinkList)malloc(sizeof(LNode));//创建头结点；\n    LNode *s,*r=L;                    //r为表尾指针\n    scanf(\"%d\",&x);                   //输入结点的值\n    while(x! =9999){                   //输入9999表示结束\n        s=(LNode*)malloc(sizeof(LNode));\n        s- >data=x;\n        r- >next=s;                  //在r结点之后插入元素x\n        r=s;                         //r指向新的表尾结点\n        scanf(\"%d\",&x);\n    }\n    r- >next=NULL;                   //尾结点指针置空\n    return L;\n}\n```\n\n#### 按序号查找结点值\n\n在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止，否则返回最后一个结点指针域NULL。\n\n时间复杂度O(n)\n\n`GetElem(L,i)`：按位查找操作。获取表L中第i个位置的元素的值。\n\n```C\n//按位查找,返回第i个元素(带头结点)\nLNode *GetElem(LinkList L,int i){\n    if(i<0)\n    {\n        return NULL;\n    }\n    LNode *p;\t//指针p指向当前扫描到的结点\n    int j = 0;\t//当前p指向的是第几个结点\n    p = L;\t\t//L指向头结点,头结点是第0个结点(不存数据)\n    while(p!=NULL && j<i)\t//循环找到第i个结点\n    {\n        p = p->next;\t\t//让p指针依次向后移\n        j++;\n    }\n    return p;\n}\n```\n\n如果i=0\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-44.png\" style=\"zoom: 50%;\" />\n\n如果i=8(i大于链表长度)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-45.png\" style=\"zoom: 50%;\" />\n\n**王道书版本**:\n\n```c\nLLNode GetElem(LinkList L,int i){\n    //本算法取出单链表L（带头结点）中第i个位置的结点指针\n    int j=1;  //计数，初始为1\n    LNode *p = L->next;  //头结点指针赋给p\n    if(i==0)\n        return L;  //若i等于0，则返回头结点\n    if(i<1)\n        return NULL;  //若 i 无效，则返回 NULL\n    while( p && j<i ) {  //从第1个结点开始找，查找第i个结点\n        p=p->next;\n        j++;\n    }\n    return p; //返回第i个结点的指针，如果i大于表长，p=NULL，直接返回p即可\n}\n```\n\n那么，封装之后。我们下面会提到的**按位插入**、**按位删除**中相应的代码段就都可以直接调用这个封装好的函数来实现。\n\n如下所示:\n\n```C\n//在第i个位置插入元素e（带头结点）\nbool ListInsert(LinkList &L, int i, ElemType e) {\n\tif(i<1) return false;\n\tLNode *p = GetElem(L, i-1);\t//找到第i-1个结点\n\treturn InsertNextNode(p, e);\t//p后插入新元素e\n}\n```\n\n#### 按值查找表结点\n\n从单链表第一个结点开始，由前往后依次比较表中各结点数据域的值，若某结点数据域的值等于给定值e，则返回该结点的指针。若整个单链表中没有这样的结点，则返回NULL。按值查找结点的算法如下：\n\n时间复杂度O(n)\n\n`LocateElem(L,e)`：按值查找操作。在表L中查找具有给定关键字值的元素\n\n```c\nLNode *LocateElem (LinkList L, ElemType e) {\n    //本算法查找单链表 L （带头结点）中数据域值等于e的结点指针，否则返回NULL\n    LNode *p=L->next;\n    while(p!=NULL && p->data!=e)  //从第1个结点开始查找data域为e的结点\n        p=p->next;\n    return p;  //找到后返回该结点指针，否则返回NULL\n}\n```\n\n> 此处同样需要注意一点：由于e的类型是ElemType，其有可能是基本类型，也有可能是结构类型。当其为结构类型时，就不能直接通过\"! =\"来判断了。原理同前文一致，不再赘述。\n\n[单链表的两种查找方式](https://blog.csdn.net/pikaqiu_JBR99/article/details/107616129)\n\n#### 插入结点操作 [单链表的插入和删除](https://itcn.blog/p/1649535832.html)\n\n##### 按位序插入\n\n###### 带头结点\n\n`ListInsert(&L,i,e)`：插入操作。**在表L中的第i个位置上插入指定元素e**\n\n(找到第i-1个结点，将新结点插入其后)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-36.png\" style=\"zoom:67%;\" />\n\n**此时，带头结点的好处就体现出来了。当我插入的位置为1时，可以把头结点看作第0个结点，向头结点后进行插入。由此，我不论在何处插入一个结点，我的处理逻辑都是统一的**。\n\n```C\nbool ListInsert(LinkList &L,int i,ElemType e){\n    if(i<1){\n        return false;\n    }\n    LNode *p;\t\t//指针p指向当前扫描到的结点\n    int j=0;\t\t//当前p指向的是第几个结点\n    p = L;\t\t\t//L指向头结点,头结点是第0个结点(不存是数据)\n    \n    while(P! =NULL && j<i-1){\t//循环找到第 i-1 个结点\n        p=p->next;\n        j++;\n    }\n    if(p==NULL)\t\t//i值不合法\n    {\n        return false;\n    }\n    LNode *s = (LNode *)malloc(sizeof(LNode));\n    s->data=e;\n    //将s指向结点的next指针指向p指向结点的next指针\n    s->next = p->next;\t \n    p->next = s;\t//将p指向结点的next指针指向s\n    return true;\t//插入成功\n}\n```\n\n<font color='red'>分析</font>:\n\n如果 i=1(也就是在表头插入元素)：时间复杂度O(1)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-37.png\" style=\"zoom: 50%;\" />\n\n如果 i = 3(也就是在表中插入元素)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-38.png\" style=\"zoom: 50%;\" />\n\n如果 i = 5(也就是在表尾插入元素)：时间复杂度O(n)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-39.png\" style=\"zoom: 50%;\" />\n\n###### 不带头结点\n\n`ListInsert(&L,i,e)`：插入操作。**在表L中的第i个位置上插入指定元素e**\n\n(找到第i-1个结点，将新结点插入其后)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-40.png\" style=\"zoom: 50%;\" />\n\n\n\n**此时，由于不带头结点，也就是不存在“第0个”结点。因此i=1时需要特殊处理。**\n\n```C\nbool ListInsert(LinkList &L,int i,ElemType e){\n    if(i<1)\n    {\n        return false;\n    }\n    if(i==1)\t\t//插入第1个结点的操作与其他结点操作不同\n    {\n        LNode *s =(LNode *)malloc(sizeof(LNode));\n        s->data = e;\n        s->next = L;\n        L = s;\t\t//头指针指向新结点\n        return true;\n    }\n    LNode *p;\t\t//指针p指向当前扫描到的结点\n    int j=1;\t\t//当前p指向的是第几个结点\n    p = L;\t\t\t//p指向第1个结点(注意:不是头结点)\n    \n    while(P!=NULL && j<i-1){\t//循环找到第 i-1 个结点\n        p=p->next;\n        j++;\n    }\n    if(p==NULL)\t\t//i值不合法\n    {\n        return false;\n    }\n    LNode *s = (LNode *)malloc(sizeof(LNode));\n    s->data=e;\n    //将s指向结点的next指针指向p指向结点的next指针\n    s->next = p->next;\t\n    p->next = s;\t//将p指向结点的next指针指向s\n    return true;\t//插入成功\n}\n}\n```\n\n> 如果不带头结点，则插入、删除第1个元素时，需要更改头指针L。\n>\n> 如果带头结点的话，头指针肯定永远都是指向头结点的。\n>\n> 但是除了第1个元素外，后续的元素操作，其逻辑和带头结点的一样。\n\n**结论**：不带头结点写代码不方便，推荐用带头结点\n\n##### 指定结点的后插操作\n\n后插操作：在结点之后插入元素\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-41.png\" style=\"zoom:67%;\" />\n\n> 给定一个结点，在这个结点之后插入一个数据元素e。\n>\n> 由于单链表的链接指针只能往后寻找，所以如果给定一个结点p的话，那么p之后的那些结点我们都是可知的，我们都可以用循环的方式把它们都找出来。\n>\n> 但是p结点之前的，我们就没办法知道了。\n\n```C\n//后插操作:在p结点之后插入元素e\nbool InsertNextNode(LNode *p,ElemType e){\n    if(p==NULL)\n    {\n        return false;\n    }\n    LNode *s =(LNode *)malloc(sizeof(LNode));\n    if(s==NULL)\t\t//某些情况下有可能分配失败,比如内存不足\n    {\n        return false;\t\n    }\n    s->data = e;\n    s->next = p->next;\n    p->next = s;\n    return true;\n}\n```\n\n当然，这个函数只是在已经找到p结点后执行的操作。其时间复杂度为O(1)。\n\n但是真正进行插入的时候，首先肯定是要先通过循环，找到结点p的。即如下代码\n\n```C\n//在第i个位置插入元素e（带头结点）\nbool ListInsert(LinkList &L, int i, ElemType e){\n\tif(i<1) return false;\n\tLNode *p;\t//指针p指向当前扫描到的结点\n\tint j = 0;\t//当前p指向的是第几个结点\n\tp = L;\t//L指向头结点，头结点是第0个结点（不存数据）\n\twhile(p!=NULL && j<i-1) {\t//循环找到第i-1个结点 \n\t\tp = p->next;\n\t\tj++;\n\t}\n\treturn InsertNextNode(p, e);\t//封装（当然，上面那几行也可以封装）\n}\n```\n\n##### 指定结点的前插操作\n\n前插操作是指在某结点的前面插入一个新结点，后插操作的定义刚好与之相反，在单链表插入算法中，通常都是釆用后插操作的。\n\n###### 单链表的基本插入算法\n\n插入操作是将值为x的新结点插入到单链表的第i个位置上。先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第i-1个结点，再在其后插入新结点。\n\n算法首先调用上面的按序号查找算法GetElem(L, i-1)，查找第i-1个结点。假设返回的第i-1个结点为 *p，然后令新结点 *s的指针域指向 *p的后继结点，再令结点 *p的指针域指向新插入的结点 *s。其操作过程如图所示。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-11.png\" style=\"zoom:80%;\" />\n\n```c\np=GetElem(L, i-1) ;  // 语句①，查找插入位置的前驱结点\ns->next=p->next;  // 语句②，图 2-6 中辑作步骤 1\np->next=s;  // 语句③，图2-6中操作步骤2\n```\n\n算法中，语句②③的顺序不能颠倒，否则，当先执行p->next=s后，指向其原后继的指针就不存在了，再执行s->next = p->next时，相当于执行了 s->next=s,显然是错误的。本算法主要的时间开销在于查找第i-1个元素，时间复杂度为O(n)。若是在给定的结点后面插入新结点，则时间复杂度仅为O(1)。\n\n以上面的算法为例，首先调用函数GetElem()找到第i-1个结点，即待插入结点的前驱结点后，再对其执行后插操作。由此可知，对结点的前插操作均可以转化为后插操作，前提是从单链表的头结点开始顺序查找到其前驱结点，时间复杂度为O(n)。\n\n###### 拓展:对某一结点的前插操作\n\n此外，可以釆用另一种方式将其转化为后插操作来实现，设待插入结点为s，将插入到p的前面。我们仍然将s插入到p的后面，然后将p->data与s->data交换即可，这样既满足了逻辑关系，又能使得时间复杂度为O(1)。算法的代码片段如下：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-42.png\" style=\"zoom:67%;\" />\n\n> 在p结点之前插入元素e。\n>\n> 此时就会出现一个问题：如何找到p结点的前驱？\n>\n> 思路一：\n>\n> 我们可以传入一个头指针。当给出头指针之后，那么我们链表的所有信息就都能够知道了。\n>\n> 我们可以从头指针开始，依次遍历各个结点，从而找到p结点的前驱结点，再对p的前驱进行后插操作。\n>\n> 那么用这种方法进行前插，时间复杂度是O(n)。\n>\n> 思路二：\n>\n> 我依然是对p进行后插。但是后插过后，我将p结点和新结点，之中的数据域进行互换。最终也能实现前插的效果。\n>\n> 这种的本质是后插，时间复杂度O(1)。\n\n**思路二代码实现**:\n\n```C\n//前插操作:在p结点之前插入元素e\nbool InsertPriorNode(LNode *p,ElemType e){\n    if(p==NULL)\n    {\n        return false;\n    }\n    LNode *s =(LNode *)malloc(sizeof(LNode));\n    if(s==NULL)\t\t\t//内存分配失败\n    {\n        return false;\n    }\n    s->next = p->next;\t\n    p->next = s;\t\t//新结点 s 连接到 p 之后\n    s->data = p->data;\t//将p中元素复制到s中\n    p->data = e;\t\t//p中元素覆盖为e\n    return true;\n}\n```\n\n**王道书中的版本**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-43.png\" style=\"zoom:67%;\" />\n\n```C\n//前插操作:在p结点之前插入结点s\nbool InsertPriorNode(LNode *p,LNode *s){\n    if(p==NULL || s==NULL)\n    {\n        return false;\n    }\n    s->next = p->next;\n    p->next = s;\t\t\t\t//s连到p之后\n    ElemType temp = p->data;\t//交换数据域部分\n    p->data = s->data;\n    s->data = temp;\n    return true;\n}\n```\n\n#### 删除结点操作 [单链表的插入和删除](https://itcn.blog/p/1649535832.html)\n\n删除操作是将单链表的第i个结点删除。先检查删除位置的合法性，然后查找表中第i-1个结点，即被删结点的前驱结点，再将其删除。其操作过程如图所示。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-12.png\"  />\n\n假设结点p为找到的被删结点的前驱结点，为了实现这一操作后的逻辑关系的变化，仅需修改p的指针域，即将p的指针域next指向q的下一结点。\n\n时间复杂度O(n)\n\n##### 带头结点按位序删除\n\n`ListDelete(&L,i,&e)`：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值(找到第i-1个结点，将其指针指向第i+1个结点，并释放第i个结点)\n\n```c\nbool ListDelete(LinkList &L,int i,ElemType &e){\n    if(i<1)\n    {\n        return false;\n    }\n    LNode *p;\t//指针p指向当前扫描到的结点\n    int j = 0;\t//当前p指向的是第几个结点\n    p = L;\t\t//L指向头结点,头结点是第0个结点(不存数据)\n    while(p!=NULL && j<i-1)\t//循环找到第 i-1 个结点\n    {\n        p = p->next;\n        j++\n    }\n    if(p==NULL)  \t\t\t// i值不合法\n    {\n        return false;\n    }\n    if(p->next == NULL)\t\t//第 i-1 个结点之后已无其他结点\n    {\n        return false;\n    }\n    LNode *q = p->next;\t\t//令q指向被删除结点\n    e = q->data;\t\t\t//用e返回元素的值\n    p->next = q->next;\t\t//将*q结点从链中断开\n    free(q);\t\t\t\t//释放结点的存储空间\n    return true;\t\t\t//删除成功\n}\n```\n\n##### 扩展：删除指定结点p\n\n要实现删除某一个给定结点p，通常的做法是先从链表的头结点开始顺序找到其前驱结点，然后再执行删除操作即可，算法的时间复杂度为O(n)。\n\n其实，删除结点p的操作可以用删除p的后继结点操作来实现，实质就是将其后继结点的值赋予其自身，然后删除后继结点，也能使得时间复杂度为O(1)。\n\n```C\n//删除指定结点p\nbool DeleteNode(LNode *p){\n    if(p==NULL)\n    {\n        return false;\n    }\n    LNode *q = p->next;\t\t//令q指向*p的后继结点\n    p->data = p->next->data;//和后继结点交换数据域\n    p->next = q->next;\t\t//将*q结点从链中\"断开\"\n    free(q);\t\t\t\t//释放后继结点的存储空间\n    return true;\n}\n```\n\n> 但是有个问题:如果要删除的这个结点，刚好是单链表的最后一个结点。那么在进行p结点与其后继结点数据域的互换的时候，就会出现问题。即`p->data = p->next->data`;的时候，就会出现空指针的错误。\n>\n> 那么如果是最后一个结点，该怎么办呢。那就只能从头结点开始，循环找到p的前驱，进行删除。时间复杂度O(n)。\n\n#### 求表长操作\n\n求表长操作就是计算单链表中数据结点（不含头结点）的个数，需要从第一个结点开始顺序依次访问表中的每一个结点，为此需要设置一个计数器变量，每访问一个结点，计数器加1，直到访问到空结点为止。算法的时间复杂度为O(n)。\n\n需要注意的是，因为单链表的长度是不包括头结点的，因此，不带头结点和带头结点的单链表在求表长操作上会略有不同。对不带头结点的单链表，当表为空时，要单独处理。\n\n```C\n//求表的长度\nint Length(LinkList L)\n{\n    int len = 0;\t\t\t//统计表长\n    LNode *p = L;\t\t\n    while(p->next !=NULL)\n    {\n        p = p->next;\n        len++;\n    }\n    return len;\n}\n```\n\n### 双链表 [双链表的基本操作](https://blog.csdn.net/qq_16933601/article/details/105351119)\n\n单链表结点中只有一个指向其后继的指针，这使得单链表只能从头结点依次顺序地向后遍历。若要访问某个结点的前驱结点（插入、删除操作时），只能从头开始遍历，访问后继结点的时间复杂度为O(1)，访问前驱结点的时间复杂度为O(n)。\n\n为了克服单链表的上述缺点，引入了双链表，双链表结点中有两个指针prior和next，分别指向其前驱结点和后继结点，如图所示。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-13.png\" style=\"zoom: 75%;\" />\n\n结点类型定义\n\n```C\ntypedef struct DNode {  //定义双链表结点类型\n    ElemType data;  //数据域\n    struct DNode *prior, *next;  //前驱和后继指针\n}DNode, *DLinklist;\n```\n\n#### 双链表的初始化\n\n```C\n//初始化双链表(带头结点)\nbool InitDLinkList(DLinklist &L){\n    L = (DNode *)malloc(sizeof(DNode));\t\t\t//分配一个头结点\n    if(L==NULL)\t\t\t\t\t\t\t\t\t//内存不足,分配失败\n    {\n        return false;\n    }\n    L->prior = NULL;\t\t\t\t\t\t\t//头结点的prior永远指向NULL\n    L->next = NULL;\t\t\t\t\t\t\t\t//头结点之后暂时还没有结点\n    return true;\n}\nvoid testDLinkList(){\n    //初始化双链表\n    DLinklist L;\n    InitDLinkList(L);\n}\n```\n\n- `DLinklist` 等价于`DNode *`\n- `DLinklist` 强调这是一个链表\n- `DNode *` 强调这是一个结点\n\n#### 判断双链表是否为空\n\n判断双链表是否为空:判断头结点的下一个是否为空\n\n```C\n//判断双链表是否为空(带头结点)\nbool Empty(DLinklist L){\n    if(L->next == NULL)\n    {\n        return true;\n    }\n    else{\n        return false;\n    }\n}\n```\n\n#### 双链表的插入操作\n\n在双链表中p所指的结点之后插入结点s，其指针的变化过程如图所示\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-14.png\"  />\n\n时间复杂度O(n)\n\n```C\ns->next=p->next;  // 语句①，将结点*s插入到结点*p之后\np->next->prior=s;  // 语句②\ns->prior=p;  // 语句③\np->next=s;  // 语句④\n```\n\n上述代码的语句顺序不是唯一的，但也不是任意的，①②两步必须在④步之前，否则p的后继结点的指针就丢掉了，导致插入失败。\n\n> 但是，**会有一个问题**。\n>\n> 当p结点为双链表最后一个结点时，在执行该操作时。其中`p->next->prior = s;`会出现空指针错误。\n>\n> 因此我们要优化一下这段代码，如下所示。\n\n##### 后插操作\n\n如果p结点是最后一个结点(特殊情况)：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-46.png\" style=\"zoom: 50%;\" />\n\n```C\n//在p结点之后插入s结点\nbool InsertNextDNode(DNode *p,DNode *s){\n    if(p=NULL || s=NULL)\t\t\t\t\t\t\t//非法参数\n    {\n        return false;\n    }\n    s->next = p->next;\n    if(p->next != NULL)\n    {\t\t\t\t\t\t\t\t\t\t\t\t//如果p结点有后继结点\n        p->next->prior = s;\n    }//如果p没有后继节点，则当然不需要修改p的后继节点的前驱指针\n    s->prior = p;\n    p->next = s;\t\n    return true;\n}\n```\n\n如果p是中间一个结点:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-47.png\" style=\"zoom:67%;\" />\n\n> 同样要注意赋值时的顺序。有些能调换，有些调换了就是错误的逻辑。\n>\n> 实现了双链表后，在对p结点执行前插操作时。就可以立即找到p结点的前驱结点q，再对q进行后插操作即可。实际上都是可以转化为，利用后插来实现。\n\n##### 按位序插入\n\n按位序插入：只需从头结点开始，找到某一个位序的前驱结点，然后对这个前驱结点执行后插操作\n\n##### 前插操作\n\n前插操作：只需找到此结点的前驱结点，然后对其前驱结点进行后插操作，即为前插操作\n\n#### 双链表的删除操作\n\n删除双链表中结点p的后继结点q，其指针的变化过程如图所示。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-15.png\"  />\n\n时间复杂度O(n)\n\n```C\np->next=q->next;  // 图2-10中步骤①\nq->next->prior=p;  //图 2-10 中步骤②\nfree (q) ; //释放结点空间\n```\n\n> 但这样写，同样会有一个问题。就是q为最后一个结点的时候。q的后继节点为NULL，没有前驱结点prior。也就是[*]会引起空指针错误。\n\n当q结点不是最后一个结点时：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-48.png\" style=\"zoom:67%;\" />\n\n```C\n//删除p结点的后继结点\nbool DeleteNextDNode(DNode *p){\n    if(p==NULL)\n    {\n        return false;\n    }\n    DNode *q = p->next;\t\t\t\t//找到p的后继结点q\n    if(q = NULL)\n    {\n        return false;\t\t\t\t//p没有后继结点\n    }\n    p->next = q->next;\n    if(q->next != NULL)\t\t\t\t//q结点不是最后一个结点\n    {\n        q->next->prior = p;\n    }\n    free(q);\t\t\t\t\t\t//释放结点空间\n    return true;\n}\n```\n\n当q结点是最后一个结点时:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-49.png\" style=\"zoom: 50%;\" />\n\n#### 双链表的销毁\n\n```C\nvoid DestoryList(DLinklist &L){\n    //循环释放各个数据结点\n    while(L->next !=NULL)\n    {\n        DeleteNextDNode(L);\n    }\n    free(L);\t\t//释放头结点\n    L=NULL;\t\t\t//头指针指向NULL\n}\n```\n\n#### 双链表的遍历\n\n##### 后向遍历\n\n```C\nwhile(p != NULL){\n    //对结点p做相应处理\n    p = p->next;\n}\n```\n\n##### 前向遍历\n\n```C\nwhile(p != NULL){\n    //对结点p做相应处理\n    p = p->prior;\n}\n```\n\n##### 前向遍历(跳过头结点)\n\n```C\nwhile(p->prior!=NULL){\n    //对结点p做相应处理\n    p = p->prior;\n}\n```\n\n> 知道怎么前向、后向遍历，那么按位查找、按值查找也就没什么问题。\n>\n> - 按位查找：在知道如何前后向遍历的基础上，设置一个遍历次数i，每遍历一次，执行i++，即可实现按位查找。\n> - 按值查找：在知道如何前后向遍历的基础上，每遍历到一个结点，判断该结点的数据域是否等于e，即可实现按值查找。\n>\n> 时间复杂度O(n)。\n\n### 循环链表\n\n#### 循环单链表\n\n循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-16.png\" style=\"zoom:67%;\" />\n\n在循环单链表中，表尾结点的next域指向L，故表中没有指针域为NULL的结点，因此，<font color='orange'>循环单链表的判空条件不是头结点的指针是否为空，而是它是否等于头指针</font>。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-21.png\" style=\"zoom: 75%;\" />\n\n循环单链表的插入、删除算法与单链表的几乎一样，所不同的是如果操作是在表尾进行，则执行的操作不相同，以让单链表继续保持循环的性质。当然，正是因为循环单链表是一个 “环”，因此，在任何一个位置上的插入和删除操作都是等价的，无须判断是否是表尾。\n\n在单链表中只能从表头结点开始往后顺序遍历整个链表，而循环单链表可以从表中的任一结点开始遍历整个链表。有时对单链表常做的操作是在表头和表尾进行的，此时可对循环单链表不设头指针而仅设尾指针，从而使得操作效率更高。\n\n##### 初始化循环单链表\n\n```C\ntypedef struct LNode{\t\t//定义单链表结点类型\n    ElemType data;\t\t\t//每个结点存放一个数据元素\n    struct LNode *next;\t\t//指针指向下一个结点\n}LNode,*LinkList;\n\n//初始化一个循环单链表\nbool InitList(LinkList &L){\n    L = (LNode *)malloc(sizeof(LNode));\t\t//分配一个头结点\n    if(L == NULL)\n    {\n        return false;\n    }\n    L->next = L;\t\t\t\t\t\t\t//头结点next指向头结点\n    return true;\n}\n```\n\n##### 判断循环单链表是否为空\n\n判断循环单链表是否为空:判断头结点的next指针是否指向它自己\n\n```C\nbool Empty(LinkList L){\n    if(L->next == L)\n    {\n        return true;\n    }else{\n        return false;\n    }\n}\n```\n\n##### 判断循环单链表表尾结点\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-50.png\" style=\"zoom: 33%;\" />\n\n```C\n//判断结点p是否是循环单链表的表尾结点\nbool isTail(LinkList L,LNode *p){\n    if(p->next == L)\n    {\n        return true;\n    }else{\n        return false;\n    }\n}\n```\n\n##### 循环单链表的好处\n\n**单链表**\n\n- 从一个结点出发，只能找到后续的各个结点，而前驱的各个结点，除非获得单链表的表头指针，否则无法得知。\n- 从头结点找到尾部，依次循环遍历，时间复杂度为O(n)。\n\n**循环单链表**\n\n- 从一个结点出发可以找到其他任意一个结点。\n- **我们让L不再指向头结点，而是指向尾结点**。那么从尾部找到头部，时间复杂度为O(1)。那么此时，我既有尾结点，又有头结点了（往后找一个即可）。而很多时候，链表的操作都是在头部或尾部。那么这样一来，就大大方便了操作，时间复杂度为O(1)。\n\n#### 循环双链表\n\n由循环单链表的定义不难推出循环双链表，不同的是在循环双链表中，头结点的prior 指针还要指向表尾结点\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-17.png\" style=\"zoom: 80%;\" />\n\n在循环双链表L中，某结点*p为尾结点时，p->next=L;当循环双链表为空表时，其头结点的prior域和next域都等于L\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-18.png\" style=\"zoom: 75%;\" />\n\n循环双链表的**优势**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-19.png\" style=\"zoom: 75%;\" />\n\n我们知道，在p为表尾结点的时候，<font color='orange'>箭头</font>处的语句会出现空指针错误。但如果我们是**循环双链表**的话，那么上述代码的逻辑就是**完全正确**的。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-20.png\" style=\"zoom: 75%;\" />\n\n我们知道，在q为表尾结点的时候，<font color='orange'>箭头</font>处的语句会出现空指针错误。但如果我们是**循环双链表**的话，那么上述代码的逻辑就是**完全正确**的。\n\n### 静态链表\n\n静态链表是<font color='cornflowerblue'>借助数组来描述线性表的链式存储结构</font>，结点也有数据域data和指针域next，与前面所讲的链表中的指针不同的是，这里的指针是**结点的相对地址**(数组下标)，又称为**游标**。和顺序表一样，静态链表也要预先分配一块连续的内存空间。\n\n**静态链表和单链表的对应关系如图**\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-22.png\" style=\"zoom: 75%;\" />\n\n> 单链表中的结点是离散的，分布在内存中的各个角落。每个节点包括一个数据域（数据元素），还有一个指针域（指向下一个结点的指针（地址））。\n\n> 静态链表分配一整片的内存空间，其中的数据元素存放在这片内存空间的某些位置。静态链表中的每个结点包含了数据元素，还有下一个结点的数组下标（游标）。\n>\n> 静态链表中，0号结点充当“头结点”，它是不存放数据元素的。\n>\n> 静态链表中每个结点的游标相当于单链表中的指针域。只不过指针域是指明了下一个结点的具体地址，而游标只是指明了在此数组中的下标。\n>\n> 静态链表如果要表示该结点为最后一个结点的话，可以将它的游标的值设为-1。\n\n> 这样一来，若0号结点的游标为2，那么就可以直接寻找到下标为2的结点的地址。（即静态链表的起始地址`addr + sizeof(Node) * 2`，实际上就是数组）\n\n#### 结点类型定义\n\n```c\n#define MaxSize 50  //静态链表的最大长度\ntypedef struct{  //静态链表结构类型的定义\n    ElemType data;  //存储数据元素\n    int next;  //下一个元素的数组下标\n}SLinkList[MaxSize];\n```\n\n上下的代码定义等价\n\n```C\n#define MaxSize 50  //静态链表的最大长度\ntypedef struct{  //静态链表结构类型的定义\n    ElemType data;  //存储数据元素\n    int next;  //下一个元素的数组下标\n};\ntypedef struct Node SLinkList[MaxSize];//可用SLinkList定义\"一个长度为MaxSize的Node型数组\"\n```\n\n> **问题**：\n>\n> 用typedef给一个结构类型起别名我理解，但是这个别名怎么是一个“数组”呢？\n>\n> 实际上这样写以后。你就可以直接通过**SLinkList**定义“**一个长度为MaxSize的Node型数组**”了。\n>\n> 即如下所示，这两个写法是等价的：\n>\n> ```C\n> void testSLinkList(){\n> \tSLinkList a;\n> } \n> \n> void testSLinkList2(){\n> \tstruct Node a[MaxSize];\n> }\n> \n> ```\n>\n> **追问：**\n>\n> 我理解了这种定义方式的作用了。但是为什么要这样写呢？这样写不别扭吗？为什么不用我们传统的`struct Node a[MaxSize];`呢？\n>\n> 其实这个地方，和我们之前提到过的`LinkLise`和`LNode *`其想要**强调含义**是一个道理。\n>\n> 我使用`SLinkList a;`来定义，是想**强调**我这里正在定义一个**静态链表**。你一看就明白了，a是一个静态链表。\n>\n> 但是使用`struct Node a[MaxSize];`，它仅仅是定义一个Node型的数组a。\n\n#### 基本操作的实现\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-24.png\" style=\"zoom: 75%;\" />\n\n### 顺序表和链表的比较\n\n**逻辑结构**:都属于线性表，都是线性结构\n\n**物理结构**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-25.png\" style=\"zoom: 75%;\" />\n\n**基本操作**:\n\n- **创建**:\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-52.png\" style=\"zoom:55%;\" />\n\n- **销毁**:\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-53.png\" style=\"zoom:55%;\" />\n\n- **增、删**:\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-54.png\" style=\"zoom:55%;\" />\n\n- **查**:\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-55.png\" style=\"zoom:55%;\" />\n\n**在实际应用中应该怎样选取存储结构呢**？\n\n- **基于存储的考虑**\n\n  难以估计线性表的长度或存储规模时，不宜采用顺序表；链表不用事先估计存储规模，但链表的存储密度较低，显然链式存储结构的存储密度是小于1的。\n\n- **基于运算的考虑**\n\n  在顺序表中按序号访问ai的时间复杂度为O(1)，而链表中按序号访问的时间复杂度为O(n)，因此若经常做的运算是按序号访问数据元素，则显然顺序表优于链表。\n\n  在顺序表中进行插入、删除操作时，平均移动表中一半的元素，当数据元素的信息量较大且表较长时，这一点是不应忽视的；在链表中进行插入、删除操作时，虽然也要找插入位置，但操作主要是比较操作，从这个角度考虑显然后者优于前者。\n\n- **基于环境的考虑**\n\n  顺序表容易实现，任何高级语言中都有数组类型；链表的操作是基于指针的，相对来说前者实现较为简单，这也是用户考虑的一个因素。\n\n**开放式问题的回答思路**\n\n**注意**：对于一些开放式问题的答题思路，例如\n\n- 请描述顺序表和链表的…（区别、联系…）\n- 实现线性表时，用顺序表还是链表好？\n\n你都可以用这样的思路（框架），来让自己的答题逻辑更加的清晰。\n\n**这样的思路（框架）**：指的是本节中，对顺序表和链表分别从**逻辑结构**、**存储结构**、**基本操作**三个角度进行了对比，并指出**优缺点**、**效率**上的差异等。\n\n> 具体的回答思路，例如：\n>\n> 顺序表和链表的逻辑结构都是线性结构，都属于线性表。\n>\n> 但是二者的存储结构不同，顺序表采用顺序存储…，具有…的特点，从而导致其优点…，缺点…；而链表采用链式存储，具有…的特点，从而导致其优点…，缺点…。\n>\n> 由于采用不同的存储方式实现，因此基本操作的实现效率也不同。当初始化时…；当插入一个数据元素时…；当删除一个数据元素时…；当查找一个数据元素时…。\n\n当然，也并不是说这其中的每一个点都必须写出来，意思就是，你可以根据实际情况，按照这个大致思路进行回答，并且选择把哪些点答上去，哪些可以不答上去。总之，思路是清晰的。\n\n此外，这样的框架性的思路除了便于答题外，也有助于自己的复习、回顾。\n\n### 习题\n\n  - 【2016】已知一个带有表头结点的双向循环链表L，结点结构为`prev|data|next`,其中，prev 和 next 分别是指向其直接前驱和直接后继结点的指针。现要删除指针 p 所指的结点，正确的语句序列是\n\n    >  p->next->prev=p->prev; p->prev->next=p->next; free(p);\n\n  - 【2016】已知表头元素为 c 的单链表在内存中的存储状态如下表所示。\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-30.png\"  />\n\n    现将 f 存放于 1014H 处并插入到单链表中，若 f 在逻辑上位于 a 和 e 之间，则 a, e, d 的“链接地址”依次是-->1014H 1004H NULL\n\n    > 链表的遍历顺序c（1008H）->a（1000H）->e（1010H）->b（1004H）->d（100CH）->null，然后你插入f到a,e 之间，则a要链接的地址就变成了f的地址，则a的链接地址为1014H ，而f的链接地址则是为e的地址1010H，最后的e后面的链接是没有变的依然是到b。总结：插入后链表的遍历顺序c（1008H）->a（1000H）->f(1014H)->e（1010H）->b（1004H）->d（100CH）->null\n\n  - 【2021】已知头指针h指向一个带头结点的非空单循环链表，结点结构为`data|next`,其中next是指向直接后继结点的指针，p是尾指针，q是临时指针。现要删除该链表的第一个元素，正确的语句序列是--> \n\n    q= h->next; h->next=q->next; if(p==q) p=h; free(q);\n\n    > 删除该链表的第一个元素就是让你删除头结点后面的第一个结点。\n    >\n    > 普通情况:\n    >\n    > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-31.png\" style=\"zoom:67%;\" />\n    >\n    > 特殊情况:要注意当我们删除head后面的节点以后，整个链表就只剩下head节点一个了。 那尾指针只能指向head，所以D选项里的if(p==q)  p=h; free(q);就非常正确。\n    >\n    > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-32.png\" style=\"zoom:67%;\" />\n\n  - 综合【2009】已知一个带有表头结点的单链表，结点结构为`data|link` 假设该链表只给出了头指针list。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第k个位置上的结点（k为正整数）。若查找成功，算法输出该结点的data域的值，并返回1；否则，只返回0。要求： \n\n    ① 描述算法的基本设计思想 \n\n    ② 描述算法的详细实现步骤 \n\n    ③ 根据设计思想和实现步骤，采用程序设计语言描述算法，关键之处请给出简要注释\n\n    > 1)关键是设计尽可能高效的算法，通过链表的一次遍历，找到倒数第k个结点的位置。算法的基本设计思想是:定义两个指针变量p和q，初始时均指向头结点的下一个结点(链表的第一个结点)，p指针沿链表移动；当p指针移动到第k个结点时，q指针开始与p指针同步移动；当p指针移动到最后一个结点时，q指针所指示结点为倒数第k个结点。\n    >\n    > 2)算法详细实现步骤:\n    >\n    > 1.count=0,p和q指向链表表头结点的下一个结点。\n    >\n    > 2.若p为空，转5\n    >\n    > 3.若count等于k，则q指向下一个结点；否则，count=count+1。\n    >\n    > 4.p指向下一个结点，转2\n    >\n    > 5.若count等于k，则查找成功，输出该结点的data域的值，返回1；否则，说明k值超过了线性表的长度，查找失败，返回0.\n    >\n    > 6.算法结束。\n    >\n    > 3)算法实现如下:\n    >\n    > ```C\n    > typedef struct LNode{\n    > \tint data;\n    > \tstruct LNode *link;\n    > }LNode, *LinkList;\n    > \n    > int Search_k(LinkList list,int k){\n    > \t//查找链表list倒数第k个结点，并输出该结点data域的值\n    > \tLNode *p=list->link;//指针p,q指向链表的第一个结点 \n    > \tLNode *q=list->link;\n    > \tint count=0;//计数器初始化为0 \n    > \twhile(p! =NULL){//指针p依次遍历链表直至最后一个结点 \n    > \t\tif(count<k) count++;\n    > \t\telse  q=q->link;\n    > \t\t p=p->link;\n    > \t} //while\n    > \t/*\n    > \t上面这几行是这个算法的核心思想，我来解释一下\n    > \t首先算法开始运行时，p在动，而q不动\n    > \t直到p向右移动了k次，此时k和count相等，这时候p和q一起向右移动\n    > \t如果k小于链表的长度，则返回q指针指向的数据域 \n    > \t*/\n    > \tif(count<k)//若k值大于链表的长度，则找不到该结点，返回0 \n    > \t   return 0;\n    > \telse{\n    > \t\tprintf(\"%d\",q->data);//找到该结点则返回该结点的数据域 \n    > \t\treturn 1;\n    > \t} \n    > } \n    > ```\n\n  - 综合【2012】假定采用带头结点的单链表保存单词，当两个单词有相同的后缀时，可共享相同的后缀存储空间，例如,\"loading\"和\"being\"的存储影像如下图所示。\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-33.png\"  />\n\n    设str1和str2分别指向两个单词所在单链表的头结点，链表结点结构为`data|next`，请设计一个时间上尽可能高效的算法，找出由str1和str2所指向两个链表共同后缀的起始位置(如图中字符i所在结点的位置p)。要求:\n\n    1)给出算法的设计思想\n\n    2)根据设计思想，采用程序语言描述算法，关键之处给出注释\n\n    3)说明你所设计算法的时间复杂度\n\n    > 1)分别求出str1和str2所指的两个链表的长度m和n；\n    > 将两个链表以表尾对齐：令指针p、q分别指向str1和str2的头结点；如果m>=n，则p指针先走，使p指向链表中的第m-n+1个结点；如果m<n，则使q指针指向链表的第n-m+1个结点；即：使得指针p、q所指的结点到表尾的长度相等；\n    > 反复将指针q和q同步向后移动，当p、q指向同一位置时停止，即：共同后缀的起始位置。算法结束。\n    > 2）\n    >\n    > ```C\n    > typedef struct LNode{\n    >  char data;\n    >  struct LNode *next;\n    > }LNode;\n    > \n    > //求链表的长度;\n    > int GetListLen(LNode *head){\n    >  int len = 0;\n    >  while(head->next != NULL){\n    >      len++;\n    >      head = head->next;\n    >  }\n    >  return len;\n    > }\n    > //找出共同后缀的起始位置；\n    > LNode* find_addr(LNode *str1,LNode *str2){\n    >  int m,n;\n    >  m = GetListLen(str1);\n    >  n = GetListLen(str2);\n    > \n    >  LNode *p,*q;\n    >  if(m >= n){\n    >      for(p = str1;m>n;m--){\n    >          p = p->next;\n    >      }\n    >  }else{\n    >      for(q = str2;n>m;n--){\n    >          q = q->next;\n    >      }\n    >  }\n    >  //得到p和q的起始位置后，找出共同后缀的起始地址；\n    >  while(p->next !=NULL && p->next != q->next){\n    >      p = p->next;\n    >      q = q->next;\n    >  }\n    >  return p->next;\n    > }\n    > ```\n    >\n    > 3)**O(max(m,n))**（m、n分别为两个链表的长度）；\n\n  - 综合【2015】用单链表保存m个整数，结点的结构为[data]|[link]，且|data|<=n(n为正整数)。现要求设计一个时间复杂度尽可能高效的算法，对于链表中data的绝对值相等的结点，仅保留第一次出现的结点而删除其余绝对值相等的结点。例如，若给定的单链表head如下:\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-34.png\" style=\"zoom:80%;\" />\n\n    则删除结点后的head为：\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-35.png\" style=\"zoom:80%;\" />\n\n    要求：  \n\n       1）给出算法的基本设计思想。  \n\n       2）使用C或C++语言，给出单链表结点的数据类型定义。  \n\n       3）根据设计思想，采用C或C++语言描述算法，关键之处给出注释。  \n\n       4）说明你所设计算法的时间复杂度和空间复杂度。\n\n    > 1）算法的基本设计思想 \n    >\n    > 算法的核心思想是用空间换时间。使用辅助数组记录链表中已出现的数值，从而只需对链表进行一趟扫描。 因为|data|≤n，故辅助数组q的大小为n+1，各元素的初值均为0。依次扫描链表中的各结点，同时检查q[|data|]的值，如果为0，则保留该结点，并令q[|data|]=1；否则，将该结点从链表中删除。 \n    >\n    > 2）使用C语言描述的单链表结点的数据类型定义\n    >\n    > ```C\n    > typedef struct node {\n    > int         data;\n    > struct node   *link;\n    > }NODE;\n    > Typedef NODE *PNODE;\n    > ```\n    >\n    > 3）算法实现\n    >\n    > ```C\n    > void func (PNODE h,int n)\n    > {\n    > PNODE p=h,r;\n    > int *q,m;\n    > q=(int *)malloc(sizeof(int)*(n+1));  //申请n+1个位置的辅助空间\n    > for(int i=0;i<n+1;i++)                //数组元素初值置0\n    > *(q+i)=0;\n    > while(p->link!=NULL)\n    > {\n    > m=p->link->data>0? p->link->data:-p->link->data;\n    > if(*(q+m)==0)                      //判断该结点的data是否已出现过\n    > {\n    > *(q+m)=1;                      //首次出现\n    > p=p->link;                     //保留\n    > }\n    > else                               //重复出现\n    > {   r=p->link;                     //删除\n    > p->link=r->link\n    > free(r);\n    > }\n    > }\n    > free(q);\n    > }\n    > ```\n    >\n    > 4）时间复杂度为O(m)，空间复杂度为O(n)\n\n  - 【2019】设线性表L=(a1,a2,a3,...,a(n-2),a(n-1),an)采用带头结点的单链表保存，链表中的结点定义如下:\n\n    ```C\n    typedef struct node {\n        int data;\n        struct node* next;\n    } NODE;\n    ```\n\n    请设计一个空间复杂度为 `O(1)` 且时间上尽可能高效的算法，重新排列 L 中的各节点，得到线性表 `L'=(a1, an, a2, a(n-1), a3, a(n-2), ...)`。要求:\n\n    1)给出算法的设计思想\n\n    2)根据设计思想，采用程序语言描述算法，关键之处给出注释\n\n    3)说明你所设计算法的时间复杂度\n\n    > 1)先观察L=(a1,a2,a3,...,a(n-2),a(n-1),an)和L'=(a1,an,a2,a(n-1),a3,a(n-2),...)，发现L'是由L摘取第一个元素，再摘取倒数第一个元素......依次合并而成的。为了方便链表后半段取元素，需要先将L后半段原地逆置[题目要求空间复杂度为O(1)，不能借助栈]，否则每取最后一个结点都需要遍历一次链表。1.先找出链表L的中间结点，为此设置两个指针p和q,指针p每次走一步，指针q每次走两步，当指针q到达链尾时，指针p正好在链表的中间结点；2.然后将L的后半段结点原地逆置。3.从单链表前后两段中依次各取一个结点，按要求重排。\n    >\n    > 2)算法实现\n    >\n    > ```C\n    > void Change_list(Linklist h){\n    > \tLNode *p,*q,*r,*s;\n    > \tp=q=h;\n    > \t/*双指针找链表的中点*/ \n    > \twhile(q->next!=NULL){\n    > \t\tp=p->next;\t\t\t\t\t//p走一步 \n    > \t\tq=q->next;\n    > \t\tif(q->next!=NULL)q=q->next; //q走两步 \n    > \t}\n    > \t/*链表的逆置*/\n    > \tq=p->next;\t\t\t//p所指结点为中点 \n    > \tp->next=NULL;\t\t//q为后半链表的首结点 \n    > \twhile(q!=NULL){\n    > \t\tr=q->next;\n    > \t\tq->next=p->next;\n    > \t\tp->next=q;\n    > \t\tq=r;\n    > \t}\n    > \t/*后半部分的链表头插进入前半部分*/\n    > \ts=h->next;\n    > \tq=p->next;\n    > \tp->next=NULL;\n    > \twhile(q!=NULL){\n    > \t\tq->next=s->next;//将q所指结点插入到s所指结点之后 \n    > \t\ts->next=q;\n    > \t\ts=q->next;\t\t//将s指向前半段的下一个插入点 \n    > \t\tq=r;\n    > \t}\n    > }\n    > \n    > ```\n    >\n    > 3)第一步找中间结点的时间复杂度为O(n),第二步逆置的时间复杂度为O(n)，第3步合并链表的时间复杂度为O(n),所以该算法的时间复杂度为O(n)。\n","tags":["408数据结构"],"categories":["408数据结构"]},{"title":"第二章 线性表(上)","url":"/p/14457/","content":"\n## 2.1 线性表的定义和基本操作\n\n### 什是线性表？🤔\n\n**有点像函数**\n\n函数：一个 x 值只能对应一个 y 值\n线性表：一个索引值只能有一个映射值\n\n**定义**:线性表是具有相同数据类型的 n(n≥0) 个<font color='orange'>数据元素</font>的有限序列，其中n为表长，当n-0时线性表是一个<font color='orange'>空表</font>。若用L命名线性表，则其一般表示为\n\nL=(a1,a2,...,ai,ai+1,...,an)\n\n**几个概念**:\n\n- ai是线性表的\"第i个\"元素线性表中的位序。\n- a1是<font color='orange'>表头元素</font>；an是<font color='orange'>表尾元素</font>。\n- 除第一个元素外，每个元素有且<font color='orange'>仅有一个直接前驱</font>；除最后一个元素外，每个元素有且<font color='orange'>仅有一个直接后继</font>\n\n**特点**:\n\n- 表中元素<font color='orange'>个数有限</font>\n- 表中元素具有逻辑上的顺序性，表中元素有其<font color='orange'>先后次序</font>\n- 表中元素都是数据元素，每个元素都是单个元素\n- 表中元素的数据类型都相同，这意味着<font color='orange'>每个元素占有相同大小的存储空间</font>\n- 表中元素具有抽象性 \n\n<font color='red'>注</font>:线性表是一种<font color='red'>逻辑结构</font>，表示元素之间一对一的相邻关系。顺序表和链表是指<font color='red'>存储结构</font>，两者属于不同的层面概念，不要混淆\n\n### 线性表的基本操作\n\n详细文档可以参考 c++容器[list 的相关函数](https://cplusplus.com/reference/list/list/)\n\n[c++代码示例](../code/2.1.list.cpp)\n\n- InitList(&L) ：初始化表，构造一个空的线性表\n\n- DestroyList(&L) ：销毁线性表\n- ClearList(&L) ：清空线性表\n- ListEmpty(&L) ：置空线性表\n- ListLength(L) ： 求线性表长度\n- GetElem(L, i, &e) ： 获取元素\n- LocateElem(L, e, compare())\n- PriorElem(L, cur_e, &pre_e) ： 获取元素的前驱\n- NextElem(L,cur_e,&next_e) ： 获得元素的后继\n- ListInsert(&L,i,e) ：插入操作\n- ListDelete(&L,i,&e) ：删除操作\n- ListTraverse(&L, vistited()) ：遍历 \n\nTips：\n\n- 对数据的操作——无非就是创建、销毁；增、删、改、查。\n- 在描述基本操作的时候，并不指明具体的参数类型，而是一种抽象的接口定义。\n- 实际开发中，可根据实际需求定义其他的基本操作。\n- 函数名和参数的形式、命名都可改变。但是尽量具有可读性，写成上面这种就很好，都是很好的命名方式了。\n- **什么时候要传入引用”&“——对参数的修改结果需要”带回来“。即操作的是同一份实实在在的数据目标，而不能是一个拷贝的复制品。**\n\n**问题**：为什么要实现对**数据结构**的基本操作？\n\n- 团队合作编程，你定义的数据结构要让别人能很方便地使用（封装）。\n- 将常用的操作/运算封装成函数，避免重复工作，降低出错风险。\n\n\n\n## 2.2 线性表的顺序表示\n\n### 顺序表的定义 Sequence List\n\n- **顺序表**--用顺序存储的方式实现线性表顺序存储。\n\n- **顺序存储**--把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。\n\n- 顺序表的**特点**:\n\n  - 表中元素的逻辑顺序与其物理顺序相同。\n  - <font color='orange'>随机访问</font>，即通过首地址和元素序号可在时间O(1)内找到指定的元素。\n  - <font color='orange'>存储密度高</font>，每个结点只存储数据元素。它不像链表那样还需要存放一个指针域。\n  - 拓展容量不方便。即使采用动态分配的方式实现，拓展长度的时间复杂度也比较高。\n  - 插入、删除操作不方便，需要移动大量元素。\n\n- 顺序表的实现\n\n  - 静态分配\n\n    ```C\n    #define MaxSize 10;\t\t\t\t//定义最大长度\n    typedef struct{\n        ElemType data[MaxSize];\t\t//用静态的\"数组\"存放数据元素\n        int length;\t\t\t\t\t//顺序表的当前长度\n    }SqList;\t\t\t\t\t\t//顺序表的类型定义(静态分配方式)\n    ```\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-1.png\" style=\"zoom: 75%;\" />\n\n    **问题**：如果“数组”存满了怎么办？\n\n    - 可以放弃了，顺序表的表长刚开始确定后就无法更改（存储空间是静态的）\n    - 如果刚开始就声明一个很大的内存空间呢？会很浪费空间。\n\n  - 动态分配\n\n    ```C\n    #define MaxSize 100;\t\t\t\t//定义最大长度\n    typedef struct{\n        ElemType *data;\t\t\t\t//指针指向第一个数据元素\n        int MaxSize;\t\t\t\t//顺序表的最大容量\n        int length;\t\t\t\t\t//顺序表的当前长度\n    }SeqList;\t\t\t\t\t\t//顺序表的类型定义(动态分配方式)\n    ```\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-2.png\" style=\"zoom: 75%;\" />\n\n  - C 的初始动态分配语句--malloc、free函数\n\n    `L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize);`\n\n    malloc函数返回一个指针，需要强制转型为你定义的数据元素类型指针\n\n    > char * p = (char* ) malloc(sizeof(char)*10)；\n    >\n    > //申请了10个char长度的连续空间，不初始化且不知道是否申请成功\n    >\n    > if(NULL == p)\n    >\n    > return；//申请内存空间失败\n\n  - C++的初始动态分配语句--new、delete关键字\n\n    `L.data = new ElemType[InitSize];`\n\n### 顺序表上基本操作\n\n- 插入操作\n\n  - 最好情况：表尾插入(即i=n+1)，时间复杂度为O(1)\n\n  - 最坏情况：表头插入(即i=1)，时间复杂度为O(n)\n\n  - 平均情况：插入到任一位置的概率相同，即i=1,2,3,...,length+1的概率都是p=1/(n+1)。 i=1，循环n次；i=2时，循环n-1次；... i=n+1时，循环0次\n    $$\n    E_{ins} = \\frac 1{n+1} \\sum^{n+1}_{i=1}(n-i+1) = \\frac 1{n+1}(n+\\cdots + 1 + 0) = \\frac n2\n    $$\n     ，平均时间复杂度为O(n)\n\n  ```C\n  void ListInsert(SqList &L, int i, int e){\n  \tfor(int j=L.length; j>=i; j--){\t//将第i个元素及之后的元素后移 \n  \t\tL.data[j] = L.data[j-1];\n  \t}\n  \tL.data[i-1] = e;\t//在位置i处放入e\n  \tL.length++;\t\t//长度加1 \n  }\n  ```\n\n  对于插入操作，如果使用者传入了一个**不合法的值**，那么我们的程序应该可以给予相应的反馈。至少要反馈插入是成功，还是失败了吧。所以我们可以优化一下，如下:\n\n  ```C\n  // 插入操作代码\n  bool ListInsert(SqList &L, int i, ElemType e) {\n      if (i < 1 || i > L.length + 1 )          // 判断i的范围是否有效\n          return false;\n      else if (L.length >= MAXSIZE)            // 当前存储空间已满\n          return false;\n      for (int j = L.length ; j >= i ; j--)\n          L.data[j] = L.data[j - 1];           // 插入位置及之后位置后移\n      L.data[i - 1] = e;                       // 将新元素放入第i个位置\n      L.length++;                              //表长增加1\n      return true;\n  }\n  ```\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-51.png\" style=\"zoom: 75%;\" />\n\n- 删除操作\n\n  - 最好情况：删除表尾元素(即i=n)，时间复杂度为O(1)\n\n  - 最坏情况：删除表头元素(即i=1)，时间复杂度为O(n)\n\n  - 平均情况：删除任何一个元素的概率相同，即I=1,2,3,...,length的概率都是p=1/n。i=1，循环n-1次；i=2时，循环n-2次；...i=n时，循环0次\n    $$\n    E_{del} = \\frac 1n \\sum^n_{i=1}(n-i)=\\frac 1n \\frac {(n-1)n}2 = \\frac{n-1}2\n    $$\n     ，平均时间复杂度为O(n)\n\n  ```C\n  // 删除操作代码\n  bool ListDelete(SqList& L, int i, ElemType &e) {\n      if (i < 1 || i > L.length)             // 判断i值是否合理\n          return false;\n      e = L.data[i - 1];         //将被删除的元素赋给e\n      for (int j = i; j < L.length; j++)\n          L.data[j - 1] = L.data[j];  //将被删除的元素赋给e\n      L.length--;  //线性表长度减1\n      return true;\n  }\n  ```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-4.png\" style=\"zoom: 70%;\" />\n\n- **按位查找**\n\n  ```C\n  ELemType GetElem(SeqList L, int i){\n      return L.data[i-1];\n  }\n  ```\n\n  时间复杂度:O(1)   \"**随机存取**\"特性!\n\n- **按值查找**（顺序查找）\n\n  - 最好情况：查找的元素就在表头循环1次，时间复杂度为O(1)\n\n  - 最坏情况：查找的元素在表尾（或不存在）循环n次，时间复杂度为O(n)\n\n  - 平均情况：目标元素出现在任一位置的概率相同，都是1/n。目标在第1位，循环1次；...在第n位，循环n次。\n    $$\n    E_{find} = \\frac 1n \\sum^n_{i=1}i= \\frac{n+1}2\n    $$\n     ，平均时间复杂度为O(n)\n\n  ```C\n  int LocateElem(SeqList L,ElemType e){\n  \tfor(int i=0;i<L.length;i++)\n      {\n          if(L.data[i]==e)\n          {\n              return i+1;\t\t//数组小标为i的元素值等于e,返回其位序i+1\n          }\n          return 0;\t\t\t//退出循环,说明查找失败\n      }\n  }\n  ```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-5.png\" style=\"zoom: 70%;\" />\n\n> **问题**：此处，像int、float、char等类型，判断相等可以使用“= =”来判断。但若是结构类型的数据呢？还可以用“= =”吗？——不能。\n>\n> 如果是结构类型的数据，判断其是否相等，你需要依次比较该结构体中的各个变量是否相等，最终判断两个结构类型变量是否相等。当然，你也可以将判断两个结构类型是否相等的代码封装成一个函数，以便复用。\n>\n> 如果使用C++、JAVA，你也可以对“= =”进行运算符重载。\n>\n> **Tips**：但是呢，如果你是在《数据结构》的考研初试的试卷当中，去手写代码的时候，你当然可以直接用“= =”来判断是否相等，不论是什么类型，而不需要考虑那么多，因为数据结构考的是一种思想、一种理解，而并不是具体的编程语言的实现。\n>\n> 但是，如果考的是《C语言程序设计》，那么，也许你就要严格按照C语言的语法来写，即使是在试卷上手写代码。\n\n### 习题\n\n- 11 顺序表的插入算法中，当 n 个空间已满时，可再申请增加分配 m 个空间，若申请失败，则说明系统没有（）可分配的存储空间 →n+m 个连续\n\n  > 顺序存储需要连续的存储空间，在申请时需申请n+m个连续的存储空间，然后将线性表原来的n个元素复制到新申请的n+m个连续的存储空间的前n个单元。\n\n- 综合题 10【2010】设将(n>1)个整数存放到一堆数组R中。设计一个在时间和空间两方面都尽可能高效的算法。将R中保存的序列循环左移p（0<p<n）个位置，即将R中的数据由（X0, X1,..., Xn-1）变换为（Xp, Xp+1,..., Xn-1, X0, X1,..., Xp-1）。要求：\n\n  1）给出算法的基本设计思想。\n\n  2）根据设计思想，采用C、C++或Java语言描述算法，关键之处给出注释。\n\n  3）说明你所设计算法的时间复杂度和空间复杂度。\n\n  > 1）算法的基本设计思想： \n  >\n  > 可以将这个问题看作是把数组ab转换成数组ba（a代表数组的前p个元素，b代表数组中余下的n-p个元素）:先将a逆置得到a^-1^b，再将b逆置得到a^-1^b^-1^，最后将整个a^-1^b^-1^逆置得到（a^-1^b^-1^）^-1^=ba。设Reverse函数执行将数组元素逆置的操作，对abcdefgh向左循环移动3（p=3）个位置的过程如下： \n  >\n  > Reverse(0,p-1)得到cbadefgh；  \n  >\n  > Reverse(p,n-1)得到cbahgfed；  \n  >\n  > Reverse(0,n-1)得到defghabc。\n  >\n  > 注：Reverse中，两个参数分别表示数组中待转换元素的始末位置。\n  >\n  > 2）使用C语言描述算法如下：\n  >\n  > ```C\n  > void Reverse(int R[],int from,int to) {\n  > int i,temp;\n  > for(i=0;i<(to-from+1)/2;i++)\n  > {    temp=R[from+i];\n  >    R[from+i]=R[to-i];\n  >    R[to-i]=temp;}\n  > }//Reverse\n  > void Converse(int R[],int n,int p){\n  > Reverse(R,0,p-1);\n  > Reverse(R,p,n-1);\n  > Reverse(R,0,n-1);\n  > }\n  > ```\n  >\n  > 3）上述算法中3个Reverse函数的时间复杂度分别为O(p/2)、O((n-p)/2)和O(n/2)，故所设计的算法的时间复杂度为O(n)，空间复杂度为O(1)。\n  >\n  > **另解**，借助辅助数组来实现。  \n  >\n  > 算法思想：创建大小为p的辅助数组S，将R中前p个整数依次暂存在S中，同时将R中后n-p个整数左移，然后将S中暂存的p个数依次放回到R中的后续单元。  \n  >\n  > 时间复杂度为O(n)，空间复杂度为O(p)。\n\n- 综合题 11【2011】一个长度为L(L>=1)的升序序列S，处在第[L/2]个位置的数称为S的中位数。例如，若序列S1=(11，13，15，17，19)，则S1的中位数是15，两个序列的中位数是含它们所有元素的升序序列的中位数。例如，若S2=（2，4，6，8，20），则S1和S2的中位数是11。现在有两个等长升序序列A和B，试设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列A和B的中位数。要求：\n\n  （1）给出算法的基本设计思想。\n\n  （2）根据设计思想，采用C、C++或Java语言描述算法，关键之处给出注释。\n\n  （3）说明你所设计算法的时间复杂度和空间复杂度。\n\n  > 1）求两个序列A和B的中位数最简单的办法就是将两个升序序列进行归并排序，然后求其中位数。这种解法虽可求解，但在时间和空间两方面都不大符合高效的要求，但也能获得部分分值。 \n  >\n  > 根据题目分析，分别求两个升序序列A和B的中位数，设为a和b。 \n  >\n  > ① 若a=b，则a或b即为所求的中位数。 \n  >\n  > 原因：容易验证，如果将两个序列归并排序，则最终序列中，排在子序列ab前边的元素为先前两个序列中排在a和b前边的元素；排在子序列ab后边的元素为先前两个序列中排在a和b后边的元素。所以子序列ab一定位于最终序列的中间，又因为a=b，显然a就是中位数。 \n  >\n  > ② 否则（假设a<b），中位数只能出现（a，b）范围内。 \n  >\n  > 原因：同样可以用归并排序后的序列来验证，归并排序后必然有形如…a…b…的序列出现，中位数必出现在（a，b）之间。因此可以做如下处理：舍弃a所在序列A的较小一半，同时舍弃b所在序列B的较大一半。在保留两个升序序列中求出新的中位数a和b，重复上述过程，直到两个序列中只含一个元素时为止，则较小者即为所求的中位数。每次总的元素个数变为原来的一半。 \n  >\n  > 算法的基本设计思想如下: \n  >\n  > 分别求出序列A和B的中位数，设为a和b，求序列A和B的中位数过程如下: \n  >\n  > ① 若a=b，则a或b即为所求中位数，算法结束。 \n  >\n  > ② 若a<b，则舍弃序列A中较小的一半，同时舍弃序列B中较大的一半，要求舍弃的长度相等。 \n  >\n  > ③ 若a>b，则舍弃序列A中较大的一半，同时舍弃序列B中较小的一半，要求舍弃的长度相等。 \n  >\n  > 在保留的两个升序序列中，重复过程①、②、③，直到两个序列中只含一个元素时为止，较小者即为所求的中位数。 \n  >\n  > 2）算法的实现如下:\n  >\n  > ```C\n  > int M_Search(int A[],int B[],int n){\n  >  int s1=0,d1=n-1,m1,s2=0,d2=n-1,m2;\n  >  //分别表示序列A和B的首位数、末位数和中位数\n  >  while(s1!=d1||s2!=d2){\n  >      m1=(s1+d1)/2;\n  >      m2=(s2+d2)/2;\n  >      if(A[m1]==B[m2])\n  >          return A[m1];           //满足条件①\n  >      if(A[m1]<B[m2]){            //满足条件②\n  >          if((s1+d1)%2==0){     //若元素个数为奇数\n  >              s1=m1;              //舍弃A中间点以前的部分，且保留中间点\n  >              d2=m2;              //舍弃B中间点以后的部分，且保留中间点\n  >          }\n  >          else{                  //元素个数为偶数\n  >              s1=m1+1;              //舍弃A中间点及中间点以前部分\n  >              d2=m2;                //舍弃B中间点以后部分且保留中间点\n  >          }\n  >      }\n  >      else{                        //满足条件③\n  >          if((s2+d2)%2==0) {     //若元素个数为奇数\n  > \t\t        d1=m1;              //舍弃A中间点以后的部分，且保留中间点\n  > \t\t        s2=m2;              //舍弃B中间点以前的部分，且保留中间点\n  > \t\t    }\t\n  > \t\t    else{                  //元素个数为偶数\t\n  > \t\t        d1=m1;              //舍弃A中间点以后部分，且保留中间点\t\n  > \t\t        s2=m2+1;                //舍弃B中间点及中间点以前部分\n  > \t\t    }\t\n  > \t\t}\n  > \t}\t\n  > \treturn A[s1]<B[s2]? A[s1]:B[s2];\n  > }\n  > ```\n  >\n  > 3）算法的时间复杂度为O(log₂n)，空间复杂度为O(1)。  \n  >\n  > 【另解】对两个长度为n的升序序列A和B的元素按由小到大的顺序依次访问，这里访问的含义只是比较序列中两个元素的大小，并不实现两个序列的合并，因此空间复杂度为O(1)。按照上述规则访问到第n个元素时，这个元素即为两个序列A和B的中位数。\n\n- 综合题 12【2013】已知一个整数序列A=(a0,a1,...,an-1)，其中0<=ai<=0(0<=o<=n)。若存在ap1=ap2=...=apm=x 且 m>n/2(0<=pk<n,1<=k<=m),则称x为A的主元素。例如A=（0,5,5,3,5,7,5,5），则5为主元素；又如A =(0,5,5,3,5,1,5,7)，则A中没有主元素。假设A中的几个元素保存在一个一维数组中，请设计一个尽可能高效的算法，找出A的主元素。若存在主元素，则输出该元素；否则输出-1。要求：\n\n  (1) 给出算法的基本设计思想\n\n  (2) 根据设计思想，釆用C或C++或Java语言描述算法，关键之处给出注释。\n\n  (3) 说明你所设计算法的时间复杂度和空间复杂度。\n\n  > (1)将第一个出现的元素num保存到c中，用count记录num出现的次数，初始时令count = 1。如果下一个遇到的元素仍然是num则将count加1，否则将count减1。如果此时count == 0，则将下一个元素保存到c中，并重置count为0。重复上述过程，直至扫描完全部元素。\n  > 判断此时的c是否为真正的主元素。统计c出现的次数，并保存到count中，如果count > n / 2，则是主元素，否则不是。\n  > **通俗来讲：就是不断消除两个不同的元素，最后剩的元素就是可能的主元素，然后再判断该可能的主元素个数是否大于n/2，若大于，则主元素就是该元素**。\n  >\n  > (2)算法实现\n  >\n  > ```C\n  > int Majority(int A[], int n)\n  > {\n  > \tint i, c, count = 1;//c用来保存候选主元素，count用来计数\n  > \tc = A[0];           //设置A[0]为候选主元素\n  > \tfor (i = 1; i < n; i++)//查找候选主元素\n  > \t\tif (A[i] == c)\n  > \t\t\tcount++;    //对A中的候选主元素计数\n  > \t\telse\n  > \t\t\tif (count > 0)//处理不是候选主元素时的情况\n  > \t\t\t\tcount--;\n  > \t\t\telse{         //更换候选主元素，重新计数\n  > \t\t\t\tc = A[i];\n  > \t\t\t\tcount = 1;\n  > \t\t\t}\n  > \tif (count > 0)\n  > \t\tcount = 0;\n  > \t\tfor (i = 0; i < n; i++)//统计候选主元素的实际出现情况\n  > \t\t\tif (A[i] == c)\n  > \t\t\t\tcount++;\n  > \tif (count > n / 2)\treturn c;//确定候选主元素\n  > \telse return -1;//不存在主元素\n  > }\n  > ```\n  >\n  > (3)实现的程序时间复杂度为O(n)，空间复杂度为O(1)。\n\n- 综合题 13【2018】给定一个含n(n>=1)个整数的数组，请设计一个在时间上尽可能高效的算法，找出数组中未出现的最小正整数。例如，数组{-5，3，2，3}中未出现的最小正整数是1；数组{1, 2, 3}中未出现的最小正整数是4。要求：\n\n  （1）给出算法的基本设计思想。 \n\n  （2）根据设计思想，采用 C 或 C++语言描述算法，关键之处给出注释。 \n\n  （3）说明你所设计算法的时间复杂度和空间复杂度。\n\n  > 1)题目要求算法时间上尽可能高效，因此采用空间换时间的办法。分配一个用于标记的 数组 B[n]，用来记录 A 中是否出现了 1～n 中的正整数，B[0]对应正整数 1，B[n-1]对应正整数 n，初始化 B 中全部为 0。由于 A 中含有 n 个整数，因此可能返回的值是 1～n+1，当 A 中 n 个数恰好为 1～n 时返回 n+1。当数组 A 中出现了小于等于 0 或大于 n 的值时，会导致 1～n 中出现空余位置，返回结果必然在 1～n 中，因此对于 A 中出现了小于等于 0 或大于 n 的值可 以不采取任何操作。 \n  >\n  > 经过以上分析可以得出算法流程：从 A[0]开始遍历 A，若 0<A[i]<=n，则令 B[A[i]-1] = 1； 否则不进行操作。对 A 遍历结束后，开始遍历数组 B，若能查找到第一个满足B[i]==0 的下标 i，返回 i+1 即为结果，此时说明 A 中未出现的最小正整数在 1～n 之间。若 B[i]全部不为 0， 返回 i+1（跳出循环时 i = n，i+1 等于 n+1），此时说明 A 中未出现的最小正整数是 n+1。\n  >\n  > 2)算法实现\n  >\n  > ```C\n  > int findMissMin(int A[], int n)\n  > {\n  >  int i, *B;                          //标记数组\n  >  B = (int *)malloc(sizeof(int) * n); //分配空间\n  >  memset(B, 0, sizeof(int) * n);      //赋初值为 0\n  >  for (i = 0; i < n; i++)\n  >      if (A[i] > 0 && A[i] <= n) //若 A[i]的值介于 1～n，则标记数组 B\n  >          B[A[i] - 1] = 1;\n  >  for (i = 0; i < n; i++) //扫描数组 B，找到目标值\n  >      if (B[i] == 0)\n  >          break;\n  >  return i + 1; //返回结果\n  > }\n  > ```\n  >\n  > 3)时间复杂度：遍历 A 一次，遍历 B 一次，两次循环内操作步骤为 O(1)量级，因此时间 复杂度为 O(n)。空间复杂度：额外分配了 B[n]，空间复杂度为 O(n)。\n  >\n  > https://www.codenong.com/cs105598468/\n  >\n  > https://icode.best/i/29345031505648\n\n- 综合题 14【2020】定义三元组(a,b,c)(a、b、c均为正数)的距离D=|a-b|+|b-c|+|c-a|。给定3个非空整数集合S1、S2和S3，按升序分别存储在3个数组中。请设计一个尽可能高效的算法，计算并输出所有可能的三元组(a,b,c)(a∈S1,b∈S2,c∈S3)中的最小距离。例如S1={-1,0,9}，S2={-25,-10,10,11}，S3={2,9,17,30,41},则最小距离为2，相应的三元组为(9,10,9)。\n\n  （1）给出算法的基本设计思想。 \n\n  （2）根据设计思想，采用 C 或 C++语言描述算法，关键之处给出注释。 \n\n  （3）说明你所设计算法的时间复杂度和空间复杂度。\n\n  > (1)\n  >\n  > ①使用Dmin记录所有已处理的三元组的最小距离，初值为一个足够大的整数。\n  >\n  > ②集合S1、S2和S3分别保存在数组A、B、C中。数组的下标变量i=j=k=0,当i< |S1|、j< |S2|且k< |S3|时（|S|表示集合中的元素个数），循环执行下面的“a)~c)”。\n  >\n  > a)计算（A[i]，B[j]，C[k]）的距离D；（计算D）\n  >\n  > b)若D<Dmin，则Dmin=D；（更新D）\n  >\n  > c)将A[i]、B[j]、C[k]中的最小值的下标+1；\n  >\n  > ③输出Dmin，结束\n  >\n  > (2)算法实现\n  >\n  > ```C\n  > #define INT_MAX 0x7fffffff\n  > int abs_(int a){//计算绝对值\n  > \tif(a<0) return -a;\n  > \telse return a;\n  > }\n  > bool xls_min(int a,int b,int c){//a是否是三个数中的最小值\n  > \tif(a<=b&&a<=c) return true;\n  > \treturn false;\n  > }\n  > int findMinofTrip(int A[],int n,int B[],int m,int C[],int p){\n  > \t//D_min用于记录三元组的最小距离，处置赋为INT_MAX\n  > \tint i=0,j=0,k=0,D_min=INT_MAX,D;\n  > \twhile(i<n&&j<m&&k<p&&D_min>0){\n  > \t\tD=abs_(A[i]-B[j])+abs_(B[j]-C[k])+abs_(C[k]-A[i]);\n  > \t\tif(D<D_min) D_min=D;\n  > \t\tif(xls_min(A[i],B[j],C[k])) i++;\n  > \t\telse if(xls_min(B[j],C[k],A[i])) j++;\n  > \t\telse k++;\n  > \t}\n  > \treturn D_min;\n  > }\n  > \n  > ```\n  >\n  > (3)设n=(|S1|+|S2|+|S3|),时间复杂度为O(n)，空间复杂度为O(1)\n","tags":["408数据结构"],"categories":["408数据结构"]},{"title":"第一章 绪论","url":"/p/24523/","content":"\n## 1.1 数据结构的基本概念\n\n**解决问题方法的效率**\n\n- 跟数据的**组织方式**有关\n- 跟**空间的利用率**有关\n- 跟**算法的巧妙**程度有关\n\n什么是<font color='orange'>数据结构</font>？简单来说，数据结构就是一种*关系*。\n\n> Algorithm + Data Structures = Programs\n\n- **数据对象**在计算机中的组织方式\n  - 逻辑结构\n    - 线性、树、图...\n  - 物理存储结构\n    - 顺序存储、链式存储\n- 数据对象必定与一系列加在其上的**操作**相关联\n- 完成这些操作所用的方法就是**算法**\n\n### 基本概念和术语\n\n- **数据 Data**:数据是<font color='orange'>信息的载体</font>，是描述客观事物属性的数、字符及所有能输入到计算机中并<font color='orange'>被计算机程序识别和处理</font>的符合的集合。数据是计算机程序加工的原料。\n\n- **数据元素 Data Element**:数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。\n\n- **数据项 Data Item**:一个数据元素可由若干<font color='orange'>数据项</font>组成，数据项是构成数据元素的不可分割的最小单位。\n\n- **数据对象 Data Object**:数据对象是具有<font color='red'>相同性质</font>的数据元素的集合，是数据的一个子集。\n\n- **数据类型 Data Type**:数据类型是一个值的集合和定义在此集合的一组操作的总称。\n\n  - **原子类型**。其值不可再分的数据类型。\n\n  - **结构类型**。其值可用再分解为若干成分的数据类型\n\n  - <font color='red'>抽象数据类型</font>。抽象数据组织及与之相关的操作。\n\n    描述数据类型的方法不依赖于具体实现\n\n    - 与存放数据的机器无关\n    - 与数据存储的物理结构无关\n    - 与实现操作的算法和编程语言均无关\n\n    只描述数据对象集和相关操作集 **是什么**，并不涉及 **如何做到** 的问题\n\n    例:**矩阵** 的抽象数据类型的定义\n\n    - **类型名称**:矩阵（ Matrix ）\n\n    - **数据对象集**:一个 M×N的矩阵 \n\n      <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds1-1.png\" style=\"zoom:80%;\" />\n\n      由 M×N 个三元组 <a,i,j> 构成，其中 a 是矩阵元素的值，i 是元素所在的行号，j 是元素所在的列号。\n\n    - **操作集**:对于任意矩阵A、B、C ∈ Matrix，以及整数i、j、M、N\n\n      - `Matrix Create(int M, int N)`：返回一个 M×N 的矩阵；\n      - `int GetMaxRow(Matrix A)`：返回矩阵 A 的总行数；\n      - `int GetMaxCol(Matrix A)`：返回矩阵 A 的总列数；\n      - `ElementType GetEntry(Matrix A, int i, int j)`：返回矩阵 A 的第 i 行、第 j 列元素；\n      - `Matrix Add(Matrix A, Matrix B)`：如果 A 和 B 的行、列数一致，则返回矩阵 C=A+B ，否则返回错误标志；\n      - `Matrix Multiply(Matrix A, Matrix B)`：如果 A 的列数等于 B 的行数，则返回矩阵 C = AB ，否则返回错误标志；\n      - ......\n\n- **数据结构 Data Structure** :数据结构是相互之间存在一种或多种<font color='red'>特定关系</font>的数据元素的集合。\n\n### 数据结构三要素\n\n- 数据的**逻辑结构**\n  **集合**:结构中的数据元素之间除\"同属一个集合\"外，别无其他关系\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds1-2.png\" style=\"zoom:67%;\" />\n\n  - **线性结构**:数据元素只存在一对一的关系。除了第一个元素，所有元素都有唯一前驱；\n\n    除了最后一个元素，所有元素都有唯一后继。\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds1-3.png\" style=\"zoom:67%;\" />\n\n  - **树形结构**:数据元素之间存在一对多的关系。\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds1-4.png\" style=\"zoom:67%;\" />\n\n  - **图状/网状结构** :数据元素之间是多对多的关系\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds1-5.png\" style=\"zoom:67%;\" />\n\n- 数据的**存储结构**\n\n  存储结构是指数据结构在计算机中的表示(又称映像)，也称**物理结构**。\n\n  - **顺序存储**:把<font color='red'>逻辑上相邻的元素存储在物理位置上也相邻的存储单元中</font>，元素之间的关系由存储单元的邻接关系来体现。\n\n    - 连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示。\n    - 优点:可以实现随机存取，每个元素占用最少的存储空间\n  - 缺点:只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片\n  - **链式存储**:<font color='red'>逻辑上相邻的元素在物理位置上可以不相邻</font>，借助指示元素存储地址的指针来表示元素之间的逻辑关系。\n    - 用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示。\n    - 优点:不会出现碎片现象，能充分利用所有存储单元\n    - 缺点:每个元素因存储指针而占用额外的存储空间。且只能实现顺序存取\n  - **索引存储**:在存储元素信息的同时，还建立附加的索引表。索引表的每项称为**索引项**，索引项的一般形式是(关键字，地址)\n    - 优点:检索速度快\n    - 缺点:附加的索引表额外占用存储空间。另外，增加和删除数据时也要修改索引表，因而会花费较多的时间。\n  - **散列存储 / 哈希存储**:根据元素的关键字之间直接计算出该元素的存储地址。\n    - 优点:检索、增加和删除结点的操作都很快；\n    - 缺点:若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds1-6.png\" style=\"zoom:67%;\" />\n\n- 数据的**运算**:施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。\n\n### 习题\n\n\"Algorithm + Data Structures = Programs.\" 是什么意思？谁说的？😉\n\n“算法 + 数据结构 = 程序” by 尼古拉斯·沃斯\n\n## 1.2 算法和算法平均\n\n### 算法的基本概念\n\n- 什么是算法?\n\n  - 一个有限指令集\n  - 接受一些输入（有些情况下不需要输入）\n  - 产生输出\n  - 一定在有限步骤之后终止\n  - 每一条指令必须\n    - 有充分明确的目标，不可以有歧义\n    - 计算机能处理的范围之内\n    - 描述应不依赖于任何一种计算机语言以及具体的实现手段\n\n- 重要特性\n\n  - 有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在又穷时间内完成。\n\n    注:**算法**必须是有穷的，而**程序**可用是无穷的\n\n  - 确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。\n\n  - 可行性：算法中描述的操作都可以通过已经实现的**基本运算执行有限次**来实现\n\n  - 输入：一个算法有零个或多个输入，这些输入取自某个特定的对象的集合。\n\n  - 输出：一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。\n\n### \"好\"算法的特征\n\n设计算法时要<font color='red'>尽量追求</font>的目标\n\n- 正确性 Correctness。正确地解决求解问题。\n- 可读性 Readability。具有良好可读性，帮助人们理解。\n- 健壮性 Robustness。输入非法数据时，适当做出反应或处理，不会产生莫名其妙的输出\n- 效率与低存储量需求 Efficiency。时间复杂度低、空间复杂度低\n\n### 算法效率的度量 🤩\n\n#### [一文讲透复杂度的计算方式](https://www.cnblogs.com/lonely-wolf/p/15674526.html)\n\n#### 时间复杂度 [Time Complex](https://en.wikipedia.org/wiki/Time_complexity)\n\n- 定义：\n  $$\n  T(n) = O(f(n))\n  $$\n   算法的基本操作执行次数还随问题的 输入数据集的不同而不同 \n\n- 最坏时间复杂度 =Tworst(n)\n\n- 平均时间复杂度Tavg(n)\n\n- **关系**:Tavg(n)<=Tworst(n)\n\n- 最好时间复杂度 \n\n- **加法规则**:**多项相加，只保留最高阶的项，且系数变为1**\n\n\n$$\nT(n) = T_1(n)+T_2(n) = O(f(n))+O(g(n)) = O(\\max(f(n),g(n)))\n$$\n\n  - 乘法规则\n\n\n$$\nT(n) = T_1(n)\\times T_2(n)=O(f(n))\\times O(g(n)) = O(f(n)\\times g(n))\n$$\n\n- 只需挑循环中的一个基本操作分析它的执行次数与n的关系即可，如果有多层嵌套循环，只需关注最深层的循环循环了几次\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds1-7.png\" style=\"zoom:67%;\" />\n\n  | 表达式 | 时间复杂度 |\n  | --- | :-: |\n  | T1(n) = 3n+3            | T1(n) = O(n)    |\n  | T2(n) = n² + 3n + 1000  | T2(n) = O(n²)   |\n  | T3(n) = n3 + n2 + 99999 | T3(n) = O(n3)   |\n  | T4(n) = n3 + n2log2n    | T4(n) = O( n3 ) |\n\n- 常见的渐进时间复杂度为:**常对幂指阶**\n  $$\n  O(1) < O(\\log_2n)<O(n)<O(n \\log_2n)<O(n^2)<O(n^3)<O(n^k)<O(n!)<O(n^n)\n  $$\n\n- **来一道练习题**\n\n  计算下述算法的时间复杂度T(n)\n\n  ```C\n  void loveYou(int n){\n      int i=1;\n      while(i<=n){\n          i=i*2;\n          printf(\"I Love U %d\\n\",i);\n      }  \n  }\n  ```\n\n  |       | 第一次循环 | 第二次循环 | 第三次循环 | …    | 第x次循环 |\n  | ----- | ---------- | ---------- | ---------- | ---- | --------- |\n  | i = 1 | i = 2      | i = 4      | i = 8      | …    | i = 2x    |\n\n  设最深层总共循环的次数为x，则循环了x次之后，i = 2^x，循环结束的条件为 i > n，即 \n  $$\n  2^x > n ，x = log_2n + 1\n  $$\n\n  $$\n  T(n) = O(x) = O(log_2n) + O(1) = O(log_2n)\n  $$\n\n  \n\n#### 空间复杂度 [Space Complexity](https://en.wikipedia.org/wiki/Space_complexity)\n\n- 定义:空间复杂度：空间开销与问题规模n之间的关系\n\n$$\nS(n) = O(g(n))\n$$\n\n- 算法原地工作是指算法所需的辅助空间为常量，即`O(1)`\n\n示例：如何实现数组逆序？\n方案一：空间复杂度为 1 的情况，即S(n) = O(1)\n\n```cpp\nfor(i = 0; i < n / 2；i++) // 遍历半个数组\n{\n\tt = a[i];              // 临时变量t\n\ta[i] = a[n-i-1];       // 交换数值\n\ta[n-i-1] = t;\n}\n```\n\n方案二：空间复杂度为 n 的情况，即S(n) = O(n)\n\n```cpp\nfor(i = 0; i < n； i++)  // 辅助数组b逆序存储a\n\tb[i] = a[n-i-1];\nfor(i = 0; i < n, i++)   // 重新赋值给a\n\ta[i] = b[i];\n```\n\n### 习题\n\n【2011】设n是描述问题规模的非负整数。下面的程序片段的时间复杂度是()\n\n```c\nx=2;\nwhile(x<n/2)\nx=2*x;\n```\n\n$$\n答案:O(\\log_2n)\n$$\n\n> 执行O（n）次，则2的O（n）次方大于等于n/2时结束，因为x为2，所以每执行一次，等于自己多做一次幂运算，复杂度为log₂n\n\n【2012】求整数n(n>0)的阶乘的算法如下,其时间复杂度\n\n```c\nint fact(int n){\n  if(n<=1) return 1;\n  return n*fact(n-1);\n}\n```\n\n$$\n答案:O(n)\n$$\n\n> 递推公式T(n)=1+T(n-1),求出T(n)=n\n\n【2013】已知两个长度分别为m和n的升序链表，若将它们合并为长度为m+n的一个降序链表，则最坏情况下的时间复杂度是\n$$\nO(max(m,n))\n$$\n\n> 两个升序链表合并，两两比较表中元素，每比较一次，确定一个元素的链接位置(取较小元素，头插法)。当一个链表比较结束后，将另一个链表的剩余元素插入即可。最坏的情况是两个链表中的元素依次进行比较，因为2max(m,n)>=m+n,所以时间复杂度为O(max(m,n))。\n>\n> [CSDN解析](https://blog.csdn.net/weixin_43722052/article/details/116133058)\n\n【2014】下列程序段的时间复杂度是\n\n```c\ncount=0;\nfor(k=1;k<=n;k*=2)\n   for(j=1;j<=n;j++)\n      count++;\n```\n\n$$\nO(n\\log_2n)\n$$\n\n> 内层循环条件j<=n与外层循环的变量无关，每次循环j自增1，每次内层循环都执行n次。外层循环条件为k<=n，增量定义为k*=2，可知循环次数为2^k<=n，即k<=log₂n。所以内层循环的时间复杂度是O(n)，外层循环的时间复杂度是O(log₂n)。对于嵌套循环，根据乘法规则可知，该段程序的时间复杂度T(n)=T1(n)xT2(n)=O(n)xO(log₂n)=O(nlog₂n)\n\n【2017】下列函数的时间复杂度是\n\n```c\nint func(int n){\n  int i=0, sum=0;\n  while(sum<n) sum+= ++i;\n  return i;\n}\n```\n\n$$\nO(n^\\frac{1}{2})\n$$\n\n> sum += ++i; 相当于++i; sum = sum + i;进行到第k趟循环，sum = (1 + k)*k/2。显然需要进行O(n½)趟循环，因此这也是该函数的时间复杂度。\n\n 「算法原地工作的含义是指不需要任何额外的辅助空间」→ 错误\n\n> 算法原地工作的含义是指辅助空间是常量\n\n【2019】设n是描述问题规模的非负整数。下列程序段的时间复杂度是\n\n```c\nx=0;\nwhile (n>(x+1)*(x+1))\nx=x+1；\n```\n\n$$\nO(n^\\frac{1}{2})\n$$\n\n**综合题** 一个算法所需时间由下述递归方程表示，试求出该算法的时间复杂度的级别（或阶）\n$$\nT(n) = \\begin{cases} 1, & n=1 \\\\ 2T(n/2)+n, & n>1 \\end{cases}\n$$\n\n式中，n 是问题的规模，为简单起见，设 n 是 2 的整数次幂 →\n$$\nO(n\\log_2n)\n$$\n\n> T(n)=2T(n/2)+n\n>\n> 两边同时除以n，得到\n>\n> T(n)/n=T(n/2)/(n/2)+1    ①\n>\n> T(n/2)/(n/2)= T(n/4)/(n/4)+1 ②\n>\n> …………\n>\n> T(2)/2=T(1)/1+1 (log₂n)\n>\n> 注：因为每次式子的变化都是除以2变化的，所以式子的个数是log~2~n\n>\n> 将下面的式子都代入到式子①中可以得到\n>\n> T(n)/n=T(1)/1+1*log₂n\n>\n> T(n)=n(T(1)/1+1*log₂n)\n>\n> T(1)=1\n>\n> 所以T(n)=n(1+log₂n)\n>\n> 所以O(n)=nlog₂n\n\n思考：斐波那契数列，用递归算法和非递归算法的时间复杂度如何？😜\n\n- 递归算法\n  $$\n  O(2^n)\n  $$\n\n- 非递归算法\n  $$\n  O(n)\n  $$\n","tags":["408数据结构"],"categories":["408数据结构"]}]