[{"title":"第六章 图(下)","url":"/p/12342/","content":"\n## 6.4 图的应用\n\n### 最小生成树 Minimum-Spanning-Tree, MST\n\n之前我们已经学过什么是生成树。\n\n连通图的**生成树**是包含图中全部顶点的一个极小连通子图。\n\n若图中顶点数为n，则它的生成树含有n-1条边。对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-57.png\" style=\"zoom:80%;\" />\n\n一个图可以有许多棵不同的生成树，所有生成树具有以下共同特点：\n\n- 生成树的顶点个数与图的顶点个数相同\n- 生成树是图的极小连通子图，去掉一条边则非连通\n- 一个有n个顶点的连通图的生成树有 n-1 条边（含有n个顶点，n-1条边的图不一定是生成树。）\n- 在生成树中再加一条边必然形成回路\n- 生成树中任意两个顶点间的路径是唯一的。\n\n#### 无向图的生成树\n\n就在上一小节，我们也介绍了，广度优先生成树和深度优先生成树。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-58.png\" style=\"zoom: 67%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-59.png\" style=\"zoom: 67%;\" />\n\n#### 最小生成树\n\n给定一个无向网，在该网中的所有生成树中，使得各边权值之和最小的那棵生成树称为该网的**最小生成树**，也叫**最小代价生成树**。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-60.png\" style=\"zoom:67%;\" />\n\n构造最小生成树的算法很多，其中多数算法都利用了 MST 的性质。\n\n<font color='red'>MST性质</font>：设N=(V,E)是一个连通网，U是顶点集V的一个非空子集。若边(u,v)是一条具有最小权值的边，其中u∈U，v∈V-U，则必存在一棵包含边(u,v)的最小生成树。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-61.png\" style=\"zoom: 67%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-62.png\" style=\"zoom:67%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-63.png\" style=\"zoom:67%;\" />\n\n#### Prim算法(普利姆)\n\n**Prim算法**:从某一个顶点开始构建生成树；每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止。\n\n**算法思想**:\n\n此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。\n\n1. 图的所有顶点集合为V；初始令集合u={s},v=V−u={s},v=V−u;\n2. 在两个集合u,v能够组成的边中，选择一条代价最小的边(u0,v0)，加入到最小生成树中，并把v0并入到集合u中。\n3. 重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。\n\n例如：\n\n我们要构造如下图的最小生成树，我们选取一个顶点，这个顶点就是U集合，其他顶点就是V-U集合\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-64.png\" style=\"zoom: 67%;\" />\n\n在U集合当中的顶点和V-U集合当中的顶点中找一条权值最小的边，将边关联的顶点选取到我们的U集合，其他顶点为V-U集合\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-65.png\" style=\"zoom: 67%;\" />\n\n之后在U集合当中的顶点和V-U集合当中的顶点中找一条权值最小的边，V1到V2为6，V1到V4为5，V3到V2为5，V3到V4为5，V3到V5为6，V3到V6为4。所以选取权值最小的边4，其关联的顶点为V6，将其加入到U集合中。此时U集合为{V1,V3,V6}\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-66.png\" style=\"zoom:67%;\" />\n\n重复上述操作，V1周边的权值为6，5，V3周边的权值为5,5,6，V6周边的权值为6，V4周边不能选(一旦选了有回路成环了)\n\n我们选择权值最小的V3到V2的5，将V2加入到U集合中\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-67.png\" style=\"zoom:67%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-72.png\" style=\"zoom:67%;\" />\n\n#### Kruskal算法(克鲁斯卡尔)\n\n**Kruskal算法**:每次选择一条权值最小的边，使这条边的两头连通(原本已经连通的就不选) 直到所有结点都连通\n\n**算法思想**：\n\n此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。\n\n1. 把图中的所有边按代价从小到大排序；\n2. 把图中的n个顶点看成独立的n棵树组成的森林；\n3. 按权值从小到大选择边，所选的边连接的两个顶点ui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。\n4. 重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。\n\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-68.png\" style=\"zoom: 67%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-71.png\" style=\"zoom:67%;\" />\n\n#### 比较\n\n| 算法名     | 普里姆算法 | 克鲁斯卡尔算法            |\n| :--------- | :--------- | :------------------------ |\n| 算法思想   | 选择点     | 选择边                    |\n| 时间复杂度 | O(\\|V\\|^2) | O(\\|E\\|log\\|E\\|)(E为边数) |\n| 适应范围   | 稠密图     | 稀疏图                    |\n\n#### 代码思想\n\n##### Prim算法\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds-142.png\" style=\"zoom: 67%;\" />\n\n从v0开始。\n\n- 由于当前树中只有v0，所以isJoin数组中只有v0是TRUE，其他为FALSE。此外，lowCost中的各个结点加入树的最低代价，是看从v0出发，加入各个结点的最低代价。\n\n- 第1轮：循环遍历所有结点，找到lowCost最低的，且还没加入树的顶点。于是将v3加入树。\n\n- 此时，由于v3的加入，isJoin数组中v3也是TRUE。且，此时lowCost中的各个结点加入树的最低代价，不止是看由v0出发的边，而是也要看v3出发的边，因此lowCost数组应该更新。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds-142.png\" style=\"zoom: 67%;\" />\n\n  \n\n- 第2轮：和第1轮是一模一样的。循环遍历所有结点，找到lowCost最低的，且还没加入树的顶点。因此我们会把v2加入到树里面。并同时需要把lowCost数组的内容重新更新。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-145.png\" style=\"zoom:67%;\" />\n\n- 第3轮：同理。把v5加入。并且更新lowCost。\n\n- 第4轮：同理。把v1加入。并且更新lowCost值。\n\n- 第5轮：只剩下v4。所以再把v4加入。\n\n> 由v0开始，总共需要n-1轮处理。\n>\n> 每一轮处理：循环遍历所有结点，找到lowCost最低的，且还没加入树的顶点。接着，再次循环遍历，更新还没加入的各个顶点的lowCost值。（所以每一轮的时间复杂度为O(2n)）。\n>\n> 所以总的时间复杂度的数量级为O(n^2)， 也就是O(|V|^2)。\n\n算法的大致执行就是这样的。有能力的可以自己动手实现一遍。但是对于考研初试阶段来说我们可以先不展开此处代码的编写\n\n##### Kruskal算法\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-144.png\" style=\"zoom: 50%;\" />\n\n\n\n由于这个算法每次要选择权值最小的一条边。所以我们要做这样的一个预处理，就是要先把各条边按照权值递增的顺序做一个排序。那么这个算法的执行，就是要把所有的这些边都检查一遍。\n\n第1轮：检查第1条边的两个顶点是否连通（是否属于同一个集合）。将v0——v3连起来。\n\n- 进行这个判断实际上是用到了**并查集**，并查集相关的内容由于在408中不要求掌握，我们只是大概说一下。\n- 我们首先把不同的顶点看作一个个不同的集合。那么v0和v3刚开始是从属于不同的集合的。也就意味着它们此时不连通。那么我们就可以把这条边给选上。\n- 同时，如果把这两个顶点给连上的话，那么这两个顶点此时就变成了同一个集合。\n\n第2轮：检查第2条边的两个顶点是否连通（是否属于同一个集合）。将v2——v5连起来。\n\n第3轮：检查第3条边的两个顶点是否连通（是否属于同一个集合）。将v1——v4连起来。\n\n第4轮：检查第4条边的两个顶点是否连通（是否属于同一个集合）。将v2——v3连起来。\n\n第5轮：检查第5条边的两个顶点是否连通（是否属于同一个集合）。由于**已连通，则跳过**。\n\n接下来的过程省略，总之我们需要把所有边都遍历一遍。在遍历到每条边的时候我们都要判断，这条边的两个顶点，它们是否从属于同一个集合。如果不属于一个集合，那就把这条边选上。\n\n> 整个图里，总共有|E|条边。\n>\n> 那么这个算法总共要执行|E|轮。\n>\n> 每轮判断两个顶点是否属于同一集合，需要O(log₂|E|)。（需要用到并查集）。\n>\n> 总时间复杂度为O(|E|log₂|E|)。\n\n### 最短路径 Short Path First, SPF\n\n问题抽象：在有向网中A点(源点)到达B点(终点)的多条路径中，寻找一条各边权值之和最小的路径。即最短路径。\n\n<font color='cornflowerblue'>最短路径与最小生成树不同，路径上不一定包含n个顶点，也不一定包含n-1条边。</font>\n\n第一类问题:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-73.png\" style=\"zoom:67%;\" />\n\n第二类问题:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-74.png\" style=\"zoom:67%;\" />\n\n- 单源最短路径\n  - BFS算法（无权图）\n  - Dijkstra算法（带权图、无权图）\n- 各顶点间的最短路径\n  - Floyd算法（带权图、无权图）\n\n#### BFS求无权图的单源最短路径\n\n**注**：无权图可以视为一种特殊的带权图，只是每条边的权值都为1。\n\n对这个图执行一次广度优先遍历，我们就可以得到由某个源点出发，到其他各个结点的最短路径。\n\n**代码实现**:\n\n先看BFS算法\n\n```C\nbool visited[MAX_VERTEX_NUM];\t//访问初始数组\n\n//广度优先遍历\nvoid BFS(Graph G, int v) {\n    visit(v);\n    Enqueue(Q,v);\n    while(!isEmpty(Q)) {\n        DeQueue(Q,v);\n        for(w=FirstNeighbor(G,v); w>=0; w=NextNeighbor(G,v,w)) {\n            if(!visited[w]) {\n                visit(w);\n                visited[w] = TRUE;\n                EnQueue(Q,w);\n            }\n        }\n    }\n}\n\n```\n\n我们要通过BFS算法来求单源最短路径，那么主体框架不变，对其中的一些地方的处理进行一些改变就可以。如下。\n\n```C\n//求顶点u到其他顶点的最短路径\nvoid BFS_MIN_Distance(Graph G, int u) {\n    //d[i]表示从u到i结点的最短路径\n    for(i=0; i<G.vexnum; ++i) {\n        d[i] = ∞;\t//初始化路径长度\n        path[i] = -1;\t//最短路径从哪个顶点过来\n    }\n    d[u] = 0;\n    visited[u] = TRUE;\n    EnQueue(Q,u);\n    while(!isEmpty(Q)) {\t//BFS算法主体过程\n        DeQueue(Q,u);\t//队头元素u出队\n        for(w=FirstNeighbor(G,u); w>=0; w=NextNeighbor(G,u,w)) {\n            if(!visited[w]) {\t\t//w为u的尚未访问的邻接点\n                d[w] = d[u] + 1;\t//路径长度+1\n                path[w] = u;\t\t//最短路径应从u到w\n                visited[w] = TRUE;\t//设已访问标记\n                EnQueue(Q,w);\t//顶点w入队\n            }\n        }\n    }\n}\n```\n\n![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-146.png)\n\n![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-147.png)\n\n就是对BFS算法的小修改。\n\n在visit一个顶点时，修改其最短路径长度`d[]`并在`path[]`记录前驱结点。\n\n> 可以看出。2到8的最短路径长度 = `d[8]` = 3\n>\n> 通过path数组可知，2到8的最短路径为：`8<--7<--6<--2`\n\n之前也说到，通过广度优先遍历，能够得到广度优先生成树。那么也可以观察一下这个广度优先生成树：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-148.png\" style=\"zoom:67%;\" />\n\n这个生成树，它的每个结点在第几层，也直接地反映了从根结点2，到达它的最短路径是多少。\n\n不难得知，通过广度优先遍历构造出的这个广度优先生成树，它的高度一定是最小的。\n\n#### Dijkstra算法\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-83.png\" style=\"zoom:67%;\" />\n\n**BFS算法的局限性**:BFS算法求单源最短路径只适用于<font color='orange'>无权图</font>，或<font color='orange'>所有边的权值都相同</font>的图\n\nDijkstra(迪杰斯特拉)算法是典型的<font color='orange'>单源最短路径算法</font>，用于计算一个节点到其他所有节点的最短路径。主要特点是<font color='orange'>以起始点为中心向外层层扩展，直到扩展到终点为止</font>。Dijkstra算法是很有代表性的最短路径算法，在很多专业课程中都作为基本内容有详细的介绍，如数据结构，图论，运筹学等等。注意该算法要求图中不存在负权边。\n\n**问题描述**：在无向图 G=(V,E) 中，假设每条边 E[i] 的长度为 w[i]，找到由顶点 V0 到其余各点的最短路径。（单源最短路径）\n\n1. 初始化：先找出从源点V0到各终点Vk的直达路径(V0,VK),即通过一条弧到达的路径。\n2. 选择：从这些路径中找出一条长度最短的路径(V0,u)\n3. 更新：然后对其余各条路径进行适当调整\n   - 若在图中存在弧(u,Vk),且(V0,u)+(u,Vk) < (V0,Vk)，则以路径(V0,u,Vk)代替(V0,Vk)\n   - 在调整后的各条路径中，再找长度最短的路径，以此类推。\n\n------\n\n**迪杰斯特拉算法**：按路径长度递增次序产生最短路径\n\n1. 把V分成两组：\n\n   (1)S：已求出最短路径的顶点的集合\n\n   (2)T=V-S：尚未确定最短路径的顶点集合\n\n2. 将T中顶点按最短路径递增的次序加入到S中，保证：\n\n   (1)从源点V0到S中各顶点的最短路径长度都不大于从V0到T中的任何顶点的最短路径长度。\n\n   (2)每个顶点对应一个距离值：\n\n    S中顶点：从V0到此顶点的最短路径长度\n\n    T中顶点：从V0到此顶点的只包括S中顶点作中间顶点的最短路径长度。\n\n执行动画过程如下图\n\n![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-75.gif)\n\n**多说无益，我们来看一个例子**\n\n##### 王卓版本\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-76.png\" style=\"zoom:67%;\" />\n\n初始时令 S = {V0}，T={其余顶点}\n\n记录V0到其他顶点的距离：若<V0,Vi>存在，则为其权值，若不存在，则为∞。使用辅助数组D存放\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-77.png\" style=\"zoom:67%;\" />\n\nV0到V1可以直达，为其权值13。V0到V2可以直达，为其权值8。V0到V3不可以直达，为∞。以此类推，然后从T中选取一个距离值最小的顶点Vj，加入S。例如我们上图中的8最小，则将V2加入S。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-78.png\" style=\"zoom:67%;\" />\n\n接下来我们要计算 **从V0直接出发到各个顶点的路径和从V0出发经过V2再到各个顶点的路径**，看是否有距离减少，没有减少则不需要改值。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-79.png\" style=\"zoom:67%;\" />\n\n如上图，加入V2之后：\n\nV0到V1的值为13，V0经过V2再到V1是无法直达为∞，所以V0到V1的最短路径依旧是13\n\nV2已经加入到S集合，所以不需要管V2。\n\nV0到V3无法直达为∞，V0经过V2再到V3可以直达为 8+5=13，所以V0到V3的最短路径为13\n\nV0到V4直达为30，V0经过V2再到V4无法直达为∞，所以V0到V4的最短路径为30\n\nV0到V5无法直达为∞，V0经过V2再到V5也无法直达为∞，所以V0到V5的最短路径为∞\n\nV0到V6直达为36，V0经过V2再到V6无法直达为∞，所以V0到V6的最短路径为32\n\n从上述最短路径中选出最小的为13，我们选择序号更小的V1，将其加入到S集合中。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-80.png\" style=\"zoom:67%;\" />\n\n此时S集合为V0、V1、V2\n\nV0到V3的最短路径依旧13\n\nV0到V4的最短路径依旧是30\n\nV0到V5无法直达，但是可以经过V1再直达，所以最短路径为 13+9=22\n\nV0到V6直达为32，但是可以经过V1再直达，所以最短路径为 13+7=20\n\n从上述最短路径中挑选值最小的为13，所以将V3加入到集合S中。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-81.png\" style=\"zoom:67%;\" />\n\n最终结果如下：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-82.png\" style=\"zoom:67%;\" />\n\n------\n\n##### 王道版本\n\n这里以有向图举例。为什么不用无向图呢，因为无向图的边等价于两条有向边，是一样的道理。我们只需要说清楚有向图的原理，无向图自然也就清楚了。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-149.png\" style=\"zoom: 50%;\" />\n\n由v0作为源点出发。\n\n我们需要设三个数组\n\n- final数组，表示各顶点是否已找到最短路径。显然先设v0为TRUE。\n- dist数组（distance），表示目前已知条件下，到达某结点的最短路径长度。\n  - 此时只有一个v0是可知的，那么目前来看，到v1的最短路径是10，到v4的最短路径是5，而到v2和v3是∞。\n- path数组，和BFS算法中的path数组是一个意思，就是记录通往结点的路径是由哪个结点过来的，也就是最短路径上的前驱结点。\n  - v1结点目前能找到的最好的一条路径，是从v0过来的，那么path设为0。v4同理。\n\n以上是三个数组的初始化，接下来我们开始一轮一轮的处理。\n\n**第一轮**：\n\n循环遍历所有结点，找到还没确定最短路径，且dist最小的顶点Vi，令final[i] = TRUE。\n\n- 那么显然，在V1~V4中，dist最小的顶点是V4的5。并将V4的final设为TRUE。也就是说，我现在已经可以确定V4的最短路径长度就是5，并且它的直接前驱是0号结点。\n\n检查所有邻接自Vi的顶点，若其final值为false，则更新dist和path信息。\n\n- 也就是检查V1~V3，看看它们如果由V4过来的话，有没有可能比之前的路径更短。\n  - 对于V1：如果改用从V4过来，那么总长度为5+3=8，比原先的10更短，则更新。\n  - 对于V2：原先我们根本就没有到达V2的路径，现在如果我们从V4出发，则有一条到V2的路径，则更新。\n  - 对于V3：和V2同理，更新。\n\n第一轮处理结果如下\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-150.png\" style=\"zoom: 67%;\" />\n\n**第二轮**：\n\n处理逻辑和第一轮是相同的。\n\n- 遍历V1~V3，看看谁的dist最小，找到V3，将V3的final设为TRUE。\n- 检查所有能够从V3过去的顶点，当然我们只需要检查final为false的顶点。\n  - 从V3过去的顶点有V0和V2，但是V0我们不需要考虑，所以只看V2。\n  - 对V2这个顶点，如果我们是从V3过去的，那么路径长度为7+6=13的路径，显然比原先的14更短，则更新V2的dist为13，并更新V2的path为3。\n\n第二轮处理结果：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-151.png\" style=\"zoom: 67%;\" />\n\n**第三轮**：\n\n- 遍历V1~V2，看看谁的dist最小，则找到V1，并将其final设为TRUE。\n- 检查所有从V1过去，且final为false的顶点。即V2。\n  - 对于V2，检查是否需要更新dist和path信息。\n  - 若V2是由V1过去的，则路径长度为8+1=9，比原先的13短。于是更新dist为9，更新path为1。\n\n第三轮处理结果：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-152.png\" style=\"zoom: 67%;\" />\n\n**第四轮**：\n\n- 遍历V2，V2的dist最小，将V2的final设为TRUE。\n- 所有结点的final全部为TRUE。此时已经找不到final为false的顶点了。\n- 算法到此结束。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-153.png\" style=\"zoom:67%;\" />\n\n以上就是Dijkstra算法的执行过程。\n\n> 通过执行结果可知，\n>\n> V0到V2的最短（带权）路径长度为：dist[2] = 9\n>\n> 通过`path[]`可知，V0到V2的最短（带权）路径：`V2<--V1<--V4<--V0`\n\n##### Dijkstra算法的时间复杂度\n\n**对于考研来说，这个算法只需要理解手动执行的过程，能够手算即可。**\n\n我们也简单的提一下，如果用代码实现，大致的思路是什么样的。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-154.png\" style=\"zoom:67%;\" />\n\n- 初始：若从V0开始。令`final[0] = TRUE`；`dist[0] = 0`；`path[0] = -1`。其余顶点`final[k] = false`；`dist[k] = arcs[0][k]`；`path[k] = (arcs[0][k]==∞) ? -1 : 0`。\n- 第n-1轮处理:\n  - 循环遍历所有顶点，找到还没确定最短路径，且dist最小的顶点Vi，令其`final[i] = true`。并遍历所有邻接自Vi，且还没确定最短路径的顶点，即`final[j] == false`，若`final[j] == false && dist[i]+arcs[i][j] < dist`，则令`dist[j] = dist[i] + arcs[i][j]; path[j] = i;`（注：`arcs[i][j]`表示Vi到Vj的弧的权值）\n\n**现在探讨一下其时间复杂度的问题**\n\n对于每一轮处理来说，我们都要循环**遍历所有顶点**，找到还没确定最短路径，且dist最小的顶点。所以需要O(n)的时间复杂度。此外，找到这个结点之后，还需要检查所有和它相邻的邻接点，又需要O(n)的时间复杂度。\n\n所以每一轮处理的时间复杂度为O(2n)，即O(n)。\n\n而总共需要n-1轮处理。所以整个算法的时间复杂度为O(n²)。即O(|V|²)。\n\n> 可以发现，这个算法其实和Prim算法是比较类似的。此代码的`dist[]`数组，和Prim算法中的`lowCost[]`数组的作用是很类似的。\n\n##### 用于负权值带权图\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-155.png\" style=\"zoom:50%;\" />\n\n\n\n这是Dijkstra算法的一个小坑。\n\n如果带权图里，有负权值的边。那么Dijkstra算法有可能就会失效，找不到最短路径。\n\n按照算法的规则，我们执行一遍：\n\n- 初始：如上图所示。\n- 第一轮：\n  - 遍历V1、V2，找到V2的dist最短，设其final为true，path为0。\n  - 第一轮结束。\n- 第二轮：\n  - 只剩下V1，将其final设为true，path为0。\n- 此时所有结点的final均为TRUE，算法执行完毕。\n\n最终结果如下\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-156.png\" style=\"zoom: 50%;\" />\n\n但是，事实上，V0到V2的最短带权路径长度为5。\n\n因此，**Dijkstra算法不适用于有负权值的带权图**。\n\n#### Floyd算法\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-86.png\" style=\"zoom:67%;\" />\n\n**Floyd-Warshall算法**（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd-Warshall算法的时间复杂度为O(N3)，空间复杂度为O(N2)。\n\n**算法思想**:\n\n<font color='cornflowerblue'>Floyd算法是一个经典的动态规划算法</font>。用通俗的语言来描述的话，首先我们的目标是寻找从点i到点j的最短路径。从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在）\n\n   从任意节点i到任意节点j的最短路径不外乎2种可能，1是直接从i到j，2是从i经过若干个节点k到j。所以，我们假设Dis(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，我们<font color='cornflowerblue'>检查Dis(i,k) + Dis(k,j) < Dis(i,j)</font>是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，我们<font color='cornflowerblue'>便设置Dis(i,j) = Dis(i,k) + Dis(k,j)</font>，这样一来，当我们遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。\n\n对于n个顶点的图G，求任意一对顶点Vi—>Vj之间的最短路径可分为如下几个阶段：\n\n- 初始：不允许在其他顶点中转，最短路径是？\n- 0：若允许在V0中转，最短路径是？\n- 1：若允许在V0、V1中转，最短路径是？\n- 2：若允许在V0、V1、V2中转，最短路径是？\n- ……\n- n-1：若允许在V0、V1、V2……V(n-1)中转，最短路径是？\n\n步骤如下：\n\n1. 初始时设置一个n阶方阵，令其对角线元素为0，若存在弧 <Vi,Vj>,则对应元素为权值，否则为∞\n2. 逐步试着在原直接路径中增加中间顶点，若加入中间顶点后路径变短，则修改之，否则，维持原值。所有顶点试探完毕，算法结束\n\n**来看一个例子**：\n\n##### 王卓版本\n\n有3各顶点，则设置一个3阶方阵，令其对角线为0，若存在弧，则对应元素为权值。\n\n例如<A,B>权值为4，<A,C>权值为11.\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-84.png\" style=\"zoom:67%;\" />\n\n加入A顶点后：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-85.png\" style=\"zoom:67%;\" />\n\nA到B，A到C距离没有变化。B到A，B到C距离也没有变化。C到A距离没有变化，C到B之前没有直达路径，加入A顶点之后可以从C经过A再到B，所以距离为 3+4=7\n\n加入B顶点之后：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-87.png\" style=\"zoom:67%;\" />\n\nA带B距离无变化，A到C直达路径为11，但是经过B路径为 4+2=6。\n\nB到A，B到C距离无变化。\n\nC到A，C到B距离无变化。\n\n加入C顶点后：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-88.png\" style=\"zoom:67%;\" />\n\n------\n\n##### 王道版本\n\n我们来把这个算法流程跑一遍。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-157.png\" style=\"zoom:67%;\" />\n\n我们设置两个矩阵（二维数组）。\n\n第一个矩阵，其实就是这个有向图的邻接矩阵。\n\n> 由于初始阶段，我们不允许有其他顶点中转的情况出现，因此，例如V0——V2，就只能走13这条路。\n>\n> 所以，第一个矩阵中，第一行第三列就是13。\n\n第二个矩阵，存放的就是，我们目前能够找到的最短路径当中，两个顶点之间的一个中转点。\n\n> 初始阶段，所有顶点之间都不可以有中转点，所以全是-1。\n\n以上是**初始阶段**的流程。\n\n**0阶段**：\n\n若允许在**V0**中转，最短路径是？——求A(0)和path(0)。\n\n我们要基于上一轮求得的两个矩阵的信息，得到这一轮的两个矩阵中应该填入的最优信息。\n\n求解的方法很简单，我们需要遍历上一阶段留下来的这个矩阵A，对于矩阵A当中的每一个具体的元素，我们都需要进行以下处理：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-158.png\" style=\"zoom:67%;\" />\n\n> 例如对于矩阵A中，第三行第二列，也就是V2——V1的这个数据。如果允许在V0中转，那么考虑\n> $$\n> A^{(-1)}[2][1]>A^{(-1)}[2][0]+A^{(-1)}[0][1]=11\n> $$\n>\n> $$\n> 则A^{(0)}[2][1]=11\n> $$\n>\n> $$\n> path^{(0)}[2][1]=0\n> $$\n\n当然，对于这个矩阵中的所有位置的元素，都需要依次循环遍历一遍，各进行判断。（按照上面的处理方法）\n\n实际上，在对所有位置元素均各执行一遍判断之后，需要改变的也就只有这一个位置，如下图\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-159.png\" style=\"zoom:67%;\" />\n\n**1阶段**：\n\n若允许在V0、**V1**中转，最短路径是？——求A(1)和path(1)。\n\n我们需要在基于0阶段得到的两个矩阵的基础上，来计算该阶段的矩阵内容，也就是1阶段的最优解。\n\n那还是利用刚才的这个规则：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-159.png\" style=\"zoom:67%;\" />\n\n我们要基于前一个阶段的矩阵的值，来对此阶段的矩阵内容进行一个判断。\n\n> 对所有元素都遍历一遍之后，我们会发现这样一个地方，是满足需要被处理的条件的：\n> $$\n> A^{(0)}[0][2]>A^{(0)}[0][1]+A^{(0)}[1][2]=10\n> $$\n>\n> $$\n> 则A^{(1)}[0][2]=10\n> $$\n>\n> $$\n> path^{(1)}[0][2]=1\n> $$\n\n经过修改之后，矩阵会变成这样：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-160.png\" style=\"zoom:67%;\" />\n\n**2阶段**：\n\n若允许在V0、V1、**V2**中转，最短路径是？——求A(2)和path(2)。\n\n要以1阶段得出的矩阵信息，作进一步处理，得到此阶段的最优解。\n\n依然是同样的处理规则。依次扫描矩阵中的所有元素，并处理满足条件的元素。\n\n> 全部扫描过后，可以发现只有一个地方满足，如下\n> $$\n> A^{(1)}[1][0]>A^{(1)}[1][2]+A^{(1)}[2][0]=9\n> $$\n>\n> $$\n> 则A^{(2)}[1][0]=9\n> $$\n>\n> $$\n> path^{(2)}[1][0]=2\n> $$\n\n到此，我们就求出了A(2)和path(2)：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-161.png\" style=\"zoom:67%;\" />\n\n到了这一步，从A(-1)和path(-1)开始，我们已经经过了**n轮递推，**每一轮递推，我们都会增加考虑一个新的结点作为中转点，**得到A(n-1)和path(n-1)**。到此，我们便得到了每两个顶点之间最短路径的长度，和路径上的信息。（n指的是总结点个数）\n\n> 观察两表，\n>\n> 例如，V1到V2的最短路径。检查A数组，发现长度是4；再检查path数组，发现它们之间是不经过任何中转点的，因此这条最短路径为V1—V2。\n>\n> 例如，V0到V2的最短路径。查找A数组，发现长度是10；再查path数组，V0到V2之间的中转点是1号中转点，因此这条最短路径为V0—V1—V2。\n>\n> 同理，V1到V0的最短路径长度为9，路径为V1—V2—V0。\n\n所以，Floyd算法的思想虽然有些抽象，但是实现起来还是比较简单的。\n\n**Floyd算法核心代码**：\n\n```C\n//......准备工作，根据图的信息初始化矩阵A和path（如上图）\nfor(int k=0; k<n; k++) {\t\t//考虑以Vk作为中转点\n    for(int i=0; i<n; i++) {\t//遍历整个矩阵，i为行号，j为列号\n        for(int j=0; j<n; j++) {\n            if(A[i][j] > A[i][k] + A[k][j]) {\t//以Vk为中转点的路径更短\n                A[i][j] = A[i][k] + A[k][j];\t//更新最短路径长度\n                path[i][j] = k;\t\t//中转点\n            }\n        }\n    }\n}\n```\n\n可见，这个算法的时间复杂度为O(n³)，即O(|V|³)。（三层嵌套）；空间复杂度为O(|V|²)。（两个矩阵）。\n\n> 注意，上面这个例子，只是有三个结点，这个例子虽然能帮助我们理解Floyd算法的流程，但是，这个例子在我们考虑加入中转点的时候，最多也就只需要走两条边。\n>\n> 而对于Floyd算法的真正的作用、效果，这个例子体现的并不是很好。\n\n##### 一个较复杂的例子\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-162.png\" style=\"zoom:67%;\" />\n\n**0阶段**：\n\n若允许在**V0**中转，最短路径是？\n\n依次检查矩阵中所有元素，检查规则为：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-158.png\" style=\"zoom:67%;\" />\n\n代码体现如下：\n\n```C\nfor(int i=0; i<n; i++) {\t\t//遍历整个矩阵，i为行号，j为列号\n    for(int j=0; j<n; j++) {\n        if(A[i][j] > A[i][k] + A[k][j]) {\t//以Vk为中转点的路径更短\n            A[i][j] = A[i][k] + A[k][j];\t//更新最短路径长度\n            path[i][j] = k;\t//中转点\n        }\n    }\n}\n```\n\n对于这个代码，此阶段就是执行k=0的情况。\n\n遍历矩阵中所有元素后，会发现所有元素都不需要更新。\n\n得到A(0)和path(0)：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-163.png\" style=\"zoom:67%;\" />\n\n> 实际上，从这个图本身也很好理解。V0这个结点只有出边，没有入边。那么，没有任何一个结点能够进入V0处，又怎么可能在V0中转呢？所以两矩阵内容并没有发生任何改变。\n\n**1阶段**：\n\n若允许在V0、**V1**中转，最短路径是？\n\n依然是遵循同样的规则/代码（k=1）。\n\n遍历过后，发现需要更改的地方，如下\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-164.png\" style=\"zoom:67%;\" />\n\n经过这一轮的处理，两矩阵更新如下：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-165.png\" style=\"zoom:67%;\" />\n\n**2阶段**：\n\n若允许在V0、V1、**V2**中转，最短路径是？\n\n遍历过后，发现需要更改的地方，如下：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-166.png\" style=\"zoom:67%;\" />\n\n> **注意**：\n>\n> 分析此步骤所反映出的结果。\n>\n> 也就是有两处需要优化：\n>\n> 0结点到1结点，改为了0—2，再2—1，OK；\n>\n> 0结点到3结点，改为了0—2，再2—3，？？？\n>\n> 通过看图，我们发现V2到V3之间没有“边”呀？为什么呢？\n>\n> **这就是因为，在上一阶段，对于V2到V3的路径，已经是由V1中转过的结果了（也就是为什么每一阶段要在上一阶段两个矩阵中的信息的基础之上进行求最优解）**。而不是单纯的理解为V2到V3是否有”边“的问题。\n>\n> 实际上，这个`A^{(1)}[2][3]`，它反映的就是在上一阶段处理2结点到3结点最短路径问题，所得的结果。（即1阶段中，允许由V0、V1中转，所求得的V2到V3的最短路径）。\n\n由此，我们就能很好的体会到，我们在之前就已经考虑到，增加V1作为中转节点，然后，现在我们的计算，是基于之前已经求得的最优结果的基础之上，再增加V2作为中转点。\n\n> 所以此处这个0结点到3结点的最优路径，表面上看是0—2，再2—3，其实是0—2，再2—1，再1—3。\n\n而对于整个路径来看，其实就已经考虑到了以V0、V1、V2作为中转点的所有情况了。\n\n此阶段处理完后，两矩阵的最新信息如下：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-167.png\" style=\"zoom:67%;\" />\n\n**3阶段**：略\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-168.png\" style=\"zoom:67%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-169.png\" style=\"zoom:67%;\" />\n\n**4阶段**：略。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-170.png\" style=\"zoom:67%;\" />\n\n结束。最终得到的两个矩阵内容如上图\n\n> 现在我们来看一下，怎么解读这两个矩阵中的信息：\n>\n> 例如，要找V0到V4的最短路径。\n>\n> - 由A矩阵可知长度为4。\n> - 由path矩阵\n>   - 首先可以知道V0到V4需要经过一个中转点是V3，也就是说V0需要先到V3，V3再到V4。但是由图中可以看出，V0到V3并没有一条直接存在的路径供我们经过，其实V0到V3的最短路径，其中还是要经过一些中转节点的。而V3到V4是不需要中转的（由path的值为-1即可看出）。\n>   - 再看V0到V3怎么走。由path数组可知，V0到V3，中间还要经过V2。也就是V0需要先到V2，V2再到V3。V0到V2（path的值为-1）是没有中转点的；而V2到V3（path值为1）还需要经过V1中转点。\n>   - 到这一步，整理一下，即`V0 V2 V1 V3 V4`，实际上这就是最终结果了。\n>\n> 总结一下获取最短路径走法的过程（通过path矩阵递归地找到完整路径）：\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-171.png\" style=\"zoom:67%;\" />\n\n可以用path矩阵配合上递归算法很好的解决这个问题。\n\n但是单从考试的角度来看，会手算即可。\n\n但是有个问题，在手算A矩阵的时候，由于这是5行5列的矩阵，我们如果要把所有元素依次完整地执行一遍，其实我们总共需要5³=125次检查。所以在考试的时候，不可能会给你这么复杂的一个图的。让你在考场上进行125次加法、比大小，是没什么意义的。所以考试的时候给的图一般阶数都比较小。\n\n##### 用于负权值带权图\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-172.png\" style=\"zoom:67%;\" />\n\n```C\n//......准备工作，根据图的信息初始化矩阵A和path（见上图）\nfor(int k=0; k<n; k++) {\t//考虑以Vk作为中转点\n    for(int i=0; i<n; i++) {\t//遍历整个矩阵，i为行号，j为列号\n        for(int j=0; j<n; j++) {\n            if(A[i][j] > A[i][k] + A[k][j]) {\t//以Vk作为中转点的路径更短\n                A[i][j] = A[i][k] + A[k][j];\t//更新最短路径长度\n                path[i][j] = k;\t\t//中转点\n            }\n        }\n    }\n}\n```\n\n**Floyd算法可以用于负权值带权图**。（就解决了Dijkstra算法解决不了的问题）\n\n但是，这个算法也有它所解决不了的问题。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-173.png\" style=\"zoom:67%;\" />\n\n对于这个图，其中的这个回路来说，你会发现，你走这个回路，走的次数越多，你的带权路径长度会越来越小。因此根本就找不到最短路径。\n\n#### 总结\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-174.png\" style=\"zoom:69%;\" />\n\n> BFS算法有两种时间复杂度的情况，是由于图的存储方式，是邻接矩阵还是邻接表存储的区别导致的。\n\n### 有向无环图\n\n#### 有向无环图(DAG)\n\n**有向无环图**：若一个**有向图**中**不存在环**，则称为有向无环图，简称**DAG图**（Directed Acyclic Graph）\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-199.png\" style=\"zoom: 45%;\" />\n\n#### DAG描述表达式\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-190.png\" style=\"zoom:40%;\" />\n\n之前我们说过，算术表达式可以用树来表示。但是对于上图来说，不难看出，有两部分是重复的，`((c+d)*e)`出现了两次。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-191.png\" style=\"zoom: 30%;\" />\n\n实际上，图中红色、绿色两棵子树，其计算结果是一样的。所以其实可以去除其中一棵，只保留一棵。就成了如下这种样子：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-244.png\" style=\"zoom:60%;\" />\n\n这么做的好处显而易见，能够节省存储空间。而现在产生的这种结构，其实就是有向无环图。\n\n其实我们继续再看一下，里面还有重复的部分：`(c+d)`。可以继续进行“合并”。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-245.png\" style=\"zoom:60%;\" />\n\n合并后，就变成如下这样：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-194.png\" style=\"zoom:30%;\" />\n\n到此，继续观察，还是有相同的“子树”：`b`出现了两次。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-195.png\" style=\"zoom:30%;\" />\n\n“合并”后，结果如下：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-196.png\" style=\"zoom:30%;\" />\n\n这个过程，如果不细心的话，有可能会无法找全所有可以合并的点。\n\n但是在考研408真题中，又会遇到类似的题，如下：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-197.png\" style=\"zoom: 50%;\" />\n\n经过合并，如下图所示\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-198.png\" style=\"zoom:33%;\" />\n\n由于这种题**容易遗漏可以合并的点**，因此总结以下解题规律：\n\n- 顶点中不可能出现重复的操作数。\n\n------\n\n因此，有以下解题步骤：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-199.png\" style=\"zoom:67%;\" />\n\n- 第一步：把各个操作数不重复地排成一排，如下图所示。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-200.png\" style=\"zoom:67%;\" />\n\n- 第二步：标出各个运算符的生效顺序（先后顺序有点出入无所谓，目的是为了不重不漏地处理完毕所有运算符）\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-201.png\"  />\n\n- 第三步：按顺序加入运算符，注意“分层”。（分层的意思见下图）\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-202.png\" style=\"zoom:67%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-203.png\" style=\"zoom:67%;\" />\n\n- 第四步：从底向上逐层检查同层的运算符是否可以合体。\n\n  （为什么一层一层检查同层的运算符，不难体会到，如果是不同层的，则是一定不可能合并的。这也是第三步构造的过程中要注意“分层”的原因）\n\n  - 看最下面一层运算符。有四个加法。但是最左边的那一个加号，它是对`a和b`进行相加，右边三个加号，均是对`c和d`进行相加。因此右边三个加号可以合并，而左边一个加号不能合并。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-204.png\" style=\"zoom:69%;\" />\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-205.png\" style=\"zoom:67%;\" />\n\n- 运算符合体完毕如下图所示。此时我们就得到了一个最简的有向无环图。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-206.png\" style=\"zoom:67%;\" />\n\n#### 拓扑排序\n\n##### 如何进行拓扑排序\n\n**AOV网**（Activity On Vertex NetWork，用顶点表示活动的网）：\n\n**用DAG图**（有向无环图）表示一个工程。顶点表示活动，有向边`<Vi, Vj>`表示活动`Vi`必须先于活动`Vj`进行。\n\n如果存在环路，则一定不是AOV网。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-207.png\" style=\"zoom: 33%;\" />\n\n> **拓扑排序**：在图论中，由一个**有向无环图**的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：\n>\n> ①每个顶点出现且只出现一次。\n>\n> ②若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径。\n>\n> 或定义为：\n>\n> 拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条从顶点A到顶点B的路径，则在排序中顶点B出现在顶点A的后面。**每个AOV网都有一个或多个拓扑排序序列**。\n\n上述定义可能看不懂，我们直接看如何进行拓扑排序。拓扑排序实际上就是：找到做事的先后顺序。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-208.png\" style=\"zoom: 33%;\" />\n\n例如这个AOV网，我们可以从`准备厨具`或`买菜`开始做起。\n\n- 例如我们将`准备厨具`作为第一件事开始。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-209.png\" style=\"zoom: 50%;\" />\n\n- 那么第二件事是什么？第二件事一定是`买菜`。因为如果不这样，那么是不可能进行其他操作的。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-210.png\" style=\"zoom: 33%;\" />\n\n- 第三件事，同理，可以先选择`打鸡蛋`，也可以先选择`洗番茄`。例如我们先选择洗番茄。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-211.png\" style=\"zoom:33%;\" />\n\n- 第四件事，我们可以先选择`打鸡蛋`，也可以先选择`切番茄`。例如我们选择先切番茄。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-212.png\" style=\"zoom:33%;\" />\n\n- 至此，剩下的事情顺序，就必须是`打鸡蛋、下锅炒、吃`了。最终拓扑排序如下所示：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-213.png\" style=\"zoom:67%;\" />\n\n**拓扑排序的实现**：\n\n①从AOV网中选择一个没有前驱（**入度为0**）的顶点并输出。\n\n②从网中删除该顶点和所有以它为起点的有向边。\n\n③重复①和②直到当前的**AOV网为空**或**当前网中不存在无前驱的顶点为止（说明有回路）**。\n\n> **注**:如果③的结果为`当前网中不存在无前驱的顶点`，则说明有回路，则说明其是不可以拓扑排序的。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-214.png\" style=\"zoom:33%;\" />\n>\n> 例如，若有回路，则，到这一步时，发现没有入度为0的结点。说明原图存在回路。\n>\n> 所以，对于存在回路的图，是不可能存在拓扑排序序列的。\n>\n> 如果原图是一个DAG图（有向无环图），那么就存在拓扑排序序列。\n\n##### 拓扑排序的代码实现\n\n其实代码实现思路很简单，就是把刚才说的那两个需要不断重复的步骤①②，不断地重复，直到达到③的条件就可以。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-215.png\" style=\"zoom:35%;\" />\n\n```C\n#define MaxVertexNum 100\t//图中顶点数目的最大值\ntypedef struct ArcNode {\t//边表结点 \n\tint adjvex;\t\t//该弧所指向的顶点的位置\n\tstruct ArcNode *nextarc;\t//指向下一条弧的指针\n\t//InfoType info;\t//网的边权值 \n}ArcNode \n\ntypedef struct VNode {\t//顶点表结点 \n\tVertexType data;\t//顶点信息\n\tArcNode *firstarc;\t//指向第一条依附该顶点的弧的指针 \n}VNode, AdjList[MaxVertexNum];\n\ntypedef struct {\n\tAdjList vertices;\t//邻接表\n\tint vexnum, arcnum;\t//图的顶点数和弧数 \n}Graph;\t\t//Graph是以邻接表存储的图类型\n\nbool TopologicalSort(Graph G) {\n\tInitStack(S);\t//初始化栈，存储入度为0的顶点\n\tfor(int i=0; i<G.vexnum; i++) {\n\t\tif(indegree[i] == 0)\n\t\t\tPush(S, i);\t//将所有入度为0的顶点进栈 \n\t}\n\tint count = 0;\t//计数，记录当前已经输出的顶点数\n\twhile(!IsEmpty(S)) {\t//栈不空，则存在入度为0的顶点 \n\t\tPop(S, i);\t//栈顶元素出栈\n\t\tprint[count++] = i;\t//输出顶点i\n\t\tfor(p=G.vertices[i].firstarc; p; p=p->nextarc) {\n\t\t\t//将所有i指向的顶点的入度减1，并且将入度为0的顶点压入栈S\n\t\t\tv = p->adjvex;\n\t\t\tif(!(--indegree[v])) \n\t\t\t\tPush(S, v);\t//入度为0，则入栈 \n\t\t}\n\t}//while\n\tif(count < G.vexnum)\n\t\treturn false;\t//排序失败，有向图中有回路 \n\telse \n\t\treturn true;\t//拓扑排序成功 \n}\n```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-216.png\" style=\"zoom:35%;\" />\n\n**时间复杂度**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-217.png\" style=\"zoom:45%;\" />\n\n由于每个顶点都需要处理一次，每条边都需要处理一次。\n\n时间复杂度：`O(|V|+|E|)`若采用邻接矩阵，则需`O(|V|²)`\n\n#### 逆拓扑排序\n\n##### 如何进行逆拓扑排序\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-218.png\" style=\"zoom: 33%;\" />\n\n对一个AOV网，如果采用下列步骤进行排序，则称之为**逆拓扑排序**：\n\n①从AOV网中选择一个没有后继（**出度为0**）的顶点并输出。\n\n②从网中删除该顶点和所有以它为终点的有向边。\n\n③重复①和②直到当前的AOV网为空。\n\n> 上图的逆拓扑排序如下：\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-219.png\" style=\"zoom:67%;\" />\n\n##### 逆拓扑排序的代码实现\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-246.png\" style=\"zoom: 50%;\" />\n\n把“拓扑排序”中，进行`入度为0`的条件判断改为`出度为0`即可实现逆拓扑排序的代码。\n\n自己练习：模仿拓扑排序的思想实现逆拓扑排序。\n\n思考：使用不同的存储结构（即改用邻接矩阵实现）对时间复杂度的影响。\n\n> 对于逆拓扑排序来说，由于每次都要寻找该顶点的入边，若采用邻接表存储，则需要重新整个遍历所有邻接表，找到指向该顶点的边。是很低效的。而如果采用邻接矩阵，会很方便。\n>\n> 甚至，还可以采用“逆邻接表”：邻接表中，每一个顶点所对应的边的信息，是由该顶点发射出的边；而逆邻接表中，每一个顶点所对应的边的信息，是指入该顶点的边。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-247.png\" style=\"zoom:50%;\" />\n\n##### 逆拓扑排序的实现(DFS算法)\n\n> 用深度优先算法实现拓扑排序或逆拓扑排序。\n>\n> 这里先不讲。但是这里先补充一个课本中没有讲的，DFS算法实现逆拓扑排序。\n\n```C\nvoid DFSTraverse(Graph G) {\t//对图G进行深度优先遍历 \n\tfor(v=0; v<G.vexnum; ++v) {\n\t\tvisited[v] = FALSE;\t//初始化已访问标记数据 \n\t}\n\tfor(v=0; v<G.vexnum; ++v) {\t//本代码中是从v=0开始遍历 \n\t\tif(!visited[v])\n\t\t\tDFS(G, v);\n\t}\n}\n\nvoid DFS(Graph G, int v) {\t//从顶点v出发，深度优先遍历图G \n\tvisit(v);\t//访问顶点v\n\tvisited[v] = TRUE;\t//设已访问标记\n\tfor(w=FirstNeighbor(G, v); w>=0; w=NextNeighbor(G,v,w)) {\n\t\tif(!visited[w]) {\t//w为u的尚未访问的邻接顶点 \n\t\t\tDFS(G, w);\n\t\t}\n\t}\n    print(v);\t//输出顶点\n}\n```\n\n在DFS算法的基础上，添加一个`print(v);`的操作，输出出来的就是逆拓扑序列。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-222.png\" style=\"zoom:80%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-223.png\" style=\"zoom:80%;\" />\n\n> 上图，本身是不存在环路的。且我们的代码实现也没有考虑回路的问题。\n>\n> 思考：如果存在回路，则不存在逆拓扑排序序列，那么如何判断回路的存在？试着对代码进行一个改进。\n\n### 关键路径\n\n#### AOE网\n\nAOE网:\n\n在带权有向图中，以**顶点表示事件**，以**有向边表示活动**，以**边上的权值表示完成该活动的开销**（如完成活动所需的时间），称之为用边表示活动的网络，简称**AOE网**（Activity On Edge NetWord）。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-224.png\" style=\"zoom: 33%;\" />\n\n> AOV网，V表示`Vertex`，指用顶点表示活动；\n>\n> AOE网，E表示`Edge`，指用边表示活动。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-225.png\" style=\"zoom: 33%;\" />\n\n> 顶点表示事件，是一瞬间发生的事情；边表示活动，是需要持续一段时间的。\n\nAOE网具有以下两个性质：\n\n①只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始；\n\n②只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。另外，有些活动是可以并行进行的。\n\n#### 关键路径\n\nAOE网还有一些概念：\n\n- 在AOE网中**仅有一个**入度为0的顶点，称为**开始顶点**（**源点**），它表示整个工程的开始；\n- 也**仅有一个**出度为0的顶点，称为**结束顶点**（**汇点**），它表示整个工程的结束。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-226.png\" style=\"zoom:33%;\" />\n\n从源点到汇点的有向路径可能有多条，所有路径中，具有最大路径长度的路径称为**关键路径**，而把关键路径上的活动称为**关键活动**。\n\n完成整个工程的最短时间就是关键路径的长度，若关键活动不能按时完成，则整个工程的完成时间就会延长。\n\n> 找到关键活动是哪些，我们就知道了影响整个项目的，是哪些事。\n\n> 对于上图：\n>\n> 最快多久可以开始做？——现在，立刻（0分钟）    最快多久可以开切？——1分钟\n>\n> 最快多久可以开炒？——4分钟                  最快多久可以吃？——6分钟\n\n**事件`Vk`的最早发生时间`Ve(k)`**——决定了所有从`Vk`开始的活动能够开工的最早时间。\n\n> （等于其前驱活动的最早开始时间 + 该活动需要消耗的时间）\n>\n> 例如，`可以切了`事件它的最早发生时间为1分钟，则在它之后的所有活动最早也要在1分钟时开工。\n\n**活动`ai`的最早开始时间`e(i)`**——指该活动弧的起点所表示的事件的最早发生时间。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-227.png\" style=\"zoom:40%;\" />\n\n上图，黄色为事件的最早发生时间，红色为活动的最早开始时间。\n\n> 如果有一个人说：6分钟后我一定要吃到，不然我会被饿死。\n>\n> 之后厨师分析了一下：整个项目6分钟可以结束。\n>\n> 由于炒菜需要2分钟，于是推出：4分钟时一定要开始炒菜这一活动。(如果4分钟时不能完成`可以炒了`事件，就意味着6分钟不可能结束)\n>\n> 继续往前推，由切番茄需要3分钟，可以推出：`可以切了`事件，必须在1分钟时就发生。\n>\n> 继续，由洗番茄需要1分钟，推出：`开始`必须是现在。\n\n上述我们从后往前推，推出了每个事件允许发生的最迟的时间。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-228.png\" style=\"zoom:40%;\" />\n\n**事件`Vk`的最迟发生时间`Vl(k)`**——它是指在不推迟整个工程完成的前提下，该事件最迟必须发生的时间。\n\n**活动`ai`的最迟开始时间`l(i)`**——它是指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差。\n\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-229.png\" style=\"zoom:43%;\" />\n>\n> 上图，红色表示活动的最早开始时间，绿色表示活动的最迟开始时间。\n\n**活动`ai`的时间余量`d(i) = l(i)-e(i)`**，表示在不增加完成整个工程所需总时间的情况下，活动`ai`可以拖延的时间。\n\n若一个活动的时间余量为零，则说明该活动必须要如期完成，`d(i)=0`即`l(i)=e(i)`的活动`a(i)`是**关键活动**。\n\n#### 求关键路径的步骤\n\n①求所有事件的最早发生时间`ve()`\n\n②求所有事件的最迟发生时间`vl()`\n\n③求所有活动的最早发生时间`e()`\n\n④求所有活动的最迟发生时间`l()`\n\n⑤求所有活动的时间余量`d()`\n\n> 到第⑤步，由于`d(i)=0`的活动就是关键活动，由关键活动可得关键路径。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-230.png\" style=\"zoom: 67%;\" />\n\n##### 求所有事件的最早发生时间\n\n> ①求所有事件的最早发生时间`ve()`\n>\n> （某一事件的最早发生时间，等于其前驱活动的最早开始时间 + 该活动需要消耗的时间）\n\n按**拓扑排序**序列，依次求各个顶点的`ve(k)`：\n\nve(源点) = 0\n\nve(k) = Max{ ve(j) + Weight(Vj, Vk) }，Vj为Vk的任意前驱\n\n> 首先我们要对这个AOE网进行一个拓扑排序。\n\n**拓扑序列**：V1、V3、V2、V5、V4、V6\n\n> 根据拓扑排序序列的顺序，来依次计算各个顶点所代表的事件的最早发生时间。\n>\n> 这是因为，拓扑排序表示活动所必需的先后次序，我们根据拓扑排序序列依次计算最早发生时间，可以做到有条不紊。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-237.png\" style=\"zoom: 50%;\" />\n\n> 一般有多个入边才需要取max\n>\n> 而取max是因为当前事件要发生的前提是它的入边的弧的起点所代表的事件要完成了\n\n##### 求所有事件的最迟发生时间\n\n> ②求所有事件的最迟发生时间`vl()`\n>\n> （某一事件的最迟发生时间，等于其后继活动的最迟发生时间-该活动需要消耗的时间）\n\n按**逆拓扑排序**序列，依次求各个顶点的`vl(k)`：\n\nvl(汇点) = ve(汇点)\n\nvl(k) = Min{ vl(j) - Weight(Vk，Vj) }，Vj为Vk的任意后继\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-238.png\" style=\"zoom:50%;\" />\n\n> 当有多个出边时才需要取min\n>\n> 取min是表示，当该事件的所有弧中所指向的事件在完成的情况下，当前事件最迟发生的事件，为了确保所有指向的事件都完成，所以取min\n\n##### 求所有活动的最早发生时间\n\n> ③求所有活动的最早发生时间`e()`\n>\n> （某活动的最早发生时间，等于其弧尾事件的最早发生时间）\n\n若边`<Vk, Vj>`表示活动`ai`，则有`e(i) = ve(k)`\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-239.png\" style=\"zoom:67%;\" />\n\n##### 求所有活动的最迟发生时间\n\n> ④求所有活动的最迟发生时间`l()`\n>\n> （某活动的最迟发生时间，等于其弧头事件的最迟发生时间 - 该活动所需时间）\n\n若边`<Vk, Vj>`表示活动`ai`，则有`l(i) = vl(j) - Weight(Vk, Vj)`\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-240.png\" style=\"zoom:67%;\" />\n\n##### 求所有活动的时间余量\n\n> ⑤求所有活动的时间余量`d()`\n>\n> 用活动的最迟发生时间 - 活动的最早发生时间\n\nd(i) = l(i) - e(i)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-241.png\" style=\"zoom: 67%;\" />\n\n##### 找出关键路径\n\n根据最终得到的各个活动的时间余量，可以发现活动a2、a5、a7的时间余量都等于0，也就是说这几个活动是绝对不允许拖延的。因此我们就找到了所有的关键活动。\n\n> 关键活动：a2、a5、a7\n>\n> 关键路径：V1——>V3——>V4——>V6\n\n#### 关键活动、关键路径的特性\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-242.png\" style=\"zoom: 50%;\" />\n\n- 若关键活动耗时增加，则整个工程的工期将增长\n- 缩短关键活动的时间，可以缩短整个工程的工期\n- 当缩短到一定程度时，关键活动可能会变成非关键活动\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-243.png\" style=\"zoom:50%;\" />\n\n- 可能有多条关键路径，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的\n  - 要么把两条路径上的关键活动分别都加速。要么把这两个关键路径的交集路线上的活动加速（也相当于给两条路径都加速了）。\n\n### 习题\n\n- 【2010】对下面进行拓扑排序，可得不同拓扑序列的个数是-->3\n\n  ![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-102.png)\n\n  > a没有被其他节点指向;d没有指向其他节点;\n  >\n  > **所以拓扑排序的形式如下:aXXXd;**又因为b指向c,**那么b一定是在c的前面**;\n  >\n  > 所以可能的拓扑排序如下:**abced,aebcd,abecd**。\n\n- 【2012】下列关于最小生成树的叙述中，正确的是→①\n  ① 最小生成树的代价唯一\n  ② 所有权值最小的边一定会出现在所有的最小生成树中\n  ③ 使用 Prim 算法从不同定点开始得到的最小生成树一定相同\n  ④ 使用 Prim 算法和 Kruskal 算法得到的最小生成树总不相同\n\n  > Ⅰ．最小生成树的代价唯一这种叙述是正确的。Ⅱ．如果利用kruskal算法，那么权值最小的边一定会出现在所有的最小生成树中，但是利用prim算法权值最小的边不一定会在最小生成树中。Ⅲ．用prim算法从不同的顶点开始得到的最小生成树也不一定相同。最后，用prim算法和kruskal算法得到的最小生成树也有可能相同。\n\n- 【2012】对下图所示的有向带权图，若采用Dijkstra算法求从源点a到其他各顶点的最短路径，则得到的第一条最短路径的目标顶点是b，第二条最短路径的目标顶点是c,后续得到的其余各最短路径的目标顶点依次是-->f,d,e\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-103.png\"  />\n\n  > 从a到各顶点的最短路径的求解过程：\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-104.png\" style=\"zoom:60%;\" />\n  >\n  > 后续目标顶点依次为f,d,e\n  >\n  > 【排除法】对于A，若下一个顶点为d，路径a,b,d的长度5，而a,b,c,f的长度仅为4，显然错误。同理可以排除B。将f加入集合S后，采用上述的方法也可以排除D。\n\n- 【2013】下列AOE网表示一项包含8个活动的工程。通过同时加快若干活动的进度可以缩短整个工程的工期。下列选项中，加快其进度就可以缩短工程工期的是-->f 和 d\n\n  ![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-105.png)\n\n  > 这个网有三条关键路径：\n  >\n  > - b、d、c、g\n  > - b、d、e、h\n  > - b、f、h\n  >\n  > 缩短工期的活动要涵盖三条路径。\n  >\n  > 具体运算如下:@牛客 我是超越迷妹了\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-106.png\" style=\"zoom: 25%;\" />\n\n- 【2012】若用邻接矩阵存储有向图，矩阵中主对角线以下的元素均为零，则关于该图拓扑序列的结论是-->C\n\n  A.存在,且唯一          B.存在,且不唯\n  C.存在,可能不唯一      D.无法确定是否存在\n\n  > 1)若邻接矩阵为 \n  >\n  > 0 1 1 \n  >\n  > 0 0 0 \n  >\n  > 0 0 0 \n  >\n  > 满足主对角线以下元素均为零 \n  >\n  > 且只有从结点1到结点2，3的边，此时拓扑序列有1，2和1，3，不唯一 \n  >\n  > 2)若邻接矩阵为   \n  >\n  > 0 1 0 \n  >\n  > 0 0 1 \n  >\n  > 0 0 0 \n  >\n  > 满足主对角线以下元素均为零， \n  >\n  > 且只有结点1到结点2，结点2到结点3的边，此时拓扑序列为1，2，3，唯一\n\n- 【2014】对下图所示的有向图进行拓扑排序，得到的拓扑序列可能是-->3,1,4,2,6,5\n\n  ![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-107.png)\n\n  > 每次选取极大顶点（入度为0的顶点），并把它跟它的出度一起从图中删掉\n  >\n  > 第一次删掉3。第二次删掉1。第三次删掉4\n  >\n  > 第四次可以删掉2或者6，若依据选项CD删掉2，那么第五次删掉6，最后删掉5\n  >\n  > 314265，选D\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-108.png\"  />\n\n- 【2015】求下面的带权图的最小生成树时，可能是Kruskal算法第2次选中但不是Prim算法（从 V4 开始）第 2 次选中的边是-->C\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-109.png\"  />\n\n  A. (V1,V3)   B. (V1,V4)\n  C. (V2,V3)   D. (V3,V4)\n\n  > 从V4开始，Kruskal算法选中的第一条边一定是权值最小的（V1,V4），B 错误。由于  V1和V4已经可达，第二条边含有V1和V4的权值为8的一定符合Prim算法，排除A、D  。\n\n- 【2016】使用Dijkstra算法求下图中从顶点1到其他各顶点的最短路径，依次得到的各最短路径的目标顶点是-->5, 2, 3, 6, 4\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-110.png\" style=\"zoom: 50%;\" />\n\n  > 对于dijkstra算法来说，只有当一个点的所有入度都被遍历过之后，才能完全确认起点到这个点的距离。但这道题没有那么严谨，它的意思似乎仅仅是给各最短路径排序，从短到长。\n\n- 【2016】若对 n 个顶点、e 条弧的有向图采用邻接表存储，则拓扑排序算法的时间复杂度是 →O(n+e)\n\n  > 对有n个顶点和e条弧的有向图而言，建立求各顶点的入度的时间复杂度为O(e)；建零入度顶点栈的时间复杂度为O(n)；在拓扑排序过程中，若有向图无环，则每个顶点进一次栈、出一次栈，入度减1的操作在while语句中总共执行e次，所以总的时间复杂度为O(n+e)。 拓扑排序初始参数只有邻接表，所以第一步建立入度数组，因为每1入度对应一条弧，总共e条弧，建立入度数组的复杂度为O(e)。每个节点输出一次，n个节点遍历一次，时间复杂度为O(n)。（使用零入度节点栈的原因是，如果不把零入度节点入栈，每次输出时都要遍历节点。建立此栈，只需遍历一次。）然后节点入度减1的操作，也是一条弧对应一次，e条弧总共O(e)。以上总计O(n+2e)即O(n+e)。 即对每条弧要建立入度数组操作和删除操作，每个顶点要遍历一次并删除。故时间复杂度为O(n+e)\n\n- 【2018】下列选项中，不是如下有向图的拓扑序列是-->D\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-111.png\" style=\"zoom:50%;\" />\n\n  A.1,5,2,3,6,4     B.5,1,2,6,3,4\n\n  C.5,1,2,3,6,4     D.5,2,1,6,3,4\n\n  > 拓扑排序每次选取入度为0的结点输出，经观察不难发现拓扑序列前两位一定是1，5或5，1(因为只有1和5的入度均为0，且其他结点都不满足仅有1或仅有5作为前驱)。\n\n- 【2019】下图所示的AOE网表示一项包含8个活动的工程。活动d的最早开始时间和最迟开始时间分别是-->12 和 14\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-112.png\" style=\"zoom:67%;\" />\n\n  > 因为活动d的最早开始时间等于该活动弧的起点所表示的时间的最早发生时间=max(a,b+c)=max(3,12)=12 \n  >\n  > 活动d的最迟开始时间等于该活动弧的最迟发生时间与该活动所需时间之差，图中的关键路径长度为27，所以事件发生的最迟时间为min(27-g)=21,所以d的最迟开始时间为21-d=14\n\n- 【2019】用有向无环图描述表达式`(x+y)((x+y)/x)`，需要的顶点个数至少是 →5\n\n  > https://blog.csdn.net/amoscn/article/details/103452640\n\n- 【2020】修改递归方式实现的图的深度优先搜索（DFS）算法，将输出（访问）顶点信息的语句移到退出递归前（即执行输出语句后立刻退出递归）。采用修改后的算法遍历有向无环图 G，若输出结果中包含 G 的全部顶点，则输出的顶点序列是G的-->B\n  A 拓扑有序序列       B 逆拓扑有序序列\n  C 广度优先搜索序列   D 深度优先搜索序列 \n\n  > https://blog.csdn.net/cuisl37186486/article/details/117968121\n\n- 【2020】若使用AOE网估算工程进度，则下列叙述中正确的是-->B\n\n  A. 关键路径是从源点到汇点边数最多的一条路径\n  B. 关键路径是从源点到汇点路径长度最长的路径\n  C. 增加任一关键活动的时间不会延长工程的工期\n  D. 缩短任一关键活动的时间将会缩短工程的工期\n\n  > 关键路径是指权值之和最大而非边数最多的路径，故选项A错误。选项B正确，是关键路径的概念。无论是存在一条还是存 在多条关键路径，增加任一关键活动的时间都会延长工程的工期，因为关键路径始终是权值之和最大的那条路径，选项C错误。仅有一条关键路径时，减少关键活动的时间会缩短工程的工期;存在多条关键路径时，缩短一条关键活动的时间不一定会缩短工程的工期，缩短了路径长度的那条关键路径不一定还是关键路径,选项D错误。\n\n- 【2020】已知无向图G如下所示，使用克鲁斯卡尔（Kruskal）算法求图G的最小生成树，加入到最小生成树中的边依次是：\n\n  A．(b,f)(b,d)(a,e)(c,e)(b,e)\n\n  B．(b,f)(b,d)(b,e)(a,e)(e,c)\n\n  C．(a,e)(b,e)(c,e)(b,d)(b,f)\n\n  D．(a,e)(c,e)(b,e)(b,f)(b,d)\n\n  ![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-114.png)\n\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-115.png\" style=\"zoom:80%;\" />\n\n- 【2021】给定如下有向图，该图的拓扑有序序列的个数是-->A\n\n  A. 1      B. 2\n\n  C. 3      D. 4\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-116.png\" style=\"zoom:67%;\" />\n\n  > 求拓扑序列的过程如下:从图中选择无入边的结点，输出该结点并删除该结点的所有出边,重复上述过程，直至全部结点都已输出，求得拓扑序列ABCDEF.每次输出一个结点并删除该结点的所有出边后，都发现仅有一个结点无入边，因此该拓扑序列唯一\n\n- 【2021】使用Djkstra算法求下图中从顶点1到其余各顶点的最短路径，将当前找到的从顶点1到顶点2,3, 4, 5的最短路径长度保存在数组dist中，求出第二条最短路径后，dist 中的内容更新为-->C\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-117.png\" style=\"zoom:67%;\" />\n\n  A、26,3,14,6      B、25,3,14,6\n\n  C、21,3,14,6      D、15,3,14,6\n\n  > 在执行Dijkstra算法时，首先初始化dist],若顶点1到顶点i(i=2,3,4, 5)有边，就初始化为边的权值;若无边，就初始化为∞;初始化顶点集s只含顶点1。Djkstra算法每次选择一个到顶点1距离最近的顶点j加入顶点集s,并判断由顶点1绕行顶点j后到任一顶点k是否距离更短，若距离更短(即distj] + arcs[j][k] < dist[k])， 则将dist[x]更新为dist[j] +arcs[j][k];重复该过程，直至所有顶点都加入顶点集S。数组dist的变化过程如下图所示,可知将第二个顶点5加入顶点集S后，数组dist更新为21,3, 14,6,故选C。\n\n><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-118.png\" style=\"zoom:67%;\" />\n\n- 综合题【2009】带权图(权值非负，表示边连接的两顶点)的最短路径问题是找出从初始顶点到目标顶点之间的一条最短路径。假设从初始顶点到目标顶点之间存在路径，现有一种解决该问题的方法∶\n  ①设最短路径初始时仅包含初始顶点，令当前顶点u为初始顶点;\n  ② 选择离u最近且尚未在最短路径中的一个顶点v，加入最短路径中，修改当前顶点u=v;\n  ③ 重复步骤②，直到u是目标顶点时为止。\n  请问上述方法能否求得最短路径?若该方法可行，请证明之;否则，请举例说明。\n\n  > 该方法不一定能（或不能）求得最短路径。  \n  >\n  > 举例说明： \n  >\n  > 图A-4中，设初始顶点为1，目标顶点为4，欲求从顶点1到顶点4之间的最短路径，显然这两点之间的最短路径长度为2。利用给定方法求得的路径长度为3，但这条路径并不是这两点之间的最短路径。 \n  >\n  > 图A-5中，设初始顶点为1，目标顶点为3，欲求从顶点1到顶点3之间的最短路径。利用给定的方法，无法求出顶点1到顶点3的路径。\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-119.png\" style=\"zoom:80%;\" />\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-120.png\" style=\"zoom:80%;\" />\n\n- 综合题【2017】使用Prim算法求带权连通图的最小生成树(MST)。请回答下列问题:\n\n  (1)对下列图 G，从顶点 A 开始求 G 的 MST，依次给出按算法选出的边。\n\n  (2)图 G 的 MST 是唯一的吗？\n\n  (3)对任意的带权连通图，满足什么条件时，其 MST 是唯一的？\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-128.png\" style=\"zoom:50%;\" />\n\n  > (1)Prim 算法属于贪心策略。算法从一个任意的顶点开始，一直长大到覆盖图中所有顶点为止。算法每一步在连接 树集合 S 中顶点和其他顶点的边中，选择一条使得树的总权重增加最小的边加入集合 S。当算法终止时，S 就是最小生 成树。 \n  >\n  > ①S 中顶点为 A，候选边为(A,D)、(A,B)、(A,E)，选择(A,D)加入 S。 \n  >\n  > ②S 中顶点为 A、D，候选边为(A,B)、(A,E)、(D,E)、(C,D)，选择(D,E)，加入 S。 \n  >\n  > ③S 中顶点为 A、D、E，候选边为(A,B)、(C,D)、(C,E)，选择(C,E)加入 S。 \n  >\n  > ④S 中顶点为 A、D、E、C，候选边为(A,B)、(B,C)，选择(B,C)加入 S。 \n  >\n  > ⑤S 就是最小生成树。 依次选出的边为： (A，D),(D，E),(C，E),(B，C) \n  >\n  > (2)图 G 的 MST 是唯一的 第一小题的最小生成树包括了图中权值最小的四条边，其他边都比这四条 边大，所以此图的 MST 唯一。\n  >\n  > (3)当带权连通图的任意一个环中所包含的边的权值均不相同时，其 MST 是唯一的\n\n- 综合题【2011】已知有6个顶点(顶点编码为0~5)的有向带权图G，其邻接矩阵 A 为上三角矩阵，按行为主序（行优先）保存在如下的一维数组中。\n\n  | 4    | 6    | ∞    | ∞    | ∞    | 5    | ∞    | ∞    | ∞    | 4    | 3    | ∞    | ∞    | 3    | 3    |\n  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n\n  要求∶\n  （1）写出图G的邻接矩阵 A。\n  （2）画出有向带权图 G。\n  （3）求图 G的关键路径，并计算该关键路径的长度。\n\n  > (1)给的一维数组可以理解为上三角矩阵的压缩存储。图有6个顶点，而且第一个值是4，说明，它没有记录节点自己到自己的节点。那么，上三角的第一行就有5个值，第二行有4个值，第三行有3个值，第四行有2个值，第五行有1个值。5+4+3+2+1 正好是给定的一维数组值得个数。主对角线都是零。\n  >\n  > 因为是有向图，下三角部分没有给值，说明没有路径。就都是无穷。\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-121.png\" style=\"zoom: 25%;\" />\n  >\n  > （2）根据邻接矩阵画出图\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-122.png\" style=\"zoom: 50%;\" />\n  >\n  > （3）关键路径的求法:https://www.bilibili.com/video/BV1Kt411R7SD/\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-123.png\" style=\"zoom: 33%;\" />\n  >\n  > |                  | 0    | 1    | 2    | 3    | 4    | 5    |\n  > | :--------------- | :--- | :--- | :--- | :--- | :--- | ---- |\n  > | 事件最早开始时间 | 0    | 4    | 9    | 13   | 12   | 16   |\n  > | 事件最晚开始时间 | 0    | 4    | 9    | 13   | 13   | 16   |\n  >\n  > |                  | a1   | a2   | a3   | a4   | a5   | a6   | a7   |\n  > | :--------------- | :--- | :--- | :--- | :--- | :--- | :--- | ---- |\n  > | 活动最早开始时间 | 0    | 0    | 4    | 9    | 9    | 13   | 12   |\n  > | 活动最晚开始时间 | 0    | 3    | 4    | 9    | 10   | 13   | 13   |\n  >\n  > 关键路径为：0 -> 1 -> 2 -> 3 -> 5      路径长度为：16\n\n- 综合题【2014】某网络中的路由器运行OSPF路由协议，下表是路由器R1维护的主要链路状态信息(LSI)，R1构造的网络拓扑图(见下图)是根据题下表及R1的接口名构造出来的网络拓扑\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-124.png\" style=\"zoom:67%;\" />\n\n   请回答下列问题。\n\n  1)   本题中的网络可抽象为数据结构中的哪种逻辑结构？\n  2)   针对题42表中的内容，设计合理的链式存储结构，以保存题42表中的链路状态信息(LSI)。要求给出链式存储结构的数据类型定义，并画出对应题42表的链式存储结构示意图(示意图中可仅以ID标识结点)。\n  3)   按照迪杰斯特拉(Dijkstra)算法的策略，依次给出R1到达题42图中子网192.1.x.x的最短路径及费用。\n\n  > 1)题中给出的是一个简单的网络拓扑图，可以抽象为无向图。\n  >\n  > 2)链式存储结构的如下图所示\n  >\n  > ![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-125.png)\n  >\n  > 其数据类型定义如下：\n  >\n  > ```C\n  > typedef struct{\n  > \n  > unsigned int ID, IP;\n  > \n  > }LinkNode; //Link 的结构\n  > \n  > typedef struct{\n  > \n  > unsigned int Prefix, Mask;\n  > \n  > }NetNode; //Net 的结构\n  > \n  > typedef struct Node{\n  > \n  > int Flag; //Flag=1 为Link;Flag=2为Net\n  > \n  > union{\n  > \n  >  LinkNode Lnode;\n  > \n  >  NetNode Nnode\n  > \n  > }LinkORNet;\n  > \n  > unsigned int Metric;\n  > \n  > struct Node *next;\n  > \n  > }ArcNode; //弧结点\n  > \n  > typedef struct HNode{\n  > \n  > unsigned int RouterID;\n  > \n  > ArcNode *LN_link;\n  > \n  > Struct HNode *next;\n  > \n  > }HNODE; //表头结点\n  > ```\n  >\n  > 对应题42表的链式存储结构示意图如下\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-126.png\" style=\"zoom: 80%;\" />\n  >\n  > 3)计算结果如下表所示\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-127.png\" style=\"zoom: 67%;\" />\n\n- 综合题【2018】拟建设一个光通信骨干网络连通BJ,CS,XA,OD,JN,NJ,TL 和 WH 8 个城市，下图中无向边上的权值表示两个城市间备选光纤的铺设费用。\n\n  请回答下列问题。 \n\n    （1）仅从铺设费用角度出发，给出所有可能的最经济的光纤铺设方案（用带权图表示）， 并计算相应方案的总费用。 \n\n    （2）题 42 图可采用图的哪种存储结构？给出求解问题（1）所使用的算法名称。 \n\n    （3）假设每个城市采用一个路由器按（1）中得到的最经济方案组网，主机 H1 直接连接在 TL 的路由器上，主机 H2 直接连接在 BJ 的路由器上。若 H1 向 H2 发送一个 TTL = 5 的 IP 分组， 则 H2 是否可以收到该 IP 分组？\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-129.png\" style=\"zoom: 33%;\" />\n\n  > 1)为了求解最经济的方案，可以把问题抽象为求无向带权图的最小生成树。可以采用手 动 Prim 算法或 Kruskal 算法作图。注意本题最小生成树有两种构造，如下图所示。\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-130.png\" style=\"zoom: 67%;\" />\n  >\n  > 方案的总费用为 16。\n  >\n  > 2)存储题中的图可以采用邻接矩阵（或邻接表）。构造最小生成树采用 Prim 算法（或 Kruskal 算法）\n  >\n  > 3)TTL = 5，即 IP 分组的生存时间（最大传递距离）为 5，方案 1 中 TL 和 BJ 的距离过远， TTL = 5 不足以让 IP 分组从 H1 传送到 H2，因此 H2 不能收到 IP 分组。而方案 2 中 TL 和 BJ 邻近，H2 可以收到 IP 分组。\n","tags":["408数据结构"],"categories":["408数据结构"]},{"title":"第六章 图(上)","url":"/p/63800/","content":"\n## 6.1 图的基本概念\n\n### 图的定义\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-1.png\" style=\"zoom:69%;\" />\n\n- 有向图、无向图\n\n  无向图：每条边都是无方向的\n\n  有向图：每条边都是有方向的\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-2.png\" style=\"zoom: 80%;\" />\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-3.png\" style=\"zoom:80%;\" />\n\n- 简单图、多重图\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-4.png\" style=\"zoom: 80%;\" />\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-5.png\" style=\"zoom: 80%;\" />\n\n- 顶点的度、入度和出度\n\n  > 例如微信好友关系图，我们如何评判某人是否是“交际达人”？只需看某人这个结点，连接的边数，即可。连接的边数越多，则越有可能是一个交际达人。\n  >\n  > 例如微博粉丝关注图，如何评判某人是否是“微博大V”？只需看这个人的结点，它作为弧尾的弧有多少条，即可。\n  >\n  > 因此，无论是有向图还是无向图，讨论某个结点所联系的边或弧的条数，是很有意义的一件事。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-6.png\" style=\"zoom: 78%;\" />\n\n  如上面这张有向图，对于顶点A\n\n  ID(A) = 1\n\n  OD(A) = 4\n\n  TD(A) = 1+4 = 5\n\n- 顶点-顶点的关系描述\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-7.png\" style=\"zoom:78%;\" />\n\n- 连通图、强连通图\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-8.png\" style=\"zoom:78%;\" />\n\n- 研究图的局部--子图\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-9.png\" style=\"zoom:70%;\" />\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-10.png\" style=\"zoom:70%;\" />\n\n- 连通分量、强连通分量\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-11.png\" style=\"zoom:70%;\" />\n\n  **极大连通子图**，即**子图必须连通，且包含尽可能多的顶点和边**。\n\n  > 连通分量这个概念也是有很多现实意义的，比如说全国铁路线路图\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-176.png\" style=\"zoom:65%;\" />\n  >\n  > 这个图里面有三个连通分量——整个大陆区域的铁路图、海南岛铁路图、台湾岛铁路图。\n  >\n  > 当然，对于大陆区域的铁路图，你可以把其中长江三角区的铁路图挑出来，那么挑出来的这个图，它是一个子图，但是并不是极大连通子图。\n\n  \n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-12.png\" style=\"zoom:70%;\" />\n\n- 生成树、生成森林\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-175.png\" style=\"zoom:70%;\" />\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-14.png\" style=\"zoom:70%;\" />\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-15.png\" style=\"zoom:70%;\" />\n\n  > 其实生成树和生成森林有很多意义：\n  >\n  > 例如有图上顶点那么多的村庄，这些村庄之间如果要开通公路，但是由于经费有限，不可能把所有的路都修起来，但是又想让每个村庄之间道路都连通。如何能有一个成本最低的修路方案呢。\n  >\n  > 就可以用无向图，推出所有可能的生成树。因为生成树能保证是连通的，且能保证边的数量是尽可能的少的。\n  >\n  > 于是，通过生成树，就可以初步得到若干个修路的施工方案。\n  >\n  > 但是在不同的生成树之间，选择哪种方案，能让修路的成本最低呢？\n  >\n  > 其实就要看一下每一条边，修起路来的成本到底是多少。\n  >\n  > 于是在生成树的基础上，再将各个边的成本考虑进去，就能得到一个最经济的方案。\n\n- 边的权、带权图/网\n\n  > 可以发现，图这种数据结构，我们除了在顶点部分保存信息外，有时候也需要给各条边赋予一个数值，来表示权值。用这个数值来表示一些具有现实含义的一些信息。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-16.png\" style=\"zoom:78%;\" />\n\n- 完全图\n\n  完全图：任意两个点都有一条边相连\n\n  无向完全图：n个顶点，任意两个顶点都要有边。所以n个顶点，共有 \n  $$\n  C_n^2 = n(n-1)/2\n  $$\n  条边。\n\n  有向完全图：n个顶点，任意两个顶点都要有两条边。所以n个顶点，共有 \n  $$\n  2C_n^2 = n(n-1)\n  $$\n  条边\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-17.png\" style=\"zoom:80%;\" />\n\n- 稀疏图、稠密图\n\n  稀疏图：有很少或弧(有向图的边也称作弧)的图\n\n  稠密图：有较多边或弧的图\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-18.png\" style=\"zoom:80%;\" />\n\n- 有向树\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-19.png\" style=\"zoom:80%;\" />\n\n### 习题\n\n- 【2011】下列关于图的叙述中，正确的-->仅 ③\n\n  ① 回路是简单路径\n  ② 存储稀疏图，用邻接矩阵比邻接表更省空间\n  ③ 若有向图中存在拓扑序列，则该图不存在回路\n\n  > 第一个顶点和最后一个顶点相同的路径称为回路；序列中顶点不重复出现的路径称为简单路径；回路显然不是简单路径，故  Ⅰ  错误；稀疏图是边比较少的情况，此时用邻接矩阵的空间复杂度为  O(n²)  ，必将浪费大量的空间，而邻接表的空间复杂度为  O(n+e)  ，应该选用邻接表，故  Ⅱ  错误。存在回路的有向图不存在拓扑序列，若拓扑排序输出结束后所余下的顶点都有前驱，则说明只得到了部分顶点的拓扑有序序列，图中存在回路，故  Ⅲ  正确。\n\n- 【2009】下列关于无向连通图特性的叙述中，正确的是-->只有Ⅰ\n\n  Ⅰ．所有顶点的度之和为偶数\n\n  Ⅱ．边数大于顶点个数\n\n  Ⅲ．至少有一个顶点的度为1\n\n  > 1，每条边连接两个顶点，所有顶点的度之和等于边数的2倍，是偶数，正确\n  > 2，如两个顶点一条边的图就不满足这个条件，错\n  > 3，如三个顶点三条边连成一个三角形的图每个顶点度为2，错\n\n- 设有无向图 G=(V, E)和 G'(V', E')，若 G'是 G 的生成树，则下列不正确的→ 只有 ①\n\n  ① G'为 G 的连通分量\n\n  ② G'为 G 的无环子图\n\n  ③ G'为 G 的极小连通子图且 V'=V\n\n- 【2013】设图的邻接矩阵A如下图所示，各顶点的度依次是-->C\n  $$\n   A=\\left[\n   \\begin{matrix}\n     0 & 1 & 0 &1\\\\\n     0 & 0 & 1 &1\\\\\n     0 & 1 & 0 &0\\\\\n     1 & 0 & 0 &0\n    \\end{matrix}\n    \\right] \n  $$\n  A.1,2,1,2       B.2,2,1,1\n\n  C.3,4,2,3       D.4,4,2,2\n\n  > 无向图的边数组（邻接矩阵）是对阵矩阵。各顶点的度为邻接矩阵中对应行的元素之和。\n  >\n  > 有向图的各顶点的度为出度加上入度之和。出度为对应顶点所在行的所有元素之和，入度为对应顶点所在列的所有元素之和。\n  >\n  > 该图明显为有向图。所以各个顶点的度为其出度和入度之和，即所在行和列元素之和。\n\n- 【2017】已知无向图G含有16条边，其中度为4的顶点个数为3，度为3的顶点个数为4，其他顶点的度均小于3。图G所含的顶点个数至少是-->11\n\n  > 无向图边数的两倍等于各顶点度数的总和。由于其他顶点的度均小于3，可以设它们的度都为2，设它们的数量是x，可列出这样的方程4×3+3×4+2×x=16x2，解得x=4。4+3+4=11，B正确。\n\n\n## 6.2 图的存储及基本操作\n\n### 邻接矩阵法\n\n所谓邻接矩阵存储，是指用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息(即各顶点之间的邻接关系)，存储顶点之间的邻接关系的二维数组称为**邻接矩阵**。\n\n结点数为n的图G=(V,E)的邻接矩阵A是n×n的。将G的顶点编号为v1,v2,...,vn则\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-253.png\" style=\"zoom: 80%;\" />\n\n上述解释为：如果两个顶点之间存在边或者弧，那么二维数组就为1，如果两个顶点之间不存在边或者弧，那么二维数组就为0\n\n#### 邻接矩阵表示法\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-20.png\" style=\"zoom: 80%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-21.png\" style=\"zoom:80%;\" />\n\n- 无向图的邻接矩阵是**对称**的。\n- 顶点i的度 = 第i行(列)中1的个数。\n- **特别的，完全图(任意两个顶点都有边)的邻接矩阵中，对角元素为0，其余均为1**。\n\n邻接矩阵的实现也很简单，只需要用一个二维数组就可以。\n\n```C\n#define MaxVertexNum 100\t//顶点数目的最大值\ntypedef struct {\n    char Vex[MaxVertexNum];\t//顶点表\n    int Edge[MaxVertexNum][MaxVertexNum];\t//邻接矩阵，边表\n    int vexnum, arcnum;\t//图的当前顶点数和边数\n}MGraph;\n```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-22.png\" style=\"zoom:80%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-23.png\" style=\"zoom: 67%;\" />\n\n在有向图的邻接矩阵中：\n\n- 第i行含义：以结点Vi为尾的弧(即出度边)\n- 第i列含义：以结点Vi为头的弧(即出度边)\n\n分析：\n\n- 有向图的邻接矩阵**可能是不对称**的。\n- 顶点的出度 = 第 i 行元素之和\n- 顶点的入度 = 第 i 列元素之和\n- 顶点的度 = 第i行元素之和+第i列元素之和\n\n<font color='red'>邻接矩阵法求顶点的度/出度/入度的时间复杂度为O(|V|)</font>\n\n#### 网(带权图)的邻接矩阵表示法\n\n对于带权图而言，若顶点vi和vj之间有边相连，则邻接矩阵中对应项存放着该边对应的权值，若顶点vi给vj不相连，则用 ∞ 来代表着两个顶点之间不存在边:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-254.png\" style=\"zoom:80%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-24.png\" style=\"zoom:80%;\" />\n\n```C\n//带权图\n#define MaxVertexNum 100  //顶点数目的最大值\ntypedef char VertexType;  //顶点的数据类型\ntypedef int EdgeType;     //带权图中边上权值的数据类型\ntypedef struct{\n    VertexType Vex[MaxVertexNum];  //顶点表\n    EdgeType Edge[MaxVertexNum][MaxVertexNum]; //邻接矩阵，边表\n    int vexnum,arcnum;     //图的当前顶点数和弧数\n}MGraph;\n```\n\n#### 邻接矩阵法的性质\n\n1. 无向图的邻接矩阵一定是一个对称矩阵(唯一)。因此，在实际存储邻接矩阵时只需要存储上(或下)三角矩阵的元素。\n\n2. 对于无向图，邻接矩阵的第i行(或第i列)非零元素(或非∞元素)的个数正好是顶点i的度TD(vi)。\n\n3. 对于有向图，邻接矩阵的第i行非零元素(或非∞元素)的个数正好是顶点i的出度OD(vi);第i列非零元素(或非∞元素)的个数正好是顶点i的入度ID(vi)。\n\n4. 用邻接矩阵存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。\n\n5. 稠密图适合使用邻接矩阵的存储表示。\n\n6. <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-26.png\" style=\"zoom:85%;\" />\n\n   > 上图中的话是什么意思呢？我们举个例子来看一下，例如A²\n   >\n   > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-177.png\" style=\"zoom:80%;\" />\n   >\n   > 我们挑其中的一项看一下它具有什么实际意义，如a(1,2)*a(2,4)\n   >\n   > 其中a(1,2)的意思是A到B是否有边，a(2,4)表示B到D是否有边。\n   >\n   > 因此a(1,2)*a(2,4)便表示从A到D，但是是由A经过B到D的路径的数目。\n   >\n   > 那么其他项也是从A到D，但是是经过不同顶点到D的路径的数目。\n   >\n   > 把这些乘积的项都加起来，就表示从A到D，且长度为2的路径的数目。\n   >\n   > 具体的矩阵乘法去学线代吧。\n\n   > 如果是A³，那么原理也是类似的。\n   >\n   > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-132.png\" style=\"zoom: 80%;\" />\n   >\n   > 看最右侧的那个结果，其中第一行第四列的值为1，就意味着，从A到D，长度为3的路径，只有一条。\n   >\n   > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-133.png\" style=\"zoom:80%;\" />\n   >\n   > 其背后的含义是什么呢？\n   >\n   > 由于这个1是前一个矩阵的第一行对应相乘后一个矩阵的第四列得到的，我们分别看这四个加项的含义。\n   >\n   > 第一项（1*0）的含义是说：从A到A且长度为2的路径有1条；而从A到D长度为1的路径有0条。\n   >\n   > 所以我们没办法把这两条路径凑起来，拼成一个更长的路径。\n   >\n   > 第二项（0*1）同理。\n   >\n   > 第三项（1*1）的含义是说：从A到C且长度为2的路径有1条；从C到D且长度为1的路径有1条。\n   >\n   > 我们把这两条路径一拼接，就能得到从A到D，且是经过C的，长度为3的路径有1条。\n   >\n   > 第四项（0*0）同理。\n   >\n   > 最后，求和之后，就能得到，由A到D，长度为3的所有路径的数目。 \n\n#### 邻接矩阵法的性能分析\n\n1. 在简单应用中，可直接用二维数组作为图的邻接矩阵(顶点信息等均可省略)。\n\n2. 当邻接矩阵的元素仅表示相应边是否存在时，EdgeType可采用值为0和1的枚举类型。\n\n3. 无向图的邻接是对称矩阵，对规模特大的邻接矩阵可采用压缩存储(只存储上三角区/下三角区)。\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-25.png\" style=\"zoom:80%;\" />\n\n4. 邻接矩阵表示法的空间复杂度为<font color='orange'>O(n²)</font>,其中n为图的顶点数|V|。所以只和顶点数相关，和实际的边数无关\n\n5. 适用于存储稠密图\n\n邻接矩阵的**优点**：\n\n- 直观、简单、好理解\n- 方便检查任意一对顶点间是否存在边\n- 方便找任一顶点的所有\"邻接点\"(有边直接相连的顶点)\n- 方便计算任一顶点的\"度\"(从该点发出的边数为\"出度\",指向该点的边数为\"入度\")\n\n**缺点**：\n\n- 不便于删除和增加顶点\n- 浪费空间-存稀疏图(点很多而边很少)，有大量无效元素\n- 浪费时间-统计稀疏图中一共有多少条边\n\n### 邻接表法\n\n所谓邻接表，是指对图G中的每个顶点vi建立一个单链表，第i个单链表中的结点表示依附于顶点vi的边(对于有向图则是以顶点vi为尾的弧)，这个单链表就称为顶点vi的**边表**(d4对于有向图则称为**出边表**)。\n\n边表的头指针和顶点的数据信息采用顺序存储(称为**顶点表**)，所以在邻接表中存在两种结点:顶点表结点和边表结点\n\n#### 无向图的邻接表\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-27.png\" style=\"zoom: 67%;\" />\n\n顶点：按编号顺序将顶点数据存储在**一维数组中**。\n\n关联同一顶点的边(以顶点为尾的弧)：用线性**链表**存储\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-178.png\" style=\"zoom:67%;\" />\n\n例如，由A指向B有一条边，那么在A的*first域中，就有一个顶点号为1的结点（顶点号为1的就是B），下一个依次为2、3（即C、D顶点）。\n\n如果我们要存的是带权图，我们可以在存放边的类型中定义权值的信息。\n\n> 其实不难发现，这种邻接表法的实现，和我们之前讲的树的孩子表示法，是相同的一种实现方式。\n>\n> 各个结点顺序存储，然后再用一个链表来指明和这个结点相连的各个边。\n\n------\n\n无向图的邻接表特点：\n\n- 邻接表不唯一\n- 若无向图中有n个顶点、e条边，则其邻接表需n个头结点和2e个表结点。适宜存储稀疏图。\n- 无向图中顶点Vi的度为第 i 个单链表中的结点数。\n\n#### 有向图的邻接表\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-179.png\" style=\"zoom:67%;\" />\n\n原理是类似的。有一条弧是从A指向B，所以A的后面跟了顶点号为1的结点。\n\n> 实际上就是，对于有向图来说，它后面这个链域存储的信息，只是由这个顶点向外射的一些弧。\n>\n> 而对于无向图来说，是不分方向的一个个边。实际上，在无向图中，每一条边在邻接表中都会对应两个结点。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-180.png\" style=\"zoom: 38%;\" />\n>\n> 比如这个，0号结点（A）后存放了一个1号结点（B）；同时，1号结点（B）后面也存放了一个0号结点（A）。而这两个结点表示了同一条边。\n>\n> 实际上在无向图中，边的数据的存放实际是有冗余的。是实际边的数量的两倍。边结点的数量是2|E|，整体空间复杂度为O(|V|+2|E|)。\n\n> 而有向图，每一条弧，都只对应于一个边结点。所以边结点的数量为|E|。所以空间复杂度为O(|V|+|E|)。\n\n<font color='cornflowerblue'>接下来需要探讨的一个问题是</font>：\n\n- 如何求顶点的度、入度、出度？\n- 如何找到与一个顶点相连的边/弧。\n\n首先来看无向图，对于无向图我们只讨论度。如何确定一个顶点的度是多少？\n\n- 我们只需要遍历，和这个顶点相关的这个边链表就可以。有多少个边结点，它的度就是多少。同时，这些边结点就是与这个顶点相连的边。\n\n再来看有向图，有向图的度=入度+出度。\n\n- 如果要找到一个顶点的出度很简单，我们只需要遍历这个结点相关的边链表就可以。同时，它也反应了从这个顶点发射出去的弧有哪些。\n- 但是如果我们要找一个顶点的入度，或者是指向该顶点的弧有哪些，就有些麻烦了。\n  - 比如我们要统计A结点的入度，或者要找到指向A结点的弧。那唯一的办法就是，把所有的结点的边链表，都依次地遍历一遍。是很麻烦的，时间复杂度也会很高。这是邻接表法存储有向图的一个比较大的缺点。\n\n> 此外，由于在一个图中，各个边出现的先后顺序是任意的，因此图的邻接表表示方式并不是唯一的。（如A的边链表可以是1、2、3，也可以是3、2、1）\n>\n> 而上一小节中我们讲的邻接矩阵，只要确定了顶点编号，图的邻接矩阵表示方式就是唯一的。（这是选择题可能会考察的一个点）\n\n#### 图的邻接表存储结构定义\n\n```C\n#define MaxVertexNum 100 //图中顶点数目的最大值\ntypedef struct ArcNode{  //边表结点\n    int adjvex;          //该弧所指向的顶点的位置\n    struct ArcNode *next;//指向下一条弧的指针\n    //InfoType info;     //网的边权值\n}ArcNode;\ntypedef struct VNode{    //顶点表结点\n    VertexType data;     //顶点信息\n    ArcNode *first;      //指向第一条依附该顶点的弧的指针\n}VNode,AdjList[MaxVertexNum];\ntypedef struct {\n    AdjList vertices;    //邻接表\n    int vexnum,arcnum;   //图的顶点数和弧数\n} ALGraph;               //ALGraph是以邻接表存储的图类型\n```\n\n#### 邻接表的特点\n\n1. 若G是无向图，则所需的存储空间为<font color='orange'>O(|V|+2|E|)</font>;若G是有向图，则所需的存储空间为<font color='orange'>O(|V|+|E|)</font>。|E|是边的数量，前者的倍数2是由于无向图中，每条边在邻接表中出现了两次。\n2. 对于稀疏图，采用邻接表表示将极大地<font color='orange'>节省存储空间</font>。\n3. 在邻接表中，给定一顶点，能很容易地找出它的所有邻边，因为只需要读取它的邻接表。在邻接矩阵中，相同的操作则需要扫描一行，花费的时间为O(n)。但是，若要确定给定的两个顶点间是否存在边，则在邻接矩阵中可以立刻查到，而在邻接表中则需要在相应结点对应的边表中查找另一结点，效率低。\n4. 在有向图的邻接表表示中，求一个给定顶点的出度只需计算其邻接表中的结点个数；但求其顶点的入度则需要遍历全部的邻接表。因此，也有人采用逆邻接表的存储方式来加速求解给定顶点的入度。当然，这实际上与邻接表存储方式是类似的。\n5. 图的邻接表表示并不唯一，因为在每个顶点对应的单链表中，各边结点的链接次序可以是任意的，它取决于建立邻接表的算法及边的输入次序。\n\n#### 邻接表和邻接矩阵的关系\n\n联系：邻接表中每个链表对应于邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数。\n\n|                  | 邻接表                                     | 邻接矩阵             |\n| ---------------- | ------------------------------------------ | -------------------- |\n| 空间复杂度       | 无向图O(\\|V\\|+2\\|E\\|);有向图O(\\|V\\|+\\|E\\|) | O(\\|V\\|²)            |\n| 适合用于         | 存储稀疏图                                 | 存储稠密图           |\n| 表示方式         | 不唯一                                     | 唯一                 |\n| 计算度/出度/入度 | 计算有向图的度、入度不方便，其余很方便     | 必须遍历对应的行或列 |\n| 找相邻的边       | 找有向图的入边不方便，其余很方便           | 必须遍历对应行或列   |\n\n### 十字链表\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-31.png\" style=\"zoom: 67%;\" />\n\n邻接矩阵的缺点是空间复杂度太高；邻接表的缺点是当它存储有向图的时候，计算入度、找入边不方便。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-32.png\" style=\"zoom:67%;\" />\n\n十字链表是<font color='cornflowerblue'>有向图</font>的另一种链式存储结构。我们也可以把它看成是将有向图的邻接表和逆邻接表结合起来形成的一种链表。\n\n有向图中的每一条弧对应十字链表中的一个**弧结点**，同时有向图中的每个顶点在十字链表中对应有一个结点，叫做顶点结点。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-181.png\" style=\"zoom:55%;\" />\n\n> 例如顶点A。\n>\n> 若要找从A射出的弧，则找A顶点结点的“绿色”部分指针，找到0→1（即A→B），而在此个弧结点的“绿色”部分指针，存放着A发出的下一条弧0→2（即A→C），下一个绿色指针为空，意味着已经没有其他从A顶点出发的弧了。\n>\n> 若要找进入A的弧，则找A顶点结点的“橙色”部分指针，找到2→0（即C→A），继续找该弧结点的下一个“橙色”指针，找到下一个进入A的弧3→0（即D→A），下一个橙色指针为空，意味着已经没有其他指向A顶点的弧了。\n\n顶点结点中有一个数据域和两个指针域（分别用 firstin 和 firstout 表示）：\n\n- firstin 指针用于连接以当前顶点为弧头的其他顶点构成的链表；\n- firstout 指针用于连接以当前顶点为弧尾的其他顶点构成的链表；\n- data 用于存储该顶点中的数据；\n\n十字链表中弧节点的存储分为 5 部分内容，它们各自的作用是：\n\n- tailvex 用于存储以首元节点为弧尾的顶点位于数组中的位置下标；\n- headvex 用于存储以首元节点为弧头的顶点位于数组中的位置下标；\n- hlink 指针：用于链接下一个存储以首元节点为弧头的顶点的节点；\n- tlink 指针：用于链接下一个存储以首元节点为弧尾的顶点的节点；\n- info 指针：用于存储与该顶点相关的信息，例如量顶点之间的权值；\n\n**空间复杂度**:<font color='orange'>O(|V|+|E|)</font>（顶点的个数+边的个数）\n\n可以看到，空间复杂度和邻接表是一样优秀的，并不会像邻接矩阵那样有空间的冗余。\n\n此外，还可以很方便的找到所有的边，包括出边和入边。\n\n- 如何找到指定顶点的所有出边?--顺着绿色线路找\n\n\n- 如何找到指定顶点的所有入边?--顺着橙色线路找\n\n<font color='red'>注意:十字链表只用于存储有向图</font>\n\n十字链表的构建过程:\n\n```C\n#define  MAX_VERTEX_NUM 20\n#define  InfoType int//图中弧包含信息的数据类型\n#define  VertexType int\ntypedef struct ArcBox{\n    int tailvex,headvex;//弧尾、弧头对应顶点在数组中的位置下标\n    struct ArcBox *hlik,*tlink;//分别指向弧头相同和弧尾相同的下一个弧\n    InfoType *info;//存储弧相关信息的指针\n}ArcBox;\ntypedef struct VexNode{\n    VertexType data;//顶点的数据域\n    ArcBox *firstin,*firstout;//指向以该顶点为弧头和弧尾的链表首个结点\n}VexNode;\ntypedef struct {\n    VexNode xlist[MAX_VERTEX_NUM];//存储顶点的一维数组\n    int vexnum,arcnum;//记录图的顶点数和弧数\n}OLGraph;\nint LocateVex(OLGraph * G,VertexType v){\n    int i=0;\n    //遍历一维数组，找到变量v\n    for (; i<G->vexnum; i++) {\n        if (G->xlist[i].data==v) {\n            break;\n        }\n    }\n    //如果找不到，输出提示语句，返回 -1\n    if (i>G->vexnum) {\n        printf(\"no such vertex.\\n\");\n        return -1;\n    }\n    return i;\n}\n//构建十字链表函数\nvoid CreateDG(OLGraph *G){\n    //输入有向图的顶点数和弧数\n    scanf(\"%d,%d\",&(G->vexnum),&(G->arcnum));\n    //使用一维数组存储顶点数据，初始化指针域为NULL\n    for (int i=0; i<G->vexnum; i++) {\n        scanf(\"%d\",&(G->xlist[i].data));\n        G->xlist[i].firstin=NULL;\n        G->xlist[i].firstout=NULL;\n    }\n    //构建十字链表\n    for (int k=0;k<G->arcnum; k++) {\n        int v1,v2;\n        scanf(\"%d,%d\",&v1,&v2);\n        //确定v1、v2在数组中的位置下标\n        int i=LocateVex(G, v1);\n        int j=LocateVex(G, v2);\n        //建立弧的结点\n        ArcBox * p=(ArcBox*)malloc(sizeof(ArcBox));\n        p->tailvex=i;\n        p->headvex=j;\n        //采用头插法插入新的p结点\n        p->hlik=G->xlist[j].firstin;\n        p->tlink=G->xlist[i].firstout;\n        G->xlist[j].firstin=G->xlist[i].firstout=p;\n    }\n}\n```\n\n### 邻接多重表\n\n邻接多重表是<font color='cornflowerblue'>无向图</font>的另一种链式存储结构\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-182.png\" style=\"zoom: 35%;\" />\n\n怎么解决这些问题呢？我们可以用邻接多重表的方式来存储无向图\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-183.png\" style=\"zoom:70%;\" />\n\n> 例如，A结点，顺着它的指针域寻找，能够找到0—1（即A—B）这条边，之后继续顺着“橙色”（即iLink）指针继续寻找，则能够找到0—3（即A—D）这条边，接着继续顺着”橙色“指针，发现为空，则表示没有与A相连的边了。\n>\n> 对于B结点，顺着它的指针，找到0—1（即A—B）这条边，可见B结点在此处存放于右侧的编号域上（实际上在左边还是在右边是没区别的），于是我们便顺着“绿色”（即jLink）指针继续寻找，继续找到2—1（同样的，B也是在右边这个位置上的），4—1（B在右边），接着继续找“绿色”结点，为空，则到此为止找到所有和B相连的边的信息。\n\n可见，利用邻接多重表想要找到某顶点的所有边是很方便的。同时每个边只对应一份边结点的数据，因此，就不必像邻接表那样，同时维护两份冗余的数据，可以保证我们在删除一个结点或删除一条边的时候，操作会方便很多。\n\n> 比如，现在我们要删除A—B这条边。这条边对应的结点是0—1这个结点。那么我们想要把这个结点删掉，并且重新改变A结点、B结点的指针域，指向这个被删除结点的下一个结点即可。那么，A结点的指针域需要顺着被删除结点的“橙色”指针，指到下一个结点上去；B结点的指针域需要顺着被删除结点的“绿色”指针，指到下一个节点上去。\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-134.png\" style=\"zoom: 50%;\" />\n\n> 比如，要删除E这个顶点。\n>\n> 那么除了删除E这个顶点外，还需要删除与E相连的所有边。\n>\n> 通过与E相连的指针，可以找到，4—1和2—4两条边。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-135.png\" style=\"zoom: 33%;\" />\n>\n> 此时需要注意，将这两个边结点删除之后，会影响到另外两个指针的指向问题。即2—1中的“1”，和2—3中的“2”的下一结点指针指向。\n>\n> 不过，可以看到，对于2—1的“绿色”指针，它指向4—1后便停止了，没有再指向下一个结点。因此将4—1删除后，只需修改2—1的“绿色”指针为空即可。另一个受影响的结点同理。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-136.png\" style=\"zoom:50%;\" />\n\n**空间复杂度**:<font color='orange'>O(|V|+|E|)</font>\n\n顶点结点:\n\n- data：存储此顶点的数据；\n- firstedge：指针域，用于指向同该顶点有直接关联的存储其他顶点的节点。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-36.png\" style=\"zoom:80%;\" />\n\n边结点:\n\n- mark：标志域，用于标记此节点是否被操作过，例如在对图中顶点做遍历操作时，为了防止多次操作同一节点，mark 域为 0 表示还未被遍历；mark 为 1 表示该节点已被遍历；\n- ivex 和 jvex：数据域，分别存储图中各边两端的顶点所在数组中的位置下标；\n- ilink：指针域，指向下一个存储与 ivex 有直接关联顶点的节点；\n- jlink：指针域，指向下一个存储与 jvex 有直接关联顶点的节点；\n- info：指针域，用于存储与该顶点有关的其他信息，比如无向网中各边的权；\n\n<font color='red'>注意:邻接多重表只适用于存储无向图</font>\n\n邻接多重表的整体结构:\n\n```C\n#define MAX_VERTEX_NUM 20                   //图中顶点的最大个数\n#define InfoType int                        //边含有的信息域的数据类型\n#define VertexType int                      //图顶点的数据类型\ntypedef enum {unvisited,visited}VisitIf;    //边标志域\ntypedef struct EBox{\n    VisitIf mark;                           //标志域\n    int ivex,jvex;                          //边两边顶点在数组中的位置下标\n    struct EBox * ilink,*jlink;             //分别指向与ivex、jvex相关的下一个边\n    InfoType *info;                         //边包含的其它的信息域的指针\n}EBox;\ntypedef struct VexBox{\n    VertexType data;                        //顶点数据域\n    EBox * firstedge;                       //顶点相关的第一条边的指针域\n}VexBox;\ntypedef struct {\n    VexBox adjmulist[MAX_VERTEX_NUM];//存储图中顶点的数组\n    int vexnum,degenum;//记录途中顶点个数和边个数的变量\n}AMLGraph;\n```\n\n`总结`\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-184.png\" style=\"zoom:67%;\" />\n\n![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-185.png)\n\n对于十字链表和邻接多重表，其实现方式比较复杂。所以在考研当中不太可能让大家用手写的方式来实现十字链表和邻接多重表。因此这两种实现方式，只需要理解它们的一些特性就可以。\n\n- 十字链表用来存放有向图，可以解决在邻接矩阵中空间复杂度较高的问题，以及在邻接表中不方便查找入度、入边的问题。\n- 邻接多重表用来存放无向图，可以解决邻接矩阵中空间复杂度较高的问题，以及在邻接表中存放无向图需要存放两份冗余数据，导致删除边、删除顶点操作较复杂的问题。\n- 另外，对于一个给定的图，采用十字链表或是邻接多重表，表示方式都是不唯一的。\n\n### 图的基本操作\n\n- Adjacent(G, x, y)\n- Neighbors(G, x)\n- InsertVertex(G, x)\n- AddEdge(G, x, y)\n- RemoveEdge(G, x, y)\n- FirstNeighbor(G, x)\n- NextNeighbor(G, x, y)\n- Get_edge_value(G, x, y)\n- Set_edge_value(G, x, y, v)\n\n那么基本操作的实现，还是和图的存储结构密不可分的。\n\n我们说过，考研当中最常考的还是邻接矩阵和邻接表法。（因为十字链表和邻接多重表实现起来较为复杂，所以不太会考察代码的书写而只考察性质的理解）\n\n此外还有图的遍历算法见下一节\n\n### 习题\n\n- 4 带权有向图G用邻接矩阵存储，则vi的入度等于邻接矩阵中→D\n\n  A 第i行非∞的元素个数\n  B 第i列非∞的元素个数\n  C 第i行非∞且非0的元素个数\n  D 第i列非∞且非0的元素个数\n\n- 13 假设有n个顶点、e条边的有向图用邻接表表示，则删除与某个顶点v相关的所有边的时间复杂度为多少？答案→O(n+e)\n\n- 综合【2015】已知含有5个顶点的图G如下图所示。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-37.png\" style=\"zoom:50%;\" />\n\n  请回答下列问题： \n\n  1）写出图 G 的邻接矩阵 A（行、列下标从 0 开始）。 \n\n  2）求 A²，矩阵 A^2中位于 0 行 3 列元素值的含义是什么？ \n\n  3）若已知具有 n（n≥2）个顶点的图的邻接矩阵为B，则 B^m（2≤m≤n）中非零元素的含义是什么？\n\n  > 1)图G的邻接矩阵A如下:\n  > $$\n  > A=\\left[\n  > \\begin{matrix}\n  > 0 & 1 & 1 & 0 & 1\\\\\n  > 1 & 0 & 0 & 1 & 1\\\\\n  > 1 & 0 & 0 & 1 & 0\\\\\n  > 0 & 1 & 1 & 0 & 1\\\\\n  > 1 & 1 & 0 & 1 &0\n  > \\end{matrix}\n  > \\right] \n  > $$\n  > 2）A²如下:\n  > $$\n  > A^2=\\left[\n  > \\begin{matrix}\n  > 3 & 1 & 0 & 3 & 1\\\\\n  > 1 & 3 & 2 & 1 & 2\\\\\n  > 0 & 2 & 2 & 0 & 2\\\\\n  > 3 & 1 & 0 & 3 & 1\\\\\n  > 1 & 2 & 2 & 1 & 3\n  > \\end{matrix}\n  > \\right]\n  > $$\n  > 0行3列的元素值3表示从顶点0到顶点3之间长度为2的路径共有3条\n  >\n  > 3)B^m(2<=m<=n)中位于i行j列(0<=i,j<=n-1)的非零元素的含义是:图中从顶点i到顶点j长度为m的路径条数。\n\n- 【2021】已知无向连通图G由顶点集V和边集E组成，|E| >0,当G中度为奇数的顶点个数为不大于2的偶数时，G存在包含所有边且长度为|E|的路径（称为EL路径）。设图G采用邻接矩阵存储类型定义如下;\n\n  ```C\n  typedef struct{ //图的定义\n  int numVertices,numEdges;\n  //图中实际的顶点数和边数\n  char Vericeslist[MAXV];\n  //顶点表。MAXV为已定义常量\n  int Edge[MAXV][MAXV];\n  // 邻接矩阵\n  }MGraph;\n  ```\n\n  请设计算法∶int IsExistEL（MGraph G），判断 G是否存在 EL 路径，若存在，则返回1，否则，返回 0。要求：\n  （1）给出算法的基本设计思想。\n  （2）根据设计思想，，采用C或C++语言描述算法，关键之处给出注释。\n  （3）说明你所设计算法的时间复杂度和空间复杂度。\n\n  > （1）算法的基本设计思想\n  > 对于采用邻接矩阵存储的无向图，邻接矩阵每一行（列）中非零元素的个数为本行（列）对应顶点的度。可以依次计算连通图 G中各顶点的度，并记录度为奇数的顶点个数，若个数为0或2，则返回1，否则返回0。\n  >\n  > （2）算法实现\n  >\n  > ```C\n  > int IsExistEL(MGraph G){\n  > //采用邻接矩阵存储，判断图是否存在 EL路径\n  > int degree,i,j,count=0;\n  > for(i=0;i<G.numVertices;i++){\n  >     degree=0;\n  >     for(j=0;j<G.numVertices;j++)\n  >         degree+=G.Edge[i][j]; //依次计算各个顶点的度\n  >     if(degree%2! =0)\n  >         count++; //对度为奇数的顶点计数\n  > }\n  > if(count == 0 || count == 2)\n  >  return l; //存在 EL路径，返回1\n  > else\n  >  return 0; //不存在 EL路径，返回0\n  > }\n  > ```\n  >\n  > （3）时间复杂度是O（n²），空间复杂度是0（1）\n\n## 6.3 图的遍历\n\n### [深度优先和广度优先遍历](https://blog.csdn.net/wdy00000/article/details/123295871)(可先点开看)\n\n从已给的连通图中某一顶点出发，沿着一些边访遍图中的所有的顶点，且使每个顶点仅被访问依次，就叫做图的遍历，它是图的基本运算。\n\n图中可能存在回路，且图的任一顶点都可能与其他顶点相通，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。那么怎么样避免重复访问呢？\n\n解决思路：设置辅助数组 visited[n]，用来标记每个被访问过的顶点。\n\n- 初始状态 visited[i] 为0\n- 顶点i被访问，改visited[i]为1，防止被多次访问\n\n### 广度优先搜索 Breadth-First-Search, BFS\n\n广度优先搜索算法(Breadth First Search)，又称为\"宽度优先搜索\"或\"横向优先搜索\"，简称BFS\n\n方法如下：\n\n从图的某一顶点出发，首先依次访问该结点的所有邻接点Vi1，Vi2，Vi3…Vin ，再按这些顶点被访问的先后次序依次访问与它们想邻接的所有未被访问的顶点。重复此过程，直至所有顶点均被访问为止。\n\n换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2...的顶点。\n\n#### 无向图的广度优先搜索\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-38.png\" style=\"zoom: 50%;\" />\n\n**第1步**：访问A。\n\n**第2步**：依次访问C,D,F。\n  在访问了A之后，接下来访问A的邻接点。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，C在\"D和F\"的前面，因此，先访问C。再访问完C之后，再依次访问D,F。\n\n**第3步**：依次访问B,G。\n  在第2步访问完C,D,F之后，再依次访问它们的邻接点。首先访问C的邻接点B，再访问F的邻接点G。\n\n**第4步**：访问E。\n  在第3步访问完B,G之后，再依次访问它们的邻接点。只有G有邻接点E，因此访问G的邻接点E。\n\n因此访问顺序是：**A -> C -> D -> F -> B -> G -> E**\n\n------\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-186.png\" style=\"zoom:50%;\" />\n\n比如我们从2号结点出发，开始进行图的广度优先遍历。\n\n那同样地，首先我们找到2号结点。然后，找到与之相连的1、6号结点。\n\n再由1、6出发，找到与它们相连的5、3、7号结点。\n\n接着，再由5、3、7号结点，找到它们更下一层的结点，4、8。\n\n#### 有向图的广度优先搜索\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-39.png\" style=\"zoom: 50%;\" />\n\n**第1步**：访问A。\n\n**第2步**：访问B。\n\n**第3步**：依次访问C,E,F。\n  在访问了B之后，接下来访问B的出边的另一个顶点，即C,E,F。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，因此会先访问C，再依次访问E,F。\n\n**第4步**：依次访问D,G。\n  在访问完C,E,F之后，再依次访问它们的出边的另一个顶点。还是按照C,E,F的顺序访问，C的已经全部访问过了，那么就只剩下E,F；先访问E的邻接点D，再访问F的邻接点G。\n\n因此访问顺序是：**A -> B -> C -> E -> F -> D -> G**\n\n#### 非连通图的广度优先遍历\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-40.png\" style=\"zoom: 50%;\" />\n\n#### 树VS图\n\n[树的深度与广度优先]:https://blog.csdn.net/weixin_55953988/article/details/122538609\n\n图的广度优先遍历，这个过程其实和树的广度优先是很类似的。我们看看有什么联系和区别。\n\n首先，不论是树还是图的广度优先遍历，我们都需要实现这样一个操作，就是通过某一个结点，找到与之相邻的其它结点。因为只有实现了这个操作，我们才有可能一层一层的往下找到所有的结点。\n\n对于树来说，找到与之相邻的其他结点，其实就是找它的孩子结点。而对于图来说，我们可以利用之前学过的两个基本操作来完成这件事情。\n\n另外，对于树来说，是不存在“回路”的，搜索相邻的结点时，不可能搜到已经访问过的结点。而对于图来说，搜索相邻的结点时，有可能搜索到已经访问过的顶点，所以我们需要对这一问题进行处理，而处理起来也很简单， 我们只需要对每个结点进行一个标记来表示有没有被访问过就可以了。\n\n#### 算法实现\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-41.png\" style=\"zoom: 80%;\" />\n\n```C\nbool visited[MAX_VERTEX_NUM];//访问标记数组\nvoid BFS(Graph G,int v){ //从顶点v出发，广度优先遍历图G\n    visit(v);   //访问初始顶点v\n    visited[v]=TRUE;   //对v做已访问标记\n    Enqueue(Q,v);    //顶点v入队列Q\n    while(!isEmpty(Q)){\n        DeQueue(Q,v);  //顶点v出队列\n        for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w)) //检测v所有邻接点\n            if(!visited[w]){  //w为v的尚未访问的邻接顶点\n                visit(w);    //访问顶点w\n                visited[w]=TRUE;//对w做已访问标记\n                EnQueue(Q,w);  //顶点w入队列\n            }\n    }\n}\n```\n\n其中，对于`visited[]`数组，刚开始我们把它全部设为false，并且数组的下标和各个结点的编号是一一对应的。（此处为了与顶点编号对应，数组的0号下标弃置不用）\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-248.png\" style=\"zoom: 55%;\" />\n\n> 对于上图：\n>\n> 从顶点2出发得到的广度优先遍历序列：`2 1 6 5 3 7 4 8`\n>\n> 从顶点1出发得到的广度优先遍历序列：`1 2 5 6 3 7 4 8`\n>\n> 从顶点3出发得到的广度优先遍历序列：`3 4 6 7 8 2 1 5`\n\n**遍历序列的可变性**\n\n每一“层”的顶点，应该按照什么样的一个顺序？\n\n实际上，这要看是按照什么存储结构来存储的。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-249.png\" style=\"zoom:55%;\" />\n\n- 如果是用邻接表存储的，由于每个顶点后面的链表中，结点的顺序是不确定的，所以顺序不确定。这个遍历序列是可变的，是不唯一的。\n  - 即：同一个图的**邻接矩阵**表示方式**唯一**，因此广度优先**遍历序列唯一**。\n- 如果是用邻接矩阵存储的，由于遍历某顶点的所有边，是按照该结点在矩阵中对应行的一个从左向右的遍历，所以遍历出来的序列应该是按照由小到大的一个递增的顺序。（一定是这样的）这个遍历序列是唯一的。\n  - 即：同一个图的**邻接表**表示方式**不唯一**，因此广度优先**遍历序列不唯一**。\n\n**算法存在的问题**\n\n至此，我们发现一个问题。\n\n刚刚对于图的广度优先遍历，无论是从哪个顶点出发，都是能够遍历到图中所有顶点的。\n\n这是因为它是一个连通图。如果是非连通图，则无法遍历完所有结点。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-250.png\" style=\"zoom:55%;\" />\n\n对于一个非连通图来说，通过刚才的代码。例如从2号结点出发，就没有办法访问到9、10、11三个结点。\n\n**怎么解决？**\n\n我们不是定义了一个`visited[]`数组吗，这个数组记录了所有顶点是否已经被访问的信息。那么当我们在第一次调用BFS这个函数遍历完毕之后，可以检查一下在visited数组当中能否找到值为false的顶点，如果能找到，那么从这个顶点出发，再次调用BFS这个函数，就可以了。\n\n#### BFS算法(Final版)\n\n```C\nbool visited[MAX_VERTEX_NUM];//访问标记数组\nvoid BFSTraverse(Graph G){ //对图G进行广度优先遍历\n    for(i=0;i<G.vexnum;++i)\n        visited[i]=FALSE;   //访问标记数组初始化\n    InitQueue(Q);           //初始化辅助队列Q\n    for(i=0;i<G.vexnum;++i) //从0号顶点开始遍历\n        if(!visited[i])     //对每个连通分量调用一次BFS\n            BFS(G,i);       //vi未访问过，从vi开始BFS\n}\nvoid BFS(Graph G,int v){ //从顶点v出发，广度优先遍历图G\n    visit(v);   //访问初始顶点v\n    visited[v]=TRUE;   //对v做已访问标记\n    Enqueue(Q,v);    //顶点v入队列Q\n    while(!isEmpty(Q)){\n        DeQueue(Q,v);  //顶点v出队列\n        for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w)) \n            //检测v所有邻接点\n            if(!visited[w]){  //w为v的尚未访问的邻接顶点\n                visit(w);    //访问顶点w\n                visited[w]=TRUE;//对w做已访问标记\n                EnQueue(Q,w);  //顶点w入队列\n            }\n    }\n}\n```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-251.png\" style=\"zoom:55%;\" />\n\n到此，我们就可以遍历完非连通图里的所有结点。此外，对于**无向图**，**调用BFS函数的次数 = 连通分量数**。\n\n#### 复杂度分析\n\n对于空间复杂度来说，其关键是要看辅助队列所需要的空间大小。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-46.png\" style=\"zoom:67%;\" />\n\n再看时间复杂度。在这个BFS算法中，我们首先要visit(v)这个顶点，其次对于每个顶点，我们还需要探索其所有的边。所以我们可以简要的认为，它的时间开销主要用于，探索每个顶点，和探索每条边。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-252.png\" style=\"zoom:55%;\" />\n\n> 可以看出，这个算法的时间复杂度的分析，并不是单纯地看最深层循环的次数。\n>\n> 而是看关键代码的次数。这个算法的关键代码在于visit(v)，和深层for循环，两者兼具（访问顶点+找各条边）。\n>\n> 这是由问题的实际过程考虑得出的，而不要一味地只顾最深层循环。\n\n#### 广度优先生成树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-137.png\" style=\"zoom: 33%;\" />\n\n标红的这些边，表示这个结点在被访问的时候，是由哪条边过去的。例如4号结点，在被访问到的时候，是由3号结点过去的，而不是由7或8过去的。\n\n对于这个n个结点的图来说，我们总共标红了n-1条边。如果把其余的那些边去掉，那么这个图其实就变成了树，因为它里面已经没有回路存在了。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-138.png\" style=\"zoom: 33%;\" />\n\n那么这就是这个图的广度优先生成树。\n\n这个生成树是由广度优先遍历，遍历的顺序得来的。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-139.png\" style=\"zoom:67%;\" />\n\n> 注意其中遍历序列的顺序。例如，由6得来的结点，有3、7，但是要注意在这个实际存储当中，是3在前、7在后的。\n>\n> 而，如果按照下面的存储，那么生成树中的次序也会随之改变，如下。\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-140.png\" style=\"zoom: 67%;\" />\n\n可以看到，两棵广度优先生成树，是有区别的。\n\n广度优先生成树由广度优先遍历过程确定。由于邻接表的表示方式不唯一，因此基于邻接表的广度优先生成树也不唯一。\n\n但是如果一个图是用邻接矩阵来存储的，那么它的广度优先生成树肯定也是唯一的了\n\n可以看看下面的视频：\n\n[暨大830数据结构每周一讲-广度优先生成树](https://www.bilibili.com/video/BV1sS4y1p7v2?spm_id_from=333.337.search-card.all.click&vd_source=278af11bcc7fe34571197ce600d488f4)\n\n#### 广度优先生成森林\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-187.png\" style=\"zoom:43%;\" />\n\n对非连通图的广度优先遍历，可以得到广度优先生成森林。很好理解，对于其中的每一个连通分量，都能得到一个广度优先生成树。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-188.png\" style=\"zoom:43%;\" />\n\n这两棵树放在一起，就可以组成一个广度优先生成森林。\n\n### 深度优先搜索 Depth-First-Search, DFS\n\n它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。\n\n方法如下：\n\n- 在访问图中某一起始顶点 v 后，由 v 出发，访问它的任一邻接顶点W1\n- 再从 W1 出发，访问与 W1 邻接但还未被访问过的顶点W2\n- 然后再从 W2 出发，进行类似的访问\n- 如此进行下去，直至到达所有的邻接顶点都被访问过的顶点u为止\n- 接着，退回一步，退到前一次刚访问过的顶点，看是否还有其他没有被访问的邻接顶点\n- 如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问\n- 如果没有，那就再退回一步进行搜索。重复上述过程，直到连通图中的所有顶点都被访问过为止。\n\n#### 无向图的深度优先搜索\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-48.png\" style=\"zoom:67%;\" />\n\n**第1步**：访问A。\n\n**第2步**：访问(A的邻接点)C。\n  在第1步访问A之后，接下来应该访问的是A的邻接点，即\"C,D,F\"中的一个。但在本文的实现中，顶点ABCDEFG是按照顺序存储，C在\"D和F\"的前面，因此，先访问C。\n\n**第3步**：访问(C的邻接点)B。\n  在第2步访问C之后，接下来应该访问C的邻接点，即\"B和D\"中一个(A已经被访问过，就不算在内)。而由于B在D之前，先访问B。\n\n**第4步**：访问(C的邻接点)D。\n  在第3步访问了C的邻接点B之后，B没有未被访问的邻接点；因此，返回到访问C的另一个邻接点D。\n\n**第5步**：访问(A的邻接点)F。\n  前面已经访问了A，并且访问完了\"A的邻接点B的所有邻接点(包括递归的邻接点在内)\"；因此，此时返回到访问A的另一个邻接点F。\n\n**第6步**：访问(F的邻接点)G。\n\n**第7步**：访问(G的邻接点)E。\n\n因此访问顺序是：**A -> C -> B -> D -> F -> G -> E**\n\n#### 有向图的深度优先搜索\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-49.png\" style=\"zoom:67%;\" />\n\n**第1步**：访问A。\n\n**第2步**：访问B。\n  在访问了A之后，接下来应该访问的是A的出边的另一个顶点，即顶点B。\n\n**第3步**：访问C。\n  在访问了B之后，接下来应该访问的是B的出边的另一个顶点，即顶点C,E,F。在本文实现的图中，顶点ABCDEFG按照顺序存储，因此先访问C。\n\n**第4步**：访问E。\n  接下来访问C的出边的另一个顶点，即顶点E。\n\n**第5步**：访问D。\n  接下来访问E的出边的另一个顶点，即顶点B,D。顶点B已经被访问过，因此访问顶点D。\n\n**第6步**：访问F。\n  接下应该回溯\"访问A的出边的另一个顶点F\"。\n\n**第7步**：访问G。\n\n因此访问顺序是：**A -> B -> C -> E -> D -> F -> G**\n\n#### 算法实现\n\n```C\nbool visited[MAX_VERTEX_NUM];\t//访问标记数组（初始都为false）\nvoid DFS(Graph G, int v) {\t//从顶点v出发，深度优先遍历图G\n    visit(v);\t//访问顶点v\n    visited[v] = TRUE;\t//设已访问标记\n    for(w = FirstNeighbor(G,v); w>=0; w = NextNeighbor(G,v,w)) {\n        if(!visited[w]){\t//w为v的尚未访问的邻接顶点\n            DFS(G,w);\n        }//if\n    }//for\n}\n```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-141.png\" style=\"zoom: 50%;\" />\n\n> 如果由2号顶点出发。\n>\n> 2号顶点有子树1，则访问1号，1号还有子树5，则继续访问5号。\n>\n> 5号执行结束没有子树，则返回到1号结点，1号没有其他子树，则返回到2号顶点。\n>\n> 找到2号顶点的下一个邻接点，即6号顶点。\n>\n> 和6号相邻的，访问3号结点，接着访问4号顶点，接着访问7号结点，接着访问8号顶点。\n>\n> 8号执行完后，由于与之相邻的所有顶点都已经被访问过，因此可以结束执行，向上返回，一路返回到最上层。最终整个函数执行完毕。\n>\n> 从2出发的深度遍历序列：2 1 5 6 3 4 7 8。\n\n**算法存在的问题**\n\n这段代码也存在类似的问题，就是，如果是非连通图，则无法遍历完所有结点\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-50.png\" style=\"zoom:80%;\" />\n\n处理的方法类似。\n\n我们在进行了一次DFS后，还可以扫描一次visited[]数组，如果在这个数组中发现了有某一个元素，它依然是false，那么就说明与之相对应的顶点是没有被访问过的，那么我们再从这个顶点出发再调用一次DFS函数就可以了。\n\n#### DFS算法(Final版)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-51.png\" style=\"zoom:80%;\" />\n\n```C\nbool visited[MAX_VERTEX_NUM];\t//访问标记数组\nvoid DFSTraverse(Graph G) {\t\t//对图G进行深度优先遍历\n    for(v=0; v<G.vexnum; ++v) {\n        visited[v] = FALSE;\t\t//初始化已访问标记数据\n    }\n    for(v=0; v<G.vexnum; ++v) {\t//本代码中是从v=0开始遍历（也可以从1开始）\n        if(!visited[v]) {\n            DFS(G, v);\n        }\n    }\n}\n\nvoid DFS(Graph G, int v) {\t//从顶点v出发，深度优先遍历图G\n    visit(v);\t//访问顶点v\n    visited[v] = TRUE;\t//设已访问标记\n    for(w=FirstNeighbor(G,v); w>=0; w=NextNeighbor(G,v,w)) {\n        if(!visited[w]) {\t//w为v的尚未访问的邻接顶点\n            DFS(G,w);\n        }//if\n    }//for\n}\n```\n\n#### 复杂度分析\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-52.png\" style=\"zoom:67%;\" />\n\n**最坏情况，递归深度为O(|V|)**。即，从1号顶点出发进行深度优先遍历，一直遍历到8号，才能发现其没有继续的子树，才能结束DFS并依次返回。那么此时函数调用栈中存放了8层递归。\n\n**最好情况，O(1)**。找到一个子树就结束DFS并返回上级。那么我们的递归调用栈只会有2层。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-53.png\" style=\"zoom:80%;\" />\n\n广度优先和深度优先，都可以把代码的时间开销简化为访问各结点+探索各条边的时间开销。\n\n无论是广度优先还是深度优先，其时间复杂度都是分为邻接矩阵和邻接表两种存储方式讨论的。\n\n### 图的遍历与图的连通性\n\n图的遍历算法可以用来判断图的连通性。\n\n对于无向图来说，如果无向图是连通的，则从任一结点出发，仅需一次遍历就能够访问图中所有顶点；\n\n如果无向图是非连通的，则从某一个顶点出发，一次遍历只能访问到该顶点所在连通分量的所有顶点，而对于图中其他连通分量的顶点无法通过这次遍历访问。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-255.png\" style=\"zoom:67%;\" />\n\n对于有向图来说，若从初始点到图中的每个顶点都有路径，则能够访问图中的所有顶点，否则不能访问到所有顶点。\n\n故而在BFSTraverse()和DFSTraverse()中添加了第二个for循环，再选取初始点，继续进行遍历，以防止一次无法遍历图中所有顶点。\n\n对于无向图，上述两个函数调用BFS(G,i)或DFS(G,i)的次数等于图中的连通分量树；\n\n而对于有向图，则不是这样没因为一个连通的有向图分为强连通的和非强连通的，它的连通子图也分为强连通分量和非强连通分量，非强连通分量一次调用BFS(G,i)或DFS(G,i)无法访问到该连通分量的所有顶点。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-256.png\" style=\"zoom:67%;\" />\n\nhttps://zhuanlan.zhihu.com/p/37792015\n\n### 习题\n\n- 【2013】若对如下无向图进行遍历，则下列选项中，不是广度优先遍历序列的是-->D\n\n  A.h，c，a，b，d，e，g，f    B.e，a，f，g，b，h，c，d\n\n  C.d，b，c，a，h，e，f，g    D.a，b，c，d，h，e，f，g\n\n  ![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-54.png)\n\n  > 图的广度优先遍历，类似树的层序遍历，需要借助辅助队列实现。 以A答案为例，从结点h开始访问，h先入队。此时队列非空，h出队，然后依次访问与h邻接但未被访问过的c，a结点，c,a结点入队。此时队列非空，取出队头元素c，依次访问与c邻接但未被访问过的结点b,d，b,d结点入队(现在队列中有abd)。队列非空，取出队头元素a，依次访问与a结点邻接但未访问过的e结点，e入队。后面的操作类似，在整个执行过程中，结点被访问的次序是hcabdegf。D是深度优先遍历\n\n- 【2015】设有向图 G=(V, E)，顶点集 V={V0, V1, V2, V3}，边集E={<v0,v1>, <v0,v2>, <v0,v3>, <v1,v3>}。若从顶点 V0 开始对图进行深度优先遍历，则可能得到的不同遍历序列个数是 -->5\n\n  > 画出该有向图图形如下：\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-55.png\" style=\"zoom:80%;\" />\n  >\n  > 采用图的深度优先遍历，共5种可能<v0, v1, v3, v2>，<v0, v2, v3, v1>，<v0, v2, v1, v3>，<v0, v3, v2, v1>，<v0, v3, v1, v2>\n\n- 【2016】下列选项中，不是下图深度优先搜索序列的是-->D\n\n  ![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-56.png)\n\n  　　A.V1，V5，V4，V3，V2 B.V1，V3，V2，V5，V4\n\n  　　C.V1，V2，V5，V4，V3 D.V1，V2，V3，V4，V5\n\n  > 对于本题，只需按深度优先遍历的策略进行遍历即可。对于选项A：先访问V1，然后访问与V1邻接且未被访问的任一顶点（满足的有V2、V3和V5），此时访问V5，然后从V5出发，访问与V5邻接且未被访问的任一顶点（满足的只有V4），然后从V4出发，访问与V4邻接且未被访问的任一顶点（满足的只有V3），然后从V3出发，访问与V3邻接且未被访问的任一顶点（满足的只有V2），结束遍历。选项B和C的分析方法与选项A相同，不再赘述。对于选项D，首先访问V1，然后从V1出发，访问与V1邻接且未被访问的任一顶点（满足的有V2、V3和V5），然后从V2出发，访问与V2邻接且未被访问的任一顶点（满足的只有V5），按规则本应该访问V5，但选项D却访问V3，D错误。\n","tags":["408数据结构"],"categories":["408数据结构"]},{"title":"第五章 树与二叉树(下)","url":"/p/56280/","content":"\n## 5.4 树、森林 Tree Forest\n\n### 树的存储结构\n\n#### 树的逻辑结构回顾\n\n树是 n(n≥0)个结点的有限集合，n=0时，称为空树，这是一种特殊情况。在任意一棵**非空树**中应满足：\n\n1. 有且仅有一个特定的称为根的结点\n2. 当 n>1 时，其余结点可分为 m(m>0) 个互不相交的有限集合 T1、T2、T3、…Tm ,其中每个集合本身又是一棵树，并且称为树结点的子树。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-222.png\" style=\"zoom:55%;\" />\n\n#### 双亲表示法(顺序存储)\n\n双亲表示法：每个结点中保存指向双亲的指针。\n\n因为在一棵树中，除了根结点外，每个结点都有且仅有一个它的父节点。\n\n所以，利用这一特性，我们在保存每个结点本身的数据之外，再保存一个指向它双亲的指针。\n\n> 即使用顺序存储，每个数据元素存放了数据data、双亲索引parent。\n>\n> 根结点固定存储在0号位置，parent = -1表示没有双亲。\n>\n> 当然，这个“指针”实际上是个int型变量。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-223.png\" style=\"zoom:55%;\" />\n\n该存储结构利用了每个结点(根结点除外)只有唯一双亲的性质，可以很快得到每个结点的双亲结点，但求结点的孩子时需要遍历整个结构。\n\n若要<font color='red'>增加</font>一个结点，只需要在数组的空闲位置写入一个结点即可，写入其数据值，并绑定其与双亲的关系即可。而结点在数组中存放的先后顺序是无所谓的，没必要按照树中层次的先后顺序来存储。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-224.png\" style=\"zoom: 55%;\" />\n\n若我们要<font color='red'>删除</font>G这个结点，有两种删除方法。方案一，把该结点的指针域置为-1，让此位置无效。方案二：将数组中最后一个结点置于此节点上将之覆盖，方案二可以保证每个位置都是有效的存储位置。最后再将树的结点数n减一即可。（方案二是较好的，见下方查找操作中的描述可知）\n\n<font color='cornflowerblue'>思考一个问题，若删除的结点不是一个叶子结点，而是某一个分支结点，该怎么进行删除操作呢？</font>\n\n那此时就不能只删除这个结点在数组中存放的位置了，因为如果这样删除，就意味着以这个结点为根的整棵子树都被删除了。我们还要将这个结点的孩子结点找到，并且用一定的办法保留在原树中。\n\n那么此时就涉及到树的**查找**操作了。\n\n在这种存储结构中，给定一个结点，对于查找它的双亲节点是很简单的，只需访问其parent指针即可（**优点**）。但如果要找到它的孩子，我们就只能从头到尾依次遍历，然后匹配出它的所有孩子结点（**缺点**）。（此处也暴露出删除一个结点操作中，方案一的缺点，会导致遍历操作的时候访问很多无效的结点，导致遍历的速度更慢）\n\n<font color='orange'>注意:区别树的顺序存储结构与二叉树的顺序存储结构。在树的顺序存储结构中，数组下标代表结点的编号，下标中所存的内容指示了结点之间的关系。而在二叉树的顺序存储结构中，数组下标既代表了结点的编号，又指示了二叉树中各结点之间的关系。当然，二叉树属于树，因此二叉树都可以用树的存储结构来存储，但树却不能用二叉树的存储结构来存储。</font>\n\n#### 孩子表示法(顺序+链式存储)\n\n孩子表示法：顺序存储各个结点，每个结点中保存孩子链表头指针。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-164.png\" style=\"zoom: 33%;\" />\n\n```C\nstruct CTNode {\n\tint child;\t//孩子结点在数组中的位置\n\tstruct CTNode *next;\t//下一个孩子 \n};\n\ntypedef struct {\n\tElemType data;\n\tstruct CTNode *firstChild;\t//第一个孩子 \n}CTBox;\n\ntypedef struct {\n\tCTBox nodes[MAX_TREE_SIZE];\n\tint n, r;\t//结点数和根的位置 \n}CTree;\n```\n\n思考这种存储方式，在进行增/删/查时的操作。以及其优缺点。此处不再展开。\n\n#### 孩子兄弟表示法(链式存储)🔥\n\n<font color='cornflowerblue'>这是最重要的一种表示法。就是用纯链式存储的方式来表示一棵树。</font>\n\n从存储的角度来看，这就是个二叉链表（每个结点有两个指针）。其实和二叉树的存储是相似的，只是变量的含义、命名有所区别。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-225.png\" style=\"zoom:55%;\" />\n\n- 左指针指向第一个孩子结点，右指针指向兄弟结点\n- A 是根节点，A的第一个孩子是B，所以A左连接B，B的兄弟结点是C，所以让B右连接C，D是C的兄弟结点，所以让C右连接D\n- B的第一个孩子是E，所以让B左连接E，E的兄弟结点是F，所以让E右连接F\n- E的第一个孩子是K，所以让E左连接K\n- C的第一个孩子是G，所以让C左连接G\n- D的第一个孩子是H，所以让D左连接H，I、J都是是H的兄弟结点，所以让H右连接I、J\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-214.png\" style=\"zoom:55%;\" />\n\n- A是根节点，左边的B是第一个孩子，B的右边C、F、L都是B的兄弟\n- D连在B的左边，所以D是B的第一个孩子，H是D的兄弟\n- G连在D的左边，所以G是D的孩子\n- E连在C的左边，所以E是C的第一个孩子，I连在E的左边，所以I是E的第一个孩子，J连在E的右边，所以J是E的兄弟\n\n### 树、森林与二叉树的转换\n\n#### 树和二叉树的转换\n\n- 将树转化为二叉树进行处理，利用二叉树的算法来实现对树的操作\n- 由于树和二叉树都可以用二叉链表作存储结构，则以二叉链表作媒介可以导出树与二叉树之间的一个对应关系。\n\n`树转化为二叉树`\n\n每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟，这个规则称\"**左孩子右兄弟**\"。由于根结点没兄弟。所以对应的二叉树没有右子树。\n\n**画法**:\n\n1. 加线：在兄弟之间加一条线\n2. 抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系\n3. 旋转：以树的根节点为轴心，将整树顺时针转45°\n\n<font color='orange'>树变二叉树：兄弟相连留长子</font>\n\n**看个例子**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-142.png\" style=\"zoom:67%;\" />\n\n`二叉树转化为树`\n\n**画法**:\n\n1. 加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子…沿分支找到所有右孩子，都与p的双亲用线连起来\n2. 抹线：抹掉原二叉树中双亲与右孩子之间的连线\n3. 调整：将结点按层序排列，形成树结构\n\n<font color='orange'>二叉树变树：左孩右右连双亲，去掉原来右孩线</font>\n\n**看个例子**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-143.png\" style=\"zoom:67%;\" />\n\n#### 森林和二叉树的转换\n\n`森林转化为二叉树`\n\n先将森林中的每棵树转换为二叉树，由于任何一棵和树对应的二叉树的右子树必空，若把森林中的第二棵树根视为第一棵树根的右兄弟，即将第二棵树对应的二叉树当作第一棵二叉树根的右子树，将第三棵树对应的二叉树当作第二棵二叉树根的右子树...以此类推\n\n**画法**:\n\n1. 将各棵树分别转换成二叉树\n2. 将每棵树的根结点用线相连\n3. 以第一课树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构\n\n<font color='orange'>森林变二叉树，树变二叉根相连</font>\n\n**看个例子**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-226.png\" style=\"zoom:55%;\" />\n\n- B、C、D 是兄弟结点，各个树的根节点视为兄弟关系，所以将C、D右连接B\n- E是B的第一个孩子，所以将E左连接B，F是E的兄弟结点，所以将F右连接E\n- K是E的第一个孩子，所以将K左连接E，L是K的兄弟结点，所以将L右连接L\n\n**再看一个例子**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-144.png\" style=\"zoom:67%;\" />\n\n`二叉树转化为森林`\n\n若二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形式，故将根的右链断开。二叉树根的右子树又可视为一个由除第一棵树外的森林转换后的二叉树，应用同样的方法，直到最后只剩一棵没有右子树的二叉树为止，最后再将每棵二叉树依次转换成树，就得到了原森林。 \n\n**画法**:\n\n1. 抹线：将二叉树中**根节点**与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树\n2. 还原：将孤立的二叉树还原成树\n\n<font color='orange'>去掉全部右孩线，孤立二叉再还原</font>\n\n**看个例子**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-227.png\" style=\"zoom:55%;\" />\n\n- A、C、F、L是兄弟结点，分别为二叉树的跟结点\n- A的左边连接了B，所以B是A的第一个孩子，B的左边连接了D，所以D是B的第一个孩子，D的左边连接了G，所以G是D的第一个孩子，D的右边连接了H，所以D和H是兄弟结点\n- C的左边连接了E，所以E是C的第一个孩子，E的左边连接了I，所以I是E的第一个孩子，E的右边连接了J，所以E和J是兄弟结点。\n- F的左边连了K，所以K是F的第一个孩子\n\n**再看个例子**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-146.png\" style=\"zoom:67%;\" />\n\n<font color='red'>二叉树转换为树或森林是唯一的</font>\n\n`小结`\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-228.png\" style=\"zoom:60%;\" />\n\n### 树和森林的遍历\n\n#### 树的先根遍历\n\n先根遍历：若树非空，先访问根节点，再依次对每棵子树进行先根遍历。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-200.png\" style=\"zoom: 42%;\" />\n\n```C\n// 树的先根遍历\nvoid PreOrder(TreeNode *R){\n    if(R!=NULL){\n        visit(R); // 访问根结点\n        while(R还有下一个子树T){\n            PreOrder(T);\t\t\t// 先根遍历下一棵子树\n        }\n    }\n}\n```\n\n把这棵树转化为与之对应的二叉树后，会发现，对**树的先根遍历序列**，和与之对应的**二叉树的先序遍历序列**相同。\n\n#### 树的后根遍历\n\n后根遍历：若树非空，先依次对每棵子树进行后根遍历，最后再访问根结点。\n\n树的后根遍历也叫做深度优先遍历。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-201.png\" style=\"zoom:42%;\" />\n\n**树的后根遍历与这棵树对应的二叉树的中序遍历序列相同**。\n\n#### 树的层次遍历\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-202.png\" style=\"zoom:42%;\" />\n\n不难发现，对于层次遍历来说，我们在探索这些结点的时候，是尽可能的横向在探索，也就是探索的范围尽可能的广，所以对**树的层次遍历**也叫**广度优先遍历**。\n\n那么与之相对的，树的**先根遍历**和**后根遍历**，我们在探索结点的时候，是尽可能的往深处探索，所以**后根遍历和先根遍历也叫深度优先遍历**。\n\n#### 森林的先序遍历\n\n先序遍历森林：\n\n- 若森林为空，则按如下规则进行遍历\n- 访问森林中第一棵树的根结点，先序遍历第一棵树中根结点的子树森林，先序遍历除去第一棵树之后剩余的树构成的森林。(效果等同于依次对各个树进行先根遍历)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-203.png\" style=\"zoom:42%;\" />\n\n- 或者将其转化为对应的二叉树，先序遍历森林效果等同于依次对二叉树的先序遍历\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-204.png\" style=\"zoom:42%;\" />\n\n#### 森林的中序遍历\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-205.png\" style=\"zoom:42%;\" />\n\n另一种方法就是将其转换成与之对应的二叉树，中序遍历森林效果等同于依次对二叉树的中序遍历\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-206.png\" style=\"zoom:42%;\" />\n\n#### 总结\n\n| 树       | 森林     | 二叉树   |\n| -------- | -------- | -------- |\n| 先根遍历 | 先序遍历 | 先序遍历 |\n| 后根遍历 | 中序遍历 | 中序遍历 |\n\n> 考试中，一般只涉及到森林的先序、中序遍历序列的求解，此时，我们将其转化为对各个树的先根、后根遍历即可很快得出其序列。\n>\n> 但是万一考察到了对森林的代码题、算法题，那么也不要慌张，将森林转化为与之对应的二叉树，然后对二叉树进行相关代码、算法的书写即可。对于二叉树的代码我们应该是很熟悉的。\n\n### 习题\n\n- 利用二叉链表存储森林时，根结点的右指针是\n\n  A 指向最左兄弟\n  B 指向最右兄弟\n  C 一定为空\n  D 不一定为空 →D\n\n- 【2009】将森林转换为对应的二叉树，若在二叉树中，结点 u 是结点 v 的父结点的父结点，则在原来的森林中，u 和 v 可能具有的关系是→①②\n  ① 父子关系\n  ② 兄弟关系\n  ③ u 的父结点与 v 的父结点是兄弟关系\n\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-101.png\" style=\"zoom: 33%;\" />\n  >\n  > 第三个说的是在森林当中u的父节点和v的父节点是兄弟关系，而不是说在二叉树中u的父节点和v的父节点是森林关系\n\n- 【2011】已知一棵有2011个结点的树，其叶结点个数为116，该树对应的二叉树中无右孩子的结点个数-->1896\n\n  > 树——>二叉树，大孩子变左孩子，兄弟变右孩子\n  > 因此对应的二叉树没有右孩子，说明该节点在树里右边没有兄弟，也就是说，该节点是其父节点最右边的孩子。有多少个有孩子的节点，就有多少个“最右的孩子节点”，因此2011-116=1895\n  > 此外，对于根节点而言，它没有父节点当然也没有兄弟，因此也是没有右孩子的。所以+1=1896\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-177.png\" style=\"zoom:30%;\" />\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-178.png\" style=\"zoom:30%;\" />\n\n- 【2014】将森林 F 转换为对应的二叉树 T，F 中叶结点的个数等于→C\n\n  A T 中叶结点的个数\n  B T 中度为 1 的结点的个数\n  C T 中左孩子指针为空的结点个数\n  D T 中右孩子指针为空的结点个数 \n\n  > 在森林转换为二叉树时候。 \n  >\n  > 左指针指向该节点的孩子， 有指针指向该节点的兄弟节点。 \n  >\n  > 如果该节点左指针为NULL,那么说明在原来森林中， 该节点也没有孩子——是叶子节点。 \n  >\n  > 如果该节点右指针为NULL， 那么说明咋原来森林中， 该节点没有右边的兄弟节点。 \n  >\n  > 因此， 森林中叶子节点等于二叉树中左指针为NULL的个数。  选C\n\n- 【2016】若森林F有15条边、25个结点，则F包含树的个数是-->10\n\n  > 森林不一定是二叉树，三叉。。有多个孩子节点。\n  >\n  > 当一棵树时，假设5个结点，得到4条边，形成一棵树。5-4=1； \n  >\n  > 形成两棵树的情况下，浪费一个结点，得到3条边，形成两棵树。5-3=2； \n  >\n  > 因此递推出关系：一棵树的边数为15，有25个结点，形成25-15=10棵。\n\n- 【2019】若将一棵树T转化为对应的二叉树BT，则下列对BT的遍历中，其遍历序列与T的后根遍历序列相同的是-->B\n\n  A. 先序遍历   B. 中序遍历\n\n  C. 后序遍历   D. 按层遍历\n\n  > 后根遍历树可分为两步：① 从左到右访问双亲结点的每个孩子（转化为二叉树后就是先访问根结点再访问右子树）；② 访问完所有孩子后再访问它们的双亲结点（转化为二叉树后就是先访问左子树再访问根结点）因此树T的后根序列与其相应的二叉树BT的中序遍历序列相同。\n\n- 【2020】已知森林 F 及与之对应的二叉树 T，若 F 的先根遍历序列是 a, b, c, d, e, f，中根遍历序列是 b, a, d, f, e, c，则 T 的后根遍历序列是？→ b, f, e, d, c, a \n\n  > 由先根遍历序列a,b,c,d,e,f和中根遍历序列b,a,d,f,e,c可知，a为T的根，{b}为a的左子树结点，{dfec}为a的右子树结点。由先根遍历序列c,d,e,f和中根遍历序列d,f,e,c可知a的右子树为c，c的左子树中的结点有{d,e,f}，右子树为空。由先根遍历序列d,e,f和中根遍历序列d,f,e可知c的左子树为d，d的左子树为空，右子树的结点有{e,f}。由先根遍历序列e,f和中根遍历序列f,e可知d的右子树为e，e的右子树为空，左子树的结点有{f}。所以，T的后遍历序列为：bfedca\n\n- 【2021】某森林F对应的二叉树为T，若T的先序遍历序列是a,b,d,c,e,g,f,中序遍历序列是b,d,a,e,g,c,f,则F中树的棵树是-->3\n\n  > 先根据先序遍历序列和中序遍历序列还原二叉树T如下：\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-102.png\" style=\"zoom:50%;\" />\n  >\n  > 由森林转化成二叉树的规则可知，森林中每棵树的根结点以右子树的方式相连，所以T中的结点a,c,f为F中树的根结点，森林F有三棵树\n\n- 综合题【2016】若一棵非空k(k>=2)叉树T中的每个非叶结点都有k个孩子，则称T为正则k叉树。请回答下列问题并给出推导过程。\n\n  （1）若 T 有 m 个非叶结点，则 T 中的叶结点有多少个？ \n\n  （2）若 T 的高度为 h（单结点的树 h=1），则 T 的结点数最多为多少个？最少为多少个？\n\n  > （1）根据定义，正则 k 叉树中仅含有两类结点；叶结点（个数记为 n0）和度为 k 的分支结点（个数记为 n1）。树 T 中的结点总数n=n0+nk=n0+m。树中所含的边数e=n-1，这些边均为m个度为k的结点发出的，即e=m×k。整理得：n0+m=m ×k+1，故 n0=（k-1）×m+1\n  >\n  > （2）高度为 h 的正则 k 叉树 T 中，含最多结点的树形为：除第 h 层外，第 1 到第 h-1 层的结点都是度为 k 的分支 结点；而第 h 层均为叶结点，即树是“满”树。此时第 j（1≤j≤h）层结点数为 k j-1，结点总数 M1为：\n  >\n  > $$\n  > M1=\\sum_{j=1}^hk^{j-1}=\\frac{k^h-1}{k-1}\n  > $$\n  > 含最少结点的正则 k 叉树的树形为：第 1 层只有根结点，第 2 到第 h-1 层仅含 1 个分支结点和 k-1 个叶结点，第 h 层有 k 个叶结点。即除根外第 2 到第 h 层中每层的结点数均为 k，故 T 中所含结点总数 M2 为： M2=1+(h-1)×k\n\n## 5.5 树与二叉树的应用\n\n### 哈夫曼树和哈夫曼编码\n\n#### 带权路径长度\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-135.png\" style=\"zoom:55%;\" />\n\n结点的权：有某种现实含义的数值(如：表示结点的重要性等)\n\n结点的带权路径长度：从树的根到该结点的路径长度(经过的边数)与该结点上权值的乘积。\n\n- 例如上图结点为3的带权路径长度 = 3 × 3 = 9\n\n树的带权路径长度：树中所有**叶结点**的带权路径长度之和\n$$\nWPL=\\sum_{i=1}^{n}{w_il_i}\n$$\n\n#### 哈夫曼树的定义\n\n在含有n个带权叶节点的二叉树中，其中**带权路径长度（WPL）最小的二叉树**称为**哈夫曼树**，也称**最优二叉树**。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-197.png\" style=\"zoom:55%;\" />\n\n像这个例子中，我们给出了四个叶子结点，它们的权值分别为1、3、4、5。\n\n我们可以构造各种形态的二叉树，把这些结点依次放到不同的位置，并保证这四个为叶子结点。\n\n那么这些不同的二叉树，其带权路径长度WPL有可能相同，也有可能不同。但是对于这四个叶子结点，无论如何改变二叉树的形态，其WPL是不可能小于25的。也就是说，25就是有可能出现的最小的树的带权路径长度。\n\n因此，上图中间的那两棵树，就是哈夫曼树。\n\n#### 哈夫曼树的构造(王道)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-147.png\" style=\"zoom:80%;\" />\n\n对于哈夫曼树并不唯一，如上图情况，我们还可以构造一个与之不同的哈夫曼树，如下所示：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-199.png\" style=\"zoom:55%;\" />\n\n而其WPL依然是最小值31。\n\n**这里的构造可能对于初学者不好理解，推荐听青岛大学王卓老师的课**\n\n#### 哈夫曼树的构造(王卓)\n\n路径：**从树中的一个结点到另一个结点之间的分支构成这两个结点间的路径**\n\n结点的路径长度：**两结点间路径上的分支数**\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-137.png\" style=\"zoom:80%;\" />\n\n树的路径长度：从树根到每一个结点的路径长度之和。记作TL\n\n<font color='orange'>结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树。</font>\n\n权：将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。\n\n结点的带权路径长度：从**根**结点到该结点之间的**路径长度**与该节点的权的**乘积**。\n\n树的带权路径长度：树中所有**叶子结点**的**带权路径长度之和**。记作WPL(Weighted Path Length)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-138.png\" style=\"zoom:67%;\" />\n\n哈夫曼树：最优树(带权路径长度(WPL)最短的树)\n\n注意：\"带权路径长度最短\"是在\"度相同\"的树中比较而得的结果，因此有最优二叉树、最优三叉树之称等等。\n\n哈夫曼树：最优二叉树(带权路径长度(WPL)最短的二叉树)\n\n------\n\n构造哈夫曼树的方法：\n\n1. 根据n个给定的权值{W1,W2,W3,…Wn}构成n棵二叉树的森林F={T1,T2,…Tn},其中Ti只有一个带权为Wi的根节点\n2. 在F中选取两棵根节点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根节点的权值为其左右子树上根节点的权值之和。\n3. 在F中删除这两棵树，同时将新的到的二叉树加入森林中。\n4. 重复2和3，直到森林中只有一棵树为止，这颗树即为哈夫曼树。\n\n口诀：1.构造森林全是根，2.选用两小造新树，3.删除两小添新人，4.重复2、3剩单根\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-139.png\" style=\"zoom:80%;\" />\n\n1. 构造森林全是根。有几个结点就有几个根节点，从而组成森林。\n   - 例如上方有4个结点，则将其都作为根节点组成森林。\n2. 选择两个权值最小的结点，将其权值加和，得到的权值为父结点，两个权值最小的结点为左右子树。\n   - 例如上方权值最下的两个结点为 2 和 4，将其权值加和为6，则 6 为父结点， 2 和 4 为左右子树。\n3. 删除刚才选择的那两个权值最小的结点，将剩余结点与第二步得到的父结点排成一排结成森林。\n   - 删除2和4结点，将 7、5、6三个结点作为根组成森林\n4. 继续选择两个权值最小的结点，将其权值加和，得到的权值为父结点，两个权值最小的结点为左右子树。\n   - 继续选择 5、6 两个结点，权值加和为11，则 11 为父结点，5、6为左右子树。\n\n> 包含n个叶子结点的哈夫曼树中共有 2n-1 个结点。(n个结点，两两合并，总共合并n-1次，产生n-1个新结点)\n>\n> 哈夫曼树的结点的度为0或2，没有度为1的结点。\n>\n> 度为1的结点是n个，度为2的结点是 n-1 个\n\n### 哈夫曼树的应用\n\nhttps://www.cnblogs.com/wkfvawl/p/9783271.html#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81\n\n#### 哈夫曼编码(王道)\n\n如电报——点、划两个信号（二进制的0、1）\n\n**固定长度编码**--每个字符用相等长度的二进制表示\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-149.png\" style=\"zoom:80%;\" />\n\n刚才我们算的所有答案的二进制长度，其实就是算了这棵树的带权路径长度。\n\n那么接下来要思考，还有没有比这种编码方案更优秀的方案？也就是要让它们之间传递的二进制长度的这个bit信息尽可能的少。就是要尽可能追求我们最终构造的这棵编码树，它的带权路径长度尽可能的小。\n\n那么就又回到了我们哈夫曼树的构造问题了。给出四个叶子结点以及权值，构造哈夫曼树。\n\n**可变长度编码**--允许对不同字符用不等长的二进制位表示\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-150.png\" style=\"zoom:80%;\" />\n\n> 到这里，有人会有疑问了：既然C是0，A是10，我想要把A与C区分开来，A是1的话，也可以区分啊？好的，那么我们来试一下：\n>\n> <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-167.png\" style=\"zoom:33%;\" />\n\n> 也就是说，不同的字符结点不一定是叶子结点。\n>\n> 并且C——0；A——1；B——111；D——110。\n>\n> 那么我们尝试发送一下：CAAABD这串答案。\n>\n> 发送方：0111111110\n>\n> 接收方翻译：CBBD。\n>\n> 会发现，对这个二进制码的解码发生错误，有歧义。\n\n所以，对于一个字符集，我们若要设计一系列**可变长度编码**的话，所有字符对应到编码树里面，只能当做叶子结点，不能当做某一个分支结点。\n\n换一个角度来说，这种编码方式，没有一个编码是另一个编码的前缀。则称这样的编码为**前缀编码**。前缀码解码无歧义，而非前缀编码在解码的时候有歧义。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-151.png\" style=\"zoom:80%;\" />\n\n由哈夫曼树得到**哈夫曼编码**--字符集中的每个字符作为一个叶子结点，各个字符出现的频度作为结点的权值，根据之前结点的方法构造哈夫曼树\n\n左分支看成0，右分支看成1。（当然，反过来也无所谓）\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-152.png\" style=\"zoom:80%;\" />\n\nhttps://blog.csdn.net/Bitter_Li/article/details/120939587\n\n#### 哈夫曼编码(王卓)\n\n1. 统计字符集每个字符在电文中出现的平均概率(概率越大，要求编码越短)\n2. 利用哈夫曼树的特点：权越大的叶子离根越近，将每个字符的概率值作为权值，构造哈夫曼树。则概率越大的结点，路径越短。\n3. 在哈夫曼树的每个分支上标上0或1，结点的左分支标0，右分支标1，把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码。\n\n**例题**：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-140.png\" style=\"zoom: 67%;\" />\n\n1. 构造哈夫曼树\n2. 左分支标0，右分支标1，把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-141.png\" style=\"zoom:80%;\" />\n\n### 并查集\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-208.png\" style=\"zoom:50%;\" />\n\n#### 逻辑结构——集合\n\n之前我们学习的逻辑结构有线性结构、树型结构和图结构。**集合**是我们没有学过的。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-209.png\" style=\"zoom: 67%;\" />\n\n对于一个全集S，我们可以按照某些想要的维度进行分类，将S划分为几个不同的子集。\n\n比如根据不同人喜欢吃的水果不一样进行划分。\n\n注意:划分后的子集是<font color='red'>互不相交</font>的。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-210.png\" style=\"zoom:60%;\" />\n\n集合这种逻辑结构之下，两个元素之间的关系要么从属于同一集合、要么从属于不同集合。\n\n<font color='cornflowerblue'>怎么用代码表示这种互不相交的集合关系呢？</font>\n\n联想一下树、森林这种表示方式，用这种思路来表达出各个集合是否属于同一子集。同属于一个集合的元素可以在物理上将它们组织成一棵树。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-211.png\" style=\"zoom:60%;\" />\n\n用互不相交的树，表示多个”集合“。\n\n#### 为什么叫做并查集\n\n<font color='cornflowerblue'>如何“查”到一个元素到底属于哪一个集合？</font>\n\n从指定元素出发，一路向北，找到根节点，通过根节点来判断集合。\n\n<font color='cornflowerblue'>如何判断两个元素是否属于同一集合？</font>\n\n分别查到两个元素的根，判断根节点是否相同即可。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-212.png\" style=\"zoom:60%;\" />\n\n<font color='orange'>如何把两个集合“并”为一个集合？</font>\n\n让一棵树成为另一棵树的子树即可。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-213.png\" style=\"zoom:60%;\" />\n\n想到这，应该知道为什么这个数据结构要叫做”并查集“了。(对集合实现并、查操作)\n\n#### 存储结构\n\n##### 引言\n\n那么应该用什么样的存储结构来实现上述操作呢？——树的双亲表示法更适合\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-223.png\" style=\"zoom:55%;\" />\n\n容易通过数组来找到双亲结点，并且能通过一棵树根节点的parent指针指向另一棵树的根节点的编号来完成”并“操作。\n\n##### 并查集的存储结构\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-229.png\" style=\"zoom:55%;\" />\n\n对于n个数据元素，只需声明一个长度为n的int型数组S，即可表示集合关系。本质上就是树的双亲表示法。\n\n#### 基本操作\n\n- 初始化\n\n  刚开始并不知道哪些数据元素是属于一个子集的，所以都初始化为各自独立的n个子集，将数组的值全部赋值为-1。\n\n  ```C\n  #define SIZE 13\n  int UFsets[SIZE];//集合元素数组\n  //初始化并查集\n  void Initial(int S[]){\n      for(int i=0;i<SIZE;i++)\n          S[i]=-1;\n  }\n  ```\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-230.png\" style=\"zoom:70%;\" />\n\n- 查操作——Find\n\n  非递归形式\n\n  ```C\n  //找x所属集合(返回x所属根结点)\n  int Find(int S[],int x){\n      while(S[x]>=0)//循环寻找x的根\n          x=S[x];\n      return x;//根的s[]小于0\n  }\n  ```\n\n  递归形式\n\n  ```C\n  int Find(int S[],int x) {\n    if (S[x] == -1){\n        return x; //若当前结点为根结点则返回该结点号\n    } \n    else{\n        return Find(S[x]); //否则递归查找其双亲结点的根结点\n    }\n  }\n  ```\n\n- 并操作——Union\n\n  ```C\n  void Union(int S[],int Root1,int Root2){\n      //要求Root1和Root2是不同的集合\n      if(Root1==Root2) return;\n      //将根Root2连接到另一根Root1下面\n      S[Root2]=Root1;\n  }\n  ```\n\n  上述代码是已知两棵树的根节点的实现。如果不知道根节点呢？\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-231.png\" style=\"zoom:67%;\" />\n\n  先对给定的两个元素进行Find操作确定根节点是谁后再执行Union操作即可。\n\n#### 时间复杂度分析\n\n首先并操作不需要多说了，已知根节点后其代码只有两行，时间复杂度O(1)\n\n若结点数为n，Find最坏时间复杂度为O(n)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-232.png\" style=\"zoom:55%;\" />\n\n可以看出来，查操作的最坏时间复杂度O(n)与树的高度h相关，顺着这个思路可以知道如何进行优化操作。\n\n#### Union操作的优化\n\n优化思路:在每次Union操作构建树的时候，尽可能让树不长高\n\n- 用根节点的绝对值表示树的结点总是——表示树的大小\n- Union操作时，让小树合并到大树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-233.png\" style=\"zoom: 67%;\" />\n\n```C\nvoid Union(int S[],int Root1,int Root2){\n    if(Root1==Root2) return;\n    if(S[Root2]>S[Root1]){//Root2结点数更少\n        S[Root1]+=S[Root2];//累加结点总数\n        S[Root2]=Root1;//小树合并到大树\n    }else{\n        S[Root2]+=S[Root1];//累加结点总数\n        S[Root1]=Root2;//小数合并到大树\n    }\n}\n```\n\n合并之后，将两棵树的根节点的绝对值累加成新的总数赋予大树的根节点。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-234.png\" style=\"zoom:67%;\" />\n$$\n该方法构造的树高不超过\\lfloor log_2n\\rfloor+1\n$$\n所以Union操作优化后，Find操作最坏时间复杂度为O(log₂n)\n\n#### 总结\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-235.png\" style=\"zoom:67%;\" />\n\n### 并查集的终极优化\n\n#### Find操作的优化(压缩路径)\n\n用前面讲到的Find操作找x所属集合(返回x所属根结点的值)，如Find(S[],11)查找L所属集合。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-236.png\" style=\"zoom:67%;\" />\n\n如上图所示，L->E->B->A就是查找L的查找路径。所谓”**压缩路径**“的这种优化方式，就是让查找路径变短。\n\n压缩路径————Find操作，先找到根节点，再将查找路径上所有结点都挂到根节点下\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-237.png\" style=\"zoom:67%;\" />\n\n```C\n//先找到根节点，再进行”压缩路径“\nint Find(int S[],int x){\n    int root=x;\n    while(S[root]>=0)   root=S[root];//循环找到根\n    while(x! =root){//压缩路径\n        int t=S[x];//t指向x的父节点\n        S[x]=root; //x直接挂到根节点下\n        x=t;\n    }\n    return root;//返回根节点编号\n}\n```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-238.png\" style=\"zoom:67%;\" />\n\n每次Find操作，先找根，再”压缩路径“，可使树的高度不超过0(a(n))。a(n)是一个增长很缓慢的函数，对于常见的n值，通常a(n)<=4,因此优化后并查集的Find、Union操作时间都很低。\n\n#### 并查集优化总结\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-239.png\" style=\"zoom:67%;\" />\n\n[408快乐站](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)\n\n### 习题\n\n- 【2010】n(n>=2)个权值均不相同的字符构成哈夫曼树，关于该树的叙述中，错误的是-->A\n\n  A.该树一定是一棵完全二叉树\n\n  B.树中一定没有度为1的结点\n\n  C.树中两个权值最小的结点一定是兄弟结点\n\n  D.树中任一非叶结点的权值一定不小于下一层任一结点的权值\n\n  > A.哈夫曼树为带权路径长度最小的二叉树，不一定是完全二叉树。哈夫曼树中没有度为1的结点，B正确；构造哈夫曼树时，最先选取两个权值最小的结点作为左、右子树构造一棵新的二叉树，C正确；哈夫曼树中任一非叶结点P的权值为其左、右子树根结点权值之和，其权值不小于其左、右子树根结点的权值，在与结点P的左、右子树根结点处于同一层的结点中，若存在权值大于结点P权值的结点Q，那么结点Q的兄弟结点中权值较小的一个应该与结点P作为左、右子树构造新的二叉树。综上可知，哈夫曼树中任一非叶结点的权值一定不小于下一层任一结点的权值。\n\n- 【2014】5个字符有如下4种编码方案，不是前缀编码的是-->D\n\n  A、01,0000,0001,001,1\n\n  B、011,000,001,010,1\n\n  C、000,001,010,011,100\n\n  D、0,100,110,1110,1100\n\n  > **前缀编码**是指对字符集进行编码时，要求字符集中任一字符的编码都不是其它字符的编码的前缀。D不符合\n  >\n  > 构造方式： \n  >\n  > 1.构造**哈夫曼树**(哈夫曼树是**同权不同构**的，可以构造出不同结构的哈夫曼树但是带权路径长度是相等的)。 \n  >\n  > 2.**前缀编码**在构造好哈夫曼树的基础上，**左0右1编码**\n\n- 【2015】下列选项给出的是从根分别到达两个叶结点路径上的权值序列，属于同一棵哈夫曼树的是-->\n\n  A. 24,10,5和24,10,7\n\n  B. 24,10,5和24,12,7\n\n  C. 24,10,10和24,14,11\n\n  D. 24,10,5和24,14,6\n\n  > 首先根据两个叶子，以及访问到叶子的前一个结点，这个结点一定是叶子的父亲结点。再根据哈夫曼树的结点一定有兄弟，即不存在度为1的结点。因此可以知道兄弟的**权值**，这样，给定的一个序列就可以推出两个叶子，两个序列推出四个叶子，这样就可以根据是否选择最小的两个叶子结点组合在一起作为判据，决定这个序列是否成立了。\n  >\n  > 我们一个一个来看。\n  >\n  > 1）首先看D  这里写图片描述\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-154.png\" style=\"zoom: 23%;\" />\n  >\n  > 首先由第一个序列的10，5可以推出另一个叶子也是5，它们的父亲是10.到此为止，不能再瞎猜测其他叶子结点了。但我们知道两个叶子形成的结点有个权值为14的兄弟，但是不知道是叶子结点还是一个由叶子形成的结点，这个有待观察。\n  >\n  > 再看第二个序列，知道叶子结点6和父亲14，可以知道有个叶子兄弟是8，这个权值是14的结点有意思了，刚好可以和第一个结合成兄弟，且父亲为24，恰恰满足要求。\n  >\n  > 因此D是符合题目的树形。\n  >\n  > 2）再看C.这里写图片描述\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-155.png\" style=\"zoom:23%;\" />\n  >\n  > 同样的分析思路再过一遍。\n  > 由第一个序列中的10，10可以得到有个叶子权值是0。第二个序列的14，11知道有个叶子是4.\n  > OK，问题出来了，四个权值10，0，11，4是原始序列中的权值，按理说0，4最小，应该组合在一起，但是这里没有。所以是错误的树形。\n  > 当然需要明确的是，0和4不一定要组合在一起，要是序列中有1，那么0，1组合才是更小的。也就是说我们选择的是最小的，在不知道全局的情况下，局部的两个最小值最合理的是组合在一起。局部中不可能出现两个最小的分散的局面。这在哈夫曼树的构造中不可能出现的。\n  >\n  > 以上D,C从正反角度看了这种问题的解法。 同理B,A不再多说，给出图形如下：\n  >\n  > 3）B的树形：这里写图片描述\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-156.png\" style=\"zoom:23%;\" />\n  >\n  > 如果24是第一个序列的，就不可能指到12，所以两个序列不是同一棵树的。\n  >\n  > 4)A也是同样的问题。A的树形：\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-157.png\" style=\"zoom:23%;\" />\n\n- 若度为 m 的哈夫曼树中，叶子结点个数为 n，则非叶子结点的个数为 →（n-1)/(m-1)\n\n- 【2017】已知字符集{a,b,c,d,e,f,g,h}，若各字符的哈夫曼编码依次是0100，10，0000，0101，001，011，11，0001，则编码序列 0100011001001011110101 的译码结果是-->D\n\n  A. acgabfh    B. adbagbb\n  C. afbeagd    D. afeefgd\n\n  > 哈夫曼编码是前缀编码，各个编码的前缀各不相同，因此直接拿编码序列与哈夫曼编码一一比对即可。序列可分割为0100 011 001 001 011 11 0101，译码结果是a f e e f g d，选项D正确\n\n- 【2018】已知字符集{a,b,c,d,e,f},若各字符出现的次数分别为6，3，8，2，10，4，则对应字符集中各字符的哈夫曼编码可能是->A\n\n  A. 00, 1011, 01, 1010, 11, 100\n\n  B. 00, 100, 110, 000, 0010, 01\n\n  C. 10, 1011, 11, 0011, 00, 010\n\n  D. 0011, 10, 11, 0010, 01, 000\n\n  > 先将这串数字构造为哈夫曼树.\n  >\n  > 其实题目中，前半部分的字母已经不用看了，因为构造哈夫曼树正常是比大小，而这里比较出现次数大小。排序为2，3，4，6，8，10\n  >\n  > 哈夫曼树为\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-158.png\" style=\"zoom:23%;\" />\n  >\n  > 将每个结点左右子树设为0，1，如下\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-159.png\" style=\"zoom: 40%;\" />\n  >\n  > 将从头结点到此结点数合起来即为哈夫曼编码\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-160.png\" style=\"zoom: 40%;\" />\n  >\n  > 此时可以得到题目中几个次数的字符集，即为对应字符的哈夫曼编码\n  >\n  > - 2->1010\n  > - 3->1011\n  > - 4->100\n  > - 6->00\n  > - 8->01\n  > - 10->11\n  >\n  > 所以各字符出现的次数分别为{ 6, 3, 8, 2, 10, 4 }，则对应字符集中各字符的哈夫曼编码可能是：00, 1011, 01, 1010, 11, 100\n\n- 【2019】对n个互不相同的符号进行哈夫曼编码。若生成的哈夫曼树共有115个结点，则n的值是-->C\n\n  A.56  B.57\n  C.58  D.60\n\n  > 哈夫曼树的特点性质：（节点为的度数为0 表示 n0,以此类推）\n  > ①哈夫曼树中只存在度为2和度为0的节点，及n1=0。\n  > ②哈夫曼树中，度为0和度为2的节点关系：n2=n0-1\n  >\n  > 由以上两个性质，本题就很好解出答案：\n  > n0+n2=115 =>\n  > n0+n0-1=115 =>\n  > n0=(115+1)/2=58\n\n- 【2021】若某二叉树有5个叶结点，其权值分别为10，12，16，21，30，则其最小的带权路径长度WPL是-->200\n\n  > 首先对集合进行排序得到`{10，12，16，21，30}`\n  >\n  > 我们找到权值最小的两个结点10和12合并；得到新的森林根结点为22。现在结点集合为`{16,21,22,30}`\n  >\n  > 接着我们找到当前最小的结点16和21合并：得到新的森林根结点为37。现在结点集合为`{22,30,37}`\n  >\n  > 接着我们找到当前最小的结点22和30合并：得到新的森林根结点为53。现在结点集合为`{37,53}`\n  >\n  > 接着我们找到当前最小的结点37和53合并：得到新的森林根结点为90。现在结点集合为`{90}`；由于结点个数只剩一个，所以算法结束、构造哈夫曼树完毕\n  >\n  > 依次累加计算所有叶结点的带权路径长度 从上面构造的哈夫曼树可知所有结点的路径长度，例如结点”16“的路径长度为2\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-161.png\" style=\"zoom: 50%;\" />\n  >\n  > 所以`WPL=(16+21+30)*2+(10+12)*3=200`\n\n- 【综合2012】设有6个有序表A,B,C,D,E,F，分别含有10,35,40,50,60和200个数据元素，各表中元素按升序排列。要求通过 5 次两两合并，将 6 个表最终合并成 1 个升序表，并在最坏情况下比较的总次数达到最小。请回答下列问题。\n\n  1 ）给出完整的合并过程，并求出最坏情况下比较的总次数。\n\n  2 ）根据你的合并过程，描述 N （ N ≥ 2 ）个不等长升序表的合并策略，并说明理由。\n\n  > 1）对于长度分别为 m ， n 的两个有序表的合并，最坏情况下是一直比较到两个表尾元素，比较次数为  m+n-1  次。故最坏情况的比较次数依赖于表长，为了缩短总的比较次数，根据哈夫曼树（最佳归并树）思想的启发，可采用如图所示的合并顺序。\n  >\n  > 根据上图中的哈夫曼树， 6个序列的合并过程为：\n  >\n  > 第 1 次合并：表 A 与表 B 合并，生成含有 45 个元素的表 AB ；\n  >\n  > 第 2 次合并：表 AB 与表 C 合并，生成含有 85 个元素的表 ABC ；\n  >\n  > 第 3 次合并：表 D 与表 E 合并，生成含有 110 个元素的表 DE ；\n  >\n  > 第 4 次合并：表 ABC 与表 DE 合并，生成含有 195 个元素的表 ABCDE ；\n  >\n  > 第 5 次合并：表 ABCDE 与表 F 合并，生成含有 395 个元素的最终表。\n  >\n  > ![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-207.png)\n  >\n  > 由上述分析可知，最坏情况下的比较次数为：第1次合并，最多比较次数=10+35-1=44；第2次合并，最多比较次数=45+40-1=84  ；第3次合并，最多比较次数=50+60-1=109；第 4 次合并，最多比较次数=85+110-1=194；第5次合并，最多比较次数=195+200-1=394。故比较的总次数最多为：44+84+109+194+394=825 。\n  >\n  > 2）各表的合并策略是：在对多个有序表进行两两合并时，若表长不同，则最坏情况下总的比较次数依赖于表的合并次序。可以借用哈夫曼树的构造思想，依次选择最短的两个表进行合并，可以获得最坏情况下最佳的合并效率。\n\n- 【综合2020】若任意一个字符的编码都不是其他字符编码的前缀，则称这种编码具有前缀特性。现有某字符集(字符个数>=2)的不等长编码，每个字符的编码均为二进制的0，1序列，最长为L位，且具有前缀特性。请回答下列问题\n\n  1)哪种数据结构适宜保存上述具有前缀特性的不等长编码？\n\n  2)基于你所设计的数据结构，简述从0/1串到字符串的译码过程\n\n  3)简述判定某字符集的不等长编码是否具有前缀特性的过程\n\n  > 1)使用一棵二叉树保存字符集中各字符的编码，每个编码对应于从根开始到达某叶结点的一条路径，路径长度等于编码位数，路径到达的叶结点中保存该编码对应的字符\n  >\n  > 2)从左至右依次扫描0/1串中的各位。从根开始，根据串中当前位沿当前结点的左子指针或右子指针下移，直到移动到叶结点时为止。输出叶结点中保存的字符。输出叶结点中保存的字符。然后从根开始重复这个过程，直到扫描到0/1串结束，译码完成。\n  >\n  > 3)二叉树既可用于保存各字符的编码，又可用于检测编码是否具有前缀特性。判定编码是否具有前缀特性的过程，也是构建二叉树的过程。初始时，二叉树中仅含有根结点，其左子指针和右子指针均为空。\n  >\n  > 依次读入编码C，建立/寻找从根开始对应于该编码的一条路径，过程如下:\n  >\n  > 对每个编码，从左至右扫描C的各位，根据C的当前位(0或1)沿结点的指针(左子指针或右子指针)向下移动。当遇到空指针时，创建新结点，让空指针指向该新结点并继续移动。沿着指针移动的过程中，可能遇到三种情况:\n  >\n  > ①若遇到了叶结点(非根)，则表明不具有前缀特性，返回。\n  >\n  > ②若在处理C的所有位的过程中，均没有创建新结点，则表明不具有前缀特性，返回。\n  >\n  > ③若在处理C的最后一个编码位时创建了新结点，则继续验证下一个编码。\n  >\n  > 若所有编码均通过验证，则编码具有前缀特性。\n","tags":["408数据结构"],"categories":["408数据结构"]},{"title":"第五章 树与二叉树(中)","url":"/p/48066/","content":"\n## 5.3 二叉树的遍历和线索二叉树\n\n### 二叉树的遍历\n\n**遍历**：按照某种次序把所有结点都访问一遍\n\n对于一个线性结构，如a1 a2 a3 a4 a5\n\n对其进行遍历，是很简单的，我们可以从前往后依次遍历，也可以从后往前。\n\n但是对于树形结构，我们的遍历规则就会更复杂一些。\n\n由于树这种结构呈现出了一层一层的效果，因此不难想到我们可以一层一层地访问这些结点。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-34.png\" style=\"zoom:80%;\" />\n\n这种方法叫做**层次遍历**，即基于树的层次特性确定的次序规则。\n\n而我们此节主要说的**先/中/后序遍历**是基于树的递归特性确定的次序规则。\n\n**二叉树的递归特性**：\n\n1. 要么是个空二叉树\n2. 要么就是由 “根节点 + 左子树 + 右子树” 组成的二叉树\n3. **先序遍历：根左右**\n4. **中序遍历：左根右**\n5. **后序遍历：左右根**\n\n------\n\n我们先来看一个简单的例子：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-35.png\" style=\"zoom:80%;\" />\n\n上述是最简单的二叉树遍历，我们再来看一个:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-36.png\" style=\"zoom: 80%;\" />\n\n#### 先序遍历 PreOrder\n\n先序遍历的操作过程如下：\n\n1. 若二叉树为空，则什么也不做\n2. 若二叉树非空\n   1. 访问根节点\n   2. 先序遍历左子树\n   3. 先序遍历右子树\n\n<font color='orange'>先序遍历——第一次路过时访问结点</font>\n\n先序遍历的算法实现（递归）\n\n```c\nvoid PreOrder(BiTree T) {\n  if (T != NULL){         // 如果二叉树非空，则继续\n    visit(T);             // 访问根结点内容\n    PreOrder(T->lchild);  // 访问左子树内容\n    PreOrder(T->rchild);  // 访问右子树内容\n  }\n}\n```\n\n#### 中序遍历 InOrder\n\n中序遍历的操作过程如下：\n\n1. 若二叉树为空，则什么也不做\n2. 若二叉树非空\n   1. 中序遍历左子树\n   2. 访问根节点\n   3. 中序遍历右子树\n\n<font color='orange'>中序遍历——第二次路过时访问结点</font>\n\n> 这里要提两个术语:前驱节点和后继节点\n>\n> 前驱节点：对一棵二叉树进行中序遍历，遍历后的顺序，当前节点的前一个节点为该节点的前驱节点；\n>\n> 后继节点：对一棵二叉树进行中序遍历，遍历后的顺序，当前节点的后一个节点为该节点的后继节点；\n\n中序遍历的算法实现（递归）\n\n```c\n// 中序遍历\nvoid InOrder(BiTree T){\n    if(T != NULL){\n        InOrder(T -> lchild);\t\t// 递归遍历左子树\n        visit(T);\t\t\t\t\t// 访问根节点\n        InOrder(T -> rchild);\t\t// 递归遍历右子树\n    }\n}\n```\n\n#### 后续遍历 PostOrder\n\n后序遍历的操作过程如下：\n\n1. 若二叉树为空，则什么也不做\n2. 若二叉树非空:\n   1. 后序遍历左子树\n   2. 后序遍历右子树\n   3. 访问根节点\n\n<font color='orange'>后序遍历——第三次路过时访问结点</font>\n\n```c\n// 后序遍历\nVoid PostOrder(BiTree T){\n    if(T != NULL){\n        PostOrder(T->lchild);\t\t\t// 递归遍历左子树\n        PostOrder(T->rchild);\t\t\t// 递归遍历右子树\n        visit(T);\t\t\t\t\t\t// 访问根节点\n    }\n}\n```\n\n#### 手算练习\n\n```C\n// 访问一个结点:打印字符\nVoid visit(BiTNode *p){\n    printf(\"%c\",p->data);\n}\n```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-37.png\" style=\"zoom:80%;\" />\n\n<font color='orange'>这里的遍历和我们学习栈的表达式时很有关联，我们将这里的先序遍历的表达式转换为中缀表达式和后缀表达式，分别对应的就是中序遍历和后序遍历，只是中序遍历没有添加界限符</font>\n\n------\n\n> 三种遍历算法中，递归遍历左、右子树的顺序都是固定的，只是访问根结点的顺序不同。不管采用哪种遍历算法，每个结点都访问一次且仅访问一次，故时间复杂度都是O(n)。在递归遍历中，递归工作栈的栈深恰好为树的深度，所以在最坏情况下，二叉树是有n个结点且深度为n的单支树，遍历算法的空间复杂度为O(n)。\n\n#### 求树的深度(应用)\n\n对于求树的深度，我们只需要选择左子树和右子树中深度最大的子树 + 1 就是树的深度\n\n```C\n// 求树的深度\nint treeDepth(BiTree T){\n    if(T == NULL){\t\t\t\t\t\t\t\t// 树是空树\n        return 0;\t\t\t\t\t\t\t\t// 深度为0\n    }else{\n        int l = treeDepth(T->lchild);\t\t\t// 求左子树的深度\n        int r = treeDepth(T->rchild);\t\t\t// 求右子树的深度\n        // 树的深度 = Max(左子树深度,右子树深度)+1\n        return l>r ? l+1 : r+1;\n    }\n}\n```\n\n#### 递归算法和非递归算法的转换\n\nhttps://blog.csdn.net/qq_53144843/article/details/121127971\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-1.jpg\" style=\"zoom: 25%;\" />\n\n上图中，用带箭头的虚线表示了这3种遍历算法的递归执行过程。其中，向下的箭头表示更深一层的递归调用，向上的箭头表示从递归调用退出返回；虚线旁的三角形、圆形和方形内的字符分别表示在先序、中序、后序遍历的过程中访问结点时输出的信息。如图，先序序列为A B D E C、中序序列为D B E A C、后序序列为D E B C A。\n\n##### 中序遍历的非递归算法\n\n借助栈，分析中序遍历的访问过程:\n\n①**沿着根的左孩子，依次入栈，直到左孩子为空**，说明已找到可以输出的结点，此时栈内元素依次为A B D。②**栈顶元素出栈并访问:若其右孩子为空，继续执行**②；**若其右孩子不空，将右子树转执行**①。栈顶D出栈并访问，它是中序序列的第一个结点:D右孩子为空，栈顶B出栈并访问；B右孩子不空，将其右孩子E入栈，E左孩子为空，栈顶E出栈并访问；E右孩子为空，栈顶A出栈并访问；A右孩子不空，将其右孩子C入栈，C左孩子为空，栈顶C出栈并访问。由此得到中序序列D B E A C。\n\n```c\nvoid InOrder2(BiTree T, SqStack S) {\n  InitStack(S); BiTree p = T;//初始化栈S；p是遍历指针\n  while (p||!IsEmpty(S)) {   //栈不空或p不空时循环\n    if (p) {                 //一路向左\n        Push(S, p);          //当前结点入栈\n        p = p->lchild;       //左孩子不空，一直向左走\n    }\n    else {                   //出栈，并转向出栈结点的右子树\n        Pop(S,p); visit(p);  //栈顶元素出栈，访问出栈结点\n        p = p->rchild;       //向右子树走，p赋值为当前结点的右孩子\n    }                        //返回while循环继续进入if-else语句\n  }\n}\n```\n\n##### 先序遍历的非递归算法\n\n先序遍历和中序遍历的基本思想是类似的，只需把访问结点操作放在入栈操作的前面。\n\n```C\nvoid InOrder2(BiTree T, SqStack S) {\n  InitStack(S); BiTree p = T;//初始化栈S；p是遍历指针\n  while (p||!IsEmpty(S)) {   //栈不空或p不空时循环\n    if (p) {                 //一路向左\n        visit(p);Push(S,p);  //访问当前结点，并入栈\n        p = p->lchild;       //左孩子不空，一直向左走\n    }\n    else {                   //出栈，并转向出栈结点的右子树\n        Pop(S,p);            //栈顶元素出栈\n        p = p->rchild;       //向右子树走，p赋值为当前结点的右孩子\n    }                        //返回while循环继续进入if-else语句\n  }\n}\n```\n\n##### 后序遍历的非递归算法\n\n> 后序遍历的非递归实现是三种遍历算法中最难的。因为后序遍历中，要保证左孩子和右孩子都已被访问并且左孩子在右孩子前访问才能访问根结点，这就为流程的控制带来了难题。\n\n后序非递归遍历算法思想:后序非递归遍历二叉树是先访问左子树，再访问右子树，最后访问根结点。结合图来分析:①**沿着根的左孩子，依次入栈，直到左孩子为空**。此时栈内元素依次为A B D。②**读栈顶元素:若其右孩子不空且未被访问过，将右子树转执行**①；**否则，栈顶元素出栈并访问**。栈顶D的右孩子为空，出栈并访问，它是后序序列的第一个结点；栈顶B的右孩子不空且未被访问过，E入栈，栈顶E的左右孩子均为空，出栈并访问；栈顶B的右孩子不空但已被访问，B出栈并访问；栈顶A的右孩子不空且未被访问，C入栈，栈顶C的左右孩子均为空，出栈并访问；栈顶A的右孩子不空但已被访问，A出栈并访问。由此得到后序序列D E B C A。\n\n在上述思想中的第②步，**必须分清返回时是从左子树返回的还是从右子树返回的**，因此设定<font color='red'>一个辅助指针r</font>，指向最近访问过的结点。<font color='orange'>也可在结点中增加一个标志域</font>，记录是否已被访问。\n\n```C\nvoid PostOrder(BiTree T){\n    InitStack(S);\n    p=T;\n    r=NULL;\n    while(p||!IsEmpty(s)){\n        if(P){   //走到最左边\n            push(S,p);\n            p=p——>lchild；\n        }\n        else{   //向右\n            GetTop(S,p); //读栈顶结点(非出栈)\n            if(p->rchild&&p->rchild! =r)//若右子树存在，且未被访问过\n                p=p->rchild; //转向右\n            else{    //否则，弹出结点并访问\n                pop(S,p); //弹出结点\n                visit(p->data); //访问该结点\n                r=p;  //记录最近访问过的结点\n                p=NULL;  //结点访问完后，重置p指针\n            }\n        }//else\n    }//while\n}\n```\n\n> 注意:每次出栈访问完一个结点就相当于遍历完以该结点为根的子树，需将p置NULL。\n\n#### 层序遍历\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-38.png\" style=\"zoom: 80%;\" />\n\n算法思想：\n\n1. 初始化一个辅助队列\n\n2. 让根结点入队\n\n3. 若队列非空，则队头结点出队，访问该结点，并将其左、右孩子插入队尾(如果有的话)\n\n   - 例如 A 结点在队头，让 A 出队，并将其左、右孩子 B、C 插入队\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-39.png\" style=\"zoom:80%;\" />\n\n4. 重复 3 直至队列为空\n\n   - B 此时为队头元素，B 出队，将 B 的左右孩子 D、E 插入队尾\n   - C 此时为队头元素，C 出队，将 C 的左右孩子 F、G 插入队尾\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-40.png\" style=\"zoom:80%;\" />\n\n```c\n// 层序遍历\nvoid LevelOrder(BiTree T){\n    LinkQueue Q;\t\t\t\t// 链队列\n    InitQueue(Q);\t\t\t\t// 初始化辅助队列\n    BiTree p;\t\t\t\t\t\n    EnQueue(Q,T);\t\t\t\t// 将根结点入队\n    while(!IsEmpty(Q)){\t\t\t// 队列不为空则循环\n        DeQueue(Q,p);\t\t\t// 队头结点出队\n        visit(p);\t\t\t\t// 访问出队结点\n        if(p->lchild != NULL){\n            EnQueue(Q,p->lchild);// 左孩子入队\n        }\n        if(p->rchild != NULL){\n            EnQueue(Q,p->rchild);// 右孩子入队\n        }\n    }\n    \n}\n```\n\n> 这里使用的是链队列，因为我们无法估计一棵树到底有多少个结点，使用链队列方便我们对空间进行扩展。\n>\n> 对于链队列的初始化、入队出队等操作，之前讲过就不再重复了。\n\n### 由遍历序列构造二叉树\n\n> 给定一棵二叉树，它的中序遍历序列是唯一的。\n>\n> 但是给定一个中序遍历序列，我们不能确切的说，它对应的是哪棵树。同一个中序遍历序列可能对应多种二叉树形态。\n>\n> 前序遍历、后序遍历、层序遍历同理。\n>\n> 因此，若只给出某一种遍历序列，就让逆推出二叉树，是不可能的。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-41.png\" style=\"zoom:67%;\" />\n\n<font color='cornflowerblue'>结论：一个中序/前序/后序/层次遍历序列可能对应多种二叉树形态，若只给出一棵二叉树的 前/中/后/层 序遍历序列中的一种，不能唯一确定一棵二叉树</font>\n\n<font color='orange'>怎样可以唯一确定一棵二叉树呢？</font>\n\n若要由二叉树的遍历序列构造二叉树，则\n\n- 前序 + 中序 遍历序列\n- 后序 + 中序 遍历序列\n- 层序 + 中序 遍历序列\n\n<font color=\"red\">注意：前序、后序、层序序列的两两组合无法唯一确定一棵二叉树，一定要有中序遍历序列，才能推出二叉树</font>\n\n#### 前序+中序遍历序列\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-42.png\" style=\"zoom:80%;\" />\n\n我们来看一个例子：\n\n- 已知前序遍历序列为：A D B C E\n- 已知中序遍历序列为：B D C A E\n\n由中序遍历序列首先推出根节点为 A ，(B D C) 均为左子树，E 为右子树。如下图\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-43.png\" style=\"zoom:50%;\" />\n\n由前序遍历序列推出左子树的根节点为 D，则由中序序列推出结点 D 的左子树为 B，右子树为 C\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-176.png\"  />\n\n------\n\n再来看一个复杂一点的例子\n\n- 已知前序遍历序列为：D A E F B C H G I\n- 已知中序遍历序列为：E A F D H C B G I\n\n由前序遍历序列推出 D 为根结点，则由中序遍历序列可知 D 的左子树为 (D A F)，右子树为(H C B G I)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-45.png\" style=\"zoom:50%;\" />\n\n根据前序遍历序列 A 为左子树的根节点，根据中序遍历序列 A 的左子树为 E，右子树则为 F\n\n根据前序遍历序列 B 为右子树的根节点，根据中序遍历序列 B 的左子树为(H C)，右子树为(GI)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-46.png\" style=\"zoom:50%;\" />\n\n根据前序遍历序列 C 为 根，根据中序遍历序列 C 的左子树为 H\n\n根据前序遍历序列 G 为根，根据中序遍历序列 G 的右子树为 I\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-47.png\" style=\"zoom:50%;\" />\n\n#### 后续+中序遍历序列\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-48.png\" style=\"zoom: 80%;\" />\n\n我们来看一个例子：\n\n- 已知后序遍历序列：E F A H C I G B D (左 右 根)\n- 已知中序遍历序列：E A F D H C B G I (左 根 右)\n\n根据后序遍历序列 D 为根节点，根据中序遍历序列 ，(E A F) 为左子树，(H C B G I) 为右子树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-49.png\" style=\"zoom: 50%;\" />\n\n根据后序遍历序列 A 为左子树的根节点，根据中序遍历序列 E 为 A 结点的左子树，F为右子树\n\n根据后序遍历序列 B 为右子树的根节点，根据中序遍历序列 (H C) 为左子树，(G I)为右子树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-50.png\" style=\"zoom:50%;\" />\n\n根据后序遍历序列 C 为根，G 为根。根据中序遍历序列 H 为左子树，I 为右子树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-51.png\" style=\"zoom:50%;\" />\n\n#### 层序+中序遍历序列\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-52.png\" style=\"zoom: 80%;\" />\n\n我们来看一个简单的例子：\n\n- 已知层序遍历序列：A B C D E (根 左子树的根 右子树的根)\n- 已知中序遍历序列：A C B E D (左 根 右)\n\n根据层序遍历序列，首先访问第一层，根为 A。格局中序遍历序列，A 的左边没有元素，则 A 的左子树为空1\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-53.png\" style=\"zoom: 50%;\" />\n\n根据层序遍历序列，访问第二层，首先出现的是 B，则 B 是右子树的根节点。根据中序遍历序列，C 为 B 的左子树，(E D) 为 B 的右子树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-54.png\" style=\"zoom:50%;\" />\n\n根据层序遍历，访问第三层，首先出现的是 C、D，则 D 为根，根据中序遍历，E 为 D 的左子树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-55.png\" style=\"zoom:50%;\" />\n\n------\n\n我们来看一个例子：\n\n- 已知层序遍历序列：D A B E F C G H I (根 左子树的根 右子树的根)\n- 已知中序遍历序列：E A F D H C B G I (左 根 右)\n\n根据层序遍历序列，访问第一层，D 为根结点，根据中序遍历序列，(E A F)为左子树，(H C B G I)为右子树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-56.png\" style=\"zoom:50%;\" />\n\n根据层序遍历序列，访问第二层，首先出现的是A、B，则A 为左子树的根节点，B 为右子树的根节点。根据中序遍历，E 为 A 的左子树，F为 A 的右子树。 (H C )为 B 的左子树，(G I) 为 B 的右子树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-57.png\" style=\"zoom:50%;\" />\n\n根据层序遍历序列，访问第三层，首先出现的是 E、F、C、G，则 根节点分别为 C、G\n\n根据中序遍历，C 的左子树为 H，G 的右子树为 \n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-58.png\" style=\"zoom:50%;\" />\n\n### 线索二叉树\n\n#### 线索二叉树的作用\n\n普通二叉树有如下两个**问题**：\n\n- 普通二叉树遍历只能从根节点开始遍历，不能从一个指定结点开始中序遍历。\n- 普通二叉树中如果只知道指向当前结点的指针，没法找到当前结点在中序遍历序列的前驱。(例如下图中只知道指向 F 结点的指针 p，如何找到结点在中序遍历序列的前驱呢？)\n\n那么我们如何解决上述问题呢？\n\n<font color='red'>思路</font>：\n\n- 从根结点出发，重新进行一次中序遍历，指针 q 记录当前访问的结点，指针 pre 记录上一个被访问的结点(前驱)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-59.png\" style=\"zoom: 80%;\" />\n\n- 下一个结点被访问(visit)之前，我们需要将 pre 前驱指针指向 q 所指向的结点，然后 q 指针指向下一个要访问的结点\n\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-60.png\" style=\"zoom: 33%;\" />\n\n- 所以现在 pre 指针所指向的结点就是 q 指针所指向结点的中序遍历的前驱。用这样的思路我们可以让 q 不断的指向后一个被访问的结点，然后 pre 也跟着依次的向后移动。\n\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-61.png\" style=\"zoom: 33%;\" />\n\n- 当 q 和 p 指向了同一个结点，也就是 q == p，那么就说明 pre 所指向的结点就是 p 所指向结点的前驱\n\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-62.png\" style=\"zoom: 33%;\" />\n\n- 继续 pre 向后移， q 也向后移。此时 pre == p，则 q 所指向的结点就是 p 所指向结点的后继\n\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-63.png\" style=\"zoom: 33%;\" />\n\n<font color='orange'>上述的操作是非常不方便的，线索二叉树就是为了解决上述问题的。</font>\n\n**n 个结点的二叉树，有 n + 1 个空链域。我们可以利用这些空链域来记录前驱、后继的信息。**\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-215.png\" style=\"zoom:55%;\" />\n\n- 如上图，D 的左子树是空链域，因为 D 没有前驱结点，是第一个结点，所以让其左子树指向NULL\n- G 的左右子树都是空链域，让左子树指向其前驱结点 D，让右子树指向其后继结点 B\n- E 的左右子树都是空链域，让左子树指向其前驱结点 B，让右子树指向其后继结点 A\n- F 的左右子树都是空链域，让左子树指向其前驱结点 A，让右子树指向其后继结点 C\n- C 的右子树是空链域，因为 C 没有后继结点，是最后一个结点，所以让其右子树指向 NULL\n\n**定义**：一个结点的左孩子指针和右孩子指针指向的是前驱和后继而不是其左右孩子的话，我们把这种类型的指针称为线索，指向前驱的是前驱线索，指向后继的是后继线索。\n\n<font color='cornflowerblue'>那么还存在一个问题，如果我们的右孩子指针指向的就是右孩子而不是后继，那么如何找后继呢？</font>\n\n#### 线索二叉树的存储结构\n\n**普通二叉树**的链式存储结点:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-65.png\" style=\"zoom: 67%;\" />\n\n```C\n// 二叉树的结点(链式存储)\ntypedef struct BiTNode {\n    ElemType data;\n    struct BiTNode *lchild,*rchild;\n}BiTNode,*BiTree;\n```\n\n**线索二叉树**的链式存储结点:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-66.png\" style=\"zoom: 67%;\" />\n\n```C\n// 线索二叉树的结点\ntypedef struct ThreadNode{\n    ElemType data;\n    struct ThreadNode *lchild,*rchild;\n    int ltag,rtag;\t\t\t\t\t\t// 左、右线索标志\n}ThreadNode,*ThreadTree;\n```\n\n##### 中序线索二叉树的存储\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-216.png\" style=\"zoom: 55%;\" />\n\n以上是中序线索二叉树。而对于先序、后序线索二叉树来说，只不过是遍历序列的顺序变了，**利用左孩子指针充当前驱线索、右孩子指针充当后继线索**的思想是一样的。\n\n> 总之，线索二叉树的思想就是利用n个结点的二叉树的n+1个空链域，把这些空链域变成**线索**，指向前驱、后继。\n>\n> 而先序/中序/后续线索二叉树的区别，仅仅是遍历出来的序列是什么的区别。\n>\n> 一些术语：\n>\n> 先/中/后序前驱、先/中/后序后继——先/中/后序线索二叉树中的**线索**\n\n#### 先序线索二叉树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-68.png\" style=\"zoom:80%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-69.png\" style=\"zoom: 67%;\" />\n\n#### 后序线索二叉树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-217.png\" style=\"zoom:55%;\" />\n\n#### 三种线索二叉树的对比\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-218.png\" style=\"zoom:55%;\" />\n\n- 中序线索二叉树 ➡ 线索指向中序前驱、中序后继\n- 先序线索二叉树 ➡ 线索指向先序前驱、先序后继\n- 后序线索二叉树 ➡ 线索指向后序前驱、后序后继\n\n### 二叉树的线索化\n\n#### 中序线索化\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-72.png\" style=\"zoom: 50%;\" />\n\n中序遍历二叉树，<font color='orange'>一边遍历一边线索化</font>\n\n- 首先中序遍历左子树，首先访问到的是 D 结点，D 结点没有前驱，所以将 pre 指针指向NULL，并将标志修改为 1 (代表这个孩子指针是线索)\n\n- 之后访问下一个结点，pre 指向 q 指向的结点，q 指向下一个结点\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-73.png\" style=\"zoom:50%;\" />\n\n- 此时 q 指向的结点为 G，判断左子树，如果为空，则建立前驱线索并修改标志为 1 ，判断其右子树，如果为空，则建立后继线索并修改标志为 1\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-74.png\" style=\"zoom:50%;\" />\n\n- 当访问最后一个结点时，pre 和 q 均指向最后一个结点，要检查 pre-> rchild 是否为 NULL，如果是，则令标志为 1\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-75.png\" style=\"zoom:50%;\" />\n\n  ```C\n  // 线索二叉树的结点\n  typedef struct ThreadNode{\n      ElemType data;\n      struct ThreadNode *lchild,*rchild;\n      int ltag,rtag;\t\t\t\t\t\t// 左、右线索标志\n  }ThreadNode,*ThreadTree;\n  \n  // 中序遍历二叉树,一边遍历一边线索化\n  void InThread(ThreadTree T){\n      if(T != NULL){\n          InThread(T->lchild);\t\t// 中序遍历左子树\n          visit(T);\t\t\t\t\t// 访问根节点\n          InThread(T->rchild);\t\t// 中序遍历右子树\n      }\n  }\n  \n  // 全局变量 pre,指向当前访问结点的前驱(开始访问第一个结点,无前驱,所以指向NULL)\n  ThreadNode *pre = NULL;\n  \n  void visit(ThreadNode *q){\n      if(q->lchild == NULL){\t\t\t// 如果左子树为空,则建立前驱线索\n          q->lchild = pre;\n          q->ltag = 1;\n      }\n      if(pre != NULL && pre->rchild == NULL){\n          pre->rchild = q;\t\t\t// 建立前驱结点的后继线索\n          pre->rtag = 1;\n      }\n      pre = q;\n  }\n  \n  // 中序线索化二叉树T\n  void CreateInThread(ThreadTree T){\n      pre=NULL;\t\t\t\t\t\t// pre初始为NULL\n      if(T != NULL){\t\t\t\t\t// 非空二叉树才能线索化\n          InThread(T);\t\t\t\t// 中序线索化二叉树\n          if(pre->rchild == NULL){\n              pre->rtag=1;\t\t\t// 处理遍历的最后一个结点\n          }\n      }\n  }\n  ```\n\n#### 先序线索化\n\n先序遍历二叉树，<font color='orange'>一边遍历一边线索化</font>\n\n- 首先访问根结点，判断左右子树，发现左右子树都非空，则不操作，让 pre 指向 q所指向的结点，q指向下一结点\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-76.png\" style=\"zoom:50%;\" />\n\n- 访问结点 B，发现 B 的左右子树都非空，则不操作，让 pre 指向 q所指向的结点，q指向下一结点\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-77.png\" style=\"zoom:50%;\" />\n\n- 之后访问 D 结点，发现其左子树为空，则建立前驱线索(将其左子树指向前驱结点B)，之后我们就要先序遍历 D结点的左子树，但是发现此时左子树为 B，这样下去就会造成循环。所以我们在先序遍历二叉树时，要让左子树不是前驱线索时再进行\n\n  ```C\n  // 先序遍历二叉树,一边遍历一边线索化\n  void PreThread(ThreadTree T){\n      if(T != NULL){\n          visit(T);\t\t\t\t// 先处理根结点\n          if(T->ltag == 0){\t\t// lchild不是前驱线索\n              PreThread(T->lchild);\n          }\n          PreThread(T->rchild);\t// 先序遍历右子树\n      }\n  }\n  \n  // 全局变量 pre,指向当前访问结点的前驱\n  ThreadNode *pre = NULL;\n  void visit(ThreadNode *q){\n      if(q->lchild == NULL){\t\t\t// 如果左子树为空,则建立前驱线索\n          q->lchild = pre;\n          q->ltag = 1;\n      }\n      if(pre != NULL && pre->rchild == NULL){\n          pre->rchild = q;\t\t\t// 建立前驱结点的后继线索\n          pre->rtag = 1;\n      }\n      pre = q;\n  }\n  \n  // 先序线索化二叉树T\n  void CreateInThread(ThreadTree T){\n      pre=NULL;\t\t\t\t\t\t// pre初始为NULL\n      if(T != NULL){\t\t\t\t\t// 非空二叉树才能线索化\n          InThread(T);\t\t\t\t// 中序线索化二叉树\n          if(pre->rchild == NULL){\n              pre->rtag=1;\t\t\t// 处理遍历的最后一个结点\n          }\n      }\n  }\n  ```\n\n#### 后序线索化\n\n```C\n// 线索二叉树的结点\ntypedef struct ThreadNode{\n    ElemType data;\n    struct ThreadNode *lchild,*rchild;\n    int ltag,rtag;\t\t\t\t\t\t// 左、右线索标志\n}ThreadNode,*ThreadTree;\n\n// 后序遍历二叉树,一边遍历一边线索化\nvoid PostThread(ThreadTree T){\n    if(T != NULL){\n        PostThread(T->lchild);\t\t// 中序遍历左子树\n        PostThread(T->rchild);\t\t// 中序遍历右子树\n        visit(T);\t\t\t\t\t// 访问根节点\n        \n    }\n}\n\n// 全局变量 pre,指向当前访问结点的前驱(开始访问第一个结点,无前驱,所以指向NULL)\nThreadNode *pre = NULL;\n\nvoid visit(ThreadNode *q){\n    if(q->lchild == NULL){\t\t\t// 如果左子树为空,则建立前驱线索\n        q->lchild = pre;\n        q->ltag = 1;\n    }\n    if(pre != NULL && pre->rchild == NULL){\n        pre->rchild = q;\t\t\t// 建立前驱结点的后继线索\n        pre->rtag = 1;\n    }\n    pre = q;\n}\n\n// 后序线索化二叉树T\nvoid CreateInThread(ThreadTree T){\n    pre=NULL;\t\t\t\t\t\t// pre初始为NULL\n    if(T != NULL){\t\t\t\t\t// 非空二叉树才能线索化\n        InThread(T);\t\t\t\t// 中序线索化二叉树\n        if(pre->rchild == NULL){\n            pre->rtag=1;\t\t\t// 处理遍历的最后一个结点\n        }\n    }\n}\n```\n\n#### 总结\n\n![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-78.png)\n\n### 线索二叉树找前驱/后继\n\n#### 中序线索二叉树找中序后继\n\n例如：我们要在中序线索二叉树中找到指定结点 *p 的中序后继 next，next = p的右子树中最左下结点\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-219.png\" style=\"zoom:55%;\" />\n\n- 若 p -> rtag == 1, 说明右子树被线索化，那么右子树就是其中序后继，则 next = p -> rchild\n- 若 p-> rtag == 0,说明右子树未被线索化，右子树肯定是非空，则 p 必然有右孩子。\n\n> 由于我们是找中序后继，也就是从中序遍历来看，在访问这个结点后，访问的下一个结点是什么。而中序遍历的访问顺序是：左、根、右。所以按照中序遍历的规则，访问p结点这个根结点之后，需要再中序遍历p的右子树。那么，在p的右子树中第一个被访问的结点，就应该是p的后继。\n>\n> 假设p的右子树只有一个右孩子，也就是只有一个叶子结点，那么显然这个右孩子就是p的后继。\n>\n> 但是如果这个结点是一个分支节点，也就是再往下还有更深层的结点的话，那么要对这个右子树继续进行中序遍历（左、根、右）这样来看的话，那么这个右子树的最左下角的那个结点就应该是p的中序后继结点。\n\n```C\n// 找到以 P 为根的子树中,第一个被中序遍历的结点\nThreadNode *Firstnode(ThreadNode *p){\n    // 循环找到最左下结点(不一定是叶结点)\n    while(p->ltag == 0){\n        p = p->lchild;\n    }\n    return p;\n}\n\n// 在中序线索二叉树中找到结点 p 的后继结点\nThreadNode *Nextnode(ThreadNode *p){\n    // 右子树最左下结点(右子树当中第一个被遍历到的结点)\n    if(p->rtag == 0){\n        return Firstnode(p->rchild);\n    }else{\n        return p->rchild;\t\t// rtag == 1 直接返回后继线索\n    }\n}\n```\n\n既然我们能遍历到结点的后继结点，那么我们就可以对中序线索二叉树进行遍历\n\n```C\n// 对中序线索二叉树进行中序遍历(利用线索实现的非递归算法) \n// 传入我们要遍历的树的根节点的指针T\nvoid Inorder(ThreadNode *T){\n    for(ThreadNode *p = Firstnode(T);p != NULL;p=Nextnode(p)){\n        visit(p);\n    }\n}\n```\n\n#### 中序线索二叉树找中序前驱\n\n例如：我们要在中序线索二叉树中找到指定结点 *p 的中序前驱pre，pre= p的左子树中最右下结点\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-220.png\" style=\"zoom:55%;\" />\n\n- 若 p -> ltag == 1, 说明左子树被线索化，那么左子树就是其中序后继，则 pre = p -> lchild\n- 若 p-> ltag == 0,说明左子树未被线索化，那么左子树肯定非空，则 p 必然有左孩子。\n\n> 按照中序遍历的规则，（左、根、右），它的这个结点的前驱一定是它的左子树当中，按照中序遍历最后一个被访问的结点。\n>\n> 如果左子树只有一个叶子结点，那么显然它的这个左孩子就是它的中序前驱。\n>\n> 而如果左子树还有多层分级的话，总之，其左子树最右下的结点就是左子树当中最后一个被访问的结点。\n\n```C\n// 找到以p为根的子树中,最后一个被中序遍历的结点\nThreadNode *Lastnode(ThreadNode *p){\n    // 循环找到最右下结点(不一定是叶节点)\n    while(p->rtag == 0){\n        p = p->rchild;\n        return p;\n    }\n}\n\n// 在中序线索二叉树中找到结点p的前驱结点\nThreadNode *Prenode(ThreadNode *p){\n    // 左子树中最右下结点\n    if(p->ltag == 0){\n        return Lastnode(p->lchild);\n    }else{\n        return p->lchild;\t\t\t//ltag==1 直接返回前驱结点\n    }\n}\n```\n\n既然我们能遍历到结点的前驱结点，那么我们就可以对中序线索二叉树进行逆向中序遍历\n\n```C\n// 对中序线索二叉树进行逆向中序遍历\nvoid RevInorder(ThreadNode *T){\n    for(ThreadNode *p = Lstnode(T);p != NULL;p = Prenode(p){\n        visit(p);\n    })\n}\n```\n\n#### 先序线索二叉树找先序后继\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-221.png\" style=\"zoom:55%;\" />\n\n- 若 p -> rtag == 1, 说明右子树被线索化，那么右子树就是其先序后继，则 next= p -> rchild\n- 若 p-> rtag == 0,说明右子树未被线索化，那么右子树肯定非空，则 p 必然有右孩子。\n\n> 我们先假设它有左孩子。\n>\n> 然后按照先序遍历（根、左、右）的规则来看，p结点的后继结点肯定是它左子树当中第一个被访问的结点。也就是不论其左子树有多少层级，都是p的那一个左孩子结点。\n>\n> 再说，如果没有左孩子。\n>\n> 如果没有左孩子的话，根据根、左、右的原则，由于左为空，那么就是根、右。那么也就是它的右子树当中第一个被先序遍历的结点。也就是，无论它的右子树是叶子结点，还是多个层级的分支节点，都是p的右孩子结点。\n\n#### 先序线索二叉树找先序前驱\n\n在先序线索二叉树中找到指定结点p的**先序前驱**pre。\n\n- 若p->ltag == 1，则next = p->lchild。\n- 若p->ltag == 0，（说明p一定有左孩子）。\n\n> 按照先序遍历的规则（根、左、右）可知，p的左子树、右子树，都只可能是p的后继，而不可能是p的前驱。因此，我们不可能在它的左右子树当中，找到它的前驱。\n>\n> 而我们的线索二叉树，它只有指向它的孩子结点的指针，不可能往上找。\n>\n> 所以在这种情况下，我们是找不到p的先序前驱的。\n>\n> 除非，用从头遍历的土办法，来重新进行一次完整的先序遍历来找到p的前驱。\n\n> 但是我们说过，二叉链表其实我们可以在某些应用场景下，根据需要，把它改为三叉链表，即增加一个指向其父节点的指针。\n>\n> 那么在这种能找到它的父节点的情况下，我们再看，能不能找到它的先序前驱。\n>\n> 第一种情况：**能找到p的父节点，且p是左孩子**\n>\n> 按照先序遍历的规则（根、左、右）来看，p结点一定是在它的父节点被访问过之后，第一个被访问到的。因此**p的父节点一定是p的先序前驱**。\n>\n> 第二种情况：**能找到p的父节点，且p是右孩子，其左兄弟为空**\n>\n> 也就是p的父节点的左孩子为空。那么按照先序遍历的规则就应该是：根、右。因此，**p的父节点一定是它的先序前驱**。\n>\n> 第三种情况：**能找到p的父节点，且p是右孩子，其左兄弟非空**\n>\n> 按照先序遍历的规则（根、左、右），p这个结点的先序前驱，一定是它的左兄弟子树，按照先序遍历的顺序**最后一个被访问到的结点，也就是最右下的结点**。即**p的先序前驱为其左兄弟子树中最后一个被先序遍历访问的结点**。\n>\n> 第四种情况：**如果p没有父节点，也就是p是根结点，则p没有先序前驱**。\n\n#### 后序线索二叉树找后序前驱\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-163.png\" style=\"zoom: 50%;\" />\n\n在后序线索二叉树中找到指定结点p的**后续前驱**pre。\n\n- 若p->ltag == 1，则pre = p->lchild。\n- 若p->ltag == 0（说明它一定有左孩子，但是不一定有没有右孩子）\n\n> 先讨论假设它有右孩子的情况：\n>\n> 按照后序遍历的规则（左、右、根），可以看到，p的后序前驱，是p的右子树中，按照后序遍历的规则被访问到的最后一个结点，也就是右孩子结点本身。因此，**若p有右孩子，则后序前驱为其右孩子**。\n>\n> 假设它没有右孩子：\n>\n> 按照后序遍历的规则（左、根），可以看到，p的后序前驱，是p的左子树中，按照后序遍历的规则被访问到的最后一个结点，也就是左孩子本身。因此，**若p没有右孩子，则后序前驱为其左孩子**。\n\n#### 后序线索二叉树找后序后继\n\n在后序线索二叉树中找指定结点p的**后序后继**next。\n\n- 若p->rtag == 1，则next = p->rchild。\n- 若p->rtag == 0，（说明其一定有右孩子）\n\n> 按照后序遍历的规则（左、右、根）来看，p的左右子树均只有可能是它的前驱，而不可能是它的后继。\n>\n> 因此，后序遍历中，左右子树中的结点只可能是p的前驱，不可能是后继。\n>\n> 因此我们只能利用土办法，即从头到尾重新进行一次完整的后序遍历，才有可能找到它的后序后继。\n\n> 但是，还可以改用三叉链表找到父节点的方式来完成。\n>\n> 第一种情况，**能找到p的父节点，且p是右孩子**：\n>\n> 按照后序遍历的规则（左、右、根），无论p结点下面还有没有孩子，p结点一定是最后一个被访问的结点。而在访问过p结点之后，下一个一定紧接着是访问它的父节点。因此，**p的后序后继为p的父节点**。\n>\n> 第二种情况，**能找到p的父节点，且p是左孩子，其右兄弟为空**：\n>\n> 按照后序遍历的规则（左、根）。显然，无论如何，在访问完p结点之后，一定会紧接着访问它的父节点。因此，**p的后序后继为p的父节点**。\n>\n> 第三种情况，**能找到p的父节点，且p是左孩子，其右兄弟非空**：\n>\n> 按照后序遍历的规则（左、右、根）来看，p的后继，就应该是它的右兄弟子树当中，按照后序遍历第一个被访问的结点，也就是右兄弟子树最左下的结点。因此，**p的后序后继为右兄弟子树中第一个被后序遍历到的结点**。\n>\n> 第四种情况，**如果p是根结点，则p没有后序后继**。\n\n#### 总结\n\n对以上所有情况的讨论，我们只需要理解其逻辑过程，而不要去背结论\n\n|        | 中序线索二叉树 | 先序线索二叉树 | 后序线索二叉树 |\n| ------ | -------------- | -------------- | -------------- |\n| 找前驱 | ✔              | ×              | ✔              |\n| 找后继 | ✔              | ✔              | ×              |\n\n对先序线索二叉树来说，找先序前驱是不可以的；同样地，对于后续线索二叉树来说，找后序后继是不可以的。除非采用**三叉链表**，或者用**土办法**从整棵树的根结点重新进行完整的遍历来寻找其**父节点**。\n\n也就是，对于先序线索二叉树来说，给你一个结点，你只能从这个结点开始向后进行先序遍历。\n\n对于后续线索二叉树来说，给你一个结点，你只能从这个结点开始进行逆向的后序遍历。\n\n### 习题\n\n- 在二叉树中有两个结点 m 和 n，若 m 是 n 的祖先，则使用什么遍历方法可以找到 m 到 n 的路径 → 后序遍历\n\n- 在二叉树的前序序列、中序序列和后序序列中，所有叶子结点的先后顺序相同吗？若不全相同，则哪几种遍历方式的先后顺序相同 → 完全相同\n\n- 【2009】给定二叉树如右图所示。设N代表二叉树的根，L代表根结点的左子树，R代表根结点的右子树。若遍历后的结点序列是(3, 1, 7, 5, 6, 2, 4)，则其遍历方式是-->RNL\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-82.png\" style=\"zoom:85%;\" />\n\n  > 分析遍历后的结点序列，可以看出根结点是在中间访问，而右子树结点在左子树之前，即遍历的方式是 RNL 。本题考查的遍历方法并不是二叉树的 3 种基本遍历方法，对于考生而言，重要的是要掌握遍历的思想。\n  >\n  > - 前序遍历：根结点 -> 左子树 -> 右子树\n  > - 中序遍历：左子树 -> 根结点 -> 右子树\n  > - 后序遍历：左子树 -> 右子树 -> 根结点\n\n- 【2011】若一棵二叉树的前序遍历序列和后序遍历序列分别为{ 1, 2, 3, 4}和{4, 3, 2, 1}，则该二叉树的中序遍历序列不会是→C\n\n  A. 1234   B. 2341\n  C. 3241   D. 4321\n\n  > 前序序列为NLR，后序序列的逆序为LRN，要使NLR=NRL（后序序列的反序），则L或R为空，这样的二叉树每层就只有一个结点，高度为4。1为根结点，由于根结点只有左孩子或右孩子，因此在中序序列中，1或在序列首或在序列尾，ABCD皆满足。仅考虑以1的孩子结点2为根的子树，同理在中序序列中，2或在序列首或在序列尾，ABD皆满足，C不满足。\n\n- 【2012】若一棵二叉树的前序遍历序列为{ a, e, b, d, c}，后序遍历序列为{ b, c, d, e, a}，则根结点的孩子结点 → 只有 e\n\n  > 由先序遍历第一个结点为a,则可知道树的根节点为a。后序遍历序列中根节点会把序列分为左右两段，左段为左子树上结点，右段为右子树上结点，所以由后序遍历序列可知b,c,d,e均为a结点的左子树上的点，a不存在右子树。再由先序遍历序列知道e为根结点a的左孩子结点。即根节点的孩子结点只有e，且为左孩子。\n\n- 【2013】若X是后序线索二叉树中的叶结点，且X存在左兄弟结点Y，则X的右线索指向的是-->A\n\n  A. X的父结点\n  B. 以Y为根的子树的最左下结点\n  C. X的左兄弟结点Y\n  D. 以Y为根的子树的最右下结点\n\n  > 根据题意，x存在左兄弟结点y,说明x是右边的那个结点\n  >\n  > 由于是后序线索二叉树，后序遍历的规则是DLR，X的后继就是其双亲结点\n  >\n  > 因此右线索指向的是：X的父结点\n\n- 【2014】若对下图所示的二叉树进行中序线索化，则结点X的左、右线索指向的结点分别是-->b，a\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-84.png\" style=\"zoom: 80%;\" />\n\n  > 中序线索化即根据中序遍历的顺序，找出该字母的前驱和后继。中序遍历结果为debxac。x的前驱是b，后继是a。所以结点x的左、右线索指向的结点分别是b，a。\n\n- 【2015】先序序列为a,b,c,d的不同二叉树的个数是-->14\n\n  > 根据二叉树前序遍历和中序遍历的递归算法中递归工作栈的状态变化得出：前序序列和中序序列的关系相当于以前序序列为入栈次序，以中序序列为出栈次序。因为前序序列和中序序列可以唯一地确定一棵二叉树，所以题意相当于“以序列 a,b,c,d 为入栈次序，则出栈序列的个数为？”，对于 n 个不同元素进栈，出栈序列的个数为14\n\n- 【2017】某二叉树的树形如图所示，其后序序列为e,a,c,b,d,g,f，树中与结点a同层的结点是-->d\n\n  ![](https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-85.png)\n\n  > 后序序列是先左子树，接着右子树，最后父结点，递归进行。根结点左子树的叶结点首先被访问，它是e。接下来是它的父结点a,然后是a的父结点c。接着访问根结点的右子树。它的叶结点b首先被访问，然后是b的父结点d，再后是d的父结点g,最后是根结点f,如右图所示。因此d与a同层。\n\n- 【2017】要使一棵非空二叉树的先序序列与中序序列相同，其所有非叶结点须满足的条件是-->B\n\n  A. 只有左子树\n  B. 只有右子树\n  C. 结点的度均为1\n  D. 结点的度均为2\n\n  > 先序序列是先父结点，接着左子树，然后右子树。中序序列是先左子树，接着父结点，然后右子树，递归进行。如果所有非叶结点只有右子树，先序序列和中序序列都是先父结点，然后右子树，递归进行，因此B正确。\n\n- 线索二叉树是一种什么结构？「逻辑、逻辑和存储、物理、线性」?→ 物理\n\n- 一棵左子树为空的二叉树在先序线索化后，其中空的链域的个数是 →2 个\n\n- 【2010】下列线索二叉树中(用虚线表示线索)，符合后序线索树定义的是-->D\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-83.png\" style=\"zoom:67%;\" />\n\n  > 题中所给二叉树的后序序列为dbca。结点d无前驱和左子树，左链域空，无右子树，右链域指向其后继结点b；结点b无左子树，左链域指向其前驱结点d；结点c无左子树，左链域指向其前驱结点b，无右子树，右链域指向其后继结点a。\n\n- 二叉树在线索化后，仍不能有效求解的问题是？→D\n\n  A 先序线索二叉树中求先序后继\n  B 中序线索二叉树中求中序后继\n  C 中序线索二叉树中求中序前驱\n  D 后序线索二叉树中求后序后继 \n\n- （ ）的遍历仍需要栈的支持→C\n\n  A 前序线索树\n  B 中序线索树\n  C 后序线索树\n  D 所有线索树 \n\n- 综合【2014】二叉树的带权路径长度(WPL)是二叉树中所有叶结点的带权路径长度之和。给定一棵二叉树T，采用二叉链表存储，结点结构为\n\n  | left | weight | right |\n  | ---- | ------ | ----- |\n\n  其中叶节点的weight域保存该结点的非负权值。设root为指向T的根节点的指针，设计求T的WPL的算法。要求：\n\n  （1）给出算法的基本设计思想；\n\n  （2）使用C或C++语言，给出二叉树结点的数据类型定义；\n\n  （3）根据设计思想，采用C或C++语言描述算法，关键之处给出注释。\n\n  > (1)算法的基本设计思想： \n  >\n  > ① 基于先序递归遍历的算法思想是用一个static变量记录wpl，把每个结点的深度作为递归函数的一个参数传递，算法步骤如下： \n  >\n  > 若该结点是叶子结点，那么变量wpl加上该结点的深度与权值之积； \n  >\n  > 若该结点非叶子结点，那么若左子树不为空，对左子树调用递归算法，若右子树不为空，对右子树调用递归算法，深度参数均为本结点的深度参数加1；\n  >\n  > 最后返回计算出的wpl即可。 \n  >\n  > ② 基于层次遍历的算法思想是使用队列进行层次遍历，并记录当前的层数， \n  >\n  > 当遍历到叶子结点时，累计wpl； \n  >\n  > 当遍历到非叶子结点时对该结点的把该结点的子树加入队列； \n  >\n  > 当某结点为该层的最后一个结点时，层数自增1； \n  >\n  > 队列空时遍历结束，返回wpl。\n  >\n  > (2)算法中使用的二叉树结点的数据类型定义如下：\n  >\n  > ```C\n  > typedef struct BiTNode{\n  > int weight;\n  > struct BiTNode *lchild,*rchild;\n  > }BiTNode,*BiTree;\n  > ```\n  >\n  > (3)代码实现\n  >\n  > ```C\n  > int WPL(BitNode root)\n  > {\n  > return wplPreOrder(root,0);\n  > }\n  > int wplPreOrder(BitNode root,int deep)\n  > {\n  > static int wpl=0;\n  > if(root->left= =NULL && root->right= =NULL)//若为叶结点，则累积WPL\n  > {\n  >   wpl+=deep*root->weight;\n  > }\n  > if(root->left! =NULL)\n  > {\n  >   wplPreOrder(root->left,deep+1);//如果左子树不为空，则对左子树进行递归遍历\n  > }\n  > if(root->right! =NULL)\n  > {\n  >   wplPreOrder(root->right,deep+1);//如果右子树不为空，则对右子树进行递归遍历\n  > }\n  > return wpl;//返回WPL值\n  > }\n  > ```\n","tags":["408数据结构"],"categories":["408数据结构"]},{"title":"第五章 树与二叉树(上)","url":"/p/63944/","content":"\n## 5.1 树的基本概念\n\n### 树的定义\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-1.png\" style=\"zoom:67%;\" />\n\n空树：结点数为 0 的树\n\n非空树的特性:\n\n- 有且仅有一个根结点\n- 没有后继的结点称为叶子结点(或者终端结点)\n- 有后继的结点称为分支结点(或者非终端结点)\n- 除了根节点外，任何一个结点都有且仅有一个前驱\n- 每个结点可以有 0 个或多个后继结点。\n\n**除了根结点外，任何一个结点都有且仅有一个前驱**\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-2.png\" style=\"zoom:67%;\" />\n\n树是 n(n≥0) 个结点的有限集合，n = 0 时，称为空树，这是一种特殊情况。在任意一棵非空树中应满足：\n\n1. 有且仅有一个特定的称为根的结点。\n2. 当 n > 1 时，其余结点可分为 m(m>0) 个互不相交的有限集合T1,T2,…Tm，其中每个集合本身又是一棵树，并且称为根结点的子树。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-3.png\" style=\"zoom:67%;\" />\n\n### 基本术语\n\n- 根结点：非空树种无前驱结点的结点\n- 结点的度：结点拥有的子树数\n- 树的度：树内各结点的度的最大值\n- 叶子（终端结点）：没有后继元素（度 = 0）\n- 分支结点（非终端结点）：度 != 0；\n- 内部结点：根结点以外的分支结点\n- 孩子，双亲：结点的子树的根称为该结点的孩子，该结点称为孩子的双亲\n- 兄弟结点：有共同的双亲\n- 堂兄弟：双亲在同一层的结点\n- 结点的祖先：从根到该结点所经分支上的所有结点\n- 结点的子孙：以某结点为根的子树中的任一结点\n- 树的深度：树中结点的最大层次\n- 有序树：树中结点的各子树从左至右有次序（最左边为第一个孩子）\n- 无须树：树中结点的各子树无次序\n- 森林：是m（m≥0）棵互不相交的树的集合，把根结点删除，树就变成了森林，一棵树可以看成是一个特殊的森林，给森林中的各子树加上一个双亲结点，森林就变成了树（树一定是森林，森林不一定是树）\n\n### 结点之间的关系描述\n\n如图就是一棵树的结构：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-4.png\" style=\"zoom: 50%;\" />\n\n- 结点：树的结点包含**一个数据元素和若干指向其子树的分支。**\n- 祖先结点：从根结点到该结点**所经过分支上的所有结点**。例如图中 K 的祖先结点有 E、B、A\n- 子孙结点：以某结点为根的子树中的任一结点都称为该结点的子孙。例如图中 A 的子孙结点是下面所有结点。\n- 双亲结点：一个结点的直接前驱就是它的双亲结点。例如图中 B、C、D 的双亲结点是 A\n- 孩子结点：一个结点的直接后继就是孩子结点。例如图中 A 的孩子结点是 B、C、D\n- 兄弟结点：具有相同**双亲结点** (即同一个前驱)的结点称为兄弟结点。例如图中 B、C、D 为兄弟结点\n- 两个结点之间的路径：只能**从上往下** 。例如结点 A 和结点 E 之间有路径，结点 E 与 结点 G 之间没有路径。\n- 两个结点之间的路径长度：一个结点到另一个结点之间经过了几条边。例如 A 到 E 的路径长度为 2\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-5.png\" style=\"zoom:50%;\" />\n\n`属性`：\n\n- 结点的层次(深度) ： 从上往下数，默认从 1 开始(有的教材默认从 0 开始，也不要奇怪，见题拆题)\n  - 深度为 1 是 A 结点\n  - 深度为 2 是 B、C、D结点\n  - 深度为 3 是 E、F、F、H、I、J 结点\n  - 深度为 4 是 K、L、M 结点\n- 结点的高度：从下往上数，默认从 1 开始\n  - 高度为 1 是 K、L、M 结点\n  - 高度为 2 是 E、F、F、H、I、J 结点\n  - 高度为 3 是 B、C、D结点\n  - 高度为 4 是 A 结点\n- 结点的度：有几个孩子(分支) 就有几个度\n  - 结点 B 有两个分支，结点 B 的度为 2\n  - 结点 C 有一个分支，结点 C 的度为 1\n  - 结点 D 有三个分支，结点 D 的度为 3\n  - 结点 M 是叶子结点，结点 M 的度为 0\n- 树的度：各结点的度的最大值。也就是树中分支数最多\n  - 结点 A 、D 的分支最多为 3 ，所以树的度为 3\n\n### 有序树、无序树、森林\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-6.png\" style=\"zoom:67%;\" />\n\n- 有序树：树中各子树从左到右是有次序的，不能互换，互换会导致含义发生错误。\n- 无序树：树种各子树从左到右是无次序的，可以更换\n- 森林：森林是 m(m≥0) 棵互不相交的树的集合\n\n### 树的性质\n\n- 树中的结点数等于所有结点的度数之和加1 \n\n- 度为m的树中第i层上至多有\n  $$\n  m^{i-1}\n  $$\n  个结点（i≥1）\n\n- 高度为h的m叉树至多有\n  $$\n  (m^h-1)/(m-1)\n  $$\n   个结点\n\n- 具有n个结点的m叉树的最小高度为\n  $$\n  \\lceil  \\log_m{(n(m-1)+1)} \\rceil\n  $$\n  \n\n### 树常考性质\n\n#### 结点数 = 总度数 + 1\n\n结点的度 = 结点有几个孩子(分支)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-7.png\" style=\"zoom:50%;\" />\n\n#### 度为 m 的树和 m 叉树\n\n- 度为 m 的树：各结点的度的最大值为 m\n- m 叉树：每个结点最多只能有 m 个孩子的树\n\n| 度为 m 的树                      | m 叉树                        |\n| :------------------------------- | :---------------------------- |\n| 任意结点的度 ≤ m(最多m个孩子)    | 任意结点的度 ≤ m(最多m个孩子) |\n| 至少有一个结点度 = m (有m个孩子) | 允许所有结点的度都 < m        |\n| 一定是非空树，至少有 m+1 个结点  | 可以是空树                    |\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-8.png\" style=\"zoom:67%;\" />\n\n#### 度为 m 的树第 i 层至多有 m^(i-1) 个结点(i ≥ 1)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-9.png\" style=\"zoom:67%;\" />\n\n所以，第i层：m^(i-1)个结点\n\n同理，**我们也可以说m叉树的第i层至多有m^(i-1)个结点（i≥1）**\n\n> 因为不管是度为m的树，还是m叉树，本质上都是在说每个节点最多允许有m个孩子。\n\n#### 高度为 h 的 m 叉树至多有 (m^h -1)/(m-1) 个结点\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-10.png\" style=\"zoom:67%;\" />\n\n#### 高度为 h 的 m 叉树至少有 h 个结点\n\n> 对于**m叉树**，我们只是规定了每个结点的孩子结点的上限是多少个，没有规定它的下限。\n\n所以高度为h的m叉树，结点最少的情况，就是从根结点一直往下，每一个结点都只有一个孩子的情况。所以至少有h个结点。\n\n**对于高度为h、度为m的树，至少有h+m-1个结点。**\n\n这是因为，首先我们让它从根结点一路向下，每一个结点都只有一个孩子。但是由于度为m的树，要保证至少有一个结点有m个孩子，所以还要加上m-1。即h+m-1。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-11.png\" style=\"zoom: 67%;\" />\n\n#### 具有n个结点的m叉树的最小高度\n\n对于n个结点的m叉树，想让它的高度最小，那么就想尽可能的让每一个结点都有尽可能多的孩子，也就是会有m个孩子。这样一来，这个树就会往宽处达到最宽，高度从而就最小了。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-12.png\" style=\"zoom:67%;\" />\n\n**总结**\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-13.png\" style=\"zoom:67%;\" />\n\n### 习题\n\n- 思考：树中的结点数等于→所有结点的度数之和+1\n\n- 树的路径长度是从树根到每个结点的路径长度的什么→总和，注意与哈夫曼树的带权路径长度的区别\n\n- 【2010】在一棵度为4的树T中，若有20个度为4的结点，10个度为3的结点，1个度为2的结点，10个度为1的结点，则树T的叶节点个数为多少 ?→82\n\n  > 任何一棵树中，结点个数比分支个数多一 \n  >\n  > 分支个数等于20x4+10x3+1x2+10x1=122 \n  >\n  > 所以这棵树一共有123个结点 \n  >\n  > 度不为零的结点数目为20+10+1+10=41 \n  >\n  > 所以叶子结点也就是度为零的结点个数为123-41=82\n\n## 5.2 二叉树的概念\n\n### 二叉树的定义\n\n每个结点至多只有两棵子树，且子树有左右之分\n\n二叉树是 n (n≥0) 个结点的有限集合。\n\n- 或者为空二叉树，即 n = 0\n- 或者由一个根节点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-14.png\" style=\"zoom:67%;\" />\n\n特点：\n\n1. 每个结点至多只有两棵子树\n2. 左右子树不能颠倒(二叉树是有序树)\n\n### 几个特殊的二叉树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-15.png\" style=\"zoom:67%;\" />\n\n#### 满二叉树\n\n满二叉树：**一棵高度为 h，且含有 2^h -1 个结点的二叉树**，即树中的每层都含有最多的结点。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-16.png\" style=\"zoom: 50%;\" />\n\n特点：\n\n1. 只有最后一层有叶子结点\n2. 不存在度为 1 的结点\n3. 按层序从 1 开始编号，结点 i 的左孩子为 2i，右孩子为 2i+1，结点 i 的父节点为 [ i / 2] (如果有的话) **[ i / 2 ]向下取整**。<font color='orange'>这个特性是很重要的，可以通过这个特性，使得我们能够用顺序存储的方式来存储这些结点。</font>\n\n#### 完全二叉树\n\n完全二叉树：当且仅当其每个结点都与高度为 h 的满二叉树中编号为 1~n 的结点一一对应时，称为完全二叉树。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-17.png\" style=\"zoom: 50%;\" />\n\n> 可以这么理解：满二叉树已经满了，不可能再有更多的结点。\n>\n> 而完全二叉树是什么呢？就是在满二叉树的基础上，可以把一些编号更大的结点，依次给去掉。（如此处将13、14、15去掉）\n>\n> 若只把结点13去掉，则其后面的14、15的编号，要改为13、14。这样一来，其每个结点的编号就不与满二叉树一一对应了，就不是完全二叉树了。\n\n可见，**满二叉树是一种特殊的完全二叉树**。**而完全二叉树不一定是满二叉树**。\n\n那么，由于我们将最后一层编号更大的结点去除了，那么就会在倒数第二层，出现叶子结点。而且不难理解，完全二叉树只有最后两层可能有叶子结点。且最多只有一个度为1的结点。\n\n特点：\n\n1. 只有最后两层可能有叶子结点。\n\n2. 同时只有一个度为 1 的结点\n\n3. 按层序从 1 开始编号，结点 i 的左孩子为 2i，右孩子为 2i+1，结点 i的父节点为 ⌊i/2⌋ (如果有的话) \n\n4. i ≤ ⌊n/2⌋ 为分支结点, i > ⌊n/2⌋为叶子结点\n\n5. 在完全二叉树中,如果某结点只有一个孩子,那么一定是左孩子\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-18.png\" style=\"zoom:67%;\" />\n\n<font color='red'>上图右下角纠正:如果结点是右孩子，那么就不是完全二叉树</font>\n\n#### 二叉排序树\n\n**二叉排序树**：一棵二叉树或者空二叉树，或者具有如下性质的二叉树:\n\n- 左子树上所有结点的关键字均**小于根结点**的关键字\n- 右子树上所有结点的关键字均**大于根节点**的关键字\n- 左子树和右子树又各是一棵二叉排序树\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-19.png\" style=\"zoom:67%;\" />\n\n**二叉排序树用于元素的排序、搜索**\n\n#### 平衡二叉树\n\n平衡二叉树：树上任一结点的**左子树**和**右子树**的**深度之差不超过 1**\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-20.png\" style=\"zoom:67%;\" />\n\n可以看出，**平衡二叉树能有更高的搜索效率**。\n\n其实平衡二叉树，就是希望一棵树在生长的时候，尽可能的往宽处长，而高度是在当前状态下的最小高度。这样一来，我们在向下搜索的过程中，搜索的次数也便是最少的了。\n\n#### 总结\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-21.png\" style=\"zoom: 80%;\" />\n\n### 二叉树的性质\n\n- 非空二叉树上的叶子结点数等于?→ 度为 2 的结点数加 1，即\n  $$\n  n_0=n_2+1\n  $$\n\n- 非空二叉树上第 k 层上至多有多少个结点，总共至多有多少个结点\n  $$\n  2^{k-1}\n  $$\n   个结点\n\n- 高度为 h 的二叉树至多有多少个结点?→\n  $$\n  2^h-1\n  $$\n   个结点\n\n- 对完全二叉树按从上到下、从左到右的顺序依次编号 1，2，...，n，则有以下关系\n\n  - ① 当 i >1 时，结点 i 的双亲的编号为 ⌊i/2⌋，即当 i 为偶数时，其双亲编号为 i/2，它是双亲的左孩子；当 i 为奇数时，其双亲的编号为 (i-1) / 2，它是双亲的右孩子\n\n  - ② 当 2i ≤ n 时，结点 i 的左孩子编号为 2i，否则无左孩子\n\n  - ③ 当 2i + 1 ≤ n 时，结点 i 的右孩子编号为 2i，否则无右孩子\n\n  - ④ 结点 i 所在的层次（深度）为 \n    $$\n    \\lfloor \\log_2 i\\rfloor+1\n    $$\n\n- 具有 n 个（n > 0）结点的完全二叉树的高度为\n  $$\n  \\lceil\\log_2(n+1)\\rceil或\\lfloor\\log_2n\\rfloor+1\n  $$\n\n### 二叉树常考性质\n\n#### 叶子结点比二分支结点多一个\n\n设非空二叉树中度为 0、1 和 2 的结点个数分别为 n0 、n1 、n2 ，则 n0 = n2 + 1\n\n(叶子结点比二分支结点多一个)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-22.png\" style=\"zoom: 80%;\" />\n\n#### 二叉树第 i 层至多有 2^(i-1) 个结点(i≥1)\n\n之前讨论过的 m叉树 第 i 层至多有 m^(i-1) 个结点(i≥1)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-23.png\" style=\"zoom: 67%;\" />\n\n#### 高度为 h 的二叉树至多有 2^h -1 个结点(满二叉树)\n\n之前讨论过的 高度为 h 的 m 叉树至多有 (m^h -1) / (m-1) 个结点\n\n### 完全二叉树常考性质\n\n#### 具有n个(n>0)结点的完全二叉树的高度\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-24.png\" style=\"zoom: 80%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-25.png\" style=\"zoom: 80%;\" />\n\n#### 对于完全二叉树，可以由结点数n推出度为 0、1和2的结点个数\n\n对于完全二叉树，可以由结点数n推出度为 0、1和2的结点个数，n0、n1和n2\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-26.png\" style=\"zoom: 80%;\" />\n\n### 二叉树的存储结构\n\n#### 顺序存储结构\n\n```C\n#define MaxSize 100\nstruct TreeNode {\n    ElemType value;\t\t\t// 结点中的数据元素\n    bool isEmpty;\t\t\t// 结点是否为空\n}\nTreeNode t[MaxSize];\n//定义一个长度为MaxSize的数组t，按照从上至下、从左至右的顺序依次存储完全二叉树中的各个结点 \n//在初始化这个数组的时候，我们要把所有的元素的结点先初始化为空。\nfor(int i=0; i<MaxSize;i++){\n    t[i].isEmpty = true;\t\t// 初始化时所有结点标记为空\n}\n```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-27.png\" style=\"zoom: 80%;\" />\n\n**几个重要常考的基本操作**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-28.png\" style=\"zoom:80%;\" />\n\n上述是完全二叉树的存储，那么对于一棵不是完全二叉树而言又如何存储呢？**如果不是完全二叉树，依然按层序将各结点顺序存储，那么无法从结点编号反映出结点点的逻辑关系**。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-29.png\" style=\"zoom:80%;\" />\n\n所以对于二叉树的顺序存储中，**一定要把树的结点编号与完全二叉树对应起来**。这样我们就可以通过结点编号来算出左孩子、右孩子、父节点，但是无法通过结点编号 i 与结点总数 n 作比较，来进行判断。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-30.png\" style=\"zoom:80%;\" />\n\n我们可以看到，这样存储的话会浪费很多存储单元，**所以对于二叉树的顺序存储结构，只适合存储完全二叉树。**\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-31.png\" style=\"zoom:67%;\" />\n\n#### 链式存储结构\n\n```c\n// 二叉树的结点(链式存储)\ntypedef struct BiTNode{\n    ElemType data;\t\t\t\t\t// 数据域\n    struct BiTNode *lchild,*rchild; // 左、右孩子指针\n}BiTNode,*BiTree;\n```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-32.png\" style=\"zoom:80%;\" />\n\n如果一个结点没有左孩子，我们可以将对应的指针设为 null。\n\n思考：<font color='cornflowerblue'>在含有 n 个结点的二叉链表中，含有多少个空链域？</font>→n+1个空链域\n\n若共有n个结点，会有2n个指针，除了根结点之外，其他结点头上都会连一个指针，也就是说有n-1结点的头上也会连接有一个指针(除了头结点外，每个结点被指1次)，所以这2n个指针中会有(2n-(n-1))= n+1个指向 null。即**n个结点的二叉链表共有n+1个空链域**。\n$$\n1n_0+1n_1+1n_2=n \\quad结点数之和\n$$\n\n$$\n0n_0+1n_1+2n_2=n-1 \\quad度和结点关系\n$$\n\n$$\n2n_0+1n_1+0n_2=? \\quad求空链域\n$$\n\n> 实际上，这些空链域可以被利用起来，**用于构造线索二叉树**（这是之后会学到的内容）\n\n**初始化一个二叉树**\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-33.png\" style=\"zoom: 50%;\" />\n\n由于每个节点都有两个指针，我们也把这种实现叫做二叉链表。\n\n```C\nstruct ElemType{\n    int value;\n};\n\n// 二叉树的结点(链式存储)\ntypedef struct BiTNode{\n    ElemType data;\t\t\t\t\t// 数据域\n    struct BiTNode *lchild,*rchild; // 左、右孩子指针\n}BiTNode,*BiTree;\n\n// 定义一棵空树\nBiTree root = NULL;\n\n// 插入根节点\nroot = (BiTree) malloc(sizeof(BiTNode));\nroot->data = {1};\t\t\t\t\t\t\t// 根节点数据域为 1\nroot->lchild = NULL;\t\t\t\t\t\t// 根节点左孩子指向NULL\nroot->rchild = NULL;\t\t\t\t\t\t// 根节点右孩子指向NULL\n\n// 插入新结点\nBiTNode *p = (BiTNode *)malloc(sizeof(BiTNode));\np->data = {2};\t\t\t\t\t\t\t\t// 新节点数据域为 2\np->lchild = NULL;\t\t\t\t\t\t\t// 新节点左孩子为NULL\np->rchild = NULL;\t\t\t\t\t\t\t// 新节点右孩子为NULL\nroot->lchild = p;\t\t\t\t//新节点作为根结点的左孩子\n```\n\n根据链式存储我们要找到指定结点 p 的左/右孩子，只需要查看结点 p 的左右孩子指针指向的结点即可。\n\n<font color='cornflowerblue'>可是如何找到指定结点 p 的父结点呢？</font>就只能从根节点开始遍历寻找，看看哪一个结点的左孩子或者右孩子是指向p结点的。显然，若整个树很大，那么这一操作还是很耗时的。因此，若你的应用场景当中，经常需要找某结点的父节点的话，你可以再给结点添加一个指针域，用来存放该结点的父节点指针。(考研一般不喜欢这么考)\n\n再来看看三叉链表，它的结点类型定义如下\n\n```c\n// 二叉树的结点(链式存储)\ntypedef struct BiTNode{\n    ElemType data;\t\t\t\t\t// 数据域\n    struct BiTNode *lchild,*rchild; // 左、右孩子指针\n    struct BiTNode *parent;\t\t\t// 父结点指针\n}BiTNode,*BiTree;\n```\n\n### 习题\n\n- 设二叉树有2n个结点，且m<n，则不可能存在（）的结点→C\n\n  A n个度为0\n  B 2m个度为0\n  C 2m个度为1\n  D 2m个度为2\n\n- 【2009】已知一棵完全二叉树的第6层（设根为第1层）有8个叶结点，则完全二叉树的结点个数最多是?→111\n\n  > 完全二叉树比满二叉树只是在最下面一层的右边缺少了部分叶结点，而最后一层之上是个满二叉树，并且只有最后两层有叶结点。第6层有叶结点则完全二叉树的高度可能为6或7，显然树高为7时结点更多。若第6层上有8个叶结点，则前六层为满二叉树，而第7层缺失了8×2=16个叶结点，故完全二叉树的结点个数最多为(27-1)-16=111个结点。\n  >\n  > 若问最少那么就六层树，树才只有六层并且叶子节点在第六层的前面。最少就是前五层满2＾5－1＋8＝39个。\n\n- 【2011】若一棵完全二叉树有768个结点，则该二叉树中叶结点的个数为→384\n\n  > 完全二叉树，只有在第一层和叶节点层上节点个数可能是奇数个，根节点本来就是奇数的，所以总数为偶数时应该先减一得到叶节点是否包含无兄弟的叶子。显然此题包含一个只有左子节点的节点，既n1等于1。n=n0+n1+n2。768-1-1=2n2。n2=383所以n0=n2+1=384\n\n- 【2018】设一棵非空完全二叉树T的所有叶结点均位于同一层，且每个非叶结点都有2个子节点。若T有k个叶结点，则T的结点总数是→2k-1\n\n  > 一棵非空完全二叉树T的所有叶结点均位于同一层，且每个非叶结点都有2个子结点就是满二叉树。\n  >\n  > 则有 k = 2^(h-1)， T的结点总数n=2^(h-1)-1+k = 2k-1\n\n- 【2020】对于任意一棵高度为5且有10个结点的二叉树，若采用顺序存储结构保存，每个结点占1个存储单元（仅存放结点的数据信息），则存放该二叉树需要的存储单元数量至少是→31\n\n  > 因为是顺序存储结构保存，所以需要的存储单元是给定高度的全部结点都要考虑。\n  > 高度为5的满二叉树共有：\n  > 25-1=31个结点\n  > 31*1个存储单元=31；\n","tags":["408数据结构"],"categories":["408数据结构"]},{"title":"第四章 串","url":"/p/17647/","content":"\n## *4.1 串的定义和实现\n\n### 什么是串\n\n字符串，简称串，是由零个或多个字符组成的<font color='orange'>有限序列</font>。一般记为 S = ‘a1a2…an’(n≥0)\n\n其中，S 是串名，单引号括起来的字符序列是串的值，ai 可以是字母、数字或其他字符；串中字符的个数 n 称为串的长度。n = 0 时的串称为空串。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-42.png\" style=\"zoom:55%;\" />\n\n串是一种<font color='orange'>特殊</font>的<font color='orange'>线性表</font>，数据元素之间呈<font color='orange'>线性关系</font>\n\n它们的区别是:\n\n- 普通的线性表里面可以存放各种各样的数据类型，是不做限制的。串的数据对象限定为字符集(如中文字符、英文字符、数字字符、标点字符等)\n\n- 普通的线性表，我们在进行增删改查等基本操作时，一般是对线性表中的某**一个数据元素**进行操作。\n\n  而我们对串的基本操作，如增删改查等，**通常以子串为操作对象**。也就是一次是对一堆字符进行操作的。\n\n### 串的存储结构\n\n#### 串的顺序存储\n\n结构类型定义（本质上就是字符数组）\n\n**静态数组实现**:定长顺序存储\n\n```c\n#define MAXLEN 255\t\t\t// 预定义最大串长为255\ntypedef struct{\n    char ch[MAXLEN];\t\t// 每个分量存储一个字符\n    int lenght;\t\t\t\t// 串的实际长度\n}SString;\t\t\n```\n\n<font color='orange'>静态数组的缺点</font>就是它的**缺点**：长度不可变。\n\n用静态数组实现串，因此它也叫**串的定长顺序存储**。\n\n顺序存储在内存中有如下四种方案：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-43.png\" style=\"zoom:55%;\" />\n\n- 方案一：会在串的末尾增添一个存储单元，用来存储串的长度变量 Length\n\n\n- 方案二：让 ch[0] 的位置来存储串的长度变量 Length，这样做的优点是字符的位序就和数组下标相同。但缺点是 ch[0] 相当于一个存储单元 1B，这样也只能存储 0~255 的数字范围\n\n\n- 方案三：去掉 Length 变量，在串末尾插入 \\0 表示结尾。缺点是如果经常需要访问串的长度，那么每次都需要对串进行遍历\n\n由方案一和方案二，我们可以想到一个两者兼备的方案，如下方案四所示。\n\n\n- 方案四：是王道书上的，ch[0] 位置不存储元素，并在串的末尾增添一个存储单元，用来存储串的长度变量 Length。这样既保证了字符的位序就和数组下标相同，也可以记录串的长度\n\n**动态数组实现**:堆分配存储\n\n```C\ntypedef struct{\n    char *ch;\t\t\t\t// 按串长分配存储区,ch指向串的基地址\n    int lenght;\t\t\t\t// 串的长度\n}HString;\n\nS.ch = (char *)malloc(MAXLEN * sizeof(char));\t\t\t// 用完需要手动 free\nS.lenght = 0;\n```\n\nmalloc方式申请的存储空间，在内存中是在堆区当中的，因此这种方法实现的，叫**堆分配存储**。同时，堆区中分配的内存空间需要手动的free释放。\n\n<font color='orange'>这两种方式的优缺点，和顺序表的不同实现方式的优缺点是一样的。</font>\n\n#### 串的链式存储\n\n用一个结点存字符，再用一个指针指向下一个结点。\n\n- char 的大小只有 1B，指针大小 4B\n- 这就意味着我们使用 1 个字节的大小来存储信息，还要使用 4 个字节的大小来存储辅助信息。\n\n和线性表的链式存储的一样的，只不过我们每个结点保存的数据的类型为`char`。\n\n```C\ntypedef struct StringNode{\n    char ch;\t\t\t\t// 每个结点存1个字符\n    struct StringNode *next;\n}StringNode,*String;\n```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-3.png\" style=\"zoom: 67%;\" />\n\n这种情况，我们把它称为**存储密度低**。即实际存储的信息比例很小。\n\n如何解决存储密度低的问题呢？<font color='cornflowerblue'>我们可以让每个结点存多个字符</font>\n\n```C\ntypedef struct StringNode{\n    char ch[4];\t\t\t\t// 每个结点存多个字符\n    struct StringNode *next;\n}StringNode,*String;\n```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-4.png\" style=\"zoom: 55%;\" />\n\n> 此处写的是4个，实际也可以更多。\n>\n> 那么这样一来，每个结点中，实际存放的信息所占大小就是4B，因此存储密度就会提高。\n>\n> 因此，若使用链式存储来实现串的话，一般推荐采用这种方式。\n>\n> 通过这种方式实现，若最后一个结点存不满字符，那么你可以用一些特殊字符（如#，也可以用我们上面提到的'\\0'）将其填充进去。\n\n### 串的基本操作\n\n可以看下面两个链接\n\n[c 语言的库：<cstring>](https://cplusplus.com/reference/cstring/)\n\n[c++的库：<string>](https://cplusplus.com/reference/string/string/)\n\n主要包括构造、销毁、清空、求串长、求字串等\n\n 基本操作\n\n  - StrAssign(&T, chars)：串赋值。把串T赋值为chars\n  - StrCompare(S, T)：串比较。若S>T，返回值>0;....\n  - StrLength(S)：求串长。返回串S的元素个数\n  - Concat(&T, S1, S2)：串连结。用T返回由S1和S2联接而成的新串\n  - SubString(&Sub, S, pos, len)：求子串。用Sub返回串S的第pos个字符起长度为len的字串。\n  - StrCopy(&T, S)：串拷贝。由串S复制得到串T。\n  - StrEmpty(S)：串判空。若S为空串，则返回TRUE，否则返回FALSE。\n  - ClearString(&S)：清空串\n  - Index(S,T,pos)：子串的位置。用Sub返回串S的第pos个字符起长度为len的子串。\n  - Repalce(&S, T, V)：串替换\n  - StrInsert(&S, pos, T)：子串插入\n  - StrDelete(&S, pos, len)：子串删除\n  - DestoryString(&S)：串销毁 \n\n#### 求字串\n\n`SubString(&Sub,S,pos,len)` 求子串。用 Sub 返回串 S 的第 pos 个字符起长度为 len 的子串\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-5.png\" style=\"zoom: 60%;\" />\n\n```C\n#define MAXLEN 255\t\t\t// 预定义最大串长为255\ntypedef struct{\n    char ch[MAXLEN];\t\t// 每个分量存储一个字符\n    int length;\t\t\t\t// 串的实际长度\n}SString;\t\t\n\n// 求子串\nbool SubString(SString &Sub,SString S,int pos,int len){\n    // 子串范围越界\n    if(pos+len-1 > S.length){\n        return false;\n    }\n    for(int i=pos; i<pos+len; i++){\n        Sub.ch[i-pos+1] = S.ch[i];\n    }\n    Sub.length = len;\n    return true;\n}\n```\n\n#### 比较操作\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-6.png\" style=\"zoom: 60%;\" />\n\n`StrCompare(S,T)` 比较两个串操作。若 S > T，则返回值 > 0；若 S = T，则返回值 = 0；若 S < T，则返回值 < 0\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-7.png\" style=\"zoom:55%;\" />\n\n```C\n// 比较两个串操作。若 S > T，则返回值 > 0；若 S = T，则返回值 = 0；若 S < T，则返回值 < 0\nint StrCompare(SString S,SString T){\n    for(int i=1; i<=S.length && i<= T.length; i++){\n        if(S.ch[i] != T.ch[i]){\n            return S.ch[i] - T.ch[i];\n        }\n    }\n    // 扫描过的所有字符都相同,则长度更长的串更大\n    return S.lenth - T.length;\n}\n```\n\n#### 定位操作\n\n`Index(S,T)`： 定位操作。若主串 S 中存在与串 T 值相同的子串，则返回它在主串 S 中第一次出现的位置，否则函数值为 0\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-8.png\" style=\"zoom:67%;\" />\n\n其实在此处，我们可以通过使用之前实现的求子串操作`SubString(&Sub, S, pos, len)`来帮助我们完成，将要检查的子串T，和主串S的所有子串依次对比即可，而且，比较两个串是否相等，也可以使用我们之前已经实现的比较操作（StrCompare(S, T)）来完成。\n\n我们可以在主串 S 中从第一个元素开始取下长度为 3 的子串，然后对比这个子串与串 T 看是否相等，如果不相等，可以再在主串 S 中从第二个元素开始取下长度为 3 的子串，然后对比这个子串与串 T 看是否相等，如果相等，那么我们只需要返回这个子串的第一个字符的位序。\n\n```C\nint Index(SString S,SString T){\n    int i=1; \n    int n=StrLength(S);\t\t\t\t// 求S串长,返回串中元素的个数\n    int m=StrLength(T);\t\t\t\t// 求T串长,返回串中元素的个数\n    SString sub;\t\t\t\t\t// 用于暂存子串\n    while(i <= n-m+1){\n        SubString(sub,S,i,m);\t\t// 取子串,用 Sub 返回串 S 的第 i 个字符起长度为 m 的子串。\n        if(StrCompare(sub,T) != 0){ // 对比\n            i++;\n        }else{\n            return i;\t\t\t\t// 返回子串在主串中的位置\n        }\n    }\n    return 0;\t\t\t\t\t\t// S中不存在与Tx\n}\n```\n\n## 4.2 串的匹配模式\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-9.png\" style=\"zoom:60%;\" />\n\n统一一些术语:\n\n- 从哪个字符串里面进行搜索，那个字符串就叫**主串**。\n- 你输入的内容，叫模式串。\n  - 为什么叫模式串，不叫子串？因为子串必定是能够在主串中找到的一个串。而模式串只是我们试图去搜索的一个串，并不一定能够找到，因此叫模式串而不能叫子串。\n\n- **串的模式匹配**：在主串中找到与模式串相同的子串，并返回其所在位置\n\n### 简单的模式匹配算法--BF算法\n\n也叫朴素模式匹配算法，其核心思想就是:<font color='red'>暴力求解</font>\n\n之所以叫做朴素模式匹配算法，是因为我们这里不会用其他串的基本操作，而是通过访问数组元素的方式来实现这个过程。\n\n在主串当中找出所有有可能与模式串相匹配的子串，然后将每个子串与模式串一一进行对比。这样肯定就没有遗漏地进行一遍对比。\n\n> 因此，如果主串长度为n，模式串长度为m，则\n>\n> 朴素模式匹配算法：将**主串中所有长度为m的子串**依次与模式串对比，直到找到一个完全匹配的，或直到所有的子串都不匹配为止。\n>\n> 问题：在长度为n的主串当中，长度为m的子串共有多少个？\n>\n> 答：共有`n-m+1`个。\n\n到这里，事实上我们已经发现了，这一系列操作，是和之前我们学过的串的定位操作`Index(S, T)`是一致的，只是换了个马甲。\n\n因此，我们所谓的朴素模式匹配算法，就可以使用之前的串定位操作来进行实现，如下。\n\n```C\n//和上节写过的那个定位操作是一模一样的内容\nint Index(SString S, SString T){\n\tint i=1,n = StrLength(S),m = StrLength(T);\n\tSString sub;\t//用于暂存子串\n\twhile(i <= n-m+1) {\n\t\tSubString(sub, S, i, m);//取出从位置i开始，长度为m的子串\n\t\tif(StrCompare(sub, T) != 0) ++i;\n\t\telse return i;\t//返回子串在主串中的位置 \n\t}\n\treturn 0;\t//没有匹配到 \n}\n```\n\n接下来，我们不借助字符串的基本操作，而是**直接通过数组下标来实现朴素模式匹配算法**。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-10.png\" style=\"zoom: 69%;\" />\n\n1.我们会使用 k 来记录当前检查的子串的起始位置，然后比对这个子串与模式串，如果不能匹配，就让 k++（这里在比对时，只要有一个字符不同，就可以停止检查当前子串）\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-11.png\" style=\"zoom: 42%;\" />\n\n2.如果对比的子串和模式串不相等，让 k 的值 ++，也就是对比下一个子串，然后让 i 和 j 分别指向子串和模式串的第一个字符\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-12.png\" style=\"zoom:41%;\" />\n\n3.循环执行操作 2，当被比对的子串和模式串的第一个值相同，这个时候让 i 和 j 的值同时向后移，对比第二个字符，第二个字符也相等，那继续让 i 和 j 的值向后移，对比第三个字符\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-13.png\" style=\"zoom:41%;\" />\n\n```C\nint Index(SString S,SString T){\n    int k=1;\n    int i=k,j=1;\n    while(i<=S.length && j <= T.length){\n        if(S.ch[i] == T.ch[j]){\t\t\t\t// 当对比的子串和模式串的第一个字符相等\n            ++i;\t\t\t\t\t\t\t// 让 i 和 j 向后移\n            ++j;\t\t\t\t\t\t\t// 继续比较后继字符\n        }else{\n            k++;\t\t\t\t\t\t\t// 检查下一个子串\n            i=k;\t\t\t\t\t\t\t// i 指向被对比子串的第一个字符\n            j=1;\t\t\t\t\t\t\t// j 指向模式串的第一个字符\n        }\n    }\n    if(j>T.length){\n        return k;\n    }else{\n        return 0;\n    }\n}\n```\n\n王道课本代码是这样的:\n\n```c\nint Index_BF(SString S, SString T) {\nint i = 1, j = 1;\nwhile (i <= S.length && j <= T.length) {\nif (S.ch[i] == T.ch[j]) {// 比较成功则继续匹配下一个字符串\n    ++i;\n    ++j;\n}\nelse { // 比较不成功则回溯\n    i = i-j+2;\n    j++;\n}\n}\nif (j > T.length)  return  i-T.length;  // 看下文注释\nelse return 0;\n}\n\n/*\nj >= T.length 是错误的，举个反例：\nS = {\"abcdef\"}; T = {\"fg\"}\nwhen i = 6;\nS.ch[i] = T.ch[j] = 'f';\nThen i=7; j=2;\n此时不符合循环条件跳出。明显j = 2匹配成功了\n*/\n```\n\n<font color='purple'>算法性能分析</font>:\n\n若模式串长度为 m，主串长度为 n，则匹配成功的最好时间复杂度为：O(m)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-14.png\" style=\"zoom:50%;\" />\n\n若模式串长度为 m，主串长度为 n，则匹配失败的最好时间复杂度为：O(n-m+1) = O(n-m) ≈ O(n)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-15.png\" style=\"zoom: 36%;\" />\n\n最坏情况：每个子串的前 m-1 个字符都和模式串匹配，只有第 m 个字符不匹配\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-16.png\" style=\"zoom:73%;\" />\n\n<font color='orange'>再回顾一下</font>:\n\n- 串的模式匹配：在主串中找到与模式串相同的子串，并返回其所在位置。\n- 朴素模式匹配算法(简单模式匹配算法)思想：将主串中的模式串长度相同的子串搞出来，挨个与模式串对比，当子串与模式串某个对应字符不匹配时，就立即放弃当前子串，转而检索下一个子串\n- 若模式串长度为 m，主串长度为 n，则直到匹配成功/匹配失败最多需要 (n-m+1)*m 次比较\n\n### 改进的模式匹配算法——KMP 算法\n\nKMP 算法：朴素模式匹配算法的优化\n\nKMP 算法之所以叫做 KMP 算法，是因为发明它的三个人的名字第一个开头字母组成的。✌️\n\n朴素模式匹配算法的缺点：**当某些子串与模式串能部分匹配时，主串的扫描指针 i 经常回溯，导致时间开销增加**。这是为什么呢。因为我们在进行匹配之前，并不知道主串里面有什么，我们只能根据下标、模式串串长，进行一个一个的对比。即使是上一轮中对比过的相等的字符，我们也并没有记录。总之每次循环前，主串中有什么内容，都是我们不知道的，我们**只知道开始匹配的下标位置，与要匹配的长度**。\n\n但是实际上，由于上一轮循环，对于字符的逐个对比，到某个字符匹配失败时结束，这一过程当中，我们必然能够通过一部分“i指向的字符与j指向的字符相等”，来得知主串当中有哪些字符。即，在遇到不匹配的字符之前的字符，一定是和模式串一致的字符。\n\n因此，对于主串中的信息，虽然刚开始我们一无所知。但是通过模式串的部分匹配，我们可以确定主串里面前边一小部分到底是什么内容。内容就是模式串失配位置前的所有字符。\n\n那么，根据模式串失配位置前的内容，映射到主串相应位置，之后去执行朴素模式匹配的话，它会寻找到某个位置之后再进行真正的匹配。\n\n而且从逻辑上来讲，这一操作过程与主串是什么无关，只是与模式串本身的信息内容、失配位置相关。\n\n<font color='red'>改进思路</font>：主串指针不回溯，只有模式串指针回溯\n\n------\n\n我们来看一个例子，例如指向模式串的指针 j = 6 时发生了不匹配\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-17.png\" style=\"zoom: 67%;\" />\n\n那么也就是说，前 5 个字符都与模式串匹配上了，这个时候我们让模式串回溯到起始位置，只需要比较子串的最后一个字符与模式串的起始字符是否相同\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-18.png\" style=\"zoom: 67%;\" />\n\n如果子串的最后一个字符与模式串的起始字符相同，我们让指向子串和模式串的指针 i++，j++，从而比较第二个字符是否相同\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-19.png\" style=\"zoom:67%;\" />\n\n如果子串的最后一个字符与模式串的起始字符不相同，我们让指向子串的 i 后移，检查后继元素是否与模式串的起始元素相同，而指向模式串的指针 j 依然是 1\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-20.png\" style=\"zoom:67%;\" />\n\n那如果指向模式串的指针 j = 5 时发生了不匹配，如图:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-21.png\" style=\"zoom:67%;\" />\n\n那么说明我们前4个字符都匹配上了，并且此时子串有第二个 g 开头，我们只需要比对模式串的第二个字符，看子串的 ？号处的字符是否与 o 相同，所以我们让指向模式串的指针 j 回到 2\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-22.png\" style=\"zoom:67%;\" />\n\n如果说指向模式串的指针 j = 3 时不匹配\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-23.png\" style=\"zoom:67%;\" />\n\n让指向模式串的指针 j 回到1\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-24.png\" style=\"zoom:67%;\" />\n\n<font color='red'>总结</font>：当我们的指针 j 扫描到某一个字符时，如果发生了不匹配，那么说明前面的字符和我们的主串是能够完全匹配上的，那我们就可以利用模式串前缀的信息，就可以分析出指针 j 接下来应该指向什么位置。\n\n------\n\n我们将 j 应该指向什么位置的信息放在一个数组里，数组名字叫 **next**\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-25.png\" style=\"zoom:67%;\" />\n\n这个数组的意思是当指针 j 指向的位置发生不匹配，那么它应该回到某一个位置。这里我们发现当 j = 1时发生不匹配，应该让 j 仍然是1，但是 next 数组里面让 j 回到 0，这是为了写代码的时候考虑。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-26.png\" style=\"zoom: 33%;\" />\n\n------\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-44.png\" style=\"zoom:67%;\" />\n\n```c\nint Index_KMP(SString S,SString T,int next[]){\n    int i=1;j=1;\n    while(i<=S.length && j<= T.length){\n        if(j==0 || S.ch[i] == T.ch[j]){\n            ++i;\n            ++j;\t\t\t\t\t\t\t\t// 继续比较后继字符\n        }else{\n            j=next[j];\t\t\t\t\t\t\t// j指回相应位置,模式串向右移动\n        }\n    }\n    if(j>T.length){\n        return i-T.length;\t\t\t\t\t\t// 匹配成功\n    }else{\n        return 0;\n    }\n}\n```\n\nKMP算法，最坏时间复杂度O(m+n)；其中，求next数组时间复杂度O(m),模式匹配过程最坏时间复杂度O(n)。\n\n### 求next数组🔥(王卓)\n\n**所以其实 KMP 算法的关键在于我们需要先搞出一个和模式串相对应的数组 next。**\n\n我们先来观察几个例子:\n\n当 j = 6 时，匹配失败，我们要让模式串向右移动到 j = 3\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-27.png\" style=\"zoom:64%;\" />\n\n当 j = 7 时，匹配失败，我们要让模式串向右移动到 j = 5\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-28.png\" style=\"zoom: 55%;\" />\n\n当 j = 5时匹配失败，我们要让模式串向右移动到 j = 4\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-29.png\" style=\"zoom:59%;\" />\n\n当 j = 5 时匹配失败，我们要让模式串向右移动到 j = 1\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-30.png\" style=\"zoom:58%;\" />\n\n当 j = 1 时就发生匹配失败，我们让 j = 0\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-31.png\" style=\"zoom:60%;\" />\n\n串的前缀：包含第一个字符，且不包含最后一个字符的子串\n\n串的后缀：包含最后一个字符，且不包含第一个字符的子串\n\n<font color='orange'>当第 j 个字符匹配失败，由前 1 ~ j-1 个字符组成的串记为 S，则： next[j] = S的最大公共前后缀长度 +1</font>\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-32.png\" style=\"zoom:65%;\" />\n\n```cpp\nvoid Get_next(SString T, int next[]){\n    int i = 1, j = 0;\n    next[1] = 0;\n    while (i < strlen(T)) {\n        if (j == 0 || T.ch[i] == T.ch[j]) {\n            ++i; ++j;\n            next[i] = j;\n        }\n        else j = next[j]; // 隐含着非常厉害的递归思想\n    }\n    return 0;\n}\n```\n\n时间复杂度O(m+n) ，其中O(m) 来自于求next数组，O(n) 来自KMP算法的里层循环（普通模式匹配算法的时间复杂度是O(mn)\n\n------\n\n### 求next数组(王道)\n\n这个有两种方法：一种是王道讲的这个；一种是王卓上面讲的，根据当前要判断的元素的前面的模式串的子串中公共前后缀的长度加1来确定当前next数组的值（不过要注意模式串下标，有的题目是j从0开始，然后这里需要加1是因为next数组第一个是0，第二个是1）。\n\n------\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-45.png\" style=\"zoom:67%;\" />\n\n- 首先分析next[1]\n\n  > next[1]的含义是，当模式串的第一个字符发生失配时，模式串指针j应该指向什么位置？\n  >\n  > 应该是让j=0，然后执行i++,j++。\n\n  对于任何一个模式串都是一样的，第一个字符不匹配时，只能匹配下一个子串。因此，**next[1]均直接写0**即可。\n\n- 分析next[2]\n\n  > next[2]的含义是，如果第二个字符发生失配，接下来指针j应该指向哪？\n  >\n  > 对于这个例子来说，我们应该让j=1。\n\n  事实上，对于任何一个模式串都一样，第2个字符不匹配时，应该尝试匹配模式串的第1个字符。因此，**next[2]均直接写1**即可。\n\n- 分析next[3]\n\n  > 在不匹配位置前边，画一个分界线。然后，让模式串一步一步往后退，直到在分界线之前“能对上”，或模式串完全跨过分界线。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-46.png\" style=\"zoom:67%;\" />\n\n  分界线右边的内容是未知的，模式串一步一步右移，观察分界线左边能不能匹配得上\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-47.png\" style=\"zoom:67%;\" />\n\n  即此模式串对应的`next[3] = 1`。\n\n- 分析next[4]\n\n  同理可知，`next[4] = 1`。\n\n- 分析next[5]\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-48.png\" style=\"zoom:67%;\" />\n\n  同理可知，`next[5] = 2`。\n\n- 分析next[6]\n\n  同理可知，`next[6] = 1`。\n\n#### 练习1\n\n<font color='green'>这里直接用算法算</font>\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-33.png\" style=\"zoom:67%;\" />\n\n如题:\n\n1. next[1] == 0\n2. next[2] 的意思是当我们匹配到第二个字符的时候发现匹配失败，那么前 1~(2-1) 个字符组成的串记为S，也就是串S此时只有一个字符为a，`'a'` 的前缀是空集，后缀也是空集，所以最长相等前后缀长度+1 = 1，所以 next[2] = 1(**其实，无脑写1即可**)\n3. next[3] 的意思是当我们匹配到第三个字符的时候发现匹配失败，那么前 1~(3-1) 个字符组成的串记为S，也就是串S此时为 `'ab'` ,前缀为{a}，后缀为{b},所以最长相等前后缀长度+1 = 1,所以 next[3] = 1\n4. next[4] 的意思是当我们匹配到第四个字符的时候发现匹配失败，那么前 1~(4-1) 个字符组成的串记为S，也就是串S此时为 `'aba'` ,前缀为{a,ab}，后缀为{a,ba},所以最长相等前后缀长度+1 = 2,所以 next[4] = 2\n5. next[5] 的意思是当我们匹配到第五个字符的时候发现匹配失败，那么前 1~(5-1) 个字符组成的串记为S，也就是串S此时为 `'abab'` ,前缀为{a,ab,aba}，后缀为{b,ab,bab},所以最长相等前后缀长度+1 = 3,所以 next[3] = 3\n6. next[6] 的意思是当我们匹配到第六个字符的时候发现匹配失败，那么前 1~(6-1) 个字符组成的串记为S，也就是串S此时为 `'ababa'` ,前缀为{a,ab,aba,abab}，后缀为{a,ba,aba,baba},所以最长相等前后缀长度+1 = 4,所以 next[6] = 4\n\n所以答案为：\n\n| 序号j   | 1    | 2    | 3    | 4    | 5    | 6    |\n| ------- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 模式串  | a    | b    | a    | b    | a    | a    |\n| next[j] | 0    | 1    | 1    | 2    | 3    | 4    |\n\n#### 练习2\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-34.png\" style=\"zoom:67%;\" />\n\n如题:\n\n1. next[1] == 0\n2. next[2] 的意思是当我们匹配到第二个字符的时候发现匹配失败，那么前 1~(2-1) 个字符组成的串记为S，也就是串S此时只有一个字符为a，`'a'` 的前缀是空集，后缀也是空集，所以最长相等前后缀长度+1 = 1，所以 next[2] = 1\n3. next[3] 的意思是当我们匹配到第三个字符的时候发现匹配失败，那么前 1~(3-1) 个字符组成的串记为S，也就是串S此时为 `'aa'` ,前缀为{a}，后缀为{a},所以最长相等前后缀长度+1 = 1,所以 next[3] = 2\n4. next[4] 的意思是当我们匹配到第四个字符的时候发现匹配失败，那么前 1~(4-1) 个字符组成的串记为S，也就是串S此时为 `'aaa'` ,前缀为{a,aa}，后缀为{a,aa},所以最长相等前后缀长度+1 = 3,所以 next[4] = 3\n5. next[5] 的意思是当我们匹配到第五个字符的时候发现匹配失败，那么前 1~(5-1) 个字符组成的串记为S，也就是串S此时为 `'aaaa'` ,前缀为{a,aa,aaa}，后缀为{a,aa,aaa},所以最长相等前后缀长度+1 = 4,所以 next[5] = 4\n\n答案为:\n\n| 序号j   | 1    | 2    | 3    | 4    | 5    |\n| ------- | ---- | ---- | ---- | ---- | ---- |\n| 模式串  | a    | a    | a    | a    | b    |\n| next[j] | 0    | 1    | 2    | 3    | 4    |\n\n#### 小结\n\n朴素模式匹配算法的缺点：当某些子串与模式串能部分匹配时，主串的扫描指针i经常回溯，导致时间开销增加。最坏的时间复杂度O(nm)\n\nKMP算法：当子串和模式串不匹配时，主串指针i不回溯，模式串指针 j=next[j] ，算法的平均时间复杂度：`O(n+m)`\n\nnext数组手算方法：当第j个字符匹配失败，由前 `1~j-1` 个字符组成的串记为S，则：`next[j]=S的最长相等前后缀长度+1`\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-35.png\" style=\"zoom:67%;\" />\n\n**感兴趣看**:\n\n[从BF算法到KMP算法](https://blog.csdn.net/ns_code/article/details/19286279)\n\n[字符串 模式匹配](https://www.cnblogs.com/jingmoxukong/p/4343770.html)\n\n### KMP 算法优化-nextval数组\n\n#### 举例说明\n\n<font color='purple'>举个例子</font>\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-49.png\" style=\"zoom:67%;\" />\n\n当第三个元素不匹配时，让j指针指回next[3]，即从模式串T第一个字符开始匹配\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-50.png\" style=\"zoom:67%;\" />\n\n主串前面两个元素是已经确定的了，第三个元素虽然具体不知道是什么，也可以肯定不是a，但此时查找next[3]为1，而模式串的第一个元素也还是a，根据前一节讲过的KMP算法，是会让模式串的第一个元素跟主串第三个元素比较的，就有点多余了，增加了时间复杂度\n\n所以改良一下，完全可以让j直接等于0,next[3]=next[1]\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-51.png\" style=\"zoom:80%;\" />\n\nj指向0的时候，i、j再同时++\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-52.png\" style=\"zoom:67%;\" />\n\n------\n\n==再举个例子==\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-53.png\" style=\"zoom:67%;\" />\n\n根据KMP算法应该让j=2，但同样的问题，匹配到5这个字符时发现匹配失败，虽然不知道主串i指针指向的元素是什么，但确定的是一定不是b，因为模式串中2这个字符和5这个字符是一样的\n\n这次再匹配失败后，j的值应该改成next[2]。与其多比较一次，不如直接让next[5]=next[2]=1\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-54.png\" style=\"zoom:67%;\" />\n\n------\n\n<font color='cornflowerblue'>那么是不是所有next数组的值都可被优化呢？</font>\n\n==来看这样一个例子==\n\n假设模式串匹配到第6个字符时才发现匹配失败，那么能确定是主串中i指向的字符一定不是c\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-55.png\" style=\"zoom:67%;\" />\n\n原本next[6]对应的是3，即应将j指向3，从3开始往后匹配。此时只知道主串匹配失败的字符一定不是c，但有可能是a，所以next[6]=3是有必要的。\n\n#### 优化\n\nKMP原本是根据模式串T，求出next数组，再利用next数组进行匹配，主串不回溯而模式串回溯。\n\n对KMP算法的优化本质是只是优化了next数组，将next数组按照上述思想优化成nextval数组，用nextval数组替代next数组\n\n```C\nvoid Get_next(SString T, int next[]){\n    int i = 1, j = 0;\n    nextval[1] = 0;\n    while (i < strlen(T)) {\n        if (j == 0 || T.ch[i] == T.ch[j]) {\n            ++i; ++j;\n            if(T.ch[i]! =T.ch[j]) nextval[i]=j;\n            else nextval[i] = nextval[j];\n        }\n        else j = nextval[j];\n    }\n    return 0;\n}\n```\n\n#### 练习1：求nextval数组\n\n[KMP算法的优化与详解](https://www.cnblogs.com/cherryljr/p/6519748.html)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-56.png\" style=\"zoom:67%;\" />\n\n首先nextval[1]无脑写0，然后从前往后依次求nextval[]，如果当前的next[j]所指的字符和目前j所指的字符不相等，nextval[j]=next[j]。反之，则nextval[j]=nextval[next[j]]。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-36.png\" style=\"zoom:50%;\" />\n\n例如，对于上述模式串`\"aaaab\"`,它的next数组如图，其nextval数组分析如下：\n\n1. nextval[1] == 0\n2. nextval[2] ,第二个字符的next[2] == 1，但是由于第二个字符与第一个字符是相同的，所以将第一个字符的 nextval[1] 赋值给第二个字符的nextval[2] == 0\n3. nextval[3] ,第三个字符的next[3] == 2，但是由于第三个字符与第二个字符是相同的，所以将第二个字符的 nextval[2] 赋值给第三个字符的 nextval[3] == 0\n4. nextval[4] ,第四个字符的next[4] == 3，但是由于第四个字符与第三个字符是相同的，所以将第三个字符的 nextval[3] 赋值给第四个字符的 nextval[4] == 0\n5. nextval[5] ,第五个字符的next[5] == 4，第五个字符b与第四个字符不相同，所以让其保持以前的 next 值不变，则nextval[5] = next[5] =4\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-37.png\" style=\"zoom:50%;\" />\n\n获得 nextval 函数\n\n```c\nvoid Get_next(SString T, int nextval[]){\nint i = 1, j = 0;\nnextval[1] = 0;\nwhile (i < strlen(T)) {\nif (j == 0 || T.ch[i] == T.ch[j]) {\n    i++;j++;\n    if(T.ch[i] != T.ch[j]) nextval[i] = j;\n    else nextval[i] = nextval[j];\n}\nelse j = nextval[j]; // 隐含着非常厉害的递归思想\n}\nreturn 0;\n}\n```\n\n**总结**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-38.png\" style=\"zoom:67%;\" />\n\n若题目中需要求 nextval 数组，那我们需要先手算出 next 数组，然后令 nextval[1] = 0,之后从左向右算出 nextval 值\n\n###   习题\n\n  - 思考：手算next数组→①next[ 1 ] = 0②next[ 2 ] = 1③next[ i ] = 前缀 和 后缀 最大交集 + 1\n\n  - 思考：` {aba} ` 的前缀和后缀分别是什么?→前缀{a, ab}（没有b，必须连续且包含第一个字符），后缀{a, ba}（必须连续且包含最后一个字符）\n\n  - 思考：模式串为` a b a b a a ` 求next数组→0 1 1 2 3 4\n\n  - 思考：模式串为` a a a a b `，求next和nextval数组?→0 1 2 3 4；0 0 0 0 4\n\n  - 5 和 7，串 ` a b a b a a a b a b a a ` 的next数组和nextval值为?→011234223456 ；010104210104\n\n    > 1、前两位：next数组前两位规定是0，1 即前两位ab对应的next数组为01，则：\n    >\n    > | 模式串   | a    | b    | a    | b    | a    | a    | a    | b    | a    | b    | a    | a    |\n    > | :------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n    > | 下标     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |\n    > | next数组 | 0    | 1    |      |      |      |      |      |      |      |      |      |      |\n    >\n    > 2、接下来看第三位，按照next数组求解方法。第三位a的前一位为第二位的b，b的next值为1对应内容为a，b与a不同，向前继续寻找next值对应的内容来与前一位进行比较。因为找到第一位都没有找到与前一位相等的内容，所以第三位a的next值为1，则：\n    >\n    > | 模式串   | a    | b    | a    | b    | a    | a    | a    | b    | a    | b    | a    | a    |\n    > | :------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n    > | 下标     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |\n    > | next数组 | 0    | 1    | 1    |      |      |      |      |      |      |      |      |      |\n    >\n    > 3、接下来看第四位b，b的前一位a的next值1对应内容为a，相同，所以该位b的next值就是前一位a的next值加上1，即为2\n    >\n    > | 模式串   | a    | b    | a    | b    | a    | a    | a    | b    | a    | b    | a    | a    |\n    > | :------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n    > | 下标     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |\n    > | next数组 | 0    | 1    | 1    | 2    |      |      |      |      |      |      |      |      |\n    >\n    > 4、接下来看第五位a，a的前一位b的next值2对应内容为b，相等，所以该位a的next值就是前一位b的next值加上1，即为3\n    >\n    > | 模式串   | a    | b    | a    | b    | a    | a    | a    | b    | a    | b    | a    | a    |\n    > | :------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n    > | 下标     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |\n    > | next数组 | 0    | 1    | 1    | 2    | 3    |      |      |      |      |      |      |      |\n    >\n    > 5、接下来看第六位a，a的前一位a的next值3对应内容为a，相等，所以该位a的next值就是前一位a的next值加上1，即为4\n    >\n    > | 模式串   | a    | b    | a    | b    | a    | a    | a    | b    | a    | b    | a    | a    |\n    > | :------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n    > | 下标     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |\n    > | next数组 | 0    | 1    | 1    | 2    | 3    | 4    |      |      |      |      |      |      |\n    >\n    > 6、接下来看第七位a，a的前一位a的next值4对应内容为b，不相等，向前继续寻找next值对应的内容来与前一位进行比较，b的next值2对应的内容为b，依旧不相等，继续向前寻找，第二位b的next值1对应内容为a，相等。因为是在第二位b处实现的相等，所以第七位a的next值为第二位b的next值上加1，即为2\n    >\n    > | 模式串   | a    | b    | a    | b    | a    | a    | a    | b    | a    | b    | a    | a    |\n    > | :------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n    > | 下标     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |\n    > | next数组 | 0    | 1    | 1    | 2    | 3    | 4    | 2    |      |      |      |      |      |\n    >\n    > 7、看第八位b，b的前一位a的next值2对应内容为b，不相等，向前继续寻找next值对应的内容来与前一位进行比较，b的next值1对应的内容为a，相等。因为是在第二位b处实现的相等，所以第八位a的next值为第二位b的next值上加1，即为2：\n    >\n    > | 模式串   | a    | b    | a    | b    | a    | a    | a    | b    | a    | b    | a    | a    |\n    > | :------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n    > | 下标     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |\n    > | next数组 | 0    | 1    | 1    | 2    | 3    | 4    | 2    | 2    |      |      |      |      |\n    >\n    > 8.看第九位，前一位b的next值2对应内容为b，相等，所以此处next值为3：\n    >\n    > | 模式串   | a    | b    | a    | b    | a    | a    | a    | b    | a    | b    | a    | a    |\n    > | :------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n    > | 下标     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |\n    > | next数组 | 0    | 1    | 1    | 2    | 3    | 4    | 2    | 2    | 3    |      |      |      |\n    >\n    > 9.第十位同理上面第8可得，为4：\n    >\n    > | 模式串   | a    | b    | a    | b    | a    | a    | a    | b    | a    | b    | a    | a    |\n    > | :------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n    > | 下标     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |\n    > | next数组 | 0    | 1    | 1    | 2    | 3    | 4    | 2    | 2    | 3    | 4    |      |      |\n    >\n    > 10、第十一位a的前一位b的next值4对应内容为b，相等，所以此处next值为5\n    >\n    > | 模式串   | a    | b    | a    | b    | a    | a    | a    | b    | a    | b    | a    | a    |\n    > | :------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n    > | 下标     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |\n    > | next数组 | 0    | 1    | 1    | 2    | 3    | 4    | 2    | 2    | 3    | 4    | 5    |      |\n    >\n    > 11.最后，第十二位也是同理可以得到next值位6：\n    >\n    > | 模式串   | a    | b    | a    | b    | a    | a    | a    | b    | a    | b    | a    | a    |\n    > | :------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n    > | 下标     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |\n    > | next数组 | 0    | 1    | 1    | 2    | 3    | 4    | 2    | 2    | 3    | 4    | 5    | 6    |\n    >\n    > 另一种解法:\n    >\n    > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-40.png\"  />\n    >\n    > nextval数组\n    >\n    > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-39.png\" style=\"zoom: 67%;\" />\n\n  - 【2015】已知字符串S为'abaabaabacacaabaabcc'，模式串t为'abaabc'。采用KMP算法进行匹配，第一次出现\"失配\"(S[i]!=t[j])时，i=j=5，则下次开始匹配时，i和j的值分别是-->i=5,j=2\n\n    > 由题中“失配s[i]≠t[j]时，i=j=5”，可知题中的主串和模式串的位序都是从0开始的（要注意灵活应变）。按照next数组生成算法，对于t有：\n    >\n    > | 编号 | 0    | 1    | 2    | 3    | 4    | 5    |\n    > | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n    > | t    | a    | b    | a    | a    | b    | c    |\n    > | next | -1   | 0    | 0    | 1    | 1    | 2    |\n    >\n    > 依据KMP算法“当失配时，i不变，j回退到next[j]的位置并重新比较”，当失配s[i]≠t[j]时，i=j=5，由上表不难得出next[j]=next[5]=2（位序从0开始）。从而最后结果应为：i=5（i保持不变），j=2。\n\n  - 【2019】设主串` a b a a b a a b c a b a a b c ` ，模式串 S = ` a b a a b c `，采用KMP算法进行模式匹配，到匹配成功时为止，在匹配过程中进行的单个字符间的比较次数是?→10次\n\n    > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-41.png\" style=\"zoom: 67%;\" />\n","tags":["408数据结构"],"categories":["408数据结构"]},{"title":"第三章 栈、队列和数组(下)","url":"/p/58315/","content":"\n## 3.3 栈和队列的应用\n\n### 栈在括号匹配中的应用\n\n#### 问题分析\n\n在我们写代码的过程中，不论是大括号、小括号，还是中括号，它们总是成双成对的出现的。\n\n我们如果只写了左括号，而没有写与它对应的右括号，那么编辑器就会检测出来错误。\n\n此外，左括号、右括号除了在数量上要匹配以外，在形状上也要匹配。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-53.png\" style=\"zoom:67%;\" />\n\n**遇到左括号就入栈，遇到右括号就出栈**\n\n例如：扫描下方括号，碰到左括号就将其压入栈底，碰到右括号就将其出栈匹配\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-54.png\" style=\"zoom: 50%;\" />\n\n\n\n这里的算法演示动画非常好理解：[王道考研 栈在括号匹配中的应用](https://www.bilibili.com/video/BV1b7411N798?p=26)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-55.png\" style=\"zoom: 50%;\" />\n\n**流程图**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-56.png\" style=\"zoom: 75%;\" />\n\n#### 算法实现\n\n```C\n// 考试中可直接食用基本操作,建议简要说明接口\n#define MaxSize 10\t\t\t\t\t\t\t// 定义栈中元素的最大个数\ntypedef struct{\t\t\t\t\t\t\t    \n    char data[MaxSize];\t\t\t\t\t\t// 静态数组存放栈中元素\n    int top;\t\t\t\t\t\t\t\t// 栈顶指针\n}SqStack;\n\n// 初始化栈\nvoid InitStack(SqStack &S)\n// 判断栈是否为空\nbool StackEmpty(SqStack &S)\n// 新元素入栈\nbool Push(SqStack &S,char x)\n// 栈顶元素出栈,用x返回\nbool Pop(SqStack &S,char &x)\n    \n// 字符数组(存储括号字符)和字符数组长度  \nbool bracketCheck(char str[],int length){\n    SqStack S;\n    InitStack(S);\t\t\t\t\t\t\t// 初始化一个栈\n    for(int i =0; i < length;i++){\n        if(str[i] == '(' || str[i] == '[' || str[i] == '{'){\n            Push(S.str[i]);\t\t\t\t\t// 扫描到左括号,入栈\n        }else{\n            if(StackEmpty(S)){\t\t\t\t// 扫描到右括号,且当前栈空\n                return false;\t\t\t\t// 匹配失败\n            }\n            char topElem;\n            Pop(S,topElem);\t\t\t\t\t// 栈顶元素出栈\n            if(str[i]==')' && topElem!= '('){\n                return false;\n            }\n            if(str[i]==']' && topElem!= '['){\n                return false;\n            }\n            if(str[i]=='}' && topElem!= '{'){\n                return false;\n            }\n        }\n    }\n    return StackEmpty(S);\t\t\t\t\t// 检索完全部括号后,栈空说明匹配成功\n}\n```\n\n> **注意一个小问题**：\n>\n> 由于我们要写的是括号匹配的算法实现，使用栈这种数据结构。\n>\n> 关键是要说明其中通过栈进行括号匹配的算法逻辑。\n>\n> 那么其中，栈的初始化、判空、入栈、出栈等操作，就可以不写详细细节，而直接使用。但是还是要简要声明操作函数的接口。用注释讲明其大概作用\n\n这种方法是用**顺序存储**的方式，有可能存满。其实实际开发的时候还是使用链栈为好。但是在考试的时候，使用顺序栈去写会更简单，也没什么问题。\n\n### 栈在表达式求值中的应用\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-57.png\" style=\"zoom:67%;\" />\n\n**前缀表达式**：前缀表达式(也叫波兰表达式)，运算符在两个操作数**前面**\n\n**后缀表达式**：后缀表达式(也叫逆波兰表达式)，运算符在两个操作数**后面**\n\n**中缀表达式**：运算符在两个操作数中间\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-58.png\" style=\"zoom:67%;\" />\n\n<font color='cornflowerblue'>这里做一下解释：例如中缀表达式为：a + b - c</font>\n\n**后缀表达式计算**：\n\n- 我们可以先计算 a + b，转换为后缀表达式为 ab+，再将 ab+ 作为一个整体与 c 进行减法操作，(ab+)-c\n\n  转换为后缀表达式为 ab+c-\n\n- 我们也可以先计算 b - c，转换为后缀表达式为 bc-，再将 bc- 作为一个整体与 a 进行加法操作，a+(bc-)\n\n  转换为后缀表达式为 abc-+\n\n> 这两个后缀表达式的结果，肯定都是正确的，表达的都是同一个中缀表达式。\n>\n> 但是，如果我们要用计算机来实现中缀转后缀的算法的话，我们只应该得到一种输出结果（因为算法应该具有确定性，即同样的输入只能得到同样的输出），那么实际上，用算法实现的结果，应该是前一种后缀表达式的结果。\n>\n> 以下几种情况同理。**那么，怎样能够保证得到的是前一种后缀表达式的结果呢？**接下来要提到“左优先“原则。\n\n**前缀表达式计算**：\n\n- 我们可以先计算 a + b，转换为前缀表达式为 +ab，再将 +ab 作为一个整体与 c 进行减法操作，(+ab)-c\n\n  转换为前缀表达式为 -+abc\n\n- 我们也可以先计算 b - c,转换为前缀表达式为 -bc，再将 -bc 作为一个整体与 a 进行加法操作，a+(-bc)\n\n  转换为前缀表达式为 +a-bc\n\n<font color='orange'>这里做一下解释：例如中缀表达式为：a + b - c * d</font>\n\n**后缀表达式计算**：\n\n- 我们可以先计算 a + b，转换为后缀表达式为 ab+，再接着计算 c * d，转换为后缀表达式为 cd* ，接着让 ab+ 和 cd * 分别作为两个整体进行减法操作，(ab+)-(cd*) 转换为后缀表达式为 ab+cd *-\n\n**前缀表达式计算**：\n\n- 我们可以先计算 a + b，转换为前缀表达式为 +ab，再接着计算 c * d，转换为前缀表达式为 *cd，接着让 +ab 和 cd * 分别作为两个整体进行减法操作，(+ab)-(*cd) 转换为前缀表达式为 -+ab *cd\n\n#### 中缀表达式转后缀表达式\n\n**方法**：\n\n1. 确定中缀表达式中各个运算符的运算顺序\n2. 选择下一个运算符，按照 [**左操作数 右操作数 运算符**] 的方式组合成一个新的操作数\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-59.png\" style=\"zoom: 85%;\" />\n\n- 左优先原则：只要左边的运算符能先计算，就优先算左边的。\n\n- 我们知道运算符的运算顺序不唯一，对应的后缀表达式也不唯一。但是如果我们遵从左优先原则，那么就可以保证对应的后缀表达式唯一，而且机算也是按照左优先原则，这样我们就可以保证手算和机算的结果相同。\n\n- 例如如下案例：\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-60.png\" style=\"zoom:69%;\" />\n\n##### 后缀表达式的手算\n\n<font color='orange'>我们将中缀表达式转换为后缀表达式，我们怎么计算这个后缀表达式呢？</font>\n\n<font color='cornflowerblue'>计算方法：从左往右扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对应运算，合体为一个操作数。</font>\n\n我们来看一个例子\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-61.png\" style=\"zoom:67%;\" />\n\n如上图后缀表达式\n\n- 我们从左向右扫描，先扫描到 ➕ 号，我们让 ➕ 号前面最近的两个操作数执行 ➕ 运算，合体为 2，于是变为 \n  - 15 7 2 ➖ ➗ 3 ✖ 2 1 1 ➕ ➕ ➖\n- 我们继续将上述后缀表达式从左向右扫描，先扫描到 ➖ ，我们让 ➖ 前面最近的两个操作数执行 ➖ 运算，合体为 5\n  - 15 5 ➗ 3 ✖ 2 1 1 ➕ ➕ ➖\n- 我们继续将上述后缀表达式从左向右扫描，先扫描到 ➗，我们让 ➗ 前面最近的两个操作数执行 ➗ 运算，合体为 3\n  - 3 3 ✖ 2 1 1 ➕ ➕ ➖\n- 我们继续将上述后缀表达式从左向右扫描，先扫描到 ✖，我们让 ✖ 前面最近的两个操作数执行 ✖ 运算，合体为 9\n  - 9 2 1 1 ➕ ➕ ➖\n- 我们继续将上述后缀表达式从左向右扫描，先扫描到 ➕，我们让 ➕ 前面最近的两个操作数执行 ➕ 运算，合体为 2\n  - 9 2 2 ➕ ➖\n- 我们继续将上述后缀表达式从左向右扫描，先扫描到 ➕，我们让 ➕ 前面最近的两个操作数执行 ➕ 运算，合体为 4\n  - 9 4 ➖\n- 最后从左向右扫描，扫描到 ➖，我们让 ➖ 前面最近的两个操作数执行 ➖ 运算，合体为 5\n  - 5\n- 所以最终结果为 5\n\n##### 后缀表达式的机算\n\n我们让运算符前面最近的两个操作数执行对应运算，最后出现的操作数最先被运算，这符合栈**后进先出**的特点，所以我们机算后缀表达式是用栈实现的。步骤如下:\n\n①从左往右扫描下一个元素，直到处理完所有元素。\n\n②若扫描到操作数，则压入栈，并回到①；否则执行③。\n\n③若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到①。\n\n例如：\n\n1. 我们扫描如图的后缀表达式，扫描到 A，压入栈，扫描到 B，压入栈\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-62.png\" style=\"zoom:67%;\" />\n\n2. 扫描到运算符 +，弹出两个栈顶元素 B、A，执行 + 运算，A + B，再将运算结果压入栈顶\n\n   - 注意,<font color='orange'>先出栈的是右操作数</font>，这里 B 先出栈，所以 B 为右操作数\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-63.png\" style=\"zoom:67%;\" />\n\n3. 接着继续从左向右扫描，扫描到 C，压入栈，扫描到 D，压入栈。\n\n   扫描到运算符 *，弹出两个栈顶元素 D、C，执行 * 运算，C * D，再将运算结果压入栈顶\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-64.png\" style=\"zoom:67%;\" />\n\n4. 接着继续从左向右扫描，扫描到 E，压入栈中。\n\n   扫描到运算符 / ，弹出栈顶元素 E、C*D，执行 / 运算，(C * D)/E，再将结果压入栈顶\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-65.png\" style=\"zoom:67%;\" />\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-66.png\" style=\"zoom:67%;\" />\n\n5. 接着扫描到运算符 -，弹出两个栈顶元素 (C * D)/E 、A+B，执行 - 操作，(A+B)-((C*D)/E)\n\n   将运算结果压入栈顶\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-67.png\" style=\"zoom:67%;\" />\n\n6. 接着从左向右扫描，扫描到 F ，压入栈\n\n   扫描到运算符 +，弹出两个栈顶元素 F、(A+B)-((C*D)/E)，执行 + 操作，(A+B)-((C * D)/E) + F\n\n   将结果压入栈顶\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-68.png\" style=\"zoom:67%;\" />\n\n7. 若表达式合法，则最后栈中只会留下一个元素，就是后缀表达式的最终结果\n\n> 由于本例中的元素均设成未知数，所以最后计算出的后缀表达式的结果是一个中缀表达式。若有具体数的话则栈中只会有一个元素，即为运算结果。这种后缀表达式的机算方式可以粗略理解为将后缀转中缀后再计算。\n\n<font color='red'>所以其实人喜欢看中缀表达式，计算机更喜欢看后缀表达式。</font>\n\n#### 后缀表达式转中缀表达式\n\n<font color='cornflowerblue'>我们知道了中缀表达式转换后缀表达式，那么后缀表达式如何转换为中缀表达式呢？</font>\n\n从左往右扫描，每遇到一个运算符，就让<font color='orange'>运算符插入前面最近的两个操作数之间，然后操作数两边带上括号</font>\n\n我们来看一个例子:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-69.png\" style=\"zoom:67%;\" />\n\n如上图后缀表达式:\n\n1. 从左向右扫描，先扫描到运算符 ➕ ，变为栈在递归中的应用\n   - 15 7 (1+1) ➖ ➗ 3 ✖ 2 1 1 ➕ ➕ ➖\n2. 接着继续从左到右扫描，先扫描到运算符 ➖\n   - 15 (7-(1+1)) ➗ 3 ✖ 2 1 1 ➕ ➕ ➖\n3. 接着继续从左到右扫描，先扫描到运算符 ➗\n   - ( 15 ÷ (7-(1+1)) ) 3 ✖ 2 1 1 ➕ ➕ ➖\n4. 接着继续从左到右扫描，先扫描到运算符 ✖\n   - (( 15 ÷ (7-(1+1)) ) * 3) 2 1 1 ➕ ➕ ➖\n5. 接着继续从左到右扫描，先扫描到运算符 ➕\n   - (( 15 ÷ (7-(1+1)) ) * 3) 2 (1+1) ➕ ➖\n6. 接着继续从左到右扫描，先扫描到运算符 ➕\n   - (( 15 ÷ (7-(1+1)) ) * 3) (2+(1+1)) ➖\n7. 接着继续从左到右扫描，先扫描到运算符 ➖\n   - (( 15 ÷ (7-(1+1)) ) * 3) - (2+(1+1))\n\n#### 中缀表达式转前缀表达式\n\n- ①确定中缀表达式中**各个运算符的运算顺序**。\n\n- ②选择下一个运算符，按照「**运算符 左操作数 右操作数**」的方式组合成一个新的操作数。\n\n- ③如果还有运算符没被处理，就继续②。\n\n注意:\n\n- 中缀表达式转后缀表达式是 **左优先** 原则\n\n- 中缀表达式转前缀表达式是 **右优先** 原则\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-70.png\" style=\"zoom: 50%;\" />\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-71.png\" style=\"zoom: 50%;\" />\n\n右优先原则：只要右边的运算符能先机算，就优先算右边的\n\n##### 前缀表达式的机算\n\n用栈实现前缀表达式的计算：\n\n- ①**从右往左**扫描下一个元素，直到处理完所有元素。\n\n- ②若扫描到操作数，则压入栈，并回到①；否则执行③。\n\n- ③若扫描到运算符，则弹出两个栈顶元素，执行响应运算，运算结果压回栈顶，回到①。\n\n**注意**：先出栈的是“左操作数”。\n\n#### 中缀表达式转后缀表达式机算\n\n初始化一个栈，用于<font color='orange'>保存暂时还不能确定运算顺序的运算符</font>。\n\n从左到右处理各个元素，直到末尾。可能遇到三种情况：\n\n1. 遇到**操作数**。直接加入后缀表达式\n2. 遇到**界限符**。遇到左括号 `(` 直接入栈；遇到右括号 `)` 则依次弹出栈内运算符并加入后缀表达式，直到弹出左括号`(` 为止。注意：左括号`(` 不加入后缀表达式。\n3. 遇到**运算符**。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到 `(` 或栈空则停止。之后再把当前运算符入栈。\n\n按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。\n\n------\n\n我们来看一下例子：\n\n1. 如下图的中缀表达式转后缀表达式，从左到右扫描\n\n   - 先扫描到操作数 A，直接加入后缀表达式\n   - 再扫描到运算符 ➕，由于栈是空栈，所以将运算符 ➕ 入栈\n   - 再扫描到操作数 B，直接加入后缀表达式\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-72.png\" style=\"zoom:70%;\" />\n\n2. 继续从左到右扫描\n\n   - 扫描到运算符 ➖，此时栈中有运算符 ➕，加号和减号的运算符优先级相同，则弹出 ➕，并加入后缀表达式，此时后缀表达式为 AB+，此时栈空，将运算符 ➖ 入栈\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-73.png\" style=\"zoom:70%;\" />\n\n3. 继续从左到右扫描\n\n   - 扫描到操作数 C，直接加入后缀表达式，此时后缀表达式为 AB+C\n   - 扫描到运算符 `*` ，栈中此时只有 ➖ 减法运算符，没有比乘法运算符优先级高的，所以将 `*` 压入栈中\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-74.png\" style=\"zoom:70%;\" />\n\n4. 继续从左到右扫描\n\n   - 扫描到操作数 D，直接加入后缀表达式，此时后缀表达式为 AB+CD\n   - 扫描到运算符`/`，此时栈中有 `*` `-` 两个运算符，乘法运算符和除法运算符优先级相同，所以将 `*` 乘法运算符弹出，并加入后缀表达式，此时后缀表达式为 AB+CD*\n   - 此时栈中只剩下 `-` 减法运算符，没有比 `/` 除法运算符优先级更高或相同的了，所以将 `/` 除法运算符压入栈中\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-75.png\" style=\"zoom:70%;\" />\n\n5. 继续从左到右扫描\n\n   - 扫描到操作数 E，直接加入后缀表达式，此时后缀表达式为 AB+CD*E\n   - 扫描到运算符 ➕，此时栈中有 `/` `-` 两个运算符，依次弹出栈中优先级高于或等于 ➕ 加号运算符的所有运算符，所以将 `/` `-` 依次弹出并加入后缀表达式，此时后缀表达式为 AB+CD*E/-\n\n6. 继续从左到右扫描\n\n   - 扫描到操作数 F，直接加入后缀表达式，此时后缀表达式为 AB+CD*E/-F\n   - 扫描完成，将栈中剩余运算符弹出栈并加入后缀表达式，所以弹出 ➕ 运算符并加入后缀表达式，最终后缀表达式为AB+CD*E/-F+\n\n------\n\n**我们接着来看一个带有界限符的例子**：\n\n1. 如下图的中缀表达式转后缀表达式，从左到右扫描\n\n   - 扫描到操作数 A， 直接加入后缀表达式。\n   - 扫描到运算符 ➕，此时栈为空，所以入栈。\n   - 扫描到操作数 B，直接加入后缀表达式。\n   - 扫描到运算符 `*` ，此时栈中只有加法运算符 ➕，没有比 `*` 乘法运算符优先级更高或相同的，所以将 `*` 入栈。\n   - 扫描到左括号 `(` ，直接入栈。\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-76.png\" style=\"zoom:67%;\" />\n\n2. 继续从左到右扫描\n\n   - 扫描到操作数 C，直接加入后缀表达式。\n   - 扫面描到运算符 ➖，此时本该依次弹出运算符高于或等于 ➖ 运算符的所有运算符，但是由于碰到了左括号`(` ，所以停止进行弹出。将 ➖ 减法运算符压入栈中。\n   - 扫描到操作数 D，直接加入后缀表达式。\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-77.png\" style=\"zoom: 67%;\" />\n\n3. 继续从左到右扫描\n\n   - 扫描到右括号 `)` ，则依次弹出栈内运算符并加入后缀表达式，直到遇到左括号 `(` 为止。\n   - 所以先弹出 ➖ 运算符，加入后缀表达式。\n   - 再弹出左括号`(` ，但是**左括号不加入后缀表达式**。\n   - 所以此时后缀表达式为 ABCD-。\n   - 此时栈中运算符有 `*` `+`。\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-78.png\" style=\"zoom:67%;\" />\n\n4. 继续从左到右扫描\n\n   - 扫描到 ➖ 运算符，依次弹出优先级高于或者等于 ➖ 运算符并加入后缀表达式中\n   - 所以将 `*` `+` 运算符弹出并加入后缀表达式，此时后缀表达式为 ABCD-*+\n   - 然后将扫描到的 ➖ 运算符加入栈中\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-79.png\" style=\"zoom:67%;\" />\n\n5. 继续从左到右扫描\n\n   - 扫描到操作数 E，直接加入后缀表达式\n   - 扫描到运算符 `/` ，栈中没有优先级高于或者等于 `/` 除法运算符的，所以将 `/` 压入栈\n   - 扫描到 F，直接加入后缀表达式，此时后缀表达式为 ABCD-*+EF\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-80.png\" style=\"zoom:67%;\" />\n\n6. 最后将栈中剩余运算符依次弹出，并加入后缀表达式\n\n   - 所以最终的后缀表达式为：ABCD-*+EF/-\n\n#### 中缀表达式的计算(用栈实现)\n\n用栈实现中缀表达式的计算\n\n初始化两个栈，**操作数栈**和**运算符栈**。\n\n- 若扫描到操作数，则压入操作数栈\n- 若扫描到运算符或界限符，则按照 “中缀转后缀” 相同的逻辑压入运算符栈(<font color='orange'>期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈</font>)\n\n------\n\n我们来看一个例子:\n\n1. 我们从左向右扫描中缀表达式\n\n   - 扫描到操作数 A，压入操作数栈\n   - 扫描到运算符 ➕，此时栈为空，则压入栈\n   - 扫描到操作数 B，压入操作数栈\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-81.png\" style=\"zoom:67%;\" />\n\n2. 继续从左向右扫描\n\n   - 扫描到运算符 ➖，弹出栈中优先级高于或等于 ➖ 运算符的所有运算符\n     - 所以弹出 ➕ 运算符，并将扫描到的运算符 ➖ 压入运算符栈\n   - 每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈\n     - 所以弹出 B、A，运算结果为 A + B，然后将运算结果压回操作数栈。\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-82.png\" style=\"zoom:67%;\" />\n\n3. 继续从左向右扫描\n\n   - 扫面描到操作数 C，压入操作数栈中\n   - 扫描到运算符 `*` ，运算符栈中没有优先级高于或者等于 `*` 乘法运算符的，所以将 `*` 压入运算符栈\n   - 扫描到操作数 D，压入操作数栈中\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-83.png\" style=\"zoom:67%;\" />\n\n4. 继续从左向右扫描\n\n   - 扫描到运算符 `/`，弹出运算符优先级高于或者等于 `/` 除号运算符的所有运算符，并将扫描到的 `/` 压入运算符栈\n   - 运算符栈中此时有 `*` `-` 两个运算符，所以弹出 `*` 乘法运算符\n   - 每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈\n   - 所以弹出 D、C 两个操作数，并执行 * 运算，运算结果为 C * D，将运算结果压入操作数栈中\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-84.png\" style=\"zoom:67%;\" />\n\n5. 继续从左向右扫描\n\n   - 扫描到操作数 E，直接压入操作数栈\n   - 扫描到运算符 ➕，弹出运算符优先级高于或者 ➕ 加法运算符的所有运算符，并将扫描到的运算符 ➕ 压入运算符栈\n   - 所以将 / 除法运算符弹出，一个运算符弹出则需要两个操作数栈的栈顶元素弹出，运算结果为 (C*D)/E，然后将运算结果压入操作数栈\n   - 之后将 - 减法运算符弹出，一个一个运算符弹出则需要两个操作数栈的栈顶元素弹出，运算结果为 (A+B)-((C*D)/E) ,然后将运算结果压入操作数栈\n\n   <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-85.png\" style=\"zoom:67%;\" />\n\n6. 继续从左向右扫描\n\n   - 扫描到操作数 F，直接压入操作数栈\n   - 扫描中缀表达式完成，运算符栈中还有 ➕ 运算符，弹出 ➕ 运算符，对应弹出两个操作数栈的栈顶元素进行计算，则最终结果为 (A+B)-((C*D)/E)+F\n\n### 栈在递归中的应用\n\n**函数调用的特点**：最后被调用的函数最先执行结束(LIFO)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-86.png\" style=\"zoom:75%;\" />\n\n例如，对于上述函数调用\n\n1. 开始运行main函数，将main函数里面的返回地址、实参、局部变量先压入栈中\n2. 执行func1函数，将其返回地址、实参、局部变量再压入栈中\n3. 执行func2函数，将其返回地址、实参、局部变量再压入栈中\n\n------\n\n计算正整数的阶乘n！\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-87.png\" style=\"zoom:67%;\" />\n\n```C\n// 计算正整数的阶乘n！\nint factorial(int n){\n    if(n==0 || n==1){\n        return 1;\n    }else{\n        return n*factorial(n-1);\n    }\n}\n\nvoid main(){\n    int x = factorial(10);\n    printf(x);\n    \n    return 0;\n}\n```\n\n递归算法可以把原始问题转换为属性相同，但规模较小的问题\n\n每进入一层递归，就将递归调用所需信息压入栈顶；每退出一层递归，就从栈顶弹出相应信息\n\n**缺点**：太多层递归可能会导致栈溢出\n\n### 队列在层次遍历中的应用\n\n树的层次遍历(在\"树\"章节)\n\n图的层次遍历(在\"图\"章节)\n\n### 队列在操作系统中的应用\n\n多个进程争抢着使用有限的系统资源时，FCFS(First Come First Service,**先来先服务**)是一种常用策略\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-88.png\" style=\"zoom:67%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-89.png\" style=\"zoom:67%;\" />\n\n### 习题\n\n- 【2009】为解决计算机主机与打印机之间速度不匹配的问题，通常设置一个打印数据缓冲区，主机将要输出的数据依次写入该缓冲区，而打印机则依次从该缓冲区中取出数据。该缓冲区的逻辑结构应该是→B\n\n  A 栈\n  B 队列\n  C 树\n  D 图 \n\n  > 这是典型的一种队列结构，一端放入另一端依次取出，也就是先进入的先取出\n\n- 执行什么操作时，需要使用队列作为辅助存储空间→B\n\n  A 查找散列（哈希）表\n  B 广度优先搜索图\n  C 前序（根）遍历二叉树\n  D 深度优先搜索图 \n\n- 【2012】已知操作符包括+、-、_、/、(和)。将中缀表达式`a + b - a * ( ( c + d) / e - f ) + g `转换为等价的后缀表达式`a b + a c d + e / f - * - g + `时，用栈来存放暂时还不能确定运算次序的操作符。若栈初始为空，则转换过程中同时保存在栈中的操作符的最大个数是 →5\n\n  > 写成伪代码是这样：\n  >\n  > ```C\n  > stack 操作符栈;\n  > for i=1 to n{\n  > \tif 当前操作符是操作数\n  > \t\t直接打印;\n  > \telse if 当前操作符是操作符{\n  > \t\tif 当前操作符是'('\n  > \t\t\t压入栈内;\n  > \t\telse if 当前操作符是')'\n  > \t\t\t不断弹出并打印栈顶元素直至栈顶为'(';\n  > \t\t\t弹出栈顶;\n  > \t\telse if 当前操作符优先级高于栈顶操作符 || 栈为空\n  > \t\t\t压入栈内;\n  > \t\telse\n  > \t\t\t不断弹出并打印栈顶元素直至栈顶优先级不大于当前元素;\n  > \t\t\t当前操作符入栈;\n  > \n  > \t}\n  > }\n  > 打印栈中剩余操作符; \n  > ```\n  >\n  > 优先级从低至高：(、+、-、*、/、^\n  >\n  > 回到本题，流程如下：（数字标明当前栈中元素个数）\n  >\n  > 1. 遇+，入栈，1个\n  > 2. 遇-，-的优先级不大于+，弹出+，压入-，1个\n  > 3. 遇 *， * 的优先级大于-，入栈，2个\n  > 4. 遇(，入栈，3个\n  > 5. 遇(，入栈，4个\n  > 6. 遇+，+的优先级大于(，入栈，5个\n  > 7. 遇)，弹出+，弹出(，3个\n  > 8. 遇/，/的优先级大于(，入栈，4个\n  > 9. 遇-，-的优先级不大于/，弹出/，压入-，4个\n  > 10. 遇)，弹出-，弹出(，2个\n  > 11. 遇+，+的优先级不大于*，弹出 *，压入+，2个\n  >\n  > 操作符遍历完毕，栈中最后自底而上为-和+，依次弹出。\n  >\n  > 综上，栈中元素最多的时候有5个\n\n- 【2014】假设栈初始为空，将中缀表达式 `a / b + ( c * d - e * f ) / g` 转化为等价 的后缀表达式的过程中，当扫描到 f 时，栈中的元素依次是 →`+ ( - *`\n\n  > 将中缀表达式转换为后缀表达式的算法思想如下：从左向右开始扫描中缀表达式；  \n  >\n  > 遇到数字时，加入后缀表达式；遇到运算符时：  \n  >\n  > a. 若为'('，入栈；  \n  >\n  > b. 若为')'，则依次把栈中的的运算符加入后缀表达式中，直到出现'('，从栈中删除'(' ；  \n  >\n  > c. 若为除括号外的其他运算符，当其优先级高于除'('以外的栈顶运算符时，直接入栈。否则从栈顶开始，依次弹出比当前处理的运算符优先级高和优先级相等的运算符，直到一个比它优先级低的或者遇到了一个左括号为止。  \n  >\n  > 当扫描的中缀表达式结束时，栈中的所有运算符依次出栈加入后缀表达式。\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-90.png\" style=\"zoom:67%;\" />\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-91.png\" style=\"zoom: 80%;\" />\n  >\n  > 由此可知，当扫描到f 的时候，栈中的元素依次是+(-*，选B。 \n  >\n  > 在此，再给出中缀表达式转换为前缀或后缀表达式的一种手工做法，以上面给出的中缀表达式为例： \n  >\n  > 第一步：按照运算符的优先级对所有的运算单位加括号。式子变成了：`((a/b)+(((c*d)-(e*f))/g))` \n  >\n  > 第二步：转换为前缀或后缀表达式。 \n  >\n  > 前缀：把运算符号移动到对应的括号前面，则变成了：`+(/(ab)/(-(*(cd)*(ef))g))` 把括号去掉：`+/ab/-*cd*efg` 前缀式子出现。 \n  >\n  > 后缀：把运算符号移动到对应的括号后面，则变成了：`((ab)/(((cd)*(ef)*)-g)/)+` 把括号去掉：`ab/cd*ef*-g/+` 后缀式子出现。 \n  >\n  > 当题目要求直接求前缀或后缀表达式时，这种方法会比上一种快捷得多。\n\n- 【2015】已知程序如下\n\n  ```C\n  int S(int n)\n  {\n      return (n<=0)?0:s(n-1) +n;\n  }\n  void main()\n  {\n      cout<<S(1);\n  }\n  ```\n\n  程序运行时使用栈来保存调用过程的信息，自栈底到栈顶保存的信息依次对应的是->\n\n  main()→S(1)→S(0)\n\n  > 1.程序执行顺序main()->S(1)->S(2)。 \n  >\n  > 2.函数在调用过程中PC（程序计数器）的操作是保护现场->将所有数据拷贝到栈->跳转到子函数 \n  >\n  > 3.根据栈的数据结构的特点（首先栈的数据结构是处理函数调用这个情况最好的办法），先入后出，因此，栈底为main()，栈顶为S(1)\n\n## 3.4 特殊矩阵和压缩存储\n\n### 数组的存储结构\n\n#### 一维数组的存储结构\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-92.png\" style=\"zoom:67%;\" />\n\n各数组元素大小相同，且物理上连续存放。\n\n因此，只需要知道其起始地址，就可以知道任何一个数组下标所对应元素的存放地址是多少。\n\n#### 二维数组的存储结构\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-93.png\" style=\"zoom:67%;\" />\n\n在内存空间中存储时，由于要进行线性存储，因此要将逻辑上的非线性给改变为线性的存储模式。因此，有两种存储策略：**行优先存储**、**列优先存储**。\n\n- 行优先：先存行，一行存完存第二行\n- 列优先：先存列，一列存完存第二列\n\n<font color='orange'>我们采用行优先或者列优先的存储方式存放二维数组，这样我们就可以通过二维数组的行号和列号来计算出这个元素所对应的存储地址。</font>\n\n##### 行优先\n\n我们来看行优先的一个例子\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-94.png\" style=\"zoom:70%;\" />\n\n(i*N+j)指的是 b[i] [j] 之前有多少个元素，每个元素再乘存储空间，就是 b[i] [j] 元素前面的存储空间\n\n再加上起始地址 LOC，就得到 b[i] [j] 的存储地址\n\n##### 列优先\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-95.png\" style=\"zoom:70%;\" />\n\n(j*M+i)指的是 b[i] [j] 之前有多少个元素, 每个元素再乘存储空间，就是 b[i] [j] 元素前面的存储空间\n\n再加上起始地址 LOC，就得到 b[i] [j] 的存储地址\n\n> M行N列的二维数组`b[M][N]`中，\n>\n> - 若按行优先存储，则`b[i] [j]`的存储地址 =`LOC + (i*N + j) * sizeof(ElemType)`\n>\n> 即每一行有多少个元素，乘它前面有多少行，再加上它位于第几列。\n>\n> - 若按列优先存储，则`b[i] [j]`的存储地址 =`LOC + (j*M + i) * sizeof(ElemType)`\n>\n> 即每一列有多少个元素，乘它前面有多少列，再加上它位于第几行。\n\n### 矩阵的存储\n\n#### 普通矩阵的存储\n\n最容易想到的就是用一个**二维数组存储**。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-96.png\" style=\"zoom: 85%;\" />\n\n#### 对称矩阵的压缩存储\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-115.png\" style=\"zoom: 80%;\" />\n\n> 由于上三角区和下三角区的数据是完全相同的，因此我们在存储数据的时候，只需要存储主对角线及上下某一个三角区即可。\n>\n> 以只存储**主对角线**与**下三角区**为例。\n>\n> 按**行优先**原则将各元素存入一维数组中。（第一行存1个数据，第二行存2个数据，第三行存3个数据…）\n\n策略：只存储主对角线 + 下三角区\n\n- 按行优先原则将各元素存入一维数组中，共存 (1+n)*n/2 个元素，由于一维数组下标从 0 开始，所以最后一个元素下标是 (1+n) * n/2 - 1\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-116.png\" style=\"zoom: 60%;\" />\n\n<font color='cornflowerblue'>我们最终的目的是将矩阵压缩存储后怎样才能方便使用</font>，这样我们就可以建立一个映射函数，矩阵下标 -> 一维数组下标，这样我们想要访问矩阵中某一行某一列的元素时，只需要通过映射函数一转，就可以知道它存放在一维数组的哪个位置。如何做呢？\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-117.png\" style=\"zoom:60%;\" />\n\n- 按行优先的原则，a[i] [j] 是第 (1+2+…+(i-1)) + j 个元素，但是由于一维数组下标是从 0 开始的，所以对应的一维数组下标为(1+2+…+(i-1)) + j -1\n\n\n- <font color='cornflowerblue'>但是如果我们想访问上三角区的元素呢？</font>虽然上三角区并没有进行存储，但是由于对称矩阵的特性，a[i] [j] = a[j] [i]，我们可以进行转换，相当于我们访问的仍然是下三角区的元素\n\n- 按列优先的原则，第一列存储n个元素，第二列存储n-1个元素，第三列存储n-2个元素，第(j-1)列总共有[n+(n-1)+(n-2)+…+(n-j+2)]个元素，所以a[i] [j] 是第 [[n+(n-1)+(n-2)+…+(n-j+2)]+(i-j)+1] 个元素\n\n\n#### 三角矩阵的压缩存储\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/co4-35.png\" style=\"zoom:55%;\" />\n\n策略：如图\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/co4-36.png\" style=\"zoom:55%;\" />\n\n<font color='cornflowerblue'>那我们如何用呢？</font>还是建立一个映射函数，这里的映射函数与对称矩阵的映射函数一样，不同的是如果我们访问上三角区常量，我们需要将其映射为一维数组的最后一个元素，因为**一维数组最后一个元素存储常量C**。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-118.png\" style=\"zoom:55%;\" />\n\n按行优先的原则，a[i] [j]前面有 i-1 行，第一行存储n个元素，第二行存储n-1个元素，第三行存储n-3个元素，第(i-1)行存储(n-i+2)个元素，所以a[i] [j]前面共有[[n+(n-1)+(n-2)+…+(n-i+2)+(j-i)]]个元素\n\n#### 三对角矩阵的压缩存储\n\n三对角矩阵，主对角线上的元素可以不为0，主对角线上元素的上下左右相邻元素也可以不为0，但是其余元素必须为0\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-119.png\" style=\"zoom: 55%;\" />\n\n按**行优先的原则**，只存储带状部分，除了第一行和最后一行为 2 个元素，其余行均为 3 个元素，所以总共需要存储 (3n-2) 个元素,由于数组下标默认从0开始，所以最后一个数组下标为 (3n-3)\n\n> 怎么把a(i,j)映射到与之对应的一维数组下标处？\n>\n> 若|i-j| >1，其值肯定是0。反之则去数组里面找。\n>\n> 按行优先的原则，a(i,j)是一维数组中的第几个元素？\n>\n> 它是第i行，在它前面有i-1行，共3(i-1)-1个元素。而且它是第i行的第j-i+2个元素。\n>\n> 所以a(i,j)是第2i+j-2个元素。数组下标若从0开始，则以上数字均需减1。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-120.png\" style=\"zoom:55%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-121.png\" style=\"zoom:55%;\" />\n\n> 反过来考虑，假设我们已知一维数组下标k，如何得知其在矩阵中的行、列，即i、j？\n>\n> 由于数组下标是从0开始的，因此下标k的元素是第k+1个元素。\n>\n> 第k+1个元素在第几行、第几列？\n>\n> 设其在第i行、第j列。\n>\n> 前i-1行共3(i-1)-1个元素。\n>\n> 所以显然，3(i-1)-1 < k+1 ≤ 3i-1\n>\n> 根据这个不等式，将i解出即可。同时j也轻易能够得出了。\n\n#### 稀疏矩阵的压缩存储\n\n##### 顺序存储——三元组\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-122.png\" style=\"zoom:55%;\" />\n\n显然，用这种方法存储稀疏矩阵的数据的话，若要访问某一行某一列的数据，就要从头顺序的依次扫描三元组，对其行号、列号遍历，直到查找到目标。就不具备随机存取的特性了。\n\n##### 链式存储——十字链表法\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-123.png\" style=\"zoom:55%;\" />\n\n在“上侧”定义一个数组，用来存放每一列的指针，叫做**向下域**（down），指向第j列的第一个元素；\n\n在“左侧”定义一个数组，用来存放每一行的指针，叫做**向右域**（right），指向第i行的第一个元素。\n\n每个非零元素成为一个数据结点，被存放着。\n\n（也就是向下域、向右域都指向当前列/行的第一个非零数据所形成的数据结点）\n\n其中，每个非零数据结点，除存放三元组（**行，列，值**）外，还存放两个指针，分别指向**同列的下一个元素**、**同行的下一个元素**。\n\n### 习题\n\n- 【2016】有一个100阶的三对角矩阵M，其元素m{i,j}(1<=i,j<=100),按行优先依次压缩存入下标从0开始的一维数组N中。元素m{30,30} 在N中的下标是→87\n\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-111.png\" style=\"zoom: 50%;\" />\n\n- 【2017】适用于压缩存储稀疏矩阵的两种存储结构是-->A\n\n  A 三元组表和十字链表\n\n  B 三元组表和邻接矩阵\n\n  C 十字链表和二叉链表\n\n  D 邻接矩阵和十字链表\n\n  > 三元组表的结点存储了行row、列col、值value三种信息，是主要用来存储稀疏矩阵的一种数据结构。十字链表将行单链表和列单链表结合起来存储稀疏矩阵。邻接矩阵空间复杂度达O(n2)，不适于存储稀疏矩阵。二叉链表又名左孩子右兄弟表示法，可用于表示树或森林。\n\n- 【2018】设有一个12x12的对称矩阵M，将其上三角部分的元素m{i,j}(1<=i<=j<=12)按行优先存入C语言的一维数组N中，元素m{6,6}在N中的下标是-->50\n\n  > 上三角矩阵从第一行开始元素数量依次是：**12，11，10，9，8，7，6，5，4，3，2，1**，m6,6表示上三角区域的第**6**行第**1**个，所以m6,6为第51个元素，占数组位置为a[50]。\n\n- 【2020】将一个10x10对称矩阵M的上三角部分的元素m{i,j}(1<=i<=j<=10)按列优先存入C语言的一维数组N中，元素𝑚{7,2}在 N 中的下标是-->22\n\n  > 上三角矩阵列优先的存储模式：先存储具有一个元素第一列，再存储具有两个元素 的第二列，以此类推\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-109.png\"  />\n  >\n  > 𝑚{7,2} 说明 1-6 列均已存满，，故此元素是第 1+2+3+4+5+6+2 个被存储单元 \n  >\n  > 【注意】C 语言数组的下标从 0 开始 故𝑚7,2在 N 中的下标为 23-1=22，即 N[22]\n\n- 【2021】二维数组A按行优先方式存储，每个元素占用1个存储单元。若元素A[0] [0]的存储地址是100，A[3] [3]的存储地址是220，则元素 A[5] [5] 的存储地址是->300\n\n  > 二维数组A按行优先存储，每个元素占用1个存储单元，由A[0] [0]和A[3] [3]的存储地址可知A[3] [3]是二维数组A的第121个元素，假设二维数组A的每行有n个元素，则nx3+4=121,则n=39,故元素A[5] [5]的存储地址为100+39x5+6-1=300\n","tags":["408数据结构"],"categories":["408数据结构"]},{"title":"第三章 栈、队列和数组(上)","url":"/p/63528/","content":"\n## 3.1 栈 Stack\n\n### 栈的基本概念\n\n- 栈的定义\n\n  - 栈是<font color='orange'>只允许在一端进行插入或删除操作的线性表</font>。限定这种线性表只能在某一端进行插入和删除操作。\n\n    - 栈顶:线性表允许进行插入删除的那一端。\n    - 栈底:固定的，不允许进行插入和删除的另一端。\n    - 空栈:栈里没有存任何数据元素，相当于线性表的空表。\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-2.svg\"  />\n\n  - **特性**：后进先出 Last In First Out, LIFO\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-1.png\" style=\"zoom: 75%;\" />\n\n    \n\n  - 栈的数学性质：卡特兰数 Catalan Number\n\n    卡特兰数一般可用于这种结论:n个不同元素进栈，出栈元素不同排列的个数为:\n\n    - $$\n      \\frac 1{n+1}C^n_{2n}\n      $$\n\n    所以，如果像上面那样有五个元素进栈，那么所有合法的出栈顺序有:\n    $$\n    \\frac 1{5+1}C^5_{10}=42\n    $$\n    可见，即使只有5个元素进栈，合法的出栈顺序就有42种，就很多了。所以考试题基本不会让你全部写出所有的，而是以选择题的形式让你选出一个合法的出栈顺序。\n\n### 栈的基本操作\n\n- InitStack(&S)：<font color='red'>初始化</font>栈操作。构造一个空栈S，分配内存空间。\n- DestroyStack(&S)：<font color='red'>销毁</font>栈操作，并<font color='red'>释放</font>栈S所占的内存空间\n- StackEmpty(S)：判定S是否为空栈。空，则返回ture,否则返回false\n- StackLength(S)：求栈的长度 [cpp::std::stack::size](https://cplusplus.com/reference/stack/stack/size/)\n- GetTop(S, &e)：取栈顶元素 [cpp::std::stack::top](https://cplusplus.com/reference/stack/stack/top/)\n- ClearStack(&S)：栈置空操作 [cpp::std::stack::empty](https://cplusplus.com/reference/stack/stack/empty/)\n- Push(&S, e)：入栈操作（压栈）[cpp::std::stack::push](https://cplusplus.com/reference/stack/stack/push/)\n- Pop(&S, &e)：出栈操作（弹栈）\n\n### 栈的顺序存储结构\n\n- 结点的类型定义\n\n  ```C\n  #define MAXSIZE 100 //定义栈中元素的最大个数\n  typedef struct {\n    ElemType data[MAXSIZE];//静态数组存放栈中元素\n    int top;  // 栈顶指针\n  } SqStack;\n  \n  void testStack(){\n  \tSqStack S;\t//声明一个顺序栈\n  \t//......\n  }\n  ```\n\n  栈顶指针：S.top，初始时设置 S.top = -1;\n\n  栈顶元素：s.data[s.Top]；\n\n  进栈操作：栈不满时，栈顶指针先加1，再送值到栈顶元素。\n\n  出栈操作：栈非空时，先去栈顶元素值，再将栈顶指针减1。\n\n  栈空条件：S.top == -1；\n\n  栈满条件：S.top == MaxSize-1;\n\n  栈长：S.top +1 。\n\n  此类一开始分配了最大空间的顺序栈要对栈溢出有相应的处理机制。\n\n- 顺序栈的基本运算\n\n  - 初始化`InitStack(&S)`:初始化栈，构造一个空栈S，分配内存空间\n\n    初始化栈就是让栈顶指针 top 指向 -1，因为栈顶指针指向的是栈顶元素，开始的时候没有元素，所以栈顶指针指向 0 这个位置是不合适的\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-3.png\" style=\"zoom: 75%;\" />\n\n  - 判栈空`StackEmpty(S)`:如上图，由于栈空的时候，数组中是没有任何元素的。如果要让栈顶指针指向0，显然是不合适的。所以空栈让栈顶指针的值为-1。因此，判断是否栈空时，只需要判断它的栈顶指针top是否等于-1就可以。\n\n  - 进栈`Push(&S,x)`:进栈，若栈S未满，则将 x 加入使之成为新栈顶；进栈时先让栈顶指针 top 加一，之后将新元素放在 top 指针所指向的位置\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-4.png\" style=\"zoom: 75%;\" />\n\n    或者写的更简洁一点，如下。\n\n    ```C\n    //新元素入栈\n    bool Push(SqStack &S, ElemType x) {\n    \tif(S.top == MaxSize-1) return false;\t//栈满，报错\n    \tS.data[++S.top] = x;\t//合并两句 \n    \treturn true; \n    }\n    ```\n\n  - 出栈`Pop(&S,&x)`:出栈，若栈S非空，则弹出栈顶元素，并用x返回\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-5.png\" style=\"zoom:75%;\" />\n\n    同上文，此处也可以将其中两句合并成一句更简洁的写法，如下\n\n    ```C\n    //出栈操作\n    bool Pop(SqStack &S, ElemType &x) {\n    \tif(S.top == -1) return false;\t//栈空，报错\n    \tx = S.data[S.top--];\t//合并两句\n    \treturn true; \n    }\n    ```\n\n  - 读栈顶元素`GetTop(S,&x)`:读取栈顶元素，若栈 S 非空，则用 x 返回栈顶元素\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-6.png\" style=\"zoom: 75%;\" />\n\n- 另一种操作方式\n\n  **初始化**时，令栈顶指针指向0，而不是-1。\n\n  ```C\n  #define MaxSize 10\n  typedef struct {\n  \tElemType data[MaxSize];\n  \tint top;\n  }SqStack; \n  \n  //初始化栈\n  void InitStack(SqStack &S) {\n  \tS.top = 0;\t//初始指向0 \n  }\n  \n  //判断栈空\n  bool StackEmpty(SqStack S) {\n  \tif(S.top == 0) return true;//此时注意栈空条件\n  \telse return false;\n  }\n  ```\n\n  **进栈、出栈**时。\n\n  ```C\n  //新元素入栈\n  bool Push(SqStack &S, ElemType x) {\n  \tif(S.top == MaxSize) return false;\t//判断栈满的条件不同\n  \tS.data[S.top++] = x;\t//赋值操作与指针移动操作顺序不同\n  \treturn true; \n  }\n  //出栈操作\n  bool Pop(SqStack &S, ElemType &x) {\n  \tif(S.top == 0) return false;\n  \tx = S.data[--S.top];\n  \treturn true; \n  }\n  ```\n\n  > 栈顶指针为-1和0的区别\n  > 在遇到相关问题时，一定要注意看清初始化栈顶指针的值。\n  > （1）当初始化为-1时，栈顶指针指向的是当前栈中的实际位置，而当初始化为为0时，栈顶指针指向的是下一次要插入的位置。\n  > （2）在进行入栈和出栈的操作时，二者核心操作是相反的。\n  > （3）在获取栈顶元素的操作中，如果初始化栈顶为0，那么需要先对指针减1才能取到栈顶元素的值，这点与初始化栈顶为-1时的操作有所不同。并且，如果函数定义中参数使用了引用传递，那么栈顶指针还需要再加1，保持栈顶指针原来的位置。如果使用值传递，则不需要，因为值传递不会改变原来的栈。\n\n- 共享栈\n\n  **顺序栈的缺点**：栈的大小不可变。\n\n  - 可以用链式存储的方式进行存储。\n  - 也可以在初始化的时候就声明一个较大的存储空间。\n\n  > 但我们知道，若一开始就申请较大空间的话，会造成空间的浪费。但是，我们可以通过**共享栈**的方式，来提高这一大片内存空间的利用率。\n  >\n  > 共享栈的意思就是，两个栈共享同一片空间。\n\n  我们可以设置两个栈顶指针。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-7.png\" style=\"zoom:75%;\" />\n\n  如果要往0号栈存放数据元素的话，是由下到上依次递增的；\n\n  如果要往1号栈存放数据元素的话，是由上到下依次递减的。\n\n  这两个栈，从逻辑上来说是两个不同的栈，但是在物理上，它们又共享同一片存储空间。这样就提高了空间利用率。\n\n  共享栈也是会满的。判断共享栈是否满了的条件，就是看`top0 + 1 == top1`\n\n  [一文搞懂共享栈](https://www.cxymm.net/article/zag666/105600288)\n\n<font color='green'>用一个数组实现两个栈</font>\n\n**思路**:从 **两头开始向中间生长**，当两个栈的 **栈顶指针相遇** 时，表示两个栈都满了\n\n```C\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAXSIZE 100\n#define ElementType int\n#define ERROR -1\n\nstruct DStack {\n    ElementType Data[MAXSIZE];\n    int Top1;  // 栈 1 的栈顶指针\n    int Top2;  // 栈 2 的栈顶指针\n} S;\n\nvoid Push(struct DStack* PtrS, ElementType item, int Tag) {\n    /* Tag 作为区分两个堆栈的标志，取值为 1 和 2 */\n    if (PtrS->Top2 - PtrS->Top1 == 1) {\n        printf(\"栈满\\n\");\n        return;\n    }\n    if (Tag == 1) {\n        PtrS->Data[++(PtrS->Top1)] = item;\n    } else {\n        PtrS->Data[--(PtrS->Top2)] = item;\n    }\n}\n\nElementType Pop(struct DStack* PtrS, int Tag) {\n    /* Tag 作为区分两个堆栈的标志，取值为 1 和 2 */\n    if (Tag == 1) {\n        if (PtrS->Top1 == -1) {\n            printf(\"栈1空\\n\");\n            return NULL;\n        } else {\n            return PtrS->Data[(PtrS->Top1)--];\n        }\n    } else {\n        if (PtrS->Top2 == MAXSIZE) {\n            printf(\"栈2空\\n\");\n            return NULL;\n        } else {\n            return PtrS->Data[(PtrS->Top2)++];\n        }\n    }\n}\n```\n\n### 栈的链式存储结构\n\n- 采用链式存储的栈称为<font color='purple'>链栈</font>，其优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况\n\n- 结点的类型定义\n\n  ```C\n  typedef struct StackNode {\n    SElemType data;\n    struct StackNode *next;\n  } StackNode, *LinkStack;\n  ```\n\n  进栈和出栈操作就对应于单链表的插入和删除操作（只在头结点那一端进行）。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-112.png\" style=\"zoom:55%;\" />\n\n  那么对于单链表在头结点处的插入删除，我们在第二章已经讲的很详细了，这里就不再赘述。\n\n  和单链表类似。对于链栈，我们也可以实现**带头结点**的版本，和**不带头结点**的版本，道理同单链表是一样的。\n\n- 初始化\n\n  ```C\n  Stack CreateStack() {\n      /* 构建一个栈的头结点，返回指针 */\n      Stack S;\n      S = (Stack)malloc(sizeof(struct SNode));\n      S->next = NULL;\n      return S;\n  }\n  ```\n\n- 入栈\n\n  ```C\n  void Push(ElementType item, Stack S) {\n      /* 将元素 item 压入栈 S */\n      struct SNode* TmpCell;\n      TmpCell = (struct SNode*)malloc(sizeof(struct SNode));\n      TmpCell->Data = item;\n      TmpCell->next = S->next;\n      S->next = TmpCell;\n  }\n  ```\n\n- 出栈\n\n  ```C\n  ElementType Pop(Stack S) {\n      /* 删除并返回栈 S 的栈顶元素 */\n      struct SNode* FirstCell;\n      ElementType TopElem;\n      if (IsEmpty(S)) {\n          printf(\"栈空\\n\");\n          return;\n      } else {\n          FirstCell = S->next;\n          S->next = FirstCell->next;\n          TopElem = FirstCell->Data;\n          free(FirstCell);\n          return TopElem;\n      }\n  }\n  ```\n\n- 判栈空\n\n  ```C\n  int IsEmpty(Stack S) {\n      /* 判断栈 S 是否为空，若为空函数返回整数 1，否则返回 0 */\n      return (S->next == NULL);\n  }\n  ```\n\n###  习题\n\n- 【2010】若元素 abcdef 依次进栈，允许出栈、退栈操作交替进行，但不允许连续 3 次进行退栈操作，不可能得到的出栈序列是→D\n\n  A. d c e b f a\n  B. c b d a e f\n  C. b c a e f d\n  D. a f e d c b\n\n  > 选项A,可由a入栈，b入栈，c入栈，d入栈，<font color='red'>d出栈</font>，<font color='red'>c出栈</font>，e入栈，<font color='red'>e出栈</font>，<font color='red'>b出栈</font>，f入栈，<font color='red'>f出栈</font>，<font color='red'>a出栈</font>得到\n  >\n  > 选项B,可由a入栈，b入栈，c入栈，<font color='red'>c出栈</font>，<font color='red'>b出栈</font>，d入栈，<font color='red'>d出栈</font>，<font color='red'>a出栈</font>，e入栈，<font color='red'>e出栈</font>，f入栈，<font color='red'>f出栈</font>得到\n  >\n  > 选项C，可由a入栈，b入栈，<font color='red'>b出栈</font>，c入栈，<font color='red'>c出栈</font>，<font color='red'>a出栈</font>，d入栈，e入栈，<font color='red'>e出栈</font>，f入栈，<font color='red'>f出栈</font>，<font color='red'>d出栈</font>得到\n  >\n  > 选项D，可由a入栈，<font color='red'>a出栈</font>，b入栈，c入栈，d入栈，e入栈，f入栈，<font color='red'>f出栈</font>，<font color='red'>e出栈</font>，<font color='red'>d出栈</font>，<font color='red'>c出栈</font>，<font color='red'>b出栈</font>得到  但不允许连续3次退栈\n\n- 【2009】设栈S和队列Q的初始状态均为空，元素abcdefg依次进入栈S。若每个元素出栈后立即进入队列Q，且7个元素出队的顺序是bdcfeag，则栈S的容量至少是-->3\n\n  > 由于**队列的特点是先进先出**，即栈S的出栈顺序就是队Q的出队顺序。故本题只需注意栈的特点是先进后出。出入栈的详细过程见下表。\n  >\n  > | 序号 | 说明  | 栈内 | 栈外 | 序号 | 说明  | 栈内 | 栈外    |\n  > | ---- | ----- | ---- | ---- | ---- | ----- | ---- | ------- |\n  > | 1    | a入栈 | a    |      | 8    | e入栈 | ae   | bdc     |\n  > | 2    | b入栈 | ab   |      | 9    | f入栈 | aef  | bdc     |\n  > | 3    | b出栈 | a    | b    | 10   | f出栈 | ae   | bdcf    |\n  > | 4    | c入栈 | ac   | b    | 11   | e出栈 | a    | bdcfe   |\n  > | 5    | d入栈 | acd  | b    | 12   | a出栈 |      | bdcfea  |\n  > | 6    | d出栈 | ac   | bd   | 13   | g入栈 | g    | bdcfea  |\n  > | 7    | c出栈 | a    | bdc  | 14   | g出栈 |      | bdcfeag |\n  >\n  > 栈内的最大深度为3，故栈S的容量至少是3。\n  >\n  > 【另解】元素的出栈顺序是b，d，c，f，e，a，g，可推出进栈出栈顺序为Push(S,a)，Push(S,b)，Pop(S,b)，Push(S,c)，Push(S,d)，Pop(S,d)，Pop(S,c)，Push(S,e)，Push(S,f)，Pop(S,f)，Pop(S,e)，Pop(S,a)，Push(S,g)，Pop(S,g)。假设初始所需容量为0，每做一次Push进行一次“+1”操作，每做一次Pop进行一次“-1”操作，记录容量的最大值为3。\n\n- 【2011】元素a,b,c,d,e依次进入初始为空的栈中，若元素进栈后可停留、可出栈，直到所有元素都出栈，则在所有可能的出栈序列中，以元素d开头的序列个数是-->4\n\n  > 考虑到题目要求是d先出栈，所以abcd的入栈顺序已经确定，e的入栈和出栈决定有几种顺序。 \n  >\n  > 1.abcd依次入栈，d出栈，e入栈，然后剩下的出栈顺序为ecba \n  >\n  > 2.abcd依次入栈，d出栈，c出栈，e入栈，e出栈，剩下的出栈顺序ba \n  >\n  > 3.abcd依次入栈，d出栈，c出栈，b出栈，e入栈，e出栈，a出栈 \n  >\n  > 4.abcd依次入栈，d出栈，c出栈，b出栈，a出栈，e入栈，e出栈，a出栈\n\n- 【2013】一个栈的入栈序列为1,2,3,...,n,出栈序列是P1,P2,P3,...,Pn。若P2 = 3，则 P3 可能取值的个数是-->(n-1)个\n\n  > 首先，栈的先进后出原则大家应该是知道的。\n  >\n  > 根据题意 P2 = 3，可以知道P1的可能情况有三种：**1,2或4** 。（看到有些人只想到了1，2）\n  >\n  > 为啥这样想呢？这里估计还有一个关键是要**考虑到 n 的大小**。\n  >\n  > **当 n = 3 时**， P2 = 3 的话，那么 P1 有两种情况 1 和 2 。\n  >\n  > - 如果 P1 = 1 ，那么 P3 = 2 ；\n  > - 如果 P1 = 2 ，那么 P3 = 1 ；\n  >\n  > 此时的话我们就可以看到 P3 只有两种可能 1或者2       （n - 1）个。\n  >\n  > **当 n > 3 时**： P2 = 3 的话，那么 P1 有三种情况1,2和4。\n  >\n  > - 如果 P1 = 1 ，那么 P3 = 2，4，5，...  n     （n - 2）个    \n  > - 如果 P1 = 2 ，那么 P3 = 1，4，5，...  n     （n - 2）个    \n  > - 如果 P1 = 4 ，那么 P3 = 2，5，6，...  n     （n - 3）个  \n  >\n  > 此时的话我们就可以看到 P3 的情况有 1，2，4，5，... n （n - 1）个。\n  >\n  > 综上所述就是 P3 可能取值的个数是 （n - 1）个。\n\n- 【2017】下列关于栈的叙述中，错误的是->I、Ⅲ、Ⅳ\n\n  Ⅰ．采用非递归方式重写递归程序时必须使用栈 \n\n  Ⅱ．函数调用时，系统要用栈保存必要的信息 \n\n  Ⅲ．只要确定了入桟次序，即可确定出栈次序\n\n  Ⅳ．栈是一种受限的线性表，允许在其两端进行操作\n\n  > I. 尾递归可以直接使用循环\n  >\n  > II.确定了入桟次序，不能确定出栈次序\n  >\n  > IV．栈是一种受限的线性表，允许在其一端（栈顶）进行操作\n\n- 【2018】若栈S1中保存整数，栈S2中保存运算符，函数F()依次执行下述各步操作:\n\n  （1）从S1中依次弹出两个操作数a和b；\n  （2）从S2中弹出一个运算符op；\n  （3）执行相应的运算b op a；\n  （4）将运算结果压入S1中。\n\n    假定S1中的操作数依次是5,8,3,2（2在栈顶），S2中的运算符依次是*,-,+（+在栈顶） \n\n    调用3次F()后，S1栈顶保存的值是-->15\n\n  > S1第一次弹出a,b 即 2,3  S2 弹出 “ +”  操作为 b + a  即 （3 + 2） 压入 S1 现在 S1 为 5 8 5 \n  >\n  > S1第二次弹出a,b 即 5，8 S2弹出\"-\" 操作为 b - a 即（8-5）压入S1 现在 S1 为 5 3 \n  >\n  > S1第三次弹出a,b 即 3,5  S2弹出 “*” 操作为 b*a  即 5*3 压入S 现在S1 为 15\n  > 所以三次后S1 栈顶为15\n\n- 【2020】对空栈S进行Push和Pop操作，入栈序列为a,b,c,d,e，经过Push，Push，Pop，Push，Pop，Push，Push，Pop 操作后得到的出栈序列是-->b,c,e\n\n  > 根据题意，出入栈操作的过程如下:\n  >\n  > | 操作 | 栈内元素 | 出栈元素 |\n  > | ---- | -------- | -------- |\n  > | Push | a        |          |\n  > | Push | a b      |          |\n  > | Pop  | a        | b        |\n  > | Push | a c      |          |\n  > | Pop  | a        | c        |\n  > | Push | a d      |          |\n  > | Push | a d e    |          |\n  > | Pop  | a d      | e        |\n  >\n  > 所以出栈元素序列为b,c,e\n\n## 3.2 队列 Queue\n\n### 队列的基本概念\n\n### 队列的定义\n\n- 队列简称队，也是一种操作受限的线性表，<font color='orange'>只允许在表的一端进行插入，而在表的另一端进行删除</font>\n\n- 向队列中插入元素称为**入队**或**进队**\n\n- 删除元素称为**出队**或**离队**\n\n- 特性：先进先出 First In First Out, FIFO\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-8.png\" style=\"zoom: 75%;\" />\n\n### 队列常见的基本操作\n\n- InitQueue(&Q)：初始化队列。\n- DestoryQueue(&Q)：销毁队列。并释放队列Q所占用的内存空间。\n- ClearQueue(&Q)：清空队列。\n- QueueLength(Q)：求队列长度。\n- GetHead(Q,&e)：得到队头元素，若队列Q非空，则将队头元素赋值给e。\n- EnQueue(&Q, e)：入队，若队列Q未满，将e加入，使之成为新的<font color='purple'>队尾</font>font>。\n- DeQueue(&Q, &e)：出队，若队列Q非空，删除<font color='purple'>队头</font>font>元素，并用e返回。\n- QueueEmpty(Q)：判队列空，若队列Q为空返回true，否则返回false。\n\n### 队列的顺序存储结构\n\n#### 队列的顺序存储\n\n队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针：队头指针front指向队头元素。队尾指针rear指向队尾元素的下一个位置（其实和单链表有无头结点是一样的，队尾指针你想指向最后一个元素或者最后一个元素的下一位都行，注意相应的操作随之变动就行）。\n\n- **结点类型定义**\n\n  ```C\n  #define MAXSIZE 100 // 最大队列长度\n  typedef struct{\n      QElemType *base; // 初始化的动态分配存储空间\n      int front;       // 队头指针\n      int rear;        // 队尾指针\n  } SqQueue;\n  void testQueue(){\n      SqQueue Q;\t//声明一个队列（顺序存储）\n      //......\n  }\n  ```\n\n  初始状态（队空条件）：Q.front == Q.rear == 0。\n\n  进队操作：队不满时，先送值到队尾元素，再将队尾指针加1。\n\n  出队操作：队不空时，先去队头元素值，再将队头指针加1。\n\n- **初始化操作**\n\n  `InitQueue(&Q)` : 初始化队列，构造一个空队列 Q\n\n  我们可以规定，让队头指针指向队头元素；让队尾指针指向队尾元素的后一个位置（接下来应该插入数据元素的位置）。那么在初始化的时候，我们可以令队头、队尾指针均指向0。\n\n  ```C\n  #define MaxSize 10\t\t\t\t\t// 定义队列中元素的最大个数\n  typedef struct {\n      ELemType data[MaxSize];\t\t\t// 用静态数组存放队列元素\n      int front,rear;\t\t\t\t\t// 队头指针和队尾指针\n  }SqQueue;\n  \n  // 初始化队列\n  void InitQueue(SqQueue &Q){\n      // 初始时,队头、队尾指针指向0\n      Q.rear = Q.front = 0;\n  }\n  ```\n\n  - 队头指针 front 指向队头元素\n\n  - 队尾指针 rear 指向队尾元素的后一个位置(下一个应该插入的位置)\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-15.png\" style=\"zoom: 50%;\" />\n\n- **判断队列是否为空**\n\n  `QueueEmpty(Q)` : 判断队列是否为空，若队列Q为空则返回 true，否则返回 false\n\n  ```C\n  // 判断队列是否为空\n  bool QueueEmpty(SqQueue Q){\n      if(Q.rear == Q.front){\t\t\t// 队空条件\n          return true;\n      }else{\n          return false;\n      }\n  }\n  ```\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-16.png\" style=\"zoom: 50%;\" />\n\n- **入队操作**\n\n  `EnQueue(&Q,x)` : 入队，若队列 Q 未满，将 x 加入，使之称为新的队尾\n\n  只能从队尾入队。把这一次要插入的数据元素，把它放到队尾指针所指向的位置。把队尾指针加1。\n\n  ```C\n  //入队\n  bool EnQueue(SqQueue &Q, ElemType x) {\n  \tif(队列已满) return false;\t//队满则报错\n  \tQ.data[Q.rear] = x;\t//将x插入队尾\n  \tQ.rear = Q.rear + 1;\t//队尾指针后移\n  \treturn true; \n  }\n  ```\n\n  <font color='cornflowerblue'>那么我们是否可以认为，队列已满的条件，就是`rear == MaxSize`呢？</font>\n\n  并不是这样。\n\n  因为，在`rear == MaxSize`的情况下，若队头出队了一些元素，则队列显然不满。但rear仍然是等于MaxSize的。\n\n  同时，接下来的新元素，是要插入到队头元素之前的空位当中的。\n\n  <font color='cornflowerblue'>那么怎样让队尾指针指向接下来要插入的队头元素前的空位处呢？</font>\n\n  只需进行一个**取余操作**即可。\n\n  看下列图\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-17.png\" style=\"zoom:55%;\" />\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-19.png\" style=\"zoom:55%;\" />\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-20.png\" style=\"zoom:55%;\" />\n\n  所以队尾指针 rear 其实是从队头指向队尾，再从队尾指向队头，这样循环移动。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-21.png\" style=\"zoom:55%;\" />\n\n  这样使用模运算将存储空间在逻辑上变成了 “**环状**”，我们也称之为<font color='red'>循环队列</font>(稍后引出)\n\n  ```C\n  #define MaxSize 10\t\t\t\t\t// 定义队列中元素的最大个数\n  typedef struct {\n    ELemType data[MaxSize];\t\t\t// 用静态数组存放队列元素\n      int front,rear;\t\t\t\t\t// 队头指针和队尾指针\n  }SqQueue;\n  \n  // 入队\n  bool EnQueue(SqQueue &Q,ElemeType x){\n      if((Q.rear + 1)%MaxSize == Q.front){\t// 判断队满\n          return false;\t\t\t\t\t\t// 队满则报错\n      }\n      Q.data[Q.rear] = x;\t\t\t\t\t\t// 将 x 插入队尾\n      Q.rear = (Q.rear + 1)%MaxSize;\t\t\t// 队尾指针加1取模,用模运算将存储空间在逻辑上变成了\"环状\"\n      return true;\n  }\n  ```\n\n  那么此时就可以知道，队列已满的条件为：队尾指针的下一个位置是队头，即`(Q.rear + 1) % MaxSize == Q.front`。\n\n  > 此处，有些人会认为。队尾指针指向的就是“接下来应该插入元素的位置”，也就是队尾指针指向的位置是一个空闲空间。**那么为什么队尾指针所指向的位置的下一个是队头时，就判满了呢？**不是还有一个空间空间吗？如果“真正满了”的话，应该是队尾指针指向队头指针呀。\n  >\n  > 要知道，队尾指针和队头指针相等，那是我们在初始化队列的时候，让队头指针和队尾指针指向同一个位置的。此外，我们也根据队尾指针与队头指针是否指向同一个位置，来判断队列是否为空。\n\n  > 这样就没办法。所以我们必须牺牲一个存储单元。来将判满与判空区分开来。\n\n- **出队操作**\n\n  `DeQueue(&Q,&x)` : 出队，若队列 Q 非空，删除队头元素，并用 x 返回\n\n  只能从队头出队\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-110.png\" style=\"zoom: 33%;\" />\n\n  ```C\n  #define MaxSize 10\t\t\t\t\t// 定义队列中元素的最大个数\n  typedef struct {\n      ELemType data[MaxSize];\t\t\t// 用静态数组存放队列元素\n      int front,rear;\t\t\t\t\t// 队头指针和队尾指针\n  }SqQueue;\n  \n  // 出队(删除一个队头元素,并用 x 返回)\n  bool DeQueue(SqQueue &Q,ElemType &x){\n      if(Q.rear ==Q.front){\t\t\t\t\t// 判断队空\n          return false;\t\t\t\t\t\t// 队空则报错\n    }\n      X = Q.data[Q.front];\n      Q.front = (Q.front +1)%MaxSize;\t\t\t// 队头指针后移\n      return true;\t\t\t\t\n  }\n  ```\n\n- **获得队头元素值**\n\n  `GetHead(Q,&x)` ：读取队头元素，若队列Q非空，则将队头元素\n\n  ```C\n  #define MaxSize 10\t\t\t\t\t// 定义队列中元素的最大个数\n  typedef struct {\n      ELemType data[MaxSize];\t\t\t// 用静态数组存放队列元素\n      int front,rear;\t\t\t\t\t// 队头指针和队尾指针\n  }SqQueue;\n  \n  // 获得队头元素的值,用 x 返回\n  bool GetHead(SqQueue Q,ElemType &x){\n      if(Q.rear == Q.front){\t\t\t// 判断队空\n          return false;   \t\t\t// 队空则报错\n      }\n      X = Q.data[Q.front];\t\t\t// 获得队头元素值\n      return true;\n  }\n  ```\n\n- **假溢出**\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-11.png\" style=\"zoom:67%;\" />\n\n  (a)所示为队列的初始状态，有Q.front == Q.front == 0成立，该条件可以作为队列判空的条件。但能否用Q.rear == MaxSize作为队列满的条件呢？显然不能，图(d)中，队列中仅有一个元素，但仍然满足该条件，这时队列出现“上溢出”，按理说，此时就不能将其他元素加入队列。但这种溢出并不是真正的溢出，在data数组中仍然存在可以存放元素的空位置，所以这是一种“<font color='red'>假溢出</font>”。\n\n#### 循环队列\n\n为了解决顺序队列的“<font color='red'>假溢出</font>”也就是空间只能用一次，严重浪费的问题，我们引出一个**循环队列**的概念。\n\n循环队列就是将顺序队列臆造为一个环状的空间，即把存储队列元素的表从逻辑上视为一个环（用链表来的指针来向下会清晰很多），称为循环队列。当队首指针`Q.front=MaxSize-1`后，再前进一个位置就自动到0，实现上可以用取余来实现。\n\n初始时：`Q.front = Q.rear = 0`;\n\n队首指针进1：`Q.front = (Q.front+1)%MaxSize`\n\n队尾指针进1：`Q.rear = (Q.rear+1)%MaxSize`\n\n对列长度：`（Q.rear+MaxSize-Q.front）%MaxSize`\n\n出队入队时：指针都按顺时针方向进1。\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-12.png\" style=\"zoom:67%;\" />\n\n根据我们前面所述，队空的时候：`Q.front = Q.rear`；那这样的话考虑一下队满的时候咋表示，顺着思路走，位指针要指向队尾的下一个，那不就是：`Q.rear = Q.front` 。这样不就队空队满无法区分了吗？\n\n<font color='orange'>为了区分队空队满的情况</font>，有以下三种处理方式：\n\n1. 牺牲一个单元来区分队空还是队满，如队时少用一个队列单元，约定以“队头指针在队尾指针的下一位置作为队满的标志”。如图(d2)所示。\n\n   **队满**：`(Q.rear+1)%MaxSize  == Q.front`；\n\n   **队空**：`Q.front == Q.rear`。\n\n   **队列中元素个数**：`(Q.rear - Q.front + MaxSize)%MaxSize`。\n\n2. 类型中增设一个数据成员，专门记录队列中元素的个数。\n\n3. 类型中增设tag数据成员，以区分是队满还是队空。tag等于0时，若因删除导致`Q.front == Q.rear`，则为队空；tag等于1时，若因插入导致`Q.front == Q.rear`，则为队满。\n\n<font color='red'>接下来会具体谈到如何判断队列已满</font>\n\n#### 循环队列的操作\n\n- **初始化**\n\n  ```C\n  void InitQueue(SqQueue &Q){\n      Q.base = new QElemType[MAXSIZE];\n      if(!Q.base) exit(OVERFLOW);\n      Q.front = Q.rear = 0;\n      return OK;\n  }\n  ```\n\n- **判队空**\n\n  ```C\n  bool isEmpty(SqQueue Q){\n      if(Q.rear == Q.front) // 队空条件\n          return true;  \n      else \n          return false;\n  }\n  ```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-13.png\" style=\"zoom:67%;\" />\n\n- **入队**\n\n  ```C\n  bool EnQueue(SqQueue &Q, QElemType e){\n    if((Q.rear+1) % MAXQSIZE == Q.front)  //判断队满\n       return false; // 队满则报错\n    Q.base[Q.rear] = e;//新元素插入队尾\n    Q.rear = (Q.rear + 1) % MAXQSIZE;//队尾指针加1取模  用模运算将存储空间在逻辑上变成了\"环状\"\n    return true;\n  }\n  ```\n\n- **出队**\n\n  `DeQueue(&Q,&x)` : 出队，若队列 Q 非空，删除队头元素，并用 x 返回\n\n  只能从队头出队\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-22.png\" style=\"zoom:55%;\" />\n\n  ```C\n  bool DeQueue(SqQueue &Q, QElemType &e){\n  if(Q.rear == Q.front)  //判断队空\n      return false; // 队空则报错\n      e = Q.base[Q.front];\n      Q.front = (Q.front + 1) % MAXQSIZE;//队头指针后移\n      return true\n  }\n  ```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-14.png\" style=\"zoom:67%;\" />\n\n- **获得队头元素**\n\n  `GetHead(Q,&x)` ：读取队头元素，若队列Q非空，则将队头元素\n\n  ```C\n  bool GetHead(SqQueue Q, ElemType &e){\n      if(Q.rear==Q.front)\n          return false;  //队空则报错\n      e=Q.data[Q.front];//获得队头元素\n      return true;\n  }\n  ```\n\n#### 判断队列已满/已空\n\n我们前面说判断队列满的时候，不得不牺牲一个存储单元，否则就与我们的队空相互矛盾，但是有时候出题老师可不想让我们浪费这一个存储单元，所以判断队列已满/已空有两种方案\n\n- 方案一：浪费一个存储单元\n- 方案二：不浪费一个存储单元，用一个 size\n- 方案三：不浪费存储单元，用一个 tag 标记\n\n##### 方案一\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-26.png\" style=\"zoom:75%;\" />\n\n- 队列已满的条件：队尾指针的再下一个位置是队头，即 `(Q.rear+1)%MaxSize == Q.front`\n\n- 队空的条件是：队尾指针和队头指针指向相同，`Q.rear == Q.front`\n\n- 队列元素个数：`(rear + MaxSize - front)%MaxSize`\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-23.png\" style=\"zoom: 67%;\" />\n\n<font color='orange'>这种方案其实算是牺牲了一个存储空间来区分队满、队空</font>\n\n##### 方案二\n\n**但有时在题目中，不允许牺牲那一个存储空间，因此我们要另想一种方案**:\n\n在队列的结构体类型中，额外定义一个属性`int size;`，用来表示队列当前长度。刚开始我们将size设为0，之后每次插入一个元素，就size++，每删除一个元素，就size–-。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-27.png\" style=\"zoom:75%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-24.png\" style=\"zoom: 55%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-25.png\" style=\"zoom:55%;\" />\n\n虽然队头和队尾指针都指向了同一位置，但是由于 size 的存在，所以仍然可以判断队列是满的还是空的。\n\n```C\n#define MaxSize 10\t\t\t\t\t// 定义队列中元素的最大个数\ntypedef struct {\n    ELemType data[MaxSize];\t\t\t// 用静态数组存放队列元素\n    int front,rear;\t\t\t\t\t// 队头指针和队尾指针\n    int size;\t\t\t\t\t\t// 队列当前长度\n}SqQueue;\n// 初始化队列\nvoid InitQueue(SqQueue &Q){\n    Q.rear = Q.front = 0;// 初始时,队头、队尾指针指向0\n    size = 0;// 队列长度也为0\n}\n// 入队\nbool EnQueue(SqQueue &Q,ElemeType x){\n    if(Q.size == MaxSize){\t\t\t\t\t// 判断队满\n        return false;\t\t\t\t\t\t// 队满则报错\n    }\n    Q.data[Q.rear] = x;\t\t\t\t\t\t// 将 x 插入队尾\n    Q.rear = (Q.rear + 1)%MaxSize;\t\t\t// 队尾指针加1取模,用模运算将存储空间在逻辑上变成了\"环状\"\n    size++;\t\t\t\t\t\t\t\t\t// 每一次入队成功我们让队列长度 + 1\n    return true;\n}\n// 出队(删除一个队头元素,并用 x 返回)\nbool DeQueue(SqQueue &Q,ElemType &x){\n    if(Q.size == 0){\t\t\t\t\t\t// 判断队空\n        return false;\t\t\t\t\t\t// 队空则报错\n    }\n    X = Q.data[Q.front];\n    Q.front = (Q.front +1)%MaxSize;\t\t\t// 队头指针后移\n    size--;\t\t\t\t\t\t\t\t\t// 每一次出队成功我们让队列长度 - 1\n    return true;\t\t\t\t\n}\n```\n\n##### 方案三\n\n在队列的结构类型中，定义一个`int tag;`，当tag为0的时候，表示最近一次执行的操作是删除操作；当tag为1的时候，表示最近一次执行的操作是插入操作。\n\n那么，也就是每次删除操作后，都将tag置为0；每次插入操作后，都将tag置为1。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-28.png\" style=\"zoom:75%;\" />\n\n```C\n#define MaxSize 10\t\t\t\t\t// 定义队列中元素的最大个数\ntypedef struct {\n    ELemType data[MaxSize];\t\t\t// 用静态数组存放队列元素\n    int front,rear;\t\t\t\t\t// 队头指针和队尾指针\n    int tag;\t\t\t\t\t\t// 最近进行的是删除(0)/插入(1)\n}SqQueue;\n// 初始化队列\nvoid InitQueue(SqQueue &Q){\n    Q.rear = Q.front = 0;// 初始时,队头、队尾指针指向0\n    tag = 0;// 标志为0\n}\n// 入队\nbool EnQueue(SqQueue &Q,ElemeType x){\n    if(Q.front == Q.rear && tag == 1){\t\t// 判断队满,只有插入操作,才可能导致队满\n        return false;\t\t\t\t\t\t// 队满则报错\n    }\n    Q.data[Q.rear] = x;\t\t\t\t\t\t// 将 x 插入队尾\n    Q.rear = (Q.rear + 1)%MaxSize;\t\t\t// 队尾指针加1取模,用模运算将存储空间在逻辑上变成了\"环状\"\n    tag == 1;\t\t\t\t\t\t\t\t// 每次插入操作成功时,都令 tag = 1\n    return true;\n}\n// 出队(删除一个队头元素,并用 x 返回)\nbool DeQueue(SqQueue &Q,ElemType &x){\n    if(Q.front == Q.rear && tag == 0){\t\t// 判断队空,只有删除操作,才可能导致队空\n        return false;\t\t\t\t\t\t// 队空则报错\n    }\n    X = Q.data[Q.front];\n    Q.front = (Q.front +1)%MaxSize;\t\t\t// 队头指针后移\n    tag == 0;\t\t\t\t\t\t\t\t// 每次删除操作成功时,都令 tag = 0\n    return true;\t\t\t\t\n}\n```\n\n#### 其他出题方法\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-114.png\" style=\"zoom:69%;\" />\n\n还有一种出题方法，就是队尾指针 rear 指向的不是队尾元素的下一个，而是队尾元素的位置\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-113.png\" style=\"zoom: 33%;\" />\n\n- 初始化\n\n  ```C\n  // 初始化队列\n  void InitQueue(SqQueue &Q){\n      // 初始时,队头指针指向0,队尾指针指向 n - 1\n      Q.front = 0;\n      Q.rear = n - 1\n  }\n  ```\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-40.png\" style=\"zoom:55%;\" />\n\n- 入队操作\n\n  ```C\n  // 入队\n  bool EnQueue(SqQueue &Q,ElemeType x){\n      if((Q.rear + 1)%MaxSize == Q.front){\t// 判断队满\n          return false;\t\t\t\t\t\t// 队满则报错\n      }\n      Q.rear = (Q.rear + 1)%MaxSize;\t\t\t// 先将队尾指针向上移一位\n      Q.data[Q.rear] = x;\t\t\t\t\t\t// 再将 x 插入队尾\n      \n      return true;\n  }\n  ```\n\n### 队列的链式存储结构\n\n#### 队列的链式存储\n\n队列的链式表示称为**链队列**，它实际上是一个同时带有队头指针和队尾指针的单链表。 头指针指向队头结点，尾指针指向队尾结点，即单链表的最后一个结点（注意与顺序存储的不同）。\n\n**结点类型定义**\n\n```c\ntypedef struct {  //链式队列结点\n    ElemType data;\n    struct LinkNode *next;\n}LinkNode;\ntypedef struct{  //链式队列\n    LinkNode *front, *rear;  //队列的队头和队尾指针\n}LinkQueue;\n```\n\n当`Q.front == NULL && Q.rear == NULL`时，链式队列为空。\n\n出队时，首先判断队是否为空，若不空，则取出队头元素，将其从链表中华摘除，并让`Q.front = Q.front->next`；\n\n入队时，建立一个新的结点，将该结点插入到链表的尾部，并让`Q.rear = Q.rear->next`。\n\n从上述描述看出，出现了和顺序队列同样的问题，就是操作浪费空间（空间只能用一次），且耗时。\n\n#### 链式队列的基本操作\n\n##### 带头结点\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-29.png\" style=\"zoom:67%;\" />\n\n- **初始化**\n\n  先申请一个结点，然后让队头指针 front、队尾指针 rear 都指向这个结点\n\n  之后让此结点的指针域指向NULL\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-30.png\" style=\"zoom: 50%;\" />\n\n  ```C\n  // 初始化队列(带头结点)\n  void InitQueue(LinkQueue &Q){\n      // 初始时, front、rear 都指向头结点\n      Q.front = Q.rear = (LinkNode*)malloc(size(LinkNode));\n      Q.front->next = NULL;\n  }\n  ```\n\n- **判队空**\n\n  判断队列是否为空，只需要看队头指针和队尾指针是否指向相同，指向相同队列为空，指向不相同队列不为空\n\n  ```C\n  // 判断队列是否为空(带头结点)\n  bool IsEmpty(LinkQueue Q){\n      if(Q.front == Q.rear){\n          return true;\n      }else{\n          return false;\n      }\n  ```\n\n- **入队**\n\n  入队只能在队尾入队\n\n  - 先申请一个结点s，将新入队元素 x 放入这个结点中\n\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-31.png\" style=\"zoom: 50%;\" />\n\n  - 将 s 结点的指针域指向 NULL，之后将 s 结点插入到 rear 之后\n\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-32.png\" style=\"zoom: 50%;\" />\n\n  - 修改表尾指针为 s 结点\n\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-33.png\" style=\"zoom: 50%;\" />\n\n  ```C\n  // 新元素入队(带头结点)\n  void EnQue(LinkQueue &Q,ElemType x){\n      LinkNode *s =(LinkNode *)malloc(sizeof(LinkNode));\t\t\t\t// 用 malloc 申请一个新结点\n      s->data = x;\t\t\t\t\t\t\t\t\t\t\t\t\t// 将 x 放入这个结点中\n      s->next = NULL;\t\t\t\t// 插入操作在表尾进行,新插入的结点x肯定是在表尾,所以将x结点指针域设为NULL\n      Q.rear->next = s;\t\t\t\t\t\t// 新结点插入到 rear 之后\n      Q.rear = s;\t\t\t\t\t\t\t\t// 修改表尾指针\n  }\n  ```\n\n- **出队**\n\n  带头结点出队只能从队头出队\n\n  - 申请一个新结点 p 指向头结点后面的一个结点(也就是队头结点)，用变量 x 返回队头结点元素\n\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-34.png\" style=\"zoom: 50%;\" />\n\n  - 修改头结点的 next 指针，使其指向 p 结点的下一个结点\n\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-35.png\" style=\"zoom: 50%;\" />\n\n  - 如果出队的结点是最后一个结点，我们要修改队尾指针rear，让其指向头结点\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-36.png\" style=\"zoom:45%;\" />\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-37.png\" style=\"zoom:45%;\" />\n\n  - 释放 p 结点\n\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-38.png\" style=\"zoom: 50%;\" />\n\n  ```C\n  // 队头元素出队(不带头结点)\n  bool DeQueue(LinkQueue &Q,ElemType &x){\n      if(Q.front == Q.rear){\n          return false;\t\t\t\t\t\t// 空队\n      }\n      LinkNode *p = Q.front->next;\t\t\t// 申请新结点p 指向头结点的后面一个结点\n      x = p->data;\t\t\t\t\t\t\t// 用变量 x 返回队头元素\n      Q.front->next = p->next;\t\t\t\t// 修改头结点的 next 指针\n      if(Q.rear == p){\t\t\t\t\t\t// 如果此次是最后一个结点出队\n          Q.rear = Q.front;\t\t\t\t\t// 修改 rear 指针\n      }\t\t\n      free(p);\t\t\t\t\t\t\t\t// 释放结点空间\n      return true;\n  }\n  ```\n\n##### 不带头结点\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-41.png\" style=\"zoom:67%;\" />\n\n- 初始化\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-42.png\" style=\"zoom: 50%;\" />\n\n  ```C\n  // 初始化队列(不带头结点)\n  void InitQueue(LinkQueue &Q){\n      // 初始时, front、rear 都指向NULL\n      Q.front = NULL;\n      Q.rear = NULL;\n  }\n  ```\n\n- 判队列空\n\n  ```C\n  // 判断队列是否为空(不带头结点)\n  bool IsEmpty(LinkQueue Q){\n      if(Q.front == NULL){\n          return true;\n      }else{\n          return false;\n      }\n  }\n  ```\n\n- 入队操作\n\n  不带头结点的队列，第一个元素入队时需要特别处理\n\n  - 先申请一个新结点 s，将新入队元素 x 放入这个结点中，将此结点的 next 指针域 指向 NULL\n\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-43.png\" style=\"zoom: 50%;\" />\n\n  - 需要判断如果这个队列为空，那么就意味着新结点 s 是这个队列的第一个结点，需要将 front、rear 都指向这个新结点 s\n\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-44.png\" style=\"zoom: 50%;\" />\n\n  - 如果队列不为空，就是执行后插操作了\n\n\n  ```C\n  // 新元素入队(不带头结点)\n  void EnQue(LinkQueue &Q,ElemType x){\n      LinkNode *s =(LinkNode *)malloc(sizeof(LinkNode));\t\t// 申请新结点\n      s->data = x;\t\t\t\t\t\t\t\t\t\t\t// 向此结点写入数据元素 x\n      s->next = NULL;\t\t\t\t// 插入操作在表尾进行,新插入的结点x肯定是在表尾,所以将x结点指针域设为NULL\n      if(Q.front == NULL){\t\t\t\t\t// 如果队列为空\t\n          Q.front = s;\t\t\t\t\t\t// 不带头结点的队列，第一个元素入队时需要特别处理\t\n          Q.rear = s;\t\t\t\t\t\t\t// 在空队列中插入第一个元素,修改队头队尾指针\n      }else{\n          Q.rear->next = s;\t\t\t\t\t\t// 新结点插入到 rear 之后\n      \tQ.rear = s;\t\t\t\t\t\t\t\t// 修改表尾指针\n      }\n  }\n  ```\n\n- 出队操作\n\n  不带头结点出队只能从队头出队\n\n  - 首先申请新结点 p 指向此次出队的结点(队头结点)，用变量 x 返回队头元素\n\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-45.png\" style=\"zoom: 50%;\" />\n\n  - 修改队头指针 front 指向，需要将 front 、rear 指针指向 NULL(将其恢复为空队的状态)\n\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-46.png\" style=\"zoom: 50%;\" />\n\n  - 释放结点 p\n\n\n  ```C\n  // 队头元素出队(不带头结点)\n  bool DeQueue(LinkQueue &Q,ElemType &x){\n      if(Q.front == NULL){\n          return false;\t\t\t\t\t\t\t\t// 空队\n      }\n      LinkNode *p = Q.front;\t\t\t\t\t\t\t// 申请新结点 p 指向此次出队的结点\n      x = p->data;\t\t\t\t\t\t\t\t\t// 用变量 x 返回队头元素\n      Q.front = p->next;\t\t\t\t\t\t\t\t// 修改 front 指针\n      if(Q.rear == p){\n          Q.front = NULL;\t\t\t\t\t\t\t\t// front 指向 NULL\n          Q.rear = NULL;\t\t\t\t\t\t\t\t// rear 指向 NULL\n      }\n      free(P);\t\t\t\t\t\t\t\t\t\t// 释放结点空间\n      return true; \n  }\n  ```\n\n##### 队列满的条件\n\n之前顺序存储实现的队列，由于是用静态数组分配的，其空间是有限的、不可拓展的，所以其最大空间被耗尽时队满。\n\n而此处用链式存储实现的队列，它的容量是可以扩展的，一般不会队满，除非内存不足。\n\n因此，在顺序存储的队列当中，我们花了很多办法去判断队列是否已满；而在链式存储实现的队列当中，我们一般不用关心已满的问题。\n\n### 双端队列\n\n- 双端队列是指<font color='orange'>允许两端都可以进行入队和出队操作的队列</font>，其元素的逻<font color='orange'>辑结构仍是线性结构</font>font>\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-47.png\" style=\"zoom:67%;\" />\n\n- 将队列的两端分别称为前端和后端，两端都可以入队和出队\n\n- 输出受限的双端队列：允许在一端进行插入和删除，另一端只允许插入\n\n- 输入受限的双端队列：允许在一端进行插入和删除，另一端只允许删除\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-48.png\" style=\"zoom:67%;\" />\n\n> 若对于一个双端队列，我只使用其中一端的插入、删除操作，那么我的使用效果就等同于使用一个栈。\n>\n> 也就是说，栈能够实现的功能，双端队列一定能实现。\n>\n> 队列同理。\n\n**考点**\n\n此处双端队列比较喜欢考察的考点，就是**判断输出序列的合法性**。（类似于栈那里的考点）\n\n###  习题\n\n- 【2010】某队列允许在其两端进行入队操作，但仅允许在一端进行出队操作。若元素a,b,c,d,e依次入此队列后再进行出队操作，则不可能得到的出队序列是->d b c a e\n\n  > 双端队列的题可以用以下技巧： \n  >\n  > 入队顺序为a b c d e，则出队顺序必然包含在序列e d c b a b c d e中，找出选项中不符合条件的序列即可。 \n  >\n  > -  A e d c **b** **a** b **c d e** 符合      \n  > -  B e **d** c **b** **a** b **c** d **e** 符合      \n  > -  C e **d** c **b** a b **c** d e 不符合      \n  > -  D **e** d **c** **b a** b c **d** e 符合\n\n- 【2011】已知循环队列存储在一维数组A[0...n-1]中，且队列非空时front和rear分别指向队头元素和队尾元素。若初试队列为空，且要求第一个进入队列的元素存储在A[0]处，则初始时front和rear的值分别是→0，n-1\n\n  > 循环队列需要留出一个空间，方便判断队列是否为满（循环队列解决假溢出）； \n  >\n  > 常用的队列实现： \n  >\n  > 当队列为空时，front == rear；其中rear指向队尾元素的下一个位置，即下一个元素入队的位置 \n  >\n  > 入队操作：先赋值，再rear = (rear+1)%MAXSIZE；此时rear仍然指向队尾元素的下一个位置 \n  >\n  > 但是题目中！！！有一句！！！front和rear分别指向队头元素和队尾元素！！！  \n  >\n  > rear指向队尾元素！！！  \n  >\n  > 把常用的队列实现方法来了个886  \n  >\n  > 那么，在这道题中，判断队满和队空我是一时半会想不下去了。。。（front == (rear + 1)%MAXSIZE 既可以是满，也可以是空啊= =，除非说还要留一个空间出来）  \n  >\n  > 但是！！！  \n  >\n  > 这道题说，初始时队列为空，无论如何还是front == (rear + 1)%MAXSIZE.  \n  >\n  > 简单的说就是，队列是空的，rear指向队尾元素，front指向队头元素，入队了，（rear +1）%n，这个时候A[0]既是队头元素，也是队尾元素，rear = front = 0；所以是rear = n-1\n\n- 【2014】循环队列放在一维数组A[0...M-1]中，end1指向队头元素，end2指向队尾元素的后一个位置。假设队列两端均可进行入队和出队操作，队列中最多能容纳M-1个元素。初始时为空。下列判断队空和队满的条件中，正确的是-->队空：end1 == end2；                                  队满：end1 == (end2+1)mod M\n\n  > end1指向队头元素，那么可知出队的操作是先从A[end1]读数，然后end1再加1。end2指向队尾元素的后一个位置，那么可知入队操作是先存数到A[end2]，然后end2再加1。若把A[0]储存第一个元素，当队列初始时，入队操作是先把数据放到A[0]，然后end2自增，即可知end2初值为0；而end1指向的是队头元素，队头元素的在数组A中的下标为0，所以得知end1初值也为0，可知队空条件为end1==end2；然后考虑队列满时，因为队列最多能容纳M-1个元素，假设队列存储在下标为0到下标为M-2的M-1个区域，队头为A[0]，队尾为A[M-2]，此时队列满，考虑在这种情况下end1和end2的状态，end1指向队头元素，可知end1=0，end2指向队尾元素的后一个位置，可知end2=M-2+1=M-1，所以可知队满的条件为end1= =(end2+1)mod M\n\n- 用链式存储方式的队列进行删除操作时需要→D\n\n  A 仅修改头指针\n\n  B 仅修改尾指针\n\n  C 头尾指针都要修改\n\n  D 头尾指针可能都要修改\n\n  > 当队列元素>1时，删除操作只修改头指针；当队列元素=1时，删除操作头尾指针都要修改\n\n- 16 假设循环单链表表示的队列长度为n，队头固定在链表尾，若只设头指针，则进队操作的时间复杂度为→O(n)\n\n- 【2018】现有队列Q与栈S，初始时Q中的元素依次是1,2,3,4,5,6(1在队头)，s为空。若仅允许下列3种操作:①出队并输出出队元素；②出队并将出队元素入栈；③出栈并输出出栈元素，则不能得到的输出序列是-->C\n\n  A. 1, 2, 5, 6, 4, 3\n\n  B. 2, 3, 4, 5, 6, 1\n\n  C. 3, 4, 5, 6, 1, 2\n\n  D. 6, 5, 4, 3, 2, 1\n\n  > A的操作顺序为①①②②①①③③。B的操作顺序为②①①①①①③。D的操作顺序为②②②②②①③③③③③。对于C:首先输出3，说明1和2必须先依次入栈，而此后2肯定比1先输出，因此无法得到1，2的输出顺序。\n\n- 【2016】设有如下图所示的火车车轨，入口到出口之间有n条轨道，列车的行进方向均为从左至右，列车可驶入任意一条轨道。现有编号为1～9的9列列车，驶入的次序依次是8，4，2，5，3，9，1，6，7。若期望驶出的次序依次为1~9，则n至少是-->C\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-49.png\" style=\"zoom:50%;\" />\n\n  A.2       B.3\n  C.4       D.5\n\n  > 将其视为多条队列，每条队列满足：先入队的元素小于**队的元素(如果8和4在同一队列，8在4的后面），这样8入队列1，4入队列2，2入队列3，5入队列2（也可以将5入队列3，但这时剩下的元素就必须放到一个新的队列中，无法使其“至少”），3入队列3，9入队列1，这时共占了3个队列，后面还有元素1，直接再占用一个新的队列4，1从队列4出队后，6、7可以入队到队列2、3、4，综上：最少占用4个队列。其中，确保满足：1）队列中后面的元素大于前面的元素；2）确保占用最少\n\n- 【2021】初始为空的队列Q的一端仅能进行入队操作，另外一段既能进行入队操作又能进行出队操作。若Q的入队序列是1，2，3，4，5，则不能得到的出队序列是-->D\n\n  A. 5、4、3、1、2\n\n  B. 5、3、1、2、4\n\n  C. 4、2、1、3、5\n\n  D. 4、1、3、2、5\n\n  > 假设队列左端允许入队和出队，右端允许入队。对于A，依次从右端入队1,2，再从左端入队3,4,5。对于B，从右端入队1,2，然后从左端入队3，再从右端入队4，最后从左端入队5。对于C，从左端入队1,2，然后从右端入队3，再从左端入队4，最后从右端入队5。无法验证D的序列。\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-124.png\" style=\"zoom: 67%;\" />\n  \n- 综合题4【2019】请设计一个队列，要求满足：\n\n  ① 初始队列为空；\n\n  ② 入队时，允许增加队列占用空间；\n\n  ③ 出队后，出队元素所占用的空间可重复使用，即整个队列所占用的空间只增不减；\n\n  ④ 入队操作和出队操作的时间复杂度始终保持为O(1\n\n  请回答下列问题\n\n  ① 该队列是选择链式存储结构，还是应选择顺序存储结构？\n\n  ② 画出队列的初始状态，并给出判断队空和队满的条件\n\n  ③ 画出第一个元素入队后的队列状态\n\n  ④ 给出入队操作和出队操作的基本过程  \n\n  > 1）顺序存储无法满足要求②的队列占用空间随着入队操作而增加。根据要求来分析：要 求①容易满足；链式存储方便开辟新空间，要求②容易满足；对于要求③，出队后的结点并不 真正释放，用队头指针指向新的队头结点，新元素入队时，有空余结点则无须开辟新空间，赋 值到队尾后的第一个空结点即可，然后用队尾指针指向新的队尾结点，这就需要设计成一个首 尾相接的循环单链表，类似于循环队列的思想。设置队头、队尾指针后，链式队列的入队操作 和出队操作的时间复杂度均为 O(1)，要求④可以满足。 \n  >\n  > 因此，采用链式存储结构（两段式单向循环链表），队头指针为 front，队尾指针为 rear。\n  >\n  > 2）该循环链式队列的实现，可以参考循环队列，不同之处在于循环链式队列可以方便增 加空间，出队的结点可以循环利用，入队时空间不够也可以动态增加。同样，循环链式队列也 要区分队满和队空的情况，这里参考循环队列牺牲一个单元来判断。初始时，创建只有一个空 闲结点的循环单链表，头指针 front 和尾指针 rear 均指向空闲结点，如下图所示。\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-50.png\" style=\"zoom:67%;\" />\n  >\n  > 队空的判定条件：`front == rear`。 队满的判定条件：`front == rear->next`。\n  >\n  > 3）插入第一个元素后的状态如下图所示。\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-51.png\" style=\"zoom:67%;\" />\n  >\n  > 4）操作的基本过程如下:\n  >\n  > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-52.png\" style=\"zoom: 55%;\" />\n","tags":["408数据结构"],"categories":["408数据结构"]},{"title":"第二章 线性表(下)","url":"/p/12625/","content":"\n## 2.3 线性表的链式表示\n\n**链表**——用**链式存储**方式实现的**线性表**。\n\n链表主要有四种：单链表、双链表、循环链表、静态链表。\n\n- 优点：不要求大片连续空间，改变容量方便\n- 缺点：不可随机存取，要耗费一定空间存指针域\n\n### 单链表的定义\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-6.png\" style=\"zoom: 75%;\" />\n\n- 线性表的链式存储又称**单链表**，它是指通过一组任意的存储单元来存储线性表中的数据元素。为了建立数据元素之间的线性关系，对每个链表结点，<font color='red'>除存放元素自身的信息外，还需要存放一个指向其后继的指针</font>。\n\n**单链表的代码实现**:\n\n```C\nstruct LNode{\t\t//单链表结点的结构类型 \n\tElemType data;\t//数据域 \n\tstruct LNode *next;\t//指针域 \n}; \n\nstruct LNode *p = (struct LNode *)malloc(sizeof(struct LNode));\t//增加一个新的结点\n```\n\n此处，我们发现，每次定义一个新结点，都要将它定义为`struct LNode`的类型。\n\n于是我们直接将原结构类型`struct LNode`使用typedef重命名一下，以简化。\n\n#### typedef的使用问题\n\n> typedef <数据类型> <别名>\n>\n> 例如：  typedef int zhengshu;  typedef int * zhengshuzhizhen;\n>\n> 这样以后，原本的  int a = 1;   int * p;\n>\n> 就可以写为  zhengshu a = 1;  zhengshuzhizhen p;\n\n**于是就有了如下的类型定义代码**\n\n**结点的类型定义**\n\n```C\ntypedef struct LNode{\t\t\t\t//定义单链表结点类型\n    ElemType data;\t\t\t\t\t//定义单链表结点类型(数据域)\n    struct LNode * next;\t\t\t//每个节点存放一个数据元素(指针域)\n}LNode,*LinkList;\t\t\t\t\t//LinkList为指向结构体LNode的指针类型\n//增加一个新的结点:在内存中申请一个结点所需空间,并用指针p指向这个结点\nLNode *p =(LNode *)malloc(sizeof(LNode));\n\n// 上述定义代码等价于\nstruct LNode{\n    ElemType data;\n    struct LNode *next;\n};\ntypedef struct LNode LNode;\t\t\t//struct LNode = LNode\ntypedef struct LNode * LinkList;\t//struct LNode *= LinkList \n\n//增加一个新的结点:在内存中申请一个结点所需空间,并用指针p指向这个结点\nstruct LNode *p =(struct LNode *)malloc(sizeof(struct LNode))\n```\n\n通常只需声明一个头指针L来表示一个单链表，指向单链表的第一个结点\n\n`LNode *L;\t\t//声明一个指向单链表的第一个结点的指针`\n这样一来，我就可以这样写我的代码:\n`LinkList L;   //声明一个指向单链表的第一个结点的指针`\n\n<font color='orange'>但是，也并不是说，写LNode 的地方，都要写作LinkList。因为，代码不论怎么写，始终是为了简洁性、可读性的。看下面这个例子：</font>\n\n```C\ntypedef struct LNode{\n\tElemType * data;\n\tstruct LNode * next;\n}LNode, *LinkList;\n\n//单链表查找某元素\nLNode * GetElem(LinkList L, int i){\t//函数返回值LNode *是想强调其返回结果是一个结点；\n    \t\t\t\t\t\t\t\t//参数L类型LinkList是想强调这是一个单链表（头结点代表单链表）\n\tint j = 1;\n\tLNode *p = L->next;\n\tif(i==0) return L;\n\tif(i<1) return NULL;\n\twhile(p!=NULL && j<i){\n\t\tp = p->next;\n\t\tj++;\n\t}\n\treturn p;\t//最终返回一个结点，类型为LNode *\n}\n```\n\n> 注意：此段代码中，并没有将LNode *全部写为LinkList。可以注意到，在我使用LNode *的地方，我往往是想要强调这是一个结点(例如函数返回值LNode *，例如其中用来索引的指针p是LNode *)，而在使用LinkList的地方，我想要强调的是这是一个单链表（例如函数的参数L是LinkList，它虽然是一个头结点，但它根本上是代表着一个单链表）\n\n**总之，这种重命名的方法（typedef），以及对重命名之后的别名的使用（是有所强调的，而不是一概而论的），希望能够好好体会。**\n\n#### 不带头结点的单链表\n\n```C\ntypedef struct{\t\t//定义单链表结点的结构类型\n\tElemType data;\t\t//数据域 \n\tstruct LNode *next;\t//指针域 \n}LNode, *LinkList;\n\n//初始化一个空的单链表（不带头结点）\nbool InitList(LinkList &L) {\n\tL = NULL;\t//空表，暂时还没有任何结点\t//初始并设为空，防止脏数据\n\treturn true; \n}\n\nvoid test(){\n\tLinkList L;\t//声明一个指向单链表的指针\t//（1）\n\tInitList(L);\t//初始化一个空表\n\t//...... \n}\n```\n\n**注意：**（1）处并没有创建一个结点。\n\n要始终去体会，**别名的使用是在含义上有所强调的**，而不仅仅是理论上来说代码能否编译问题\n\n#### 带头结点的单链表\n\n单链表第一个结点之前附加一个结点，称为头结点。\n\nhttps://blog.csdn.net/zhenyusoso/article/details/6092843\n\n引入头结点后，可用带来两个优点:\n\n1. 由于第一个数据结点的位置被存放在头结点的指针域中，因此在链表的第一个位置上的操作和在表的其他位置上的操作一致，无须进行特殊处理。\n2. 无论链表是否为空，其头指针都指向头结点的非空指针(空表中头结点的指针域为空)，因此空表和非空表的处理也就得到了统一。\n\n```C\ntypedef struct LNode{\n\tElemType data;\n\tstruct LNode *next;\n}LNode, *LinkList;\n\n//初始化一个单链表（带头结点） \nbool InitList(LinkList &L){\n\tL = (LNode *)malloc(sizeof(LNode));\t//分配一个头结点\n\tif(L == NULL)  return false;\t//内存不足，分配失败\n\tL->next = NULL;\t//头结点之后暂时还没有结点\n\treturn true; \n}\n\nvoid test(){\n\tLinkList L;\t//声明一个指向头结点的指针\n\tInitList(L);\t//初始化一个空表\n\t//...... \n}\n```\n\n**注意**：此头结点的数据域是不存储数据元素的，只有指针域有意义。这是为了方便后续的链表操作。\n\n```C\n//判断单链表是否为空（带头结点） \nbool Empty(LinkList L) {\n\tif(L->next == NULL) return true;\n\telse return false;\n}\n\n```\n\n#### 不带/带头结点的区别\n\n- 不带头结点，写代码更麻烦。对第一个数据结点和后续数据结点的处理需要用不同的代码逻辑。对空表和非空表的处理需要用不同的代码逻辑。\n- 带头结点，写代码更方便。一般都是带头结点的。\n- 不带头结点，头指针L所指向的下一个结点，就是实际用于存放数据的结点。而带头结点，头指针所指向的结点，也就是头结点，是不存放实际的数据元素的，而头结点指向的下一个结点才会用于存放数据。\n- 不带头结点，空表判断：`L==NULL`；带头结点，空表判断：`L->next==NULL`\n\n### 单链表上基本操作的实现\n\n#### 采用头插法建立单链表\n\n- 头插法建立单链表时，读入数据的顺序与生成的链表中的元素的顺序是相反的。每个结点插入的时间为O(1),设单链表长n,时间复杂度O(n)。\n- <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-9.png\"  />\n\n```c\nLinkList List_HeadInsert(LinkList &L){//逆向建立单链表\n    LNode *s; int x;\n    L=(LinkList)malloc(sizeof(LNode));//创建头结点；\n    L->next=NULL;                    //初始为空链表[*]\n    scanf(\"%d\",&x);                   //输入结点的值\n    while(x! = 9999){                 //输入9999表示结束\n        s=(LNode*)malloc(sizeof(LNode));//创建新结点\n        s- >data=x;\n        s- >next=L- >next;\n        L- >next=s;                   //将新结点插入表中，L为头指针\n        scanf(\"%d\",&x);\n    }\n    return L;\n}\n```\n\n[头插法创建单链表（带源码+解析）](http://data.biancheng.net/view/93.html)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-8.png\" style=\"zoom: 75%;\" />\n\n> 注意:在代码[\\*]处，初始化空链表的时候，必须将L的next置为NULL。否则插入若干数据结点后，表尾的next会是一个脏数据，而不是NULL。而尾插法为什么不用，是因为尾插法在最后执行了尾结点指针域置空的操作。但总之，你只要是初始化单链表，都先把头指针指向NULL，这是一个好习惯。\n\n> **重要应用：链表的逆置**！！[B站-链表逆置的两种方法](https://www.bilibili.com/video/BV1yU4y1U7L2?spm_id_from=333.337.search-card.all.click&vd_source=278af11bcc7fe34571197ce600d488f4)\n>\n> 在使用头插法插入数据的时候，你依次插入a、b、c。那么在此单链表中，从头结点开始，依次为：c、b、a。于是这里引起了一个重要的应用，**链表的逆置**。\n>\n> 也就是再建立一个新的链表，之后将原来的链表从头到尾依次头插法插入新链表中，新链表就是原链表的逆置。\n>\n> 当然，你也可以不建立新链表，而是在原链表，直接依次对每个结点，向原链表的头结点后执行头插，最终得到的结果也是原链表的逆置。\n\n#### 采用尾插法建立单链表\n\n- 时间复杂度O(n)\n\n- **头插法**建立单链表的算法虽然简单，但生成的链表中结点的次序和输入数据的顺序**不一致**。若希望两者次序一致，可采用尾插法。该方法是将新结点插入到当前链表的表尾上，为此必须增加一个尾指针r,使其始终指向当前链表的尾结点，如图所示。\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-10.png\"  />\n\n**初始化单链表后，向单链表末尾进行后插操作**\n\n```C\n//在第i个位置插入元素e（带头结点）\nbool ListInsert(LinkList &L, int i, ElemType e) {\n\tif(i<1) return false;\n\tLNode *p;\t//指针p指向当前扫描到的结点\n\tint j=0;\t//当前p指向的是第几个结点\n\tp = L;\t//L指向头结点\n\twhile(p!=NULL && j<i-1) {\t//循环找到第i-1个结点 \n\t\tp = p->next;\n\t\tj++;\n\t}\n\tif(p == NULL) return false;\t//i值不合法\n\tLNode *s = (LNode *)malloc(sizeof(LNode));\n\ts->data = e;\n\ts->next = p->next;\n\tp->next = s;\t//将结点s连到p之后 \n\treturn true;\n}\n```\n\n> 但是此时有一个问题。即每次向表尾插入一个元素，都要从表头开始循环，找到表尾结点。那么若要插入n个元素进去，则时间复杂度为O(n²)。\n>\n> 但是实际上，我们每次向表尾插入新的元素，没有必要每次都从表头再全部遍历一次。我们可以设立一个表尾指针r，专门用于指向表尾。之后若要插入新元素，对表尾指针r做一个后插操作即可。\n>\n> 如何对表尾指针r做后插操作，见指定结点的后插操作。\n\n```c\nLinkList List_TailInsert(LinkList &L){//正向建立单链表\n    int x;                            //设元素类型为整型\n    L=(LinkList)malloc(sizeof(LNode));//创建头结点；\n    LNode *s,*r=L;                    //r为表尾指针\n    scanf(\"%d\",&x);                   //输入结点的值\n    while(x! =9999){                   //输入9999表示结束\n        s=(LNode*)malloc(sizeof(LNode));\n        s- >data=x;\n        r- >next=s;                  //在r结点之后插入元素x\n        r=s;                         //r指向新的表尾结点\n        scanf(\"%d\",&x);\n    }\n    r- >next=NULL;                   //尾结点指针置空\n    return L;\n}\n```\n\n#### 按序号查找结点值\n\n在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止，否则返回最后一个结点指针域NULL。\n\n时间复杂度O(n)\n\n`GetElem(L,i)`：按位查找操作。获取表L中第i个位置的元素的值。\n\n```C\n//按位查找,返回第i个元素(带头结点)\nLNode *GetElem(LinkList L,int i){\n    if(i<0)\n    {\n        return NULL;\n    }\n    LNode *p;\t//指针p指向当前扫描到的结点\n    int j = 0;\t//当前p指向的是第几个结点\n    p = L;\t\t//L指向头结点,头结点是第0个结点(不存数据)\n    while(p!=NULL && j<i)\t//循环找到第i个结点\n    {\n        p = p->next;\t\t//让p指针依次向后移\n        j++;\n    }\n    return p;\n}\n```\n\n如果i=0\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-44.png\" style=\"zoom: 50%;\" />\n\n如果i=8(i大于链表长度)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-45.png\" style=\"zoom: 50%;\" />\n\n**王道书版本**:\n\n```c\nLLNode GetElem(LinkList L,int i){\n    //本算法取出单链表L（带头结点）中第i个位置的结点指针\n    int j=1;  //计数，初始为1\n    LNode *p = L->next;  //头结点指针赋给p\n    if(i==0)\n        return L;  //若i等于0，则返回头结点\n    if(i<1)\n        return NULL;  //若 i 无效，则返回 NULL\n    while( p && j<i ) {  //从第1个结点开始找，查找第i个结点\n        p=p->next;\n        j++;\n    }\n    return p; //返回第i个结点的指针，如果i大于表长，p=NULL，直接返回p即可\n}\n```\n\n那么，封装之后。我们下面会提到的**按位插入**、**按位删除**中相应的代码段就都可以直接调用这个封装好的函数来实现。\n\n如下所示:\n\n```C\n//在第i个位置插入元素e（带头结点）\nbool ListInsert(LinkList &L, int i, ElemType e) {\n\tif(i<1) return false;\n\tLNode *p = GetElem(L, i-1);\t//找到第i-1个结点\n\treturn InsertNextNode(p, e);\t//p后插入新元素e\n}\n```\n\n#### 按值查找表结点\n\n从单链表第一个结点开始，由前往后依次比较表中各结点数据域的值，若某结点数据域的值等于给定值e，则返回该结点的指针。若整个单链表中没有这样的结点，则返回NULL。按值查找结点的算法如下：\n\n时间复杂度O(n)\n\n`LocateElem(L,e)`：按值查找操作。在表L中查找具有给定关键字值的元素\n\n```c\nLNode *LocateElem (LinkList L, ElemType e) {\n    //本算法查找单链表 L （带头结点）中数据域值等于e的结点指针，否则返回NULL\n    LNode *p=L->next;\n    while(p!=NULL && p->data!=e)  //从第1个结点开始查找data域为e的结点\n        p=p->next;\n    return p;  //找到后返回该结点指针，否则返回NULL\n}\n```\n\n> 此处同样需要注意一点：由于e的类型是ElemType，其有可能是基本类型，也有可能是结构类型。当其为结构类型时，就不能直接通过\"! =\"来判断了。原理同前文一致，不再赘述。\n\n[单链表的两种查找方式](https://blog.csdn.net/pikaqiu_JBR99/article/details/107616129)\n\n#### 插入结点操作 [单链表的插入和删除](https://itcn.blog/p/1649535832.html)\n\n##### 按位序插入\n\n###### 带头结点\n\n`ListInsert(&L,i,e)`：插入操作。**在表L中的第i个位置上插入指定元素e**\n\n(找到第i-1个结点，将新结点插入其后)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-36.png\" style=\"zoom:67%;\" />\n\n**此时，带头结点的好处就体现出来了。当我插入的位置为1时，可以把头结点看作第0个结点，向头结点后进行插入。由此，我不论在何处插入一个结点，我的处理逻辑都是统一的**。\n\n```C\nbool ListInsert(LinkList &L,int i,ElemType e){\n    if(i<1){\n        return false;\n    }\n    LNode *p;\t\t//指针p指向当前扫描到的结点\n    int j=0;\t\t//当前p指向的是第几个结点\n    p = L;\t\t\t//L指向头结点,头结点是第0个结点(不存是数据)\n    \n    while(P! =NULL && j<i-1){\t//循环找到第 i-1 个结点\n        p=p->next;\n        j++;\n    }\n    if(p==NULL)\t\t//i值不合法\n    {\n        return false;\n    }\n    LNode *s = (LNode *)malloc(sizeof(LNode));\n    s->data=e;\n    //将s指向结点的next指针指向p指向结点的next指针\n    s->next = p->next;\t \n    p->next = s;\t//将p指向结点的next指针指向s\n    return true;\t//插入成功\n}\n```\n\n<font color='red'>分析</font>:\n\n如果 i=1(也就是在表头插入元素)：时间复杂度O(1)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-37.png\" style=\"zoom: 50%;\" />\n\n如果 i = 3(也就是在表中插入元素)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-38.png\" style=\"zoom: 50%;\" />\n\n如果 i = 5(也就是在表尾插入元素)：时间复杂度O(n)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-39.png\" style=\"zoom: 50%;\" />\n\n###### 不带头结点\n\n`ListInsert(&L,i,e)`：插入操作。**在表L中的第i个位置上插入指定元素e**\n\n(找到第i-1个结点，将新结点插入其后)\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-40.png\" style=\"zoom: 50%;\" />\n\n\n\n**此时，由于不带头结点，也就是不存在“第0个”结点。因此i=1时需要特殊处理。**\n\n```C\nbool ListInsert(LinkList &L,int i,ElemType e){\n    if(i<1)\n    {\n        return false;\n    }\n    if(i==1)\t\t//插入第1个结点的操作与其他结点操作不同\n    {\n        LNode *s =(LNode *)malloc(sizeof(LNode));\n        s->data = e;\n        s->next = L;\n        L = s;\t\t//头指针指向新结点\n        return true;\n    }\n    LNode *p;\t\t//指针p指向当前扫描到的结点\n    int j=1;\t\t//当前p指向的是第几个结点\n    p = L;\t\t\t//p指向第1个结点(注意:不是头结点)\n    \n    while(P!=NULL && j<i-1){\t//循环找到第 i-1 个结点\n        p=p->next;\n        j++;\n    }\n    if(p==NULL)\t\t//i值不合法\n    {\n        return false;\n    }\n    LNode *s = (LNode *)malloc(sizeof(LNode));\n    s->data=e;\n    //将s指向结点的next指针指向p指向结点的next指针\n    s->next = p->next;\t\n    p->next = s;\t//将p指向结点的next指针指向s\n    return true;\t//插入成功\n}\n}\n```\n\n> 如果不带头结点，则插入、删除第1个元素时，需要更改头指针L。\n>\n> 如果带头结点的话，头指针肯定永远都是指向头结点的。\n>\n> 但是除了第1个元素外，后续的元素操作，其逻辑和带头结点的一样。\n\n**结论**：不带头结点写代码不方便，推荐用带头结点\n\n##### 指定结点的后插操作\n\n后插操作：在结点之后插入元素\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-41.png\" style=\"zoom:67%;\" />\n\n> 给定一个结点，在这个结点之后插入一个数据元素e。\n>\n> 由于单链表的链接指针只能往后寻找，所以如果给定一个结点p的话，那么p之后的那些结点我们都是可知的，我们都可以用循环的方式把它们都找出来。\n>\n> 但是p结点之前的，我们就没办法知道了。\n\n```C\n//后插操作:在p结点之后插入元素e\nbool InsertNextNode(LNode *p,ElemType e){\n    if(p==NULL)\n    {\n        return false;\n    }\n    LNode *s =(LNode *)malloc(sizeof(LNode));\n    if(s==NULL)\t\t//某些情况下有可能分配失败,比如内存不足\n    {\n        return false;\t\n    }\n    s->data = e;\n    s->next = p->next;\n    p->next = s;\n    return true;\n}\n```\n\n当然，这个函数只是在已经找到p结点后执行的操作。其时间复杂度为O(1)。\n\n但是真正进行插入的时候，首先肯定是要先通过循环，找到结点p的。即如下代码\n\n```C\n//在第i个位置插入元素e（带头结点）\nbool ListInsert(LinkList &L, int i, ElemType e){\n\tif(i<1) return false;\n\tLNode *p;\t//指针p指向当前扫描到的结点\n\tint j = 0;\t//当前p指向的是第几个结点\n\tp = L;\t//L指向头结点，头结点是第0个结点（不存数据）\n\twhile(p!=NULL && j<i-1) {\t//循环找到第i-1个结点 \n\t\tp = p->next;\n\t\tj++;\n\t}\n\treturn InsertNextNode(p, e);\t//封装（当然，上面那几行也可以封装）\n}\n```\n\n##### 指定结点的前插操作\n\n前插操作是指在某结点的前面插入一个新结点，后插操作的定义刚好与之相反，在单链表插入算法中，通常都是釆用后插操作的。\n\n###### 单链表的基本插入算法\n\n插入操作是将值为x的新结点插入到单链表的第i个位置上。先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第i-1个结点，再在其后插入新结点。\n\n算法首先调用上面的按序号查找算法GetElem(L, i-1)，查找第i-1个结点。假设返回的第i-1个结点为 *p，然后令新结点 *s的指针域指向 *p的后继结点，再令结点 *p的指针域指向新插入的结点 *s。其操作过程如图所示。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-11.png\" style=\"zoom:80%;\" />\n\n```c\np=GetElem(L, i-1) ;  // 语句①，查找插入位置的前驱结点\ns->next=p->next;  // 语句②，图 2-6 中辑作步骤 1\np->next=s;  // 语句③，图2-6中操作步骤2\n```\n\n算法中，语句②③的顺序不能颠倒，否则，当先执行p->next=s后，指向其原后继的指针就不存在了，再执行s->next = p->next时，相当于执行了 s->next=s,显然是错误的。本算法主要的时间开销在于查找第i-1个元素，时间复杂度为O(n)。若是在给定的结点后面插入新结点，则时间复杂度仅为O(1)。\n\n以上面的算法为例，首先调用函数GetElem()找到第i-1个结点，即待插入结点的前驱结点后，再对其执行后插操作。由此可知，对结点的前插操作均可以转化为后插操作，前提是从单链表的头结点开始顺序查找到其前驱结点，时间复杂度为O(n)。\n\n###### 拓展:对某一结点的前插操作\n\n此外，可以釆用另一种方式将其转化为后插操作来实现，设待插入结点为s，将插入到p的前面。我们仍然将s插入到p的后面，然后将p->data与s->data交换即可，这样既满足了逻辑关系，又能使得时间复杂度为O(1)。算法的代码片段如下：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-42.png\" style=\"zoom:67%;\" />\n\n> 在p结点之前插入元素e。\n>\n> 此时就会出现一个问题：如何找到p结点的前驱？\n>\n> 思路一：\n>\n> 我们可以传入一个头指针。当给出头指针之后，那么我们链表的所有信息就都能够知道了。\n>\n> 我们可以从头指针开始，依次遍历各个结点，从而找到p结点的前驱结点，再对p的前驱进行后插操作。\n>\n> 那么用这种方法进行前插，时间复杂度是O(n)。\n>\n> 思路二：\n>\n> 我依然是对p进行后插。但是后插过后，我将p结点和新结点，之中的数据域进行互换。最终也能实现前插的效果。\n>\n> 这种的本质是后插，时间复杂度O(1)。\n\n**思路二代码实现**:\n\n```C\n//前插操作:在p结点之前插入元素e\nbool InsertPriorNode(LNode *p,ElemType e){\n    if(p==NULL)\n    {\n        return false;\n    }\n    LNode *s =(LNode *)malloc(sizeof(LNode));\n    if(s==NULL)\t\t\t//内存分配失败\n    {\n        return false;\n    }\n    s->next = p->next;\t\n    p->next = s;\t\t//新结点 s 连接到 p 之后\n    s->data = p->data;\t//将p中元素复制到s中\n    p->data = e;\t\t//p中元素覆盖为e\n    return true;\n}\n```\n\n**王道书中的版本**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-43.png\" style=\"zoom:67%;\" />\n\n```C\n//前插操作:在p结点之前插入结点s\nbool InsertPriorNode(LNode *p,LNode *s){\n    if(p==NULL || s==NULL)\n    {\n        return false;\n    }\n    s->next = p->next;\n    p->next = s;\t\t\t\t//s连到p之后\n    ElemType temp = p->data;\t//交换数据域部分\n    p->data = s->data;\n    s->data = temp;\n    return true;\n}\n```\n\n#### 删除结点操作 [单链表的插入和删除](https://itcn.blog/p/1649535832.html)\n\n删除操作是将单链表的第i个结点删除。先检查删除位置的合法性，然后查找表中第i-1个结点，即被删结点的前驱结点，再将其删除。其操作过程如图所示。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-12.png\"  />\n\n假设结点p为找到的被删结点的前驱结点，为了实现这一操作后的逻辑关系的变化，仅需修改p的指针域，即将p的指针域next指向q的下一结点。\n\n时间复杂度O(n)\n\n##### 带头结点按位序删除\n\n`ListDelete(&L,i,&e)`：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值(找到第i-1个结点，将其指针指向第i+1个结点，并释放第i个结点)\n\n```c\nbool ListDelete(LinkList &L,int i,ElemType &e){\n    if(i<1)\n    {\n        return false;\n    }\n    LNode *p;\t//指针p指向当前扫描到的结点\n    int j = 0;\t//当前p指向的是第几个结点\n    p = L;\t\t//L指向头结点,头结点是第0个结点(不存数据)\n    while(p!=NULL && j<i-1)\t//循环找到第 i-1 个结点\n    {\n        p = p->next;\n        j++\n    }\n    if(p==NULL)  \t\t\t// i值不合法\n    {\n        return false;\n    }\n    if(p->next == NULL)\t\t//第 i-1 个结点之后已无其他结点\n    {\n        return false;\n    }\n    LNode *q = p->next;\t\t//令q指向被删除结点\n    e = q->data;\t\t\t//用e返回元素的值\n    p->next = q->next;\t\t//将*q结点从链中断开\n    free(q);\t\t\t\t//释放结点的存储空间\n    return true;\t\t\t//删除成功\n}\n```\n\n##### 扩展：删除指定结点p\n\n要实现删除某一个给定结点p，通常的做法是先从链表的头结点开始顺序找到其前驱结点，然后再执行删除操作即可，算法的时间复杂度为O(n)。\n\n其实，删除结点p的操作可以用删除p的后继结点操作来实现，实质就是将其后继结点的值赋予其自身，然后删除后继结点，也能使得时间复杂度为O(1)。\n\n```C\n//删除指定结点p\nbool DeleteNode(LNode *p){\n    if(p==NULL)\n    {\n        return false;\n    }\n    LNode *q = p->next;\t\t//令q指向*p的后继结点\n    p->data = p->next->data;//和后继结点交换数据域\n    p->next = q->next;\t\t//将*q结点从链中\"断开\"\n    free(q);\t\t\t\t//释放后继结点的存储空间\n    return true;\n}\n```\n\n> 但是有个问题:如果要删除的这个结点，刚好是单链表的最后一个结点。那么在进行p结点与其后继结点数据域的互换的时候，就会出现问题。即`p->data = p->next->data`;的时候，就会出现空指针的错误。\n>\n> 那么如果是最后一个结点，该怎么办呢。那就只能从头结点开始，循环找到p的前驱，进行删除。时间复杂度O(n)。\n\n#### 求表长操作\n\n求表长操作就是计算单链表中数据结点（不含头结点）的个数，需要从第一个结点开始顺序依次访问表中的每一个结点，为此需要设置一个计数器变量，每访问一个结点，计数器加1，直到访问到空结点为止。算法的时间复杂度为O(n)。\n\n需要注意的是，因为单链表的长度是不包括头结点的，因此，不带头结点和带头结点的单链表在求表长操作上会略有不同。对不带头结点的单链表，当表为空时，要单独处理。\n\n```C\n//求表的长度\nint Length(LinkList L)\n{\n    int len = 0;\t\t\t//统计表长\n    LNode *p = L;\t\t\n    while(p->next !=NULL)\n    {\n        p = p->next;\n        len++;\n    }\n    return len;\n}\n```\n\n### 双链表 [双链表的基本操作](https://blog.csdn.net/qq_16933601/article/details/105351119)\n\n单链表结点中只有一个指向其后继的指针，这使得单链表只能从头结点依次顺序地向后遍历。若要访问某个结点的前驱结点（插入、删除操作时），只能从头开始遍历，访问后继结点的时间复杂度为O(1)，访问前驱结点的时间复杂度为O(n)。\n\n为了克服单链表的上述缺点，引入了双链表，双链表结点中有两个指针prior和next，分别指向其前驱结点和后继结点，如图所示。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-13.png\" style=\"zoom: 75%;\" />\n\n结点类型定义\n\n```C\ntypedef struct DNode {  //定义双链表结点类型\n    ElemType data;  //数据域\n    struct DNode *prior, *next;  //前驱和后继指针\n}DNode, *DLinklist;\n```\n\n#### 双链表的初始化\n\n```C\n//初始化双链表(带头结点)\nbool InitDLinkList(DLinklist &L){\n    L = (DNode *)malloc(sizeof(DNode));\t\t\t//分配一个头结点\n    if(L==NULL)\t\t\t\t\t\t\t\t\t//内存不足,分配失败\n    {\n        return false;\n    }\n    L->prior = NULL;\t\t\t\t\t\t\t//头结点的prior永远指向NULL\n    L->next = NULL;\t\t\t\t\t\t\t\t//头结点之后暂时还没有结点\n    return true;\n}\nvoid testDLinkList(){\n    //初始化双链表\n    DLinklist L;\n    InitDLinkList(L);\n}\n```\n\n- `DLinklist` 等价于`DNode *`\n- `DLinklist` 强调这是一个链表\n- `DNode *` 强调这是一个结点\n\n#### 判断双链表是否为空\n\n判断双链表是否为空:判断头结点的下一个是否为空\n\n```C\n//判断双链表是否为空(带头结点)\nbool Empty(DLinklist L){\n    if(L->next == NULL)\n    {\n        return true;\n    }\n    else{\n        return false;\n    }\n}\n```\n\n#### 双链表的插入操作\n\n在双链表中p所指的结点之后插入结点s，其指针的变化过程如图所示\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-14.png\"  />\n\n时间复杂度O(n)\n\n```C\ns->next=p->next;  // 语句①，将结点*s插入到结点*p之后\np->next->prior=s;  // 语句②\ns->prior=p;  // 语句③\np->next=s;  // 语句④\n```\n\n上述代码的语句顺序不是唯一的，但也不是任意的，①②两步必须在④步之前，否则p的后继结点的指针就丢掉了，导致插入失败。\n\n> 但是，**会有一个问题**。\n>\n> 当p结点为双链表最后一个结点时，在执行该操作时。其中`p->next->prior = s;`会出现空指针错误。\n>\n> 因此我们要优化一下这段代码，如下所示。\n\n##### 后插操作\n\n如果p结点是最后一个结点(特殊情况)：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-46.png\" style=\"zoom: 50%;\" />\n\n```C\n//在p结点之后插入s结点\nbool InsertNextDNode(DNode *p,DNode *s){\n    if(p=NULL || s=NULL)\t\t\t\t\t\t\t//非法参数\n    {\n        return false;\n    }\n    s->next = p->next;\n    if(p->next != NULL)\n    {\t\t\t\t\t\t\t\t\t\t\t\t//如果p结点有后继结点\n        p->next->prior = s;\n    }//如果p没有后继节点，则当然不需要修改p的后继节点的前驱指针\n    s->prior = p;\n    p->next = s;\t\n    return true;\n}\n```\n\n如果p是中间一个结点:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-47.png\" style=\"zoom:67%;\" />\n\n> 同样要注意赋值时的顺序。有些能调换，有些调换了就是错误的逻辑。\n>\n> 实现了双链表后，在对p结点执行前插操作时。就可以立即找到p结点的前驱结点q，再对q进行后插操作即可。实际上都是可以转化为，利用后插来实现。\n\n##### 按位序插入\n\n按位序插入：只需从头结点开始，找到某一个位序的前驱结点，然后对这个前驱结点执行后插操作\n\n##### 前插操作\n\n前插操作：只需找到此结点的前驱结点，然后对其前驱结点进行后插操作，即为前插操作\n\n#### 双链表的删除操作\n\n删除双链表中结点p的后继结点q，其指针的变化过程如图所示。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-15.png\"  />\n\n时间复杂度O(n)\n\n```C\np->next=q->next;  // 图2-10中步骤①\nq->next->prior=p;  //图 2-10 中步骤②\nfree (q) ; //释放结点空间\n```\n\n> 但这样写，同样会有一个问题。就是q为最后一个结点的时候。q的后继节点为NULL，没有前驱结点prior。也就是[*]会引起空指针错误。\n\n当q结点不是最后一个结点时：\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-48.png\" style=\"zoom:67%;\" />\n\n```C\n//删除p结点的后继结点\nbool DeleteNextDNode(DNode *p){\n    if(p==NULL)\n    {\n        return false;\n    }\n    DNode *q = p->next;\t\t\t\t//找到p的后继结点q\n    if(q = NULL)\n    {\n        return false;\t\t\t\t//p没有后继结点\n    }\n    p->next = q->next;\n    if(q->next != NULL)\t\t\t\t//q结点不是最后一个结点\n    {\n        q->next->prior = p;\n    }\n    free(q);\t\t\t\t\t\t//释放结点空间\n    return true;\n}\n```\n\n当q结点是最后一个结点时:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-49.png\" style=\"zoom: 50%;\" />\n\n#### 双链表的销毁\n\n```C\nvoid DestoryList(DLinklist &L){\n    //循环释放各个数据结点\n    while(L->next !=NULL)\n    {\n        DeleteNextDNode(L);\n    }\n    free(L);\t\t//释放头结点\n    L=NULL;\t\t\t//头指针指向NULL\n}\n```\n\n#### 双链表的遍历\n\n##### 后向遍历\n\n```C\nwhile(p != NULL){\n    //对结点p做相应处理\n    p = p->next;\n}\n```\n\n##### 前向遍历\n\n```C\nwhile(p != NULL){\n    //对结点p做相应处理\n    p = p->prior;\n}\n```\n\n##### 前向遍历(跳过头结点)\n\n```C\nwhile(p->prior!=NULL){\n    //对结点p做相应处理\n    p = p->prior;\n}\n```\n\n> 知道怎么前向、后向遍历，那么按位查找、按值查找也就没什么问题。\n>\n> - 按位查找：在知道如何前后向遍历的基础上，设置一个遍历次数i，每遍历一次，执行i++，即可实现按位查找。\n> - 按值查找：在知道如何前后向遍历的基础上，每遍历到一个结点，判断该结点的数据域是否等于e，即可实现按值查找。\n>\n> 时间复杂度O(n)。\n\n### 循环链表\n\n#### 循环单链表\n\n循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-16.png\" style=\"zoom:67%;\" />\n\n在循环单链表中，表尾结点的next域指向L，故表中没有指针域为NULL的结点，因此，<font color='orange'>循环单链表的判空条件不是头结点的指针是否为空，而是它是否等于头指针</font>。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-21.png\" style=\"zoom: 75%;\" />\n\n循环单链表的插入、删除算法与单链表的几乎一样，所不同的是如果操作是在表尾进行，则执行的操作不相同，以让单链表继续保持循环的性质。当然，正是因为循环单链表是一个 “环”，因此，在任何一个位置上的插入和删除操作都是等价的，无须判断是否是表尾。\n\n在单链表中只能从表头结点开始往后顺序遍历整个链表，而循环单链表可以从表中的任一结点开始遍历整个链表。有时对单链表常做的操作是在表头和表尾进行的，此时可对循环单链表不设头指针而仅设尾指针，从而使得操作效率更高。\n\n##### 初始化循环单链表\n\n```C\ntypedef struct LNode{\t\t//定义单链表结点类型\n    ElemType data;\t\t\t//每个结点存放一个数据元素\n    struct LNode *next;\t\t//指针指向下一个结点\n}LNode,*LinkList;\n\n//初始化一个循环单链表\nbool InitList(LinkList &L){\n    L = (LNode *)malloc(sizeof(LNode));\t\t//分配一个头结点\n    if(L == NULL)\n    {\n        return false;\n    }\n    L->next = L;\t\t\t\t\t\t\t//头结点next指向头结点\n    return true;\n}\n```\n\n##### 判断循环单链表是否为空\n\n判断循环单链表是否为空:判断头结点的next指针是否指向它自己\n\n```C\nbool Empty(LinkList L){\n    if(L->next == L)\n    {\n        return true;\n    }else{\n        return false;\n    }\n}\n```\n\n##### 判断循环单链表表尾结点\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-50.png\" style=\"zoom: 33%;\" />\n\n```C\n//判断结点p是否是循环单链表的表尾结点\nbool isTail(LinkList L,LNode *p){\n    if(p->next == L)\n    {\n        return true;\n    }else{\n        return false;\n    }\n}\n```\n\n##### 循环单链表的好处\n\n**单链表**\n\n- 从一个结点出发，只能找到后续的各个结点，而前驱的各个结点，除非获得单链表的表头指针，否则无法得知。\n- 从头结点找到尾部，依次循环遍历，时间复杂度为O(n)。\n\n**循环单链表**\n\n- 从一个结点出发可以找到其他任意一个结点。\n- **我们让L不再指向头结点，而是指向尾结点**。那么从尾部找到头部，时间复杂度为O(1)。那么此时，我既有尾结点，又有头结点了（往后找一个即可）。而很多时候，链表的操作都是在头部或尾部。那么这样一来，就大大方便了操作，时间复杂度为O(1)。\n\n#### 循环双链表\n\n由循环单链表的定义不难推出循环双链表，不同的是在循环双链表中，头结点的prior 指针还要指向表尾结点\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-17.png\" style=\"zoom: 80%;\" />\n\n在循环双链表L中，某结点*p为尾结点时，p->next=L;当循环双链表为空表时，其头结点的prior域和next域都等于L\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-18.png\" style=\"zoom: 75%;\" />\n\n循环双链表的**优势**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-19.png\" style=\"zoom: 75%;\" />\n\n我们知道，在p为表尾结点的时候，<font color='orange'>箭头</font>处的语句会出现空指针错误。但如果我们是**循环双链表**的话，那么上述代码的逻辑就是**完全正确**的。\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-20.png\" style=\"zoom: 75%;\" />\n\n我们知道，在q为表尾结点的时候，<font color='orange'>箭头</font>处的语句会出现空指针错误。但如果我们是**循环双链表**的话，那么上述代码的逻辑就是**完全正确**的。\n\n### 静态链表\n\n静态链表是<font color='cornflowerblue'>借助数组来描述线性表的链式存储结构</font>，结点也有数据域data和指针域next，与前面所讲的链表中的指针不同的是，这里的指针是**结点的相对地址**(数组下标)，又称为**游标**。和顺序表一样，静态链表也要预先分配一块连续的内存空间。\n\n**静态链表和单链表的对应关系如图**\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-22.png\" style=\"zoom: 75%;\" />\n\n> 单链表中的结点是离散的，分布在内存中的各个角落。每个节点包括一个数据域（数据元素），还有一个指针域（指向下一个结点的指针（地址））。\n\n> 静态链表分配一整片的内存空间，其中的数据元素存放在这片内存空间的某些位置。静态链表中的每个结点包含了数据元素，还有下一个结点的数组下标（游标）。\n>\n> 静态链表中，0号结点充当“头结点”，它是不存放数据元素的。\n>\n> 静态链表中每个结点的游标相当于单链表中的指针域。只不过指针域是指明了下一个结点的具体地址，而游标只是指明了在此数组中的下标。\n>\n> 静态链表如果要表示该结点为最后一个结点的话，可以将它的游标的值设为-1。\n\n> 这样一来，若0号结点的游标为2，那么就可以直接寻找到下标为2的结点的地址。（即静态链表的起始地址`addr + sizeof(Node) * 2`，实际上就是数组）\n\n#### 结点类型定义\n\n```c\n#define MaxSize 50  //静态链表的最大长度\ntypedef struct{  //静态链表结构类型的定义\n    ElemType data;  //存储数据元素\n    int next;  //下一个元素的数组下标\n}SLinkList[MaxSize];\n```\n\n上下的代码定义等价\n\n```C\n#define MaxSize 50  //静态链表的最大长度\ntypedef struct{  //静态链表结构类型的定义\n    ElemType data;  //存储数据元素\n    int next;  //下一个元素的数组下标\n};\ntypedef struct Node SLinkList[MaxSize];//可用SLinkList定义\"一个长度为MaxSize的Node型数组\"\n```\n\n> **问题**：\n>\n> 用typedef给一个结构类型起别名我理解，但是这个别名怎么是一个“数组”呢？\n>\n> 实际上这样写以后。你就可以直接通过**SLinkList**定义“**一个长度为MaxSize的Node型数组**”了。\n>\n> 即如下所示，这两个写法是等价的：\n>\n> ```C\n> void testSLinkList(){\n> \tSLinkList a;\n> } \n> \n> void testSLinkList2(){\n> \tstruct Node a[MaxSize];\n> }\n> \n> ```\n>\n> **追问：**\n>\n> 我理解了这种定义方式的作用了。但是为什么要这样写呢？这样写不别扭吗？为什么不用我们传统的`struct Node a[MaxSize];`呢？\n>\n> 其实这个地方，和我们之前提到过的`LinkLise`和`LNode *`其想要**强调含义**是一个道理。\n>\n> 我使用`SLinkList a;`来定义，是想**强调**我这里正在定义一个**静态链表**。你一看就明白了，a是一个静态链表。\n>\n> 但是使用`struct Node a[MaxSize];`，它仅仅是定义一个Node型的数组a。\n\n#### 基本操作的实现\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-24.png\" style=\"zoom: 75%;\" />\n\n### 顺序表和链表的比较\n\n**逻辑结构**:都属于线性表，都是线性结构\n\n**物理结构**:\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-25.png\" style=\"zoom: 75%;\" />\n\n**基本操作**:\n\n- **创建**:\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-52.png\" style=\"zoom:55%;\" />\n\n- **销毁**:\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-53.png\" style=\"zoom:55%;\" />\n\n- **增、删**:\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-54.png\" style=\"zoom:55%;\" />\n\n- **查**:\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-55.png\" style=\"zoom:55%;\" />\n\n**在实际应用中应该怎样选取存储结构呢**？\n\n- **基于存储的考虑**\n\n  难以估计线性表的长度或存储规模时，不宜采用顺序表；链表不用事先估计存储规模，但链表的存储密度较低，显然链式存储结构的存储密度是小于1的。\n\n- **基于运算的考虑**\n\n  在顺序表中按序号访问ai的时间复杂度为O(1)，而链表中按序号访问的时间复杂度为O(n)，因此若经常做的运算是按序号访问数据元素，则显然顺序表优于链表。\n\n  在顺序表中进行插入、删除操作时，平均移动表中一半的元素，当数据元素的信息量较大且表较长时，这一点是不应忽视的；在链表中进行插入、删除操作时，虽然也要找插入位置，但操作主要是比较操作，从这个角度考虑显然后者优于前者。\n\n- **基于环境的考虑**\n\n  顺序表容易实现，任何高级语言中都有数组类型；链表的操作是基于指针的，相对来说前者实现较为简单，这也是用户考虑的一个因素。\n\n**开放式问题的回答思路**\n\n**注意**：对于一些开放式问题的答题思路，例如\n\n- 请描述顺序表和链表的…（区别、联系…）\n- 实现线性表时，用顺序表还是链表好？\n\n你都可以用这样的思路（框架），来让自己的答题逻辑更加的清晰。\n\n**这样的思路（框架）**：指的是本节中，对顺序表和链表分别从**逻辑结构**、**存储结构**、**基本操作**三个角度进行了对比，并指出**优缺点**、**效率**上的差异等。\n\n> 具体的回答思路，例如：\n>\n> 顺序表和链表的逻辑结构都是线性结构，都属于线性表。\n>\n> 但是二者的存储结构不同，顺序表采用顺序存储…，具有…的特点，从而导致其优点…，缺点…；而链表采用链式存储，具有…的特点，从而导致其优点…，缺点…。\n>\n> 由于采用不同的存储方式实现，因此基本操作的实现效率也不同。当初始化时…；当插入一个数据元素时…；当删除一个数据元素时…；当查找一个数据元素时…。\n\n当然，也并不是说这其中的每一个点都必须写出来，意思就是，你可以根据实际情况，按照这个大致思路进行回答，并且选择把哪些点答上去，哪些可以不答上去。总之，思路是清晰的。\n\n此外，这样的框架性的思路除了便于答题外，也有助于自己的复习、回顾。\n\n### 习题\n\n  - 【2016】已知一个带有表头结点的双向循环链表L，结点结构为`prev|data|next`,其中，prev 和 next 分别是指向其直接前驱和直接后继结点的指针。现要删除指针 p 所指的结点，正确的语句序列是\n\n    >  p->next->prev=p->prev; p->prev->next=p->next; free(p);\n\n  - 【2016】已知表头元素为 c 的单链表在内存中的存储状态如下表所示。\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-30.png\"  />\n\n    现将 f 存放于 1014H 处并插入到单链表中，若 f 在逻辑上位于 a 和 e 之间，则 a, e, d 的“链接地址”依次是-->1014H 1004H NULL\n\n    > 链表的遍历顺序c（1008H）->a（1000H）->e（1010H）->b（1004H）->d（100CH）->null，然后你插入f到a,e 之间，则a要链接的地址就变成了f的地址，则a的链接地址为1014H ，而f的链接地址则是为e的地址1010H，最后的e后面的链接是没有变的依然是到b。总结：插入后链表的遍历顺序c（1008H）->a（1000H）->f(1014H)->e（1010H）->b（1004H）->d（100CH）->null\n\n  - 【2021】已知头指针h指向一个带头结点的非空单循环链表，结点结构为`data|next`,其中next是指向直接后继结点的指针，p是尾指针，q是临时指针。现要删除该链表的第一个元素，正确的语句序列是--> \n\n    q= h->next; h->next=q->next; if(p==q) p=h; free(q);\n\n    > 删除该链表的第一个元素就是让你删除头结点后面的第一个结点。\n    >\n    > 普通情况:\n    >\n    > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-31.png\" style=\"zoom:67%;\" />\n    >\n    > 特殊情况:要注意当我们删除head后面的节点以后，整个链表就只剩下head节点一个了。 那尾指针只能指向head，所以D选项里的if(p==q)  p=h; free(q);就非常正确。\n    >\n    > <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-32.png\" style=\"zoom:67%;\" />\n\n  - 综合【2009】已知一个带有表头结点的单链表，结点结构为`data|link` 假设该链表只给出了头指针list。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第k个位置上的结点（k为正整数）。若查找成功，算法输出该结点的data域的值，并返回1；否则，只返回0。要求： \n\n    ① 描述算法的基本设计思想 \n\n    ② 描述算法的详细实现步骤 \n\n    ③ 根据设计思想和实现步骤，采用程序设计语言描述算法，关键之处请给出简要注释\n\n    > 1)关键是设计尽可能高效的算法，通过链表的一次遍历，找到倒数第k个结点的位置。算法的基本设计思想是:定义两个指针变量p和q，初始时均指向头结点的下一个结点(链表的第一个结点)，p指针沿链表移动；当p指针移动到第k个结点时，q指针开始与p指针同步移动；当p指针移动到最后一个结点时，q指针所指示结点为倒数第k个结点。\n    >\n    > 2)算法详细实现步骤:\n    >\n    > 1.count=0,p和q指向链表表头结点的下一个结点。\n    >\n    > 2.若p为空，转5\n    >\n    > 3.若count等于k，则q指向下一个结点；否则，count=count+1。\n    >\n    > 4.p指向下一个结点，转2\n    >\n    > 5.若count等于k，则查找成功，输出该结点的data域的值，返回1；否则，说明k值超过了线性表的长度，查找失败，返回0.\n    >\n    > 6.算法结束。\n    >\n    > 3)算法实现如下:\n    >\n    > ```C\n    > typedef struct LNode{\n    > \tint data;\n    > \tstruct LNode *link;\n    > }LNode, *LinkList;\n    > \n    > int Search_k(LinkList list,int k){\n    > \t//查找链表list倒数第k个结点，并输出该结点data域的值\n    > \tLNode *p=list->link;//指针p,q指向链表的第一个结点 \n    > \tLNode *q=list->link;\n    > \tint count=0;//计数器初始化为0 \n    > \twhile(p! =NULL){//指针p依次遍历链表直至最后一个结点 \n    > \t\tif(count<k) count++;\n    > \t\telse  q=q->link;\n    > \t\t p=p->link;\n    > \t} //while\n    > \t/*\n    > \t上面这几行是这个算法的核心思想，我来解释一下\n    > \t首先算法开始运行时，p在动，而q不动\n    > \t直到p向右移动了k次，此时k和count相等，这时候p和q一起向右移动\n    > \t如果k小于链表的长度，则返回q指针指向的数据域 \n    > \t*/\n    > \tif(count<k)//若k值大于链表的长度，则找不到该结点，返回0 \n    > \t   return 0;\n    > \telse{\n    > \t\tprintf(\"%d\",q->data);//找到该结点则返回该结点的数据域 \n    > \t\treturn 1;\n    > \t} \n    > } \n    > ```\n\n  - 综合【2012】假定采用带头结点的单链表保存单词，当两个单词有相同的后缀时，可共享相同的后缀存储空间，例如,\"loading\"和\"being\"的存储影像如下图所示。\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-33.png\"  />\n\n    设str1和str2分别指向两个单词所在单链表的头结点，链表结点结构为`data|next`，请设计一个时间上尽可能高效的算法，找出由str1和str2所指向两个链表共同后缀的起始位置(如图中字符i所在结点的位置p)。要求:\n\n    1)给出算法的设计思想\n\n    2)根据设计思想，采用程序语言描述算法，关键之处给出注释\n\n    3)说明你所设计算法的时间复杂度\n\n    > 1)分别求出str1和str2所指的两个链表的长度m和n；\n    > 将两个链表以表尾对齐：令指针p、q分别指向str1和str2的头结点；如果m>=n，则p指针先走，使p指向链表中的第m-n+1个结点；如果m<n，则使q指针指向链表的第n-m+1个结点；即：使得指针p、q所指的结点到表尾的长度相等；\n    > 反复将指针q和q同步向后移动，当p、q指向同一位置时停止，即：共同后缀的起始位置。算法结束。\n    > 2）\n    >\n    > ```C\n    > typedef struct LNode{\n    >  char data;\n    >  struct LNode *next;\n    > }LNode;\n    > \n    > //求链表的长度;\n    > int GetListLen(LNode *head){\n    >  int len = 0;\n    >  while(head->next != NULL){\n    >      len++;\n    >      head = head->next;\n    >  }\n    >  return len;\n    > }\n    > //找出共同后缀的起始位置；\n    > LNode* find_addr(LNode *str1,LNode *str2){\n    >  int m,n;\n    >  m = GetListLen(str1);\n    >  n = GetListLen(str2);\n    > \n    >  LNode *p,*q;\n    >  if(m >= n){\n    >      for(p = str1;m>n;m--){\n    >          p = p->next;\n    >      }\n    >  }else{\n    >      for(q = str2;n>m;n--){\n    >          q = q->next;\n    >      }\n    >  }\n    >  //得到p和q的起始位置后，找出共同后缀的起始地址；\n    >  while(p->next !=NULL && p->next != q->next){\n    >      p = p->next;\n    >      q = q->next;\n    >  }\n    >  return p->next;\n    > }\n    > ```\n    >\n    > 3)**O(max(m,n))**（m、n分别为两个链表的长度）；\n\n  - 综合【2015】用单链表保存m个整数，结点的结构为[data]|[link]，且|data|<=n(n为正整数)。现要求设计一个时间复杂度尽可能高效的算法，对于链表中data的绝对值相等的结点，仅保留第一次出现的结点而删除其余绝对值相等的结点。例如，若给定的单链表head如下:\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-34.png\" style=\"zoom:80%;\" />\n\n    则删除结点后的head为：\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-35.png\" style=\"zoom:80%;\" />\n\n    要求：  \n\n       1）给出算法的基本设计思想。  \n\n       2）使用C或C++语言，给出单链表结点的数据类型定义。  \n\n       3）根据设计思想，采用C或C++语言描述算法，关键之处给出注释。  \n\n       4）说明你所设计算法的时间复杂度和空间复杂度。\n\n    > 1）算法的基本设计思想 \n    >\n    > 算法的核心思想是用空间换时间。使用辅助数组记录链表中已出现的数值，从而只需对链表进行一趟扫描。 因为|data|≤n，故辅助数组q的大小为n+1，各元素的初值均为0。依次扫描链表中的各结点，同时检查q[|data|]的值，如果为0，则保留该结点，并令q[|data|]=1；否则，将该结点从链表中删除。 \n    >\n    > 2）使用C语言描述的单链表结点的数据类型定义\n    >\n    > ```C\n    > typedef struct node {\n    > int         data;\n    > struct node   *link;\n    > }NODE;\n    > Typedef NODE *PNODE;\n    > ```\n    >\n    > 3）算法实现\n    >\n    > ```C\n    > void func (PNODE h,int n)\n    > {\n    > PNODE p=h,r;\n    > int *q,m;\n    > q=(int *)malloc(sizeof(int)*(n+1));  //申请n+1个位置的辅助空间\n    > for(int i=0;i<n+1;i++)                //数组元素初值置0\n    > *(q+i)=0;\n    > while(p->link!=NULL)\n    > {\n    > m=p->link->data>0? p->link->data:-p->link->data;\n    > if(*(q+m)==0)                      //判断该结点的data是否已出现过\n    > {\n    > *(q+m)=1;                      //首次出现\n    > p=p->link;                     //保留\n    > }\n    > else                               //重复出现\n    > {   r=p->link;                     //删除\n    > p->link=r->link\n    > free(r);\n    > }\n    > }\n    > free(q);\n    > }\n    > ```\n    >\n    > 4）时间复杂度为O(m)，空间复杂度为O(n)\n\n  - 【2019】设线性表L=(a1,a2,a3,...,a(n-2),a(n-1),an)采用带头结点的单链表保存，链表中的结点定义如下:\n\n    ```C\n    typedef struct node {\n        int data;\n        struct node* next;\n    } NODE;\n    ```\n\n    请设计一个空间复杂度为 `O(1)` 且时间上尽可能高效的算法，重新排列 L 中的各节点，得到线性表 `L'=(a1, an, a2, a(n-1), a3, a(n-2), ...)`。要求:\n\n    1)给出算法的设计思想\n\n    2)根据设计思想，采用程序语言描述算法，关键之处给出注释\n\n    3)说明你所设计算法的时间复杂度\n\n    > 1)先观察L=(a1,a2,a3,...,a(n-2),a(n-1),an)和L'=(a1,an,a2,a(n-1),a3,a(n-2),...)，发现L'是由L摘取第一个元素，再摘取倒数第一个元素......依次合并而成的。为了方便链表后半段取元素，需要先将L后半段原地逆置[题目要求空间复杂度为O(1)，不能借助栈]，否则每取最后一个结点都需要遍历一次链表。1.先找出链表L的中间结点，为此设置两个指针p和q,指针p每次走一步，指针q每次走两步，当指针q到达链尾时，指针p正好在链表的中间结点；2.然后将L的后半段结点原地逆置。3.从单链表前后两段中依次各取一个结点，按要求重排。\n    >\n    > 2)算法实现\n    >\n    > ```C\n    > void Change_list(Linklist h){\n    > \tLNode *p,*q,*r,*s;\n    > \tp=q=h;\n    > \t/*双指针找链表的中点*/ \n    > \twhile(q->next!=NULL){\n    > \t\tp=p->next;\t\t\t\t\t//p走一步 \n    > \t\tq=q->next;\n    > \t\tif(q->next!=NULL)q=q->next; //q走两步 \n    > \t}\n    > \t/*链表的逆置*/\n    > \tq=p->next;\t\t\t//p所指结点为中点 \n    > \tp->next=NULL;\t\t//q为后半链表的首结点 \n    > \twhile(q!=NULL){\n    > \t\tr=q->next;\n    > \t\tq->next=p->next;\n    > \t\tp->next=q;\n    > \t\tq=r;\n    > \t}\n    > \t/*后半部分的链表头插进入前半部分*/\n    > \ts=h->next;\n    > \tq=p->next;\n    > \tp->next=NULL;\n    > \twhile(q!=NULL){\n    > \t\tq->next=s->next;//将q所指结点插入到s所指结点之后 \n    > \t\ts->next=q;\n    > \t\ts=q->next;\t\t//将s指向前半段的下一个插入点 \n    > \t\tq=r;\n    > \t}\n    > }\n    > \n    > ```\n    >\n    > 3)第一步找中间结点的时间复杂度为O(n),第二步逆置的时间复杂度为O(n)，第3步合并链表的时间复杂度为O(n),所以该算法的时间复杂度为O(n)。\n","tags":["408数据结构"],"categories":["408数据结构"]},{"title":"第二章 线性表(上)","url":"/p/14457/","content":"\n## 2.1 线性表的定义和基本操作\n\n### 什是线性表？🤔\n\n**有点像函数**\n\n函数：一个 x 值只能对应一个 y 值\n线性表：一个索引值只能有一个映射值\n\n**定义**:线性表是具有相同数据类型的 n(n≥0) 个<font color='orange'>数据元素</font>的有限序列，其中n为表长，当n-0时线性表是一个<font color='orange'>空表</font>。若用L命名线性表，则其一般表示为\n\nL=(a1,a2,...,ai,ai+1,...,an)\n\n**几个概念**:\n\n- ai是线性表的\"第i个\"元素线性表中的位序。\n- a1是<font color='orange'>表头元素</font>；an是<font color='orange'>表尾元素</font>。\n- 除第一个元素外，每个元素有且<font color='orange'>仅有一个直接前驱</font>；除最后一个元素外，每个元素有且<font color='orange'>仅有一个直接后继</font>\n\n**特点**:\n\n- 表中元素<font color='orange'>个数有限</font>\n- 表中元素具有逻辑上的顺序性，表中元素有其<font color='orange'>先后次序</font>\n- 表中元素都是数据元素，每个元素都是单个元素\n- 表中元素的数据类型都相同，这意味着<font color='orange'>每个元素占有相同大小的存储空间</font>\n- 表中元素具有抽象性 \n\n<font color='red'>注</font>:线性表是一种<font color='red'>逻辑结构</font>，表示元素之间一对一的相邻关系。顺序表和链表是指<font color='red'>存储结构</font>，两者属于不同的层面概念，不要混淆\n\n### 线性表的基本操作\n\n详细文档可以参考 c++容器[list 的相关函数](https://cplusplus.com/reference/list/list/)\n\n[c++代码示例](../code/2.1.list.cpp)\n\n- InitList(&L) ：初始化表，构造一个空的线性表\n\n- DestroyList(&L) ：销毁线性表\n- ClearList(&L) ：清空线性表\n- ListEmpty(&L) ：置空线性表\n- ListLength(L) ： 求线性表长度\n- GetElem(L, i, &e) ： 获取元素\n- LocateElem(L, e, compare())\n- PriorElem(L, cur_e, &pre_e) ： 获取元素的前驱\n- NextElem(L,cur_e,&next_e) ： 获得元素的后继\n- ListInsert(&L,i,e) ：插入操作\n- ListDelete(&L,i,&e) ：删除操作\n- ListTraverse(&L, vistited()) ：遍历 \n\nTips：\n\n- 对数据的操作——无非就是创建、销毁；增、删、改、查。\n- 在描述基本操作的时候，并不指明具体的参数类型，而是一种抽象的接口定义。\n- 实际开发中，可根据实际需求定义其他的基本操作。\n- 函数名和参数的形式、命名都可改变。但是尽量具有可读性，写成上面这种就很好，都是很好的命名方式了。\n- **什么时候要传入引用”&“——对参数的修改结果需要”带回来“。即操作的是同一份实实在在的数据目标，而不能是一个拷贝的复制品。**\n\n**问题**：为什么要实现对**数据结构**的基本操作？\n\n- 团队合作编程，你定义的数据结构要让别人能很方便地使用（封装）。\n- 将常用的操作/运算封装成函数，避免重复工作，降低出错风险。\n\n\n\n## 2.2 线性表的顺序表示\n\n### 顺序表的定义 Sequence List\n\n- **顺序表**--用顺序存储的方式实现线性表顺序存储。\n\n- **顺序存储**--把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。\n\n- 顺序表的**特点**:\n\n  - 表中元素的逻辑顺序与其物理顺序相同。\n  - <font color='orange'>随机访问</font>，即通过首地址和元素序号可在时间O(1)内找到指定的元素。\n  - <font color='orange'>存储密度高</font>，每个结点只存储数据元素。它不像链表那样还需要存放一个指针域。\n  - 拓展容量不方便。即使采用动态分配的方式实现，拓展长度的时间复杂度也比较高。\n  - 插入、删除操作不方便，需要移动大量元素。\n\n- 顺序表的实现\n\n  - 静态分配\n\n    ```C\n    #define MaxSize 10;\t\t\t\t//定义最大长度\n    typedef struct{\n        ElemType data[MaxSize];\t\t//用静态的\"数组\"存放数据元素\n        int length;\t\t\t\t\t//顺序表的当前长度\n    }SqList;\t\t\t\t\t\t//顺序表的类型定义(静态分配方式)\n    ```\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-1.png\" style=\"zoom: 75%;\" />\n\n    **问题**：如果“数组”存满了怎么办？\n\n    - 可以放弃了，顺序表的表长刚开始确定后就无法更改（存储空间是静态的）\n    - 如果刚开始就声明一个很大的内存空间呢？会很浪费空间。\n\n  - 动态分配\n\n    ```C\n    #define MaxSize 100;\t\t\t\t//定义最大长度\n    typedef struct{\n        ElemType *data;\t\t\t\t//指针指向第一个数据元素\n        int MaxSize;\t\t\t\t//顺序表的最大容量\n        int length;\t\t\t\t\t//顺序表的当前长度\n    }SeqList;\t\t\t\t\t\t//顺序表的类型定义(动态分配方式)\n    ```\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-2.png\" style=\"zoom: 75%;\" />\n\n  - C 的初始动态分配语句--malloc、free函数\n\n    `L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize);`\n\n    malloc函数返回一个指针，需要强制转型为你定义的数据元素类型指针\n\n    > char * p = (char* ) malloc(sizeof(char)*10)；\n    >\n    > //申请了10个char长度的连续空间，不初始化且不知道是否申请成功\n    >\n    > if(NULL == p)\n    >\n    > return；//申请内存空间失败\n\n  - C++的初始动态分配语句--new、delete关键字\n\n    `L.data = new ElemType[InitSize];`\n\n### 顺序表上基本操作\n\n- 插入操作\n\n  - 最好情况：表尾插入(即i=n+1)，时间复杂度为O(1)\n\n  - 最坏情况：表头插入(即i=1)，时间复杂度为O(n)\n\n  - 平均情况：插入到任一位置的概率相同，即i=1,2,3,...,length+1的概率都是p=1/(n+1)。 i=1，循环n次；i=2时，循环n-1次；... i=n+1时，循环0次\n    $$\n    E_{ins} = \\frac 1{n+1} \\sum^{n+1}_{i=1}(n-i+1) = \\frac 1{n+1}(n+\\cdots + 1 + 0) = \\frac n2\n    $$\n     ，平均时间复杂度为O(n)\n\n  ```C\n  void ListInsert(SqList &L, int i, int e){\n  \tfor(int j=L.length; j>=i; j--){\t//将第i个元素及之后的元素后移 \n  \t\tL.data[j] = L.data[j-1];\n  \t}\n  \tL.data[i-1] = e;\t//在位置i处放入e\n  \tL.length++;\t\t//长度加1 \n  }\n  ```\n\n  对于插入操作，如果使用者传入了一个**不合法的值**，那么我们的程序应该可以给予相应的反馈。至少要反馈插入是成功，还是失败了吧。所以我们可以优化一下，如下:\n\n  ```C\n  // 插入操作代码\n  bool ListInsert(SqList &L, int i, ElemType e) {\n      if (i < 1 || i > L.length + 1 )          // 判断i的范围是否有效\n          return false;\n      else if (L.length >= MAXSIZE)            // 当前存储空间已满\n          return false;\n      for (int j = L.length ; j >= i ; j--)\n          L.data[j] = L.data[j - 1];           // 插入位置及之后位置后移\n      L.data[i - 1] = e;                       // 将新元素放入第i个位置\n      L.length++;                              //表长增加1\n      return true;\n  }\n  ```\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-51.png\" style=\"zoom: 75%;\" />\n\n- 删除操作\n\n  - 最好情况：删除表尾元素(即i=n)，时间复杂度为O(1)\n\n  - 最坏情况：删除表头元素(即i=1)，时间复杂度为O(n)\n\n  - 平均情况：删除任何一个元素的概率相同，即I=1,2,3,...,length的概率都是p=1/n。i=1，循环n-1次；i=2时，循环n-2次；...i=n时，循环0次\n    $$\n    E_{del} = \\frac 1n \\sum^n_{i=1}(n-i)=\\frac 1n \\frac {(n-1)n}2 = \\frac{n-1}2\n    $$\n     ，平均时间复杂度为O(n)\n\n  ```C\n  // 删除操作代码\n  bool ListDelete(SqList& L, int i, ElemType &e) {\n      if (i < 1 || i > L.length)             // 判断i值是否合理\n          return false;\n      e = L.data[i - 1];         //将被删除的元素赋给e\n      for (int j = i; j < L.length; j++)\n          L.data[j - 1] = L.data[j];  //将被删除的元素赋给e\n      L.length--;  //线性表长度减1\n      return true;\n  }\n  ```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-4.png\" style=\"zoom: 70%;\" />\n\n- **按位查找**\n\n  ```C\n  ELemType GetElem(SeqList L, int i){\n      return L.data[i-1];\n  }\n  ```\n\n  时间复杂度:O(1)   \"**随机存取**\"特性!\n\n- **按值查找**（顺序查找）\n\n  - 最好情况：查找的元素就在表头循环1次，时间复杂度为O(1)\n\n  - 最坏情况：查找的元素在表尾（或不存在）循环n次，时间复杂度为O(n)\n\n  - 平均情况：目标元素出现在任一位置的概率相同，都是1/n。目标在第1位，循环1次；...在第n位，循环n次。\n    $$\n    E_{find} = \\frac 1n \\sum^n_{i=1}i= \\frac{n+1}2\n    $$\n     ，平均时间复杂度为O(n)\n\n  ```C\n  int LocateElem(SeqList L,ElemType e){\n  \tfor(int i=0;i<L.length;i++)\n      {\n          if(L.data[i]==e)\n          {\n              return i+1;\t\t//数组小标为i的元素值等于e,返回其位序i+1\n          }\n          return 0;\t\t\t//退出循环,说明查找失败\n      }\n  }\n  ```\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-5.png\" style=\"zoom: 70%;\" />\n\n> **问题**：此处，像int、float、char等类型，判断相等可以使用“= =”来判断。但若是结构类型的数据呢？还可以用“= =”吗？——不能。\n>\n> 如果是结构类型的数据，判断其是否相等，你需要依次比较该结构体中的各个变量是否相等，最终判断两个结构类型变量是否相等。当然，你也可以将判断两个结构类型是否相等的代码封装成一个函数，以便复用。\n>\n> 如果使用C++、JAVA，你也可以对“= =”进行运算符重载。\n>\n> **Tips**：但是呢，如果你是在《数据结构》的考研初试的试卷当中，去手写代码的时候，你当然可以直接用“= =”来判断是否相等，不论是什么类型，而不需要考虑那么多，因为数据结构考的是一种思想、一种理解，而并不是具体的编程语言的实现。\n>\n> 但是，如果考的是《C语言程序设计》，那么，也许你就要严格按照C语言的语法来写，即使是在试卷上手写代码。\n\n### 习题\n\n- 11 顺序表的插入算法中，当 n 个空间已满时，可再申请增加分配 m 个空间，若申请失败，则说明系统没有（）可分配的存储空间 →n+m 个连续\n\n  > 顺序存储需要连续的存储空间，在申请时需申请n+m个连续的存储空间，然后将线性表原来的n个元素复制到新申请的n+m个连续的存储空间的前n个单元。\n\n- 综合题 10【2010】设将(n>1)个整数存放到一堆数组R中。设计一个在时间和空间两方面都尽可能高效的算法。将R中保存的序列循环左移p（0<p<n）个位置，即将R中的数据由（X0, X1,..., Xn-1）变换为（Xp, Xp+1,..., Xn-1, X0, X1,..., Xp-1）。要求：\n\n  1）给出算法的基本设计思想。\n\n  2）根据设计思想，采用C、C++或Java语言描述算法，关键之处给出注释。\n\n  3）说明你所设计算法的时间复杂度和空间复杂度。\n\n  > 1）算法的基本设计思想： \n  >\n  > 可以将这个问题看作是把数组ab转换成数组ba（a代表数组的前p个元素，b代表数组中余下的n-p个元素）:先将a逆置得到a^-1^b，再将b逆置得到a^-1^b^-1^，最后将整个a^-1^b^-1^逆置得到（a^-1^b^-1^）^-1^=ba。设Reverse函数执行将数组元素逆置的操作，对abcdefgh向左循环移动3（p=3）个位置的过程如下： \n  >\n  > Reverse(0,p-1)得到cbadefgh；  \n  >\n  > Reverse(p,n-1)得到cbahgfed；  \n  >\n  > Reverse(0,n-1)得到defghabc。\n  >\n  > 注：Reverse中，两个参数分别表示数组中待转换元素的始末位置。\n  >\n  > 2）使用C语言描述算法如下：\n  >\n  > ```C\n  > void Reverse(int R[],int from,int to) {\n  > int i,temp;\n  > for(i=0;i<(to-from+1)/2;i++)\n  > {    temp=R[from+i];\n  >    R[from+i]=R[to-i];\n  >    R[to-i]=temp;}\n  > }//Reverse\n  > void Converse(int R[],int n,int p){\n  > Reverse(R,0,p-1);\n  > Reverse(R,p,n-1);\n  > Reverse(R,0,n-1);\n  > }\n  > ```\n  >\n  > 3）上述算法中3个Reverse函数的时间复杂度分别为O(p/2)、O((n-p)/2)和O(n/2)，故所设计的算法的时间复杂度为O(n)，空间复杂度为O(1)。\n  >\n  > **另解**，借助辅助数组来实现。  \n  >\n  > 算法思想：创建大小为p的辅助数组S，将R中前p个整数依次暂存在S中，同时将R中后n-p个整数左移，然后将S中暂存的p个数依次放回到R中的后续单元。  \n  >\n  > 时间复杂度为O(n)，空间复杂度为O(p)。\n\n- 综合题 11【2011】一个长度为L(L>=1)的升序序列S，处在第[L/2]个位置的数称为S的中位数。例如，若序列S1=(11，13，15，17，19)，则S1的中位数是15，两个序列的中位数是含它们所有元素的升序序列的中位数。例如，若S2=（2，4，6，8，20），则S1和S2的中位数是11。现在有两个等长升序序列A和B，试设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列A和B的中位数。要求：\n\n  （1）给出算法的基本设计思想。\n\n  （2）根据设计思想，采用C、C++或Java语言描述算法，关键之处给出注释。\n\n  （3）说明你所设计算法的时间复杂度和空间复杂度。\n\n  > 1）求两个序列A和B的中位数最简单的办法就是将两个升序序列进行归并排序，然后求其中位数。这种解法虽可求解，但在时间和空间两方面都不大符合高效的要求，但也能获得部分分值。 \n  >\n  > 根据题目分析，分别求两个升序序列A和B的中位数，设为a和b。 \n  >\n  > ① 若a=b，则a或b即为所求的中位数。 \n  >\n  > 原因：容易验证，如果将两个序列归并排序，则最终序列中，排在子序列ab前边的元素为先前两个序列中排在a和b前边的元素；排在子序列ab后边的元素为先前两个序列中排在a和b后边的元素。所以子序列ab一定位于最终序列的中间，又因为a=b，显然a就是中位数。 \n  >\n  > ② 否则（假设a<b），中位数只能出现（a，b）范围内。 \n  >\n  > 原因：同样可以用归并排序后的序列来验证，归并排序后必然有形如…a…b…的序列出现，中位数必出现在（a，b）之间。因此可以做如下处理：舍弃a所在序列A的较小一半，同时舍弃b所在序列B的较大一半。在保留两个升序序列中求出新的中位数a和b，重复上述过程，直到两个序列中只含一个元素时为止，则较小者即为所求的中位数。每次总的元素个数变为原来的一半。 \n  >\n  > 算法的基本设计思想如下: \n  >\n  > 分别求出序列A和B的中位数，设为a和b，求序列A和B的中位数过程如下: \n  >\n  > ① 若a=b，则a或b即为所求中位数，算法结束。 \n  >\n  > ② 若a<b，则舍弃序列A中较小的一半，同时舍弃序列B中较大的一半，要求舍弃的长度相等。 \n  >\n  > ③ 若a>b，则舍弃序列A中较大的一半，同时舍弃序列B中较小的一半，要求舍弃的长度相等。 \n  >\n  > 在保留的两个升序序列中，重复过程①、②、③，直到两个序列中只含一个元素时为止，较小者即为所求的中位数。 \n  >\n  > 2）算法的实现如下:\n  >\n  > ```C\n  > int M_Search(int A[],int B[],int n){\n  >  int s1=0,d1=n-1,m1,s2=0,d2=n-1,m2;\n  >  //分别表示序列A和B的首位数、末位数和中位数\n  >  while(s1!=d1||s2!=d2){\n  >      m1=(s1+d1)/2;\n  >      m2=(s2+d2)/2;\n  >      if(A[m1]==B[m2])\n  >          return A[m1];           //满足条件①\n  >      if(A[m1]<B[m2]){            //满足条件②\n  >          if((s1+d1)%2==0){     //若元素个数为奇数\n  >              s1=m1;              //舍弃A中间点以前的部分，且保留中间点\n  >              d2=m2;              //舍弃B中间点以后的部分，且保留中间点\n  >          }\n  >          else{                  //元素个数为偶数\n  >              s1=m1+1;              //舍弃A中间点及中间点以前部分\n  >              d2=m2;                //舍弃B中间点以后部分且保留中间点\n  >          }\n  >      }\n  >      else{                        //满足条件③\n  >          if((s2+d2)%2==0) {     //若元素个数为奇数\n  > \t\t        d1=m1;              //舍弃A中间点以后的部分，且保留中间点\n  > \t\t        s2=m2;              //舍弃B中间点以前的部分，且保留中间点\n  > \t\t    }\t\n  > \t\t    else{                  //元素个数为偶数\t\n  > \t\t        d1=m1;              //舍弃A中间点以后部分，且保留中间点\t\n  > \t\t        s2=m2+1;                //舍弃B中间点及中间点以前部分\n  > \t\t    }\t\n  > \t\t}\n  > \t}\t\n  > \treturn A[s1]<B[s2]? A[s1]:B[s2];\n  > }\n  > ```\n  >\n  > 3）算法的时间复杂度为O(log₂n)，空间复杂度为O(1)。  \n  >\n  > 【另解】对两个长度为n的升序序列A和B的元素按由小到大的顺序依次访问，这里访问的含义只是比较序列中两个元素的大小，并不实现两个序列的合并，因此空间复杂度为O(1)。按照上述规则访问到第n个元素时，这个元素即为两个序列A和B的中位数。\n\n- 综合题 12【2013】已知一个整数序列A=(a0,a1,...,an-1)，其中0<=ai<=0(0<=o<=n)。若存在ap1=ap2=...=apm=x 且 m>n/2(0<=pk<n,1<=k<=m),则称x为A的主元素。例如A=（0,5,5,3,5,7,5,5），则5为主元素；又如A =(0,5,5,3,5,1,5,7)，则A中没有主元素。假设A中的几个元素保存在一个一维数组中，请设计一个尽可能高效的算法，找出A的主元素。若存在主元素，则输出该元素；否则输出-1。要求：\n\n  (1) 给出算法的基本设计思想\n\n  (2) 根据设计思想，釆用C或C++或Java语言描述算法，关键之处给出注释。\n\n  (3) 说明你所设计算法的时间复杂度和空间复杂度。\n\n  > (1)将第一个出现的元素num保存到c中，用count记录num出现的次数，初始时令count = 1。如果下一个遇到的元素仍然是num则将count加1，否则将count减1。如果此时count == 0，则将下一个元素保存到c中，并重置count为0。重复上述过程，直至扫描完全部元素。\n  > 判断此时的c是否为真正的主元素。统计c出现的次数，并保存到count中，如果count > n / 2，则是主元素，否则不是。\n  > **通俗来讲：就是不断消除两个不同的元素，最后剩的元素就是可能的主元素，然后再判断该可能的主元素个数是否大于n/2，若大于，则主元素就是该元素**。\n  >\n  > (2)算法实现\n  >\n  > ```C\n  > int Majority(int A[], int n)\n  > {\n  > \tint i, c, count = 1;//c用来保存候选主元素，count用来计数\n  > \tc = A[0];           //设置A[0]为候选主元素\n  > \tfor (i = 1; i < n; i++)//查找候选主元素\n  > \t\tif (A[i] == c)\n  > \t\t\tcount++;    //对A中的候选主元素计数\n  > \t\telse\n  > \t\t\tif (count > 0)//处理不是候选主元素时的情况\n  > \t\t\t\tcount--;\n  > \t\t\telse{         //更换候选主元素，重新计数\n  > \t\t\t\tc = A[i];\n  > \t\t\t\tcount = 1;\n  > \t\t\t}\n  > \tif (count > 0)\n  > \t\tcount = 0;\n  > \t\tfor (i = 0; i < n; i++)//统计候选主元素的实际出现情况\n  > \t\t\tif (A[i] == c)\n  > \t\t\t\tcount++;\n  > \tif (count > n / 2)\treturn c;//确定候选主元素\n  > \telse return -1;//不存在主元素\n  > }\n  > ```\n  >\n  > (3)实现的程序时间复杂度为O(n)，空间复杂度为O(1)。\n\n- 综合题 13【2018】给定一个含n(n>=1)个整数的数组，请设计一个在时间上尽可能高效的算法，找出数组中未出现的最小正整数。例如，数组{-5，3，2，3}中未出现的最小正整数是1；数组{1, 2, 3}中未出现的最小正整数是4。要求：\n\n  （1）给出算法的基本设计思想。 \n\n  （2）根据设计思想，采用 C 或 C++语言描述算法，关键之处给出注释。 \n\n  （3）说明你所设计算法的时间复杂度和空间复杂度。\n\n  > 1)题目要求算法时间上尽可能高效，因此采用空间换时间的办法。分配一个用于标记的 数组 B[n]，用来记录 A 中是否出现了 1～n 中的正整数，B[0]对应正整数 1，B[n-1]对应正整数 n，初始化 B 中全部为 0。由于 A 中含有 n 个整数，因此可能返回的值是 1～n+1，当 A 中 n 个数恰好为 1～n 时返回 n+1。当数组 A 中出现了小于等于 0 或大于 n 的值时，会导致 1～n 中出现空余位置，返回结果必然在 1～n 中，因此对于 A 中出现了小于等于 0 或大于 n 的值可 以不采取任何操作。 \n  >\n  > 经过以上分析可以得出算法流程：从 A[0]开始遍历 A，若 0<A[i]<=n，则令 B[A[i]-1] = 1； 否则不进行操作。对 A 遍历结束后，开始遍历数组 B，若能查找到第一个满足B[i]==0 的下标 i，返回 i+1 即为结果，此时说明 A 中未出现的最小正整数在 1～n 之间。若 B[i]全部不为 0， 返回 i+1（跳出循环时 i = n，i+1 等于 n+1），此时说明 A 中未出现的最小正整数是 n+1。\n  >\n  > 2)算法实现\n  >\n  > ```C\n  > int findMissMin(int A[], int n)\n  > {\n  >  int i, *B;                          //标记数组\n  >  B = (int *)malloc(sizeof(int) * n); //分配空间\n  >  memset(B, 0, sizeof(int) * n);      //赋初值为 0\n  >  for (i = 0; i < n; i++)\n  >      if (A[i] > 0 && A[i] <= n) //若 A[i]的值介于 1～n，则标记数组 B\n  >          B[A[i] - 1] = 1;\n  >  for (i = 0; i < n; i++) //扫描数组 B，找到目标值\n  >      if (B[i] == 0)\n  >          break;\n  >  return i + 1; //返回结果\n  > }\n  > ```\n  >\n  > 3)时间复杂度：遍历 A 一次，遍历 B 一次，两次循环内操作步骤为 O(1)量级，因此时间 复杂度为 O(n)。空间复杂度：额外分配了 B[n]，空间复杂度为 O(n)。\n  >\n  > https://www.codenong.com/cs105598468/\n  >\n  > https://icode.best/i/29345031505648\n\n- 综合题 14【2020】定义三元组(a,b,c)(a、b、c均为正数)的距离D=|a-b|+|b-c|+|c-a|。给定3个非空整数集合S1、S2和S3，按升序分别存储在3个数组中。请设计一个尽可能高效的算法，计算并输出所有可能的三元组(a,b,c)(a∈S1,b∈S2,c∈S3)中的最小距离。例如S1={-1,0,9}，S2={-25,-10,10,11}，S3={2,9,17,30,41},则最小距离为2，相应的三元组为(9,10,9)。\n\n  （1）给出算法的基本设计思想。 \n\n  （2）根据设计思想，采用 C 或 C++语言描述算法，关键之处给出注释。 \n\n  （3）说明你所设计算法的时间复杂度和空间复杂度。\n\n  > (1)\n  >\n  > ①使用Dmin记录所有已处理的三元组的最小距离，初值为一个足够大的整数。\n  >\n  > ②集合S1、S2和S3分别保存在数组A、B、C中。数组的下标变量i=j=k=0,当i< |S1|、j< |S2|且k< |S3|时（|S|表示集合中的元素个数），循环执行下面的“a)~c)”。\n  >\n  > a)计算（A[i]，B[j]，C[k]）的距离D；（计算D）\n  >\n  > b)若D<Dmin，则Dmin=D；（更新D）\n  >\n  > c)将A[i]、B[j]、C[k]中的最小值的下标+1；\n  >\n  > ③输出Dmin，结束\n  >\n  > (2)算法实现\n  >\n  > ```C\n  > #define INT_MAX 0x7fffffff\n  > int abs_(int a){//计算绝对值\n  > \tif(a<0) return -a;\n  > \telse return a;\n  > }\n  > bool xls_min(int a,int b,int c){//a是否是三个数中的最小值\n  > \tif(a<=b&&a<=c) return true;\n  > \treturn false;\n  > }\n  > int findMinofTrip(int A[],int n,int B[],int m,int C[],int p){\n  > \t//D_min用于记录三元组的最小距离，处置赋为INT_MAX\n  > \tint i=0,j=0,k=0,D_min=INT_MAX,D;\n  > \twhile(i<n&&j<m&&k<p&&D_min>0){\n  > \t\tD=abs_(A[i]-B[j])+abs_(B[j]-C[k])+abs_(C[k]-A[i]);\n  > \t\tif(D<D_min) D_min=D;\n  > \t\tif(xls_min(A[i],B[j],C[k])) i++;\n  > \t\telse if(xls_min(B[j],C[k],A[i])) j++;\n  > \t\telse k++;\n  > \t}\n  > \treturn D_min;\n  > }\n  > \n  > ```\n  >\n  > (3)设n=(|S1|+|S2|+|S3|),时间复杂度为O(n)，空间复杂度为O(1)\n","tags":["408数据结构"],"categories":["408数据结构"]},{"title":"第一章 绪论","url":"/p/24523/","content":"\n## 1.1 数据结构的基本概念\n\n**解决问题方法的效率**\n\n- 跟数据的**组织方式**有关\n- 跟**空间的利用率**有关\n- 跟**算法的巧妙**程度有关\n\n什么是<font color='orange'>数据结构</font>？简单来说，数据结构就是一种*关系*。\n\n> Algorithm + Data Structures = Programs\n\n- **数据对象**在计算机中的组织方式\n  - 逻辑结构\n    - 线性、树、图...\n  - 物理存储结构\n    - 顺序存储、链式存储\n- 数据对象必定与一系列加在其上的**操作**相关联\n- 完成这些操作所用的方法就是**算法**\n\n### 基本概念和术语\n\n- **数据 Data**:数据是<font color='orange'>信息的载体</font>，是描述客观事物属性的数、字符及所有能输入到计算机中并<font color='orange'>被计算机程序识别和处理</font>的符合的集合。数据是计算机程序加工的原料。\n\n- **数据元素 Data Element**:数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。\n\n- **数据项 Data Item**:一个数据元素可由若干<font color='orange'>数据项</font>组成，数据项是构成数据元素的不可分割的最小单位。\n\n- **数据对象 Data Object**:数据对象是具有<font color='red'>相同性质</font>的数据元素的集合，是数据的一个子集。\n\n- **数据类型 Data Type**:数据类型是一个值的集合和定义在此集合的一组操作的总称。\n\n  - **原子类型**。其值不可再分的数据类型。\n\n  - **结构类型**。其值可用再分解为若干成分的数据类型\n\n  - <font color='red'>抽象数据类型</font>。抽象数据组织及与之相关的操作。\n\n    描述数据类型的方法不依赖于具体实现\n\n    - 与存放数据的机器无关\n    - 与数据存储的物理结构无关\n    - 与实现操作的算法和编程语言均无关\n\n    只描述数据对象集和相关操作集 **是什么**，并不涉及 **如何做到** 的问题\n\n    例:**矩阵** 的抽象数据类型的定义\n\n    - **类型名称**:矩阵（ Matrix ）\n\n    - **数据对象集**:一个 M×N的矩阵 \n\n      <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds1-1.png\" style=\"zoom:80%;\" />\n\n      由 M×N 个三元组 <a,i,j> 构成，其中 a 是矩阵元素的值，i 是元素所在的行号，j 是元素所在的列号。\n\n    - **操作集**:对于任意矩阵A、B、C ∈ Matrix，以及整数i、j、M、N\n\n      - `Matrix Create(int M, int N)`：返回一个 M×N 的矩阵；\n      - `int GetMaxRow(Matrix A)`：返回矩阵 A 的总行数；\n      - `int GetMaxCol(Matrix A)`：返回矩阵 A 的总列数；\n      - `ElementType GetEntry(Matrix A, int i, int j)`：返回矩阵 A 的第 i 行、第 j 列元素；\n      - `Matrix Add(Matrix A, Matrix B)`：如果 A 和 B 的行、列数一致，则返回矩阵 C=A+B ，否则返回错误标志；\n      - `Matrix Multiply(Matrix A, Matrix B)`：如果 A 的列数等于 B 的行数，则返回矩阵 C = AB ，否则返回错误标志；\n      - ......\n\n- **数据结构 Data Structure** :数据结构是相互之间存在一种或多种<font color='red'>特定关系</font>的数据元素的集合。\n\n### 数据结构三要素\n\n- 数据的**逻辑结构**\n  **集合**:结构中的数据元素之间除\"同属一个集合\"外，别无其他关系\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds1-2.png\" style=\"zoom:67%;\" />\n\n  - **线性结构**:数据元素只存在一对一的关系。除了第一个元素，所有元素都有唯一前驱；\n\n    除了最后一个元素，所有元素都有唯一后继。\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds1-3.png\" style=\"zoom:67%;\" />\n\n  - **树形结构**:数据元素之间存在一对多的关系。\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds1-4.png\" style=\"zoom:67%;\" />\n\n  - **图状/网状结构** :数据元素之间是多对多的关系\n\n    <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds1-5.png\" style=\"zoom:67%;\" />\n\n- 数据的**存储结构**\n\n  存储结构是指数据结构在计算机中的表示(又称映像)，也称**物理结构**。\n\n  - **顺序存储**:把<font color='red'>逻辑上相邻的元素存储在物理位置上也相邻的存储单元中</font>，元素之间的关系由存储单元的邻接关系来体现。\n\n    - 连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示。\n    - 优点:可以实现随机存取，每个元素占用最少的存储空间\n  - 缺点:只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片\n  - **链式存储**:<font color='red'>逻辑上相邻的元素在物理位置上可以不相邻</font>，借助指示元素存储地址的指针来表示元素之间的逻辑关系。\n    - 用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示。\n    - 优点:不会出现碎片现象，能充分利用所有存储单元\n    - 缺点:每个元素因存储指针而占用额外的存储空间。且只能实现顺序存取\n  - **索引存储**:在存储元素信息的同时，还建立附加的索引表。索引表的每项称为**索引项**，索引项的一般形式是(关键字，地址)\n    - 优点:检索速度快\n    - 缺点:附加的索引表额外占用存储空间。另外，增加和删除数据时也要修改索引表，因而会花费较多的时间。\n  - **散列存储 / 哈希存储**:根据元素的关键字之间直接计算出该元素的存储地址。\n    - 优点:检索、增加和删除结点的操作都很快；\n    - 缺点:若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds1-6.png\" style=\"zoom:67%;\" />\n\n- 数据的**运算**:施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。\n\n### 习题\n\n\"Algorithm + Data Structures = Programs.\" 是什么意思？谁说的？😉\n\n“算法 + 数据结构 = 程序” by 尼古拉斯·沃斯\n\n## 1.2 算法和算法平均\n\n### 算法的基本概念\n\n- 什么是算法?\n\n  - 一个有限指令集\n  - 接受一些输入（有些情况下不需要输入）\n  - 产生输出\n  - 一定在有限步骤之后终止\n  - 每一条指令必须\n    - 有充分明确的目标，不可以有歧义\n    - 计算机能处理的范围之内\n    - 描述应不依赖于任何一种计算机语言以及具体的实现手段\n\n- 重要特性\n\n  - 有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在又穷时间内完成。\n\n    注:**算法**必须是有穷的，而**程序**可用是无穷的\n\n  - 确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。\n\n  - 可行性：算法中描述的操作都可以通过已经实现的**基本运算执行有限次**来实现\n\n  - 输入：一个算法有零个或多个输入，这些输入取自某个特定的对象的集合。\n\n  - 输出：一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。\n\n### \"好\"算法的特征\n\n设计算法时要<font color='red'>尽量追求</font>的目标\n\n- 正确性 Correctness。正确地解决求解问题。\n- 可读性 Readability。具有良好可读性，帮助人们理解。\n- 健壮性 Robustness。输入非法数据时，适当做出反应或处理，不会产生莫名其妙的输出\n- 效率与低存储量需求 Efficiency。时间复杂度低、空间复杂度低\n\n### 算法效率的度量 🤩\n\n#### [一文讲透复杂度的计算方式](https://www.cnblogs.com/lonely-wolf/p/15674526.html)\n\n#### 时间复杂度 [Time Complex](https://en.wikipedia.org/wiki/Time_complexity)\n\n- 定义：\n  $$\n  T(n) = O(f(n))\n  $$\n   算法的基本操作执行次数还随问题的 输入数据集的不同而不同 \n\n- 最坏时间复杂度 =Tworst(n)\n\n- 平均时间复杂度Tavg(n)\n\n- **关系**:Tavg(n)<=Tworst(n)\n\n- 最好时间复杂度 \n\n- **加法规则**:**多项相加，只保留最高阶的项，且系数变为1**\n\n\n$$\nT(n) = T_1(n)+T_2(n) = O(f(n))+O(g(n)) = O(\\max(f(n),g(n)))\n$$\n\n  - 乘法规则\n\n\n$$\nT(n) = T_1(n)\\times T_2(n)=O(f(n))\\times O(g(n)) = O(f(n)\\times g(n))\n$$\n\n- 只需挑循环中的一个基本操作分析它的执行次数与n的关系即可，如果有多层嵌套循环，只需关注最深层的循环循环了几次\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds1-7.png\" style=\"zoom:67%;\" />\n\n  | 表达式 | 时间复杂度 |\n  | --- | :-: |\n  | T1(n) = 3n+3            | T1(n) = O(n)    |\n  | T2(n) = n² + 3n + 1000  | T2(n) = O(n²)   |\n  | T3(n) = n3 + n2 + 99999 | T3(n) = O(n3)   |\n  | T4(n) = n3 + n2log2n    | T4(n) = O( n3 ) |\n\n- 常见的渐进时间复杂度为:**常对幂指阶**\n  $$\n  O(1) < O(\\log_2n)<O(n)<O(n \\log_2n)<O(n^2)<O(n^3)<O(n^k)<O(n!)<O(n^n)\n  $$\n\n- **来一道练习题**\n\n  计算下述算法的时间复杂度T(n)\n\n  ```C\n  void loveYou(int n){\n      int i=1;\n      while(i<=n){\n          i=i*2;\n          printf(\"I Love U %d\\n\",i);\n      }  \n  }\n  ```\n\n  |       | 第一次循环 | 第二次循环 | 第三次循环 | …    | 第x次循环 |\n  | ----- | ---------- | ---------- | ---------- | ---- | --------- |\n  | i = 1 | i = 2      | i = 4      | i = 8      | …    | i = 2x    |\n\n  设最深层总共循环的次数为x，则循环了x次之后，i = 2^x，循环结束的条件为 i > n，即 \n  $$\n  2^x > n ，x = log_2n + 1\n  $$\n\n  $$\n  T(n) = O(x) = O(log_2n) + O(1) = O(log_2n)\n  $$\n\n  \n\n#### 空间复杂度 [Space Complexity](https://en.wikipedia.org/wiki/Space_complexity)\n\n- 定义:空间复杂度：空间开销与问题规模n之间的关系\n\n$$\nS(n) = O(g(n))\n$$\n\n- 算法原地工作是指算法所需的辅助空间为常量，即`O(1)`\n\n示例：如何实现数组逆序？\n方案一：空间复杂度为 1 的情况，即S(n) = O(1)\n\n```cpp\nfor(i = 0; i < n / 2；i++) // 遍历半个数组\n{\n\tt = a[i];              // 临时变量t\n\ta[i] = a[n-i-1];       // 交换数值\n\ta[n-i-1] = t;\n}\n```\n\n方案二：空间复杂度为 n 的情况，即S(n) = O(n)\n\n```cpp\nfor(i = 0; i < n； i++)  // 辅助数组b逆序存储a\n\tb[i] = a[n-i-1];\nfor(i = 0; i < n, i++)   // 重新赋值给a\n\ta[i] = b[i];\n```\n\n### 习题\n\n【2011】设n是描述问题规模的非负整数。下面的程序片段的时间复杂度是()\n\n```c\nx=2;\nwhile(x<n/2)\nx=2*x;\n```\n\n$$\n答案:O(\\log_2n)\n$$\n\n> 执行O（n）次，则2的O（n）次方大于等于n/2时结束，因为x为2，所以每执行一次，等于自己多做一次幂运算，复杂度为log₂n\n\n【2012】求整数n(n>0)的阶乘的算法如下,其时间复杂度\n\n```c\nint fact(int n){\n  if(n<=1) return 1;\n  return n*fact(n-1);\n}\n```\n\n$$\n答案:O(n)\n$$\n\n> 递推公式T(n)=1+T(n-1),求出T(n)=n\n\n【2013】已知两个长度分别为m和n的升序链表，若将它们合并为长度为m+n的一个降序链表，则最坏情况下的时间复杂度是\n$$\nO(max(m,n))\n$$\n\n> 两个升序链表合并，两两比较表中元素，每比较一次，确定一个元素的链接位置(取较小元素，头插法)。当一个链表比较结束后，将另一个链表的剩余元素插入即可。最坏的情况是两个链表中的元素依次进行比较，因为2max(m,n)>=m+n,所以时间复杂度为O(max(m,n))。\n>\n> [CSDN解析](https://blog.csdn.net/weixin_43722052/article/details/116133058)\n\n【2014】下列程序段的时间复杂度是\n\n```c\ncount=0;\nfor(k=1;k<=n;k*=2)\n   for(j=1;j<=n;j++)\n      count++;\n```\n\n$$\nO(n\\log_2n)\n$$\n\n> 内层循环条件j<=n与外层循环的变量无关，每次循环j自增1，每次内层循环都执行n次。外层循环条件为k<=n，增量定义为k*=2，可知循环次数为2^k<=n，即k<=log₂n。所以内层循环的时间复杂度是O(n)，外层循环的时间复杂度是O(log₂n)。对于嵌套循环，根据乘法规则可知，该段程序的时间复杂度T(n)=T1(n)xT2(n)=O(n)xO(log₂n)=O(nlog₂n)\n\n【2017】下列函数的时间复杂度是\n\n```c\nint func(int n){\n  int i=0, sum=0;\n  while(sum<n) sum+= ++i;\n  return i;\n}\n```\n\n$$\nO(n^\\frac{1}{2})\n$$\n\n> sum += ++i; 相当于++i; sum = sum + i;进行到第k趟循环，sum = (1 + k)*k/2。显然需要进行O(n½)趟循环，因此这也是该函数的时间复杂度。\n\n 「算法原地工作的含义是指不需要任何额外的辅助空间」→ 错误\n\n> 算法原地工作的含义是指辅助空间是常量\n\n【2019】设n是描述问题规模的非负整数。下列程序段的时间复杂度是\n\n```c\nx=0;\nwhile (n>(x+1)*(x+1))\nx=x+1；\n```\n\n$$\nO(n^\\frac{1}{2})\n$$\n\n**综合题** 一个算法所需时间由下述递归方程表示，试求出该算法的时间复杂度的级别（或阶）\n$$\nT(n) = \\begin{cases} 1, & n=1 \\\\ 2T(n/2)+n, & n>1 \\end{cases}\n$$\n\n式中，n 是问题的规模，为简单起见，设 n 是 2 的整数次幂 →\n$$\nO(n\\log_2n)\n$$\n\n> T(n)=2T(n/2)+n\n>\n> 两边同时除以n，得到\n>\n> T(n)/n=T(n/2)/(n/2)+1    ①\n>\n> T(n/2)/(n/2)= T(n/4)/(n/4)+1 ②\n>\n> …………\n>\n> T(2)/2=T(1)/1+1 (log₂n)\n>\n> 注：因为每次式子的变化都是除以2变化的，所以式子的个数是log~2~n\n>\n> 将下面的式子都代入到式子①中可以得到\n>\n> T(n)/n=T(1)/1+1*log₂n\n>\n> T(n)=n(T(1)/1+1*log₂n)\n>\n> T(1)=1\n>\n> 所以T(n)=n(1+log₂n)\n>\n> 所以O(n)=nlog₂n\n\n思考：斐波那契数列，用递归算法和非递归算法的时间复杂度如何？😜\n\n- 递归算法\n  $$\n  O(2^n)\n  $$\n\n- 非递归算法\n  $$\n  O(n)\n  $$\n","tags":["408数据结构"],"categories":["408数据结构"]}]