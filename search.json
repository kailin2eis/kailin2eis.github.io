[{"title":"第一章 绪论","url":"/p/24523/","content":"<h2 id=\"1-1-数据结构的基本概念\"><a href=\"#1-1-数据结构的基本概念\" class=\"headerlink\" title=\"1.1 数据结构的基本概念\"></a>1.1 数据结构的基本概念</h2><p><strong>解决问题方法的效率</strong></p>\n<ul>\n<li>跟数据的<strong>组织方式</strong>有关</li>\n<li>跟<strong>空间的利用率</strong>有关</li>\n<li>跟<strong>算法的巧妙</strong>程度有关</li>\n</ul>\n<p>什么是<font color='orange'>数据结构</font>？简单来说，数据结构就是一种<em>关系</em>。</p>\n<blockquote>\n<p>Algorithm + Data Structures = Programs</p>\n</blockquote>\n<ul>\n<li><strong>数据对象</strong>在计算机中的组织方式<ul>\n<li>逻辑结构<ul>\n<li>线性、树、图…</li>\n</ul>\n</li>\n<li>物理存储结构<ul>\n<li>顺序存储、链式存储</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>数据对象必定与一系列加在其上的<strong>操作</strong>相关联</li>\n<li>完成这些操作所用的方法就是<strong>算法</strong></li>\n</ul>\n<h3 id=\"基本概念和术语\"><a href=\"#基本概念和术语\" class=\"headerlink\" title=\"基本概念和术语\"></a>基本概念和术语</h3><ul>\n<li><p><strong>数据 Data</strong>:数据是<font color='orange'>信息的载体</font>，是描述客观事物属性的数、字符及所有能输入到计算机中并<font color='orange'>被计算机程序识别和处理</font>的符合的集合。数据是计算机程序加工的原料。</p>\n</li>\n<li><p><strong>数据元素 Data Element</strong>:数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。</p>\n</li>\n<li><p><strong>数据项 Data Item</strong>:一个数据元素可由若干<font color='orange'>数据项</font>组成，数据项是构成数据元素的不可分割的最小单位。</p>\n</li>\n<li><p><strong>数据对象 Data Object</strong>:数据对象是具有<font color='red'>相同性质</font>的数据元素的集合，是数据的一个子集。</p>\n</li>\n<li><p><strong>数据类型 Data Type</strong>:数据类型是一个值的集合和定义在此集合的一组操作的总称。</p>\n<ul>\n<li><p><strong>原子类型</strong>。其值不可再分的数据类型。</p>\n</li>\n<li><p><strong>结构类型</strong>。其值可用再分解为若干成分的数据类型</p>\n</li>\n<li><p><font color='red'>抽象数据类型</font>。抽象数据组织及与之相关的操作。</p>\n<p>描述数据类型的方法不依赖于具体实现</p>\n<ul>\n<li>与存放数据的机器无关</li>\n<li>与数据存储的物理结构无关</li>\n<li>与实现操作的算法和编程语言均无关</li>\n</ul>\n<p>只描述数据对象集和相关操作集 <strong>是什么</strong>，并不涉及 <strong>如何做到</strong> 的问题</p>\n<p>例:<strong>矩阵</strong> 的抽象数据类型的定义</p>\n<ul>\n<li><p><strong>类型名称</strong>:矩阵（ Matrix ）</p>\n</li>\n<li><p><strong>数据对象集</strong>:一个 M×N的矩阵 </p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds1-1.png\" style=\"zoom:80%;\" />\n\n<p>由 M×N 个三元组 &lt;a,i,j&gt; 构成，其中 a 是矩阵元素的值，i 是元素所在的行号，j 是元素所在的列号。</p>\n</li>\n<li><p><strong>操作集</strong>:对于任意矩阵A、B、C ∈ Matrix，以及整数i、j、M、N</p>\n<ul>\n<li><code>Matrix Create(int M, int N)</code>：返回一个 M×N 的矩阵；</li>\n<li><code>int GetMaxRow(Matrix A)</code>：返回矩阵 A 的总行数；</li>\n<li><code>int GetMaxCol(Matrix A)</code>：返回矩阵 A 的总列数；</li>\n<li><code>ElementType GetEntry(Matrix A, int i, int j)</code>：返回矩阵 A 的第 i 行、第 j 列元素；</li>\n<li><code>Matrix Add(Matrix A, Matrix B)</code>：如果 A 和 B 的行、列数一致，则返回矩阵 C=A+B ，否则返回错误标志；</li>\n<li><code>Matrix Multiply(Matrix A, Matrix B)</code>：如果 A 的列数等于 B 的行数，则返回矩阵 C = AB ，否则返回错误标志；</li>\n<li>……</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>数据结构 Data Structure</strong> :数据结构是相互之间存在一种或多种<font color='red'>特定关系</font>的数据元素的集合。</p>\n</li>\n</ul>\n<h3 id=\"数据结构三要素\"><a href=\"#数据结构三要素\" class=\"headerlink\" title=\"数据结构三要素\"></a>数据结构三要素</h3><ul>\n<li><p>数据的<strong>逻辑结构</strong><br><strong>集合</strong>:结构中的数据元素之间除”同属一个集合”外，别无其他关系</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds1-2.png\" style=\"zoom:67%;\" />\n\n<ul>\n<li><p><strong>线性结构</strong>:数据元素只存在一对一的关系。除了第一个元素，所有元素都有唯一前驱；</p>\n<p>除了最后一个元素，所有元素都有唯一后继。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds1-3.png\" style=\"zoom:67%;\" /></li>\n<li><p><strong>树形结构</strong>:数据元素之间存在一对多的关系。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds1-4.png\" style=\"zoom:67%;\" /></li>\n<li><p><strong>图状/网状结构</strong> :数据元素之间是多对多的关系</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds1-5.png\" style=\"zoom:67%;\" /></li>\n</ul>\n</li>\n<li><p>数据的<strong>存储结构</strong></p>\n<p>存储结构是指数据结构在计算机中的表示(又称映像)，也称<strong>物理结构</strong>。</p>\n<ul>\n<li><p><strong>顺序存储</strong>:把<font color='red'>逻辑上相邻的元素存储在物理位置上也相邻的存储单元中</font>，元素之间的关系由存储单元的邻接关系来体现。</p>\n<ul>\n<li>连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示。</li>\n<li>优点:可以实现随机存取，每个元素占用最少的存储空间</li>\n</ul>\n</li>\n<li><p>缺点:只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片</p>\n</li>\n<li><p><strong>链式存储</strong>:<font color='red'>逻辑上相邻的元素在物理位置上可以不相邻</font>，借助指示元素存储地址的指针来表示元素之间的逻辑关系。</p>\n<ul>\n<li>用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示。</li>\n<li>优点:不会出现碎片现象，能充分利用所有存储单元</li>\n<li>缺点:每个元素因存储指针而占用额外的存储空间。且只能实现顺序存取</li>\n</ul>\n</li>\n<li><p><strong>索引存储</strong>:在存储元素信息的同时，还建立附加的索引表。索引表的每项称为<strong>索引项</strong>，索引项的一般形式是(关键字，地址)</p>\n<ul>\n<li>优点:检索速度快</li>\n<li>缺点:附加的索引表额外占用存储空间。另外，增加和删除数据时也要修改索引表，因而会花费较多的时间。</li>\n</ul>\n</li>\n<li><p><strong>散列存储 / 哈希存储</strong>:根据元素的关键字之间直接计算出该元素的存储地址。</p>\n<ul>\n<li>优点:检索、增加和删除结点的操作都很快；</li>\n<li>缺点:若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds1-6.png\" style=\"zoom:67%;\" /></li>\n<li><p>数据的<strong>运算</strong>:施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。</p>\n</li>\n</ul>\n<h3 id=\"习题\"><a href=\"#习题\" class=\"headerlink\" title=\"习题\"></a>习题</h3><p>“Algorithm + Data Structures = Programs.” 是什么意思？谁说的？😉</p>\n<p>“算法 + 数据结构 = 程序” by 尼古拉斯·沃斯</p>\n<h2 id=\"1-2-算法和算法平均\"><a href=\"#1-2-算法和算法平均\" class=\"headerlink\" title=\"1.2 算法和算法平均\"></a>1.2 算法和算法平均</h2><h3 id=\"算法的基本概念\"><a href=\"#算法的基本概念\" class=\"headerlink\" title=\"算法的基本概念\"></a>算法的基本概念</h3><ul>\n<li><p>什么是算法?</p>\n<ul>\n<li>一个有限指令集</li>\n<li>接受一些输入（有些情况下不需要输入）</li>\n<li>产生输出</li>\n<li>一定在有限步骤之后终止</li>\n<li>每一条指令必须<ul>\n<li>有充分明确的目标，不可以有歧义</li>\n<li>计算机能处理的范围之内</li>\n<li>描述应不依赖于任何一种计算机语言以及具体的实现手段</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>重要特性</p>\n<ul>\n<li><p>有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在又穷时间内完成。</p>\n<p>注:<strong>算法</strong>必须是有穷的，而<strong>程序</strong>可用是无穷的</p>\n</li>\n<li><p>确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。</p>\n</li>\n<li><p>可行性：算法中描述的操作都可以通过已经实现的<strong>基本运算执行有限次</strong>来实现</p>\n</li>\n<li><p>输入：一个算法有零个或多个输入，这些输入取自某个特定的对象的集合。</p>\n</li>\n<li><p>输出：一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"“好”算法的特征\"><a href=\"#“好”算法的特征\" class=\"headerlink\" title=\"“好”算法的特征\"></a>“好”算法的特征</h3><p>设计算法时要<font color='red'>尽量追求</font>的目标</p>\n<ul>\n<li>正确性 Correctness。正确地解决求解问题。</li>\n<li>可读性 Readability。具有良好可读性，帮助人们理解。</li>\n<li>健壮性 Robustness。输入非法数据时，适当做出反应或处理，不会产生莫名其妙的输出</li>\n<li>效率与低存储量需求 Efficiency。时间复杂度低、空间复杂度低</li>\n</ul>\n<h3 id=\"算法效率的度量-🤩\"><a href=\"#算法效率的度量-🤩\" class=\"headerlink\" title=\"算法效率的度量 🤩\"></a>算法效率的度量 🤩</h3><h4 id=\"一文讲透复杂度的计算方式\"><a href=\"#一文讲透复杂度的计算方式\" class=\"headerlink\" title=\"一文讲透复杂度的计算方式\"></a><a href=\"https://www.cnblogs.com/lonely-wolf/p/15674526.html\">一文讲透复杂度的计算方式</a></h4><h4 id=\"时间复杂度-Time-Complex\"><a href=\"#时间复杂度-Time-Complex\" class=\"headerlink\" title=\"时间复杂度 Time Complex\"></a>时间复杂度 <a href=\"https://en.wikipedia.org/wiki/Time_complexity\">Time Complex</a></h4><ul>\n<li><p>定义：<br>$$<br>T(n) = O(f(n))<br>$$<br> 算法的基本操作执行次数还随问题的 输入数据集的不同而不同 </p>\n</li>\n<li><p>最坏时间复杂度 =Tworst(n)</p>\n</li>\n<li><p>平均时间复杂度Tavg(n)</p>\n</li>\n<li><p><strong>关系</strong>:Tavg(n)&lt;=Tworst(n)</p>\n</li>\n<li><p>最好时间复杂度 </p>\n</li>\n<li><p><strong>加法规则</strong>:<strong>多项相加，只保留最高阶的项，且系数变为1</strong></p>\n</li>\n</ul>\n<p>$$<br>T(n) = T_1(n)+T_2(n) = O(f(n))+O(g(n)) = O(\\max(f(n),g(n)))<br>$$</p>\n<ul>\n<li>乘法规则</li>\n</ul>\n<p>$$<br>T(n) = T_1(n)\\times T_2(n)=O(f(n))\\times O(g(n)) = O(f(n)\\times g(n))<br>$$</p>\n<ul>\n<li><p>只需挑循环中的一个基本操作分析它的执行次数与n的关系即可，如果有多层嵌套循环，只需关注最深层的循环循环了几次</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds1-7.png\" style=\"zoom:67%;\" />\n\n<table>\n<thead>\n<tr>\n<th>表达式</th>\n<th align=\"center\">时间复杂度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>T1(n) = 3n+3</td>\n<td align=\"center\">T1(n) = O(n)</td>\n</tr>\n<tr>\n<td>T2(n) = n² + 3n + 1000</td>\n<td align=\"center\">T2(n) = O(n²)</td>\n</tr>\n<tr>\n<td>T3(n) = n3 + n2 + 99999</td>\n<td align=\"center\">T3(n) = O(n3)</td>\n</tr>\n<tr>\n<td>T4(n) = n3 + n2log2n</td>\n<td align=\"center\">T4(n) = O( n3 )</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>常见的渐进时间复杂度为:<strong>常对幂指阶</strong><br>$$<br>O(1) &lt; O(\\log_2n)&lt;O(n)&lt;O(n \\log_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(n^k)&lt;O(n!)&lt;O(n^n)<br>$$</p>\n</li>\n<li><p><strong>来一道练习题</strong></p>\n<p>计算下述算法的时间复杂度T(n)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">loveYou</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&lt;=n)&#123;</span><br><span class=\"line\">        i=i*<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;I Love U %d\\n&quot;</span>,i);</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th></th>\n<th>第一次循环</th>\n<th>第二次循环</th>\n<th>第三次循环</th>\n<th>…</th>\n<th>第x次循环</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>i = 1</td>\n<td>i = 2</td>\n<td>i = 4</td>\n<td>i = 8</td>\n<td>…</td>\n<td>i = 2x</td>\n</tr>\n</tbody></table>\n<p>设最深层总共循环的次数为x，则循环了x次之后，i = 2^x，循环结束的条件为 i &gt; n，即<br>$$<br>2^x &gt; n ，x = log_2n + 1<br>$$</p>\n<p>$$<br>T(n) = O(x) = O(log_2n) + O(1) = O(log_2n)<br>$$</p>\n</li>\n</ul>\n<h4 id=\"空间复杂度-Space-Complexity\"><a href=\"#空间复杂度-Space-Complexity\" class=\"headerlink\" title=\"空间复杂度 Space Complexity\"></a>空间复杂度 <a href=\"https://en.wikipedia.org/wiki/Space_complexity\">Space Complexity</a></h4><ul>\n<li>定义:空间复杂度：空间开销与问题规模n之间的关系</li>\n</ul>\n<p>$$<br>S(n) = O(g(n))<br>$$</p>\n<ul>\n<li>算法原地工作是指算法所需的辅助空间为常量，即<code>O(1)</code></li>\n</ul>\n<p>示例：如何实现数组逆序？<br>方案一：空间复杂度为 1 的情况，即S(n) = O(1)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n / <span class=\"number\">2</span>；i++) <span class=\"comment\">// 遍历半个数组</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tt = a[i];              <span class=\"comment\">// 临时变量t</span></span><br><span class=\"line\">\ta[i] = a[n-i<span class=\"number\">-1</span>];       <span class=\"comment\">// 交换数值</span></span><br><span class=\"line\">\ta[n-i<span class=\"number\">-1</span>] = t;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方案二：空间复杂度为 n 的情况，即S(n) = O(n)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n； i++)  <span class=\"comment\">// 辅助数组b逆序存储a</span></span><br><span class=\"line\">\tb[i] = a[n-i<span class=\"number\">-1</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n, i++)   <span class=\"comment\">// 重新赋值给a</span></span><br><span class=\"line\">\ta[i] = b[i];</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"习题-1\"><a href=\"#习题-1\" class=\"headerlink\" title=\"习题\"></a>习题</h3><p>【2011】设n是描述问题规模的非负整数。下面的程序片段的时间复杂度是()</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">x=<span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(x&lt;n/<span class=\"number\">2</span>)</span><br><span class=\"line\">x=<span class=\"number\">2</span>*x;</span><br></pre></td></tr></table></figure>\n\n<p>$$<br>答案:O(\\log_2n)<br>$$</p>\n<blockquote>\n<p>执行O（n）次，则2的O（n）次方大于等于n/2时结束，因为x为2，所以每执行一次，等于自己多做一次幂运算，复杂度为log₂n</p>\n</blockquote>\n<p>【2012】求整数n(n&gt;0)的阶乘的算法如下,其时间复杂度</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">fact</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(n&lt;=<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n*fact(n<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>$$<br>答案:O(n)<br>$$</p>\n<blockquote>\n<p>递推公式T(n)=1+T(n-1),求出T(n)=n</p>\n</blockquote>\n<p>【2013】已知两个长度分别为m和n的升序链表，若将它们合并为长度为m+n的一个降序链表，则最坏情况下的时间复杂度是<br>$$<br>O(max(m,n))<br>$$</p>\n<blockquote>\n<p>两个升序链表合并，两两比较表中元素，每比较一次，确定一个元素的链接位置(取较小元素，头插法)。当一个链表比较结束后，将另一个链表的剩余元素插入即可。最坏的情况是两个链表中的元素依次进行比较，因为2max(m,n)&gt;=m+n,所以时间复杂度为O(max(m,n))。</p>\n<p><a href=\"https://blog.csdn.net/weixin_43722052/article/details/116133058\">CSDN解析</a></p>\n</blockquote>\n<p>【2014】下列程序段的时间复杂度是</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">count=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(k=<span class=\"number\">1</span>;k&lt;=n;k*=<span class=\"number\">2</span>)</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">      count++;</span><br></pre></td></tr></table></figure>\n\n<p>$$<br>O(n\\log_2n)<br>$$</p>\n<blockquote>\n<p>内层循环条件j&lt;=n与外层循环的变量无关，每次循环j自增1，每次内层循环都执行n次。外层循环条件为k&lt;=n，增量定义为k*=2，可知循环次数为2^k&lt;=n，即k&lt;=log₂n。所以内层循环的时间复杂度是O(n)，外层循环的时间复杂度是O(log₂n)。对于嵌套循环，根据乘法规则可知，该段程序的时间复杂度T(n)=T1(n)xT2(n)=O(n)xO(log₂n)=O(nlog₂n)</p>\n</blockquote>\n<p>【2017】下列函数的时间复杂度是</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">func</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> i=<span class=\"number\">0</span>, sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(sum&lt;n) sum+= ++i;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>$$<br>O(n^\\frac{1}{2})<br>$$</p>\n<blockquote>\n<p>sum += ++i; 相当于++i; sum = sum + i;进行到第k趟循环，sum = (1 + k)*k/2。显然需要进行O(n½)趟循环，因此这也是该函数的时间复杂度。</p>\n</blockquote>\n<p> 「算法原地工作的含义是指不需要任何额外的辅助空间」→ 错误</p>\n<blockquote>\n<p>算法原地工作的含义是指辅助空间是常量</p>\n</blockquote>\n<p>【2019】设n是描述问题规模的非负整数。下列程序段的时间复杂度是</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">x=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (n&gt;(x+<span class=\"number\">1</span>)*(x+<span class=\"number\">1</span>))</span><br><span class=\"line\">x=x+<span class=\"number\">1</span>；</span><br></pre></td></tr></table></figure>\n\n<p>$$<br>O(n^\\frac{1}{2})<br>$$</p>\n<p><strong>综合题</strong> 一个算法所需时间由下述递归方程表示，试求出该算法的时间复杂度的级别（或阶）<br>$$<br>T(n) = \\begin{cases} 1, &amp; n=1 \\ 2T(n/2)+n, &amp; n&gt;1 \\end{cases}<br>$$</p>\n<p>式中，n 是问题的规模，为简单起见，设 n 是 2 的整数次幂 →<br>$$<br>O(n\\log_2n)<br>$$</p>\n<blockquote>\n<p>T(n)=2T(n/2)+n</p>\n<p>两边同时除以n，得到</p>\n<p>T(n)/n=T(n/2)/(n/2)+1    ①</p>\n<p>T(n/2)/(n/2)= T(n/4)/(n/4)+1 ②</p>\n<p>…………</p>\n<p>T(2)/2=T(1)/1+1 (log₂n)</p>\n<p>注：因为每次式子的变化都是除以2变化的，所以式子的个数是log<del>2</del>n</p>\n<p>将下面的式子都代入到式子①中可以得到</p>\n<p>T(n)/n=T(1)/1+1*log₂n</p>\n<p>T(n)=n(T(1)/1+1*log₂n)</p>\n<p>T(1)=1</p>\n<p>所以T(n)=n(1+log₂n)</p>\n<p>所以O(n)=nlog₂n</p>\n</blockquote>\n<p>思考：斐波那契数列，用递归算法和非递归算法的时间复杂度如何？😜</p>\n<ul>\n<li><p>递归算法<br>$$<br>O(2^n)<br>$$</p>\n</li>\n<li><p>非递归算法<br>$$<br>O(n)<br>$$</p>\n</li>\n</ul>\n","categories":["408数据结构"],"tags":["408数据结构"]},{"title":"第二章 线性表(上)","url":"/p/14457/","content":"<h2 id=\"2-1-线性表的定义和基本操作\"><a href=\"#2-1-线性表的定义和基本操作\" class=\"headerlink\" title=\"2.1 线性表的定义和基本操作\"></a>2.1 线性表的定义和基本操作</h2><h3 id=\"什是线性表？🤔\"><a href=\"#什是线性表？🤔\" class=\"headerlink\" title=\"什是线性表？🤔\"></a>什是线性表？🤔</h3><p><strong>有点像函数</strong></p>\n<p>函数：一个 x 值只能对应一个 y 值<br>线性表：一个索引值只能有一个映射值</p>\n<p><strong>定义</strong>:线性表是具有相同数据类型的 n(n≥0) 个<font color='orange'>数据元素</font>的有限序列，其中n为表长，当n-0时线性表是一个<font color='orange'>空表</font>。若用L命名线性表，则其一般表示为</p>\n<p>L=(a1,a2,…,ai,ai+1,…,an)</p>\n<p><strong>几个概念</strong>:</p>\n<ul>\n<li>ai是线性表的”第i个”元素线性表中的位序。</li>\n<li>a1是<font color='orange'>表头元素</font>；an是<font color='orange'>表尾元素</font>。</li>\n<li>除第一个元素外，每个元素有且<font color='orange'>仅有一个直接前驱</font>；除最后一个元素外，每个元素有且<font color='orange'>仅有一个直接后继</font></li>\n</ul>\n<p><strong>特点</strong>:</p>\n<ul>\n<li>表中元素<font color='orange'>个数有限</font></li>\n<li>表中元素具有逻辑上的顺序性，表中元素有其<font color='orange'>先后次序</font></li>\n<li>表中元素都是数据元素，每个元素都是单个元素</li>\n<li>表中元素的数据类型都相同，这意味着<font color='orange'>每个元素占有相同大小的存储空间</font></li>\n<li>表中元素具有抽象性 </li>\n</ul>\n<p><font color='red'>注</font>:线性表是一种<font color='red'>逻辑结构</font>，表示元素之间一对一的相邻关系。顺序表和链表是指<font color='red'>存储结构</font>，两者属于不同的层面概念，不要混淆</p>\n<h3 id=\"线性表的基本操作\"><a href=\"#线性表的基本操作\" class=\"headerlink\" title=\"线性表的基本操作\"></a>线性表的基本操作</h3><p>详细文档可以参考 c++容器<a href=\"https://cplusplus.com/reference/list/list/\">list 的相关函数</a></p>\n<p><a href=\"../code/2.1.list.cpp\">c++代码示例</a></p>\n<ul>\n<li><p>InitList(&amp;L) ：初始化表，构造一个空的线性表</p>\n</li>\n<li><p>DestroyList(&amp;L) ：销毁线性表</p>\n</li>\n<li><p>ClearList(&amp;L) ：清空线性表</p>\n</li>\n<li><p>ListEmpty(&amp;L) ：置空线性表</p>\n</li>\n<li><p>ListLength(L) ： 求线性表长度</p>\n</li>\n<li><p>GetElem(L, i, &amp;e) ： 获取元素</p>\n</li>\n<li><p>LocateElem(L, e, compare())</p>\n</li>\n<li><p>PriorElem(L, cur_e, &amp;pre_e) ： 获取元素的前驱</p>\n</li>\n<li><p>NextElem(L,cur_e,&amp;next_e) ： 获得元素的后继</p>\n</li>\n<li><p>ListInsert(&amp;L,i,e) ：插入操作</p>\n</li>\n<li><p>ListDelete(&amp;L,i,&amp;e) ：删除操作</p>\n</li>\n<li><p>ListTraverse(&amp;L, vistited()) ：遍历 </p>\n</li>\n</ul>\n<p>Tips：</p>\n<ul>\n<li>对数据的操作——无非就是创建、销毁；增、删、改、查。</li>\n<li>在描述基本操作的时候，并不指明具体的参数类型，而是一种抽象的接口定义。</li>\n<li>实际开发中，可根据实际需求定义其他的基本操作。</li>\n<li>函数名和参数的形式、命名都可改变。但是尽量具有可读性，写成上面这种就很好，都是很好的命名方式了。</li>\n<li><strong>什么时候要传入引用”&amp;“——对参数的修改结果需要”带回来“。即操作的是同一份实实在在的数据目标，而不能是一个拷贝的复制品。</strong></li>\n</ul>\n<p><strong>问题</strong>：为什么要实现对<strong>数据结构</strong>的基本操作？</p>\n<ul>\n<li>团队合作编程，你定义的数据结构要让别人能很方便地使用（封装）。</li>\n<li>将常用的操作/运算封装成函数，避免重复工作，降低出错风险。</li>\n</ul>\n<h2 id=\"2-2-线性表的顺序表示\"><a href=\"#2-2-线性表的顺序表示\" class=\"headerlink\" title=\"2.2 线性表的顺序表示\"></a>2.2 线性表的顺序表示</h2><h3 id=\"顺序表的定义-Sequence-List\"><a href=\"#顺序表的定义-Sequence-List\" class=\"headerlink\" title=\"顺序表的定义 Sequence List\"></a>顺序表的定义 Sequence List</h3><ul>\n<li><p><strong>顺序表</strong>–用顺序存储的方式实现线性表顺序存储。</p>\n</li>\n<li><p><strong>顺序存储</strong>–把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。</p>\n</li>\n<li><p>顺序表的<strong>特点</strong>:</p>\n<ul>\n<li>表中元素的逻辑顺序与其物理顺序相同。</li>\n<li><font color='orange'>随机访问</font>，即通过首地址和元素序号可在时间O(1)内找到指定的元素。</li>\n<li><font color='orange'>存储密度高</font>，每个结点只存储数据元素。它不像链表那样还需要存放一个指针域。</li>\n<li>拓展容量不方便。即使采用动态分配的方式实现，拓展长度的时间复杂度也比较高。</li>\n<li>插入、删除操作不方便，需要移动大量元素。</li>\n</ul>\n</li>\n<li><p>顺序表的实现</p>\n<ul>\n<li><p>静态分配</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 10;\t\t\t\t<span class=\"comment\">//定义最大长度</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    ElemType data[MaxSize];\t\t<span class=\"comment\">//用静态的&quot;数组&quot;存放数据元素</span></span><br><span class=\"line\">    <span class=\"type\">int</span> length;\t\t\t\t\t<span class=\"comment\">//顺序表的当前长度</span></span><br><span class=\"line\">&#125;SqList;\t\t\t\t\t\t<span class=\"comment\">//顺序表的类型定义(静态分配方式)</span></span><br></pre></td></tr></table></figure>\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-1.png\" style=\"zoom: 75%;\" />\n\n<p><strong>问题</strong>：如果“数组”存满了怎么办？</p>\n<ul>\n<li>可以放弃了，顺序表的表长刚开始确定后就无法更改（存储空间是静态的）</li>\n<li>如果刚开始就声明一个很大的内存空间呢？会很浪费空间。</li>\n</ul>\n</li>\n<li><p>动态分配</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 100;\t\t\t\t<span class=\"comment\">//定义最大长度</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    ElemType *data;\t\t\t\t<span class=\"comment\">//指针指向第一个数据元素</span></span><br><span class=\"line\">    <span class=\"type\">int</span> MaxSize;\t\t\t\t<span class=\"comment\">//顺序表的最大容量</span></span><br><span class=\"line\">    <span class=\"type\">int</span> length;\t\t\t\t\t<span class=\"comment\">//顺序表的当前长度</span></span><br><span class=\"line\">&#125;SeqList;\t\t\t\t\t\t<span class=\"comment\">//顺序表的类型定义(动态分配方式)</span></span><br></pre></td></tr></table></figure>\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-2.png\" style=\"zoom: 75%;\" /></li>\n<li><p>C 的初始动态分配语句–malloc、free函数</p>\n<p><code>L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize);</code></p>\n<p>malloc函数返回一个指针，需要强制转型为你定义的数据元素类型指针</p>\n<blockquote>\n<p>char * p = (char* ) malloc(sizeof(char)*10)；</p>\n<p>//申请了10个char长度的连续空间，不初始化且不知道是否申请成功</p>\n<p>if(NULL == p)</p>\n<p>return；//申请内存空间失败</p>\n</blockquote>\n</li>\n<li><p>C++的初始动态分配语句–new、delete关键字</p>\n<p><code>L.data = new ElemType[InitSize];</code></p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"顺序表上基本操作\"><a href=\"#顺序表上基本操作\" class=\"headerlink\" title=\"顺序表上基本操作\"></a>顺序表上基本操作</h3><ul>\n<li><p>插入操作</p>\n<ul>\n<li><p>最好情况：表尾插入(即i=n+1)，时间复杂度为O(1)</p>\n</li>\n<li><p>最坏情况：表头插入(即i=1)，时间复杂度为O(n)</p>\n</li>\n<li><p>平均情况：插入到任一位置的概率相同，即i=1,2,3,…,length+1的概率都是p=1/(n+1)。 i=1，循环n次；i=2时，循环n-1次；… i=n+1时，循环0次<br>$$<br>E_{ins} = \\frac 1{n+1} \\sum^{n+1}_{i=1}(n-i+1) = \\frac 1{n+1}(n+\\cdots + 1 + 0) = \\frac n2<br>$$<br> ，平均时间复杂度为O(n)</p>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ListInsert</span><span class=\"params\">(SqList &amp;L, <span class=\"type\">int</span> i, <span class=\"type\">int</span> e)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=L.length; j&gt;=i; j--)&#123;\t<span class=\"comment\">//将第i个元素及之后的元素后移 </span></span><br><span class=\"line\">\t\tL.data[j] = L.data[j<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tL.data[i<span class=\"number\">-1</span>] = e;\t<span class=\"comment\">//在位置i处放入e</span></span><br><span class=\"line\">\tL.length++;\t\t<span class=\"comment\">//长度加1 </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于插入操作，如果使用者传入了一个<strong>不合法的值</strong>，那么我们的程序应该可以给予相应的反馈。至少要反馈插入是成功，还是失败了吧。所以我们可以优化一下，如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 插入操作代码</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">ListInsert</span><span class=\"params\">(SqList &amp;L, <span class=\"type\">int</span> i, ElemType e)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">1</span> || i &gt; L.length + <span class=\"number\">1</span> )          <span class=\"comment\">// 判断i的范围是否有效</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (L.length &gt;= MAXSIZE)            <span class=\"comment\">// 当前存储空间已满</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = L.length ; j &gt;= i ; j--)</span><br><span class=\"line\">        L.data[j] = L.data[j - <span class=\"number\">1</span>];           <span class=\"comment\">// 插入位置及之后位置后移</span></span><br><span class=\"line\">    L.data[i - <span class=\"number\">1</span>] = e;                       <span class=\"comment\">// 将新元素放入第i个位置</span></span><br><span class=\"line\">    L.length++;                              <span class=\"comment\">//表长增加1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-51.png\" style=\"zoom: 75%;\" /></li>\n<li><p>删除操作</p>\n<ul>\n<li><p>最好情况：删除表尾元素(即i=n)，时间复杂度为O(1)</p>\n</li>\n<li><p>最坏情况：删除表头元素(即i=1)，时间复杂度为O(n)</p>\n</li>\n<li><p>平均情况：删除任何一个元素的概率相同，即I=1,2,3,…,length的概率都是p=1/n。i=1，循环n-1次；i=2时，循环n-2次；…i=n时，循环0次<br>$$<br>E_{del} = \\frac 1n \\sum^n_{i=1}(n-i)=\\frac 1n \\frac {(n-1)n}2 = \\frac{n-1}2<br>$$<br> ，平均时间复杂度为O(n)</p>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除操作代码</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">ListDelete</span><span class=\"params\">(SqList&amp; L, <span class=\"type\">int</span> i, ElemType &amp;e)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">1</span> || i &gt; L.length)             <span class=\"comment\">// 判断i值是否合理</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    e = L.data[i - <span class=\"number\">1</span>];         <span class=\"comment\">//将被删除的元素赋给e</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt; L.length; j++)</span><br><span class=\"line\">        L.data[j - <span class=\"number\">1</span>] = L.data[j];  <span class=\"comment\">//将被删除的元素赋给e</span></span><br><span class=\"line\">    L.length--;  <span class=\"comment\">//线性表长度减1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-4.png\" style=\"zoom: 70%;\" />\n\n<ul>\n<li><p><strong>按位查找</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">ELemType <span class=\"title function_\">GetElem</span><span class=\"params\">(SeqList L, <span class=\"type\">int</span> i)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L.data[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度:O(1)   “<strong>随机存取</strong>“特性!</p>\n</li>\n<li><p><strong>按值查找</strong>（顺序查找）</p>\n<ul>\n<li><p>最好情况：查找的元素就在表头循环1次，时间复杂度为O(1)</p>\n</li>\n<li><p>最坏情况：查找的元素在表尾（或不存在）循环n次，时间复杂度为O(n)</p>\n</li>\n<li><p>平均情况：目标元素出现在任一位置的概率相同，都是1/n。目标在第1位，循环1次；…在第n位，循环n次。<br>$$<br>E_{find} = \\frac 1n \\sum^n_{i=1}i= \\frac{n+1}2<br>$$<br> ，平均时间复杂度为O(n)</p>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">LocateElem</span><span class=\"params\">(SeqList L,ElemType e)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;L.length;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(L.data[i]==e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i+<span class=\"number\">1</span>;\t\t<span class=\"comment\">//数组小标为i的元素值等于e,返回其位序i+1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\t\t\t<span class=\"comment\">//退出循环,说明查找失败</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-5.png\" style=\"zoom: 70%;\" />\n\n<blockquote>\n<p><strong>问题</strong>：此处，像int、float、char等类型，判断相等可以使用“= =”来判断。但若是结构类型的数据呢？还可以用“= =”吗？——不能。</p>\n<p>如果是结构类型的数据，判断其是否相等，你需要依次比较该结构体中的各个变量是否相等，最终判断两个结构类型变量是否相等。当然，你也可以将判断两个结构类型是否相等的代码封装成一个函数，以便复用。</p>\n<p>如果使用C++、JAVA，你也可以对“= =”进行运算符重载。</p>\n<p><strong>Tips</strong>：但是呢，如果你是在《数据结构》的考研初试的试卷当中，去手写代码的时候，你当然可以直接用“= =”来判断是否相等，不论是什么类型，而不需要考虑那么多，因为数据结构考的是一种思想、一种理解，而并不是具体的编程语言的实现。</p>\n<p>但是，如果考的是《C语言程序设计》，那么，也许你就要严格按照C语言的语法来写，即使是在试卷上手写代码。</p>\n</blockquote>\n<h3 id=\"习题\"><a href=\"#习题\" class=\"headerlink\" title=\"习题\"></a>习题</h3><ul>\n<li><p>11 顺序表的插入算法中，当 n 个空间已满时，可再申请增加分配 m 个空间，若申请失败，则说明系统没有（）可分配的存储空间 →n+m 个连续</p>\n<blockquote>\n<p>顺序存储需要连续的存储空间，在申请时需申请n+m个连续的存储空间，然后将线性表原来的n个元素复制到新申请的n+m个连续的存储空间的前n个单元。</p>\n</blockquote>\n</li>\n<li><p>综合题 10【2010】设将(n&gt;1)个整数存放到一堆数组R中。设计一个在时间和空间两方面都尽可能高效的算法。将R中保存的序列循环左移p（0&lt;p&lt;n）个位置，即将R中的数据由（X0, X1,…, Xn-1）变换为（Xp, Xp+1,…, Xn-1, X0, X1,…, Xp-1）。要求：</p>\n<p>1）给出算法的基本设计思想。</p>\n<p>2）根据设计思想，采用C、C++或Java语言描述算法，关键之处给出注释。</p>\n<p>3）说明你所设计算法的时间复杂度和空间复杂度。</p>\n<blockquote>\n<p>1）算法的基本设计思想： </p>\n<p>可以将这个问题看作是把数组ab转换成数组ba（a代表数组的前p个元素，b代表数组中余下的n-p个元素）:先将a逆置得到a^-1^b，再将b逆置得到a^-1^b^-1^，最后将整个a^-1^b^-1^逆置得到（a^-1^b^-1^）^-1^=ba。设Reverse函数执行将数组元素逆置的操作，对abcdefgh向左循环移动3（p=3）个位置的过程如下： </p>\n<p>Reverse(0,p-1)得到cbadefgh；  </p>\n<p>Reverse(p,n-1)得到cbahgfed；  </p>\n<p>Reverse(0,n-1)得到defghabc。</p>\n<p>注：Reverse中，两个参数分别表示数组中待转换元素的始末位置。</p>\n<p>2）使用C语言描述算法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Reverse</span><span class=\"params\">(<span class=\"type\">int</span> R[],<span class=\"type\">int</span> from,<span class=\"type\">int</span> to)</span> &#123;</span><br><span class=\"line\"><span class=\"type\">int</span> i,temp;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;(to-from+<span class=\"number\">1</span>)/<span class=\"number\">2</span>;i++)</span><br><span class=\"line\">&#123;    temp=R[from+i];</span><br><span class=\"line\">   R[from+i]=R[to-i];</span><br><span class=\"line\">   R[to-i]=temp;&#125;</span><br><span class=\"line\">&#125;<span class=\"comment\">//Reverse</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Converse</span><span class=\"params\">(<span class=\"type\">int</span> R[],<span class=\"type\">int</span> n,<span class=\"type\">int</span> p)</span>&#123;</span><br><span class=\"line\">Reverse(R,<span class=\"number\">0</span>,p<span class=\"number\">-1</span>);</span><br><span class=\"line\">Reverse(R,p,n<span class=\"number\">-1</span>);</span><br><span class=\"line\">Reverse(R,<span class=\"number\">0</span>,n<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3）上述算法中3个Reverse函数的时间复杂度分别为O(p/2)、O((n-p)/2)和O(n/2)，故所设计的算法的时间复杂度为O(n)，空间复杂度为O(1)。</p>\n<p><strong>另解</strong>，借助辅助数组来实现。  </p>\n<p>算法思想：创建大小为p的辅助数组S，将R中前p个整数依次暂存在S中，同时将R中后n-p个整数左移，然后将S中暂存的p个数依次放回到R中的后续单元。  </p>\n<p>时间复杂度为O(n)，空间复杂度为O(p)。</p>\n</blockquote>\n</li>\n<li><p>综合题 11【2011】一个长度为L(L&gt;=1)的升序序列S，处在第[L/2]个位置的数称为S的中位数。例如，若序列S1=(11，13，15，17，19)，则S1的中位数是15，两个序列的中位数是含它们所有元素的升序序列的中位数。例如，若S2=（2，4，6，8，20），则S1和S2的中位数是11。现在有两个等长升序序列A和B，试设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列A和B的中位数。要求：</p>\n<p>（1）给出算法的基本设计思想。</p>\n<p>（2）根据设计思想，采用C、C++或Java语言描述算法，关键之处给出注释。</p>\n<p>（3）说明你所设计算法的时间复杂度和空间复杂度。</p>\n<blockquote>\n<p>1）求两个序列A和B的中位数最简单的办法就是将两个升序序列进行归并排序，然后求其中位数。这种解法虽可求解，但在时间和空间两方面都不大符合高效的要求，但也能获得部分分值。 </p>\n<p>根据题目分析，分别求两个升序序列A和B的中位数，设为a和b。 </p>\n<p>① 若a=b，则a或b即为所求的中位数。 </p>\n<p>原因：容易验证，如果将两个序列归并排序，则最终序列中，排在子序列ab前边的元素为先前两个序列中排在a和b前边的元素；排在子序列ab后边的元素为先前两个序列中排在a和b后边的元素。所以子序列ab一定位于最终序列的中间，又因为a=b，显然a就是中位数。 </p>\n<p>② 否则（假设a&lt;b），中位数只能出现（a，b）范围内。 </p>\n<p>原因：同样可以用归并排序后的序列来验证，归并排序后必然有形如…a…b…的序列出现，中位数必出现在（a，b）之间。因此可以做如下处理：舍弃a所在序列A的较小一半，同时舍弃b所在序列B的较大一半。在保留两个升序序列中求出新的中位数a和b，重复上述过程，直到两个序列中只含一个元素时为止，则较小者即为所求的中位数。每次总的元素个数变为原来的一半。 </p>\n<p>算法的基本设计思想如下: </p>\n<p>分别求出序列A和B的中位数，设为a和b，求序列A和B的中位数过程如下: </p>\n<p>① 若a=b，则a或b即为所求中位数，算法结束。 </p>\n<p>② 若a&lt;b，则舍弃序列A中较小的一半，同时舍弃序列B中较大的一半，要求舍弃的长度相等。 </p>\n<p>③ 若a&gt;b，则舍弃序列A中较大的一半，同时舍弃序列B中较小的一半，要求舍弃的长度相等。 </p>\n<p>在保留的两个升序序列中，重复过程①、②、③，直到两个序列中只含一个元素时为止，较小者即为所求的中位数。 </p>\n<p>2）算法的实现如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">M_Search</span><span class=\"params\">(<span class=\"type\">int</span> A[],<span class=\"type\">int</span> B[],<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\"> <span class=\"type\">int</span> s1=<span class=\"number\">0</span>,d1=n<span class=\"number\">-1</span>,m1,s2=<span class=\"number\">0</span>,d2=n<span class=\"number\">-1</span>,m2;</span><br><span class=\"line\"> <span class=\"comment\">//分别表示序列A和B的首位数、末位数和中位数</span></span><br><span class=\"line\"> <span class=\"keyword\">while</span>(s1!=d1||s2!=d2)&#123;</span><br><span class=\"line\">     m1=(s1+d1)/<span class=\"number\">2</span>;</span><br><span class=\"line\">     m2=(s2+d2)/<span class=\"number\">2</span>;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(A[m1]==B[m2])</span><br><span class=\"line\">         <span class=\"keyword\">return</span> A[m1];           <span class=\"comment\">//满足条件①</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span>(A[m1]&lt;B[m2])&#123;            <span class=\"comment\">//满足条件②</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span>((s1+d1)%<span class=\"number\">2</span>==<span class=\"number\">0</span>)&#123;     <span class=\"comment\">//若元素个数为奇数</span></span><br><span class=\"line\">             s1=m1;              <span class=\"comment\">//舍弃A中间点以前的部分，且保留中间点</span></span><br><span class=\"line\">             d2=m2;              <span class=\"comment\">//舍弃B中间点以后的部分，且保留中间点</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">else</span>&#123;                  <span class=\"comment\">//元素个数为偶数</span></span><br><span class=\"line\">             s1=m1+<span class=\"number\">1</span>;              <span class=\"comment\">//舍弃A中间点及中间点以前部分</span></span><br><span class=\"line\">             d2=m2;                <span class=\"comment\">//舍弃B中间点以后部分且保留中间点</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">else</span>&#123;                        <span class=\"comment\">//满足条件③</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span>((s2+d2)%<span class=\"number\">2</span>==<span class=\"number\">0</span>) &#123;     <span class=\"comment\">//若元素个数为奇数</span></span><br><span class=\"line\">\t\t        d1=m1;              <span class=\"comment\">//舍弃A中间点以后的部分，且保留中间点</span></span><br><span class=\"line\">\t\t        s2=m2;              <span class=\"comment\">//舍弃B中间点以前的部分，且保留中间点</span></span><br><span class=\"line\">\t\t    &#125;\t</span><br><span class=\"line\">\t\t    <span class=\"keyword\">else</span>&#123;                  <span class=\"comment\">//元素个数为偶数\t</span></span><br><span class=\"line\">\t\t        d1=m1;              <span class=\"comment\">//舍弃A中间点以后部分，且保留中间点\t</span></span><br><span class=\"line\">\t\t        s2=m2+<span class=\"number\">1</span>;                <span class=\"comment\">//舍弃B中间点及中间点以前部分</span></span><br><span class=\"line\">\t\t    &#125;\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> A[s1]&lt;B[s2]? A[s1]:B[s2];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3）算法的时间复杂度为O(log₂n)，空间复杂度为O(1)。  </p>\n<p>【另解】对两个长度为n的升序序列A和B的元素按由小到大的顺序依次访问，这里访问的含义只是比较序列中两个元素的大小，并不实现两个序列的合并，因此空间复杂度为O(1)。按照上述规则访问到第n个元素时，这个元素即为两个序列A和B的中位数。</p>\n</blockquote>\n</li>\n<li><p>综合题 12【2013】已知一个整数序列A=(a0,a1,…,an-1)，其中0&lt;=ai&lt;=0(0&lt;=o&lt;=n)。若存在ap1=ap2=…=apm=x 且 m&gt;n/2(0&lt;=pk&lt;n,1&lt;=k&lt;=m),则称x为A的主元素。例如A=（0,5,5,3,5,7,5,5），则5为主元素；又如A =(0,5,5,3,5,1,5,7)，则A中没有主元素。假设A中的几个元素保存在一个一维数组中，请设计一个尽可能高效的算法，找出A的主元素。若存在主元素，则输出该元素；否则输出-1。要求：</p>\n<p>(1) 给出算法的基本设计思想</p>\n<p>(2) 根据设计思想，釆用C或C++或Java语言描述算法，关键之处给出注释。</p>\n<p>(3) 说明你所设计算法的时间复杂度和空间复杂度。</p>\n<blockquote>\n<p>(1)将第一个出现的元素num保存到c中，用count记录num出现的次数，初始时令count = 1。如果下一个遇到的元素仍然是num则将count加1，否则将count减1。如果此时count == 0，则将下一个元素保存到c中，并重置count为0。重复上述过程，直至扫描完全部元素。<br>判断此时的c是否为真正的主元素。统计c出现的次数，并保存到count中，如果count &gt; n / 2，则是主元素，否则不是。<br><strong>通俗来讲：就是不断消除两个不同的元素，最后剩的元素就是可能的主元素，然后再判断该可能的主元素个数是否大于n/2，若大于，则主元素就是该元素</strong>。</p>\n<p>(2)算法实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Majority</span><span class=\"params\">(<span class=\"type\">int</span> A[], <span class=\"type\">int</span> n)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i, c, count = <span class=\"number\">1</span>;<span class=\"comment\">//c用来保存候选主元素，count用来计数</span></span><br><span class=\"line\">\tc = A[<span class=\"number\">0</span>];           <span class=\"comment\">//设置A[0]为候选主元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; n; i++)<span class=\"comment\">//查找候选主元素</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (A[i] == c)</span><br><span class=\"line\">\t\t\tcount++;    <span class=\"comment\">//对A中的候选主元素计数</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (count &gt; <span class=\"number\">0</span>)<span class=\"comment\">//处理不是候选主元素时的情况</span></span><br><span class=\"line\">\t\t\t\tcount--;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;         <span class=\"comment\">//更换候选主元素，重新计数</span></span><br><span class=\"line\">\t\t\t\tc = A[i];</span><br><span class=\"line\">\t\t\t\tcount = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (count &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\tcount = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; n; i++)<span class=\"comment\">//统计候选主元素的实际出现情况</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (A[i] == c)</span><br><span class=\"line\">\t\t\t\tcount++;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (count &gt; n / <span class=\"number\">2</span>)\t<span class=\"keyword\">return</span> c;<span class=\"comment\">//确定候选主元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;<span class=\"comment\">//不存在主元素</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>(3)实现的程序时间复杂度为O(n)，空间复杂度为O(1)。</p>\n</blockquote>\n</li>\n<li><p>综合题 13【2018】给定一个含n(n&gt;=1)个整数的数组，请设计一个在时间上尽可能高效的算法，找出数组中未出现的最小正整数。例如，数组{-5，3，2，3}中未出现的最小正整数是1；数组{1, 2, 3}中未出现的最小正整数是4。要求：</p>\n<p>（1）给出算法的基本设计思想。 </p>\n<p>（2）根据设计思想，采用 C 或 C++语言描述算法，关键之处给出注释。 </p>\n<p>（3）说明你所设计算法的时间复杂度和空间复杂度。</p>\n<blockquote>\n<p>1)题目要求算法时间上尽可能高效，因此采用空间换时间的办法。分配一个用于标记的 数组 B[n]，用来记录 A 中是否出现了 1～n 中的正整数，B[0]对应正整数 1，B[n-1]对应正整数 n，初始化 B 中全部为 0。由于 A 中含有 n 个整数，因此可能返回的值是 1～n+1，当 A 中 n 个数恰好为 1～n 时返回 n+1。当数组 A 中出现了小于等于 0 或大于 n 的值时，会导致 1～n 中出现空余位置，返回结果必然在 1～n 中，因此对于 A 中出现了小于等于 0 或大于 n 的值可 以不采取任何操作。 </p>\n<p>经过以上分析可以得出算法流程：从 A[0]开始遍历 A，若 0&lt;A[i]&lt;=n，则令 B[A[i]-1] = 1； 否则不进行操作。对 A 遍历结束后，开始遍历数组 B，若能查找到第一个满足B[i]==0 的下标 i，返回 i+1 即为结果，此时说明 A 中未出现的最小正整数在 1～n 之间。若 B[i]全部不为 0， 返回 i+1（跳出循环时 i = n，i+1 等于 n+1），此时说明 A 中未出现的最小正整数是 n+1。</p>\n<p>2)算法实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">findMissMin</span><span class=\"params\">(<span class=\"type\">int</span> A[], <span class=\"type\">int</span> n)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"type\">int</span> i, *B;                          <span class=\"comment\">//标记数组</span></span><br><span class=\"line\"> B = (<span class=\"type\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>) * n); <span class=\"comment\">//分配空间</span></span><br><span class=\"line\"> <span class=\"built_in\">memset</span>(B, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>) * n);      <span class=\"comment\">//赋初值为 0</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (A[i] &gt; <span class=\"number\">0</span> &amp;&amp; A[i] &lt;= n) <span class=\"comment\">//若 A[i]的值介于 1～n，则标记数组 B</span></span><br><span class=\"line\">         B[A[i] - <span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\"> <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; n; i++) <span class=\"comment\">//扫描数组 B，找到目标值</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (B[i] == <span class=\"number\">0</span>)</span><br><span class=\"line\">         <span class=\"keyword\">break</span>;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> i + <span class=\"number\">1</span>; <span class=\"comment\">//返回结果</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3)时间复杂度：遍历 A 一次，遍历 B 一次，两次循环内操作步骤为 O(1)量级，因此时间 复杂度为 O(n)。空间复杂度：额外分配了 B[n]，空间复杂度为 O(n)。</p>\n<p><a href=\"https://www.codenong.com/cs105598468/\">https://www.codenong.com/cs105598468/</a></p>\n<p><a href=\"https://icode.best/i/29345031505648\">https://icode.best/i/29345031505648</a></p>\n</blockquote>\n</li>\n<li><p>综合题 14【2020】定义三元组(a,b,c)(a、b、c均为正数)的距离D=|a-b|+|b-c|+|c-a|。给定3个非空整数集合S1、S2和S3，按升序分别存储在3个数组中。请设计一个尽可能高效的算法，计算并输出所有可能的三元组(a,b,c)(a∈S1,b∈S2,c∈S3)中的最小距离。例如S1={-1,0,9}，S2={-25,-10,10,11}，S3={2,9,17,30,41},则最小距离为2，相应的三元组为(9,10,9)。</p>\n<p>（1）给出算法的基本设计思想。 </p>\n<p>（2）根据设计思想，采用 C 或 C++语言描述算法，关键之处给出注释。 </p>\n<p>（3）说明你所设计算法的时间复杂度和空间复杂度。</p>\n<blockquote>\n<p>(1)</p>\n<p>①使用Dmin记录所有已处理的三元组的最小距离，初值为一个足够大的整数。</p>\n<p>②集合S1、S2和S3分别保存在数组A、B、C中。数组的下标变量i=j=k=0,当i&lt; |S1|、j&lt; |S2|且k&lt; |S3|时（|S|表示集合中的元素个数），循环执行下面的“a)~c)”。</p>\n<p>a)计算（A[i]，B[j]，C[k]）的距离D；（计算D）</p>\n<p>b)若D&lt;Dmin，则Dmin=D；（更新D）</p>\n<p>c)将A[i]、B[j]、C[k]中的最小值的下标+1；</p>\n<p>③输出Dmin，结束</p>\n<p>(2)算法实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> INT_MAX 0x7fffffff</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">abs_</span><span class=\"params\">(<span class=\"type\">int</span> a)</span>&#123;<span class=\"comment\">//计算绝对值</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(a&lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span> -a;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">xls_min</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b,<span class=\"type\">int</span> c)</span>&#123;<span class=\"comment\">//a是否是三个数中的最小值</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(a&lt;=b&amp;&amp;a&lt;=c) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">findMinofTrip</span><span class=\"params\">(<span class=\"type\">int</span> A[],<span class=\"type\">int</span> n,<span class=\"type\">int</span> B[],<span class=\"type\">int</span> m,<span class=\"type\">int</span> C[],<span class=\"type\">int</span> p)</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//D_min用于记录三元组的最小距离，处置赋为INT_MAX</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> i=<span class=\"number\">0</span>,j=<span class=\"number\">0</span>,k=<span class=\"number\">0</span>,D_min=INT_MAX,D;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(i&lt;n&amp;&amp;j&lt;m&amp;&amp;k&lt;p&amp;&amp;D_min&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\tD=abs_(A[i]-B[j])+abs_(B[j]-C[k])+abs_(C[k]-A[i]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(D&lt;D_min) D_min=D;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(xls_min(A[i],B[j],C[k])) i++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(xls_min(B[j],C[k],A[i])) j++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> k++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> D_min;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>(3)设n=(|S1|+|S2|+|S3|),时间复杂度为O(n)，空间复杂度为O(1)</p>\n</blockquote>\n</li>\n</ul>\n","categories":["408数据结构"],"tags":["408数据结构"]},{"title":"第二章 线性表(下)","url":"/p/12625/","content":"<h2 id=\"2-3-线性表的链式表示\"><a href=\"#2-3-线性表的链式表示\" class=\"headerlink\" title=\"2.3 线性表的链式表示\"></a>2.3 线性表的链式表示</h2><p><strong>链表</strong>——用<strong>链式存储</strong>方式实现的<strong>线性表</strong>。</p>\n<p>链表主要有四种：单链表、双链表、循环链表、静态链表。</p>\n<ul>\n<li>优点：不要求大片连续空间，改变容量方便</li>\n<li>缺点：不可随机存取，要耗费一定空间存指针域</li>\n</ul>\n<h3 id=\"单链表的定义\"><a href=\"#单链表的定义\" class=\"headerlink\" title=\"单链表的定义\"></a>单链表的定义</h3><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-6.png\" style=\"zoom: 75%;\" />\n\n<ul>\n<li>线性表的链式存储又称<strong>单链表</strong>，它是指通过一组任意的存储单元来存储线性表中的数据元素。为了建立数据元素之间的线性关系，对每个链表结点，<font color='red'>除存放元素自身的信息外，还需要存放一个指向其后继的指针</font>。</li>\n</ul>\n<p><strong>单链表的代码实现</strong>:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span>&#123;</span>\t\t<span class=\"comment\">//单链表结点的结构类型 </span></span><br><span class=\"line\">\tElemType data;\t<span class=\"comment\">//数据域 </span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">next</span>;</span>\t<span class=\"comment\">//指针域 </span></span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">p</span> =</span> (<span class=\"keyword\">struct</span> LNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> LNode));\t<span class=\"comment\">//增加一个新的结点</span></span><br></pre></td></tr></table></figure>\n\n<p>此处，我们发现，每次定义一个新结点，都要将它定义为<code>struct LNode</code>的类型。</p>\n<p>于是我们直接将原结构类型<code>struct LNode</code>使用typedef重命名一下，以简化。</p>\n<h4 id=\"typedef的使用问题\"><a href=\"#typedef的使用问题\" class=\"headerlink\" title=\"typedef的使用问题\"></a>typedef的使用问题</h4><blockquote>\n<p>typedef &lt;数据类型&gt; &lt;别名&gt;</p>\n<p>例如：  typedef int zhengshu;  typedef int * zhengshuzhizhen;</p>\n<p>这样以后，原本的  int a = 1;   int * p;</p>\n<p>就可以写为  zhengshu a = 1;  zhengshuzhizhen p;</p>\n</blockquote>\n<p><strong>于是就有了如下的类型定义代码</strong></p>\n<p><strong>结点的类型定义</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span>&#123;</span>\t\t\t\t<span class=\"comment\">//定义单链表结点类型</span></span><br><span class=\"line\">    ElemType data;\t\t\t\t\t<span class=\"comment\">//定义单链表结点类型(数据域)</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> * <span class=\"title\">next</span>;</span>\t\t\t<span class=\"comment\">//每个节点存放一个数据元素(指针域)</span></span><br><span class=\"line\">&#125;LNode,*LinkList;\t\t\t\t\t<span class=\"comment\">//LinkList为指向结构体LNode的指针类型</span></span><br><span class=\"line\"><span class=\"comment\">//增加一个新的结点:在内存中申请一个结点所需空间,并用指针p指向这个结点</span></span><br><span class=\"line\">LNode *p =(LNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上述定义代码等价于</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span>&#123;</span></span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> <span class=\"title\">LNode</span>;</span>\t\t\t<span class=\"comment\">//struct LNode = LNode</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> * <span class=\"title\">LinkList</span>;</span>\t<span class=\"comment\">//struct LNode *= LinkList </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//增加一个新的结点:在内存中申请一个结点所需空间,并用指针p指向这个结点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">p</span> =</span>(<span class=\"keyword\">struct</span> LNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> LNode))</span><br></pre></td></tr></table></figure>\n\n<p>通常只需声明一个头指针L来表示一个单链表，指向单链表的第一个结点</p>\n<p><code>LNode *L;        //声明一个指向单链表的第一个结点的指针</code><br>这样一来，我就可以这样写我的代码:<br><code>LinkList L;   //声明一个指向单链表的第一个结点的指针</code></p>\n<p><font color='orange'>但是，也并不是说，写LNode 的地方，都要写作LinkList。因为，代码不论怎么写，始终是为了简洁性、可读性的。看下面这个例子：</font></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span>&#123;</span></span><br><span class=\"line\">\tElemType * data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> * <span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;LNode, *LinkList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//单链表查找某元素</span></span><br><span class=\"line\">LNode * <span class=\"title function_\">GetElem</span><span class=\"params\">(LinkList L, <span class=\"type\">int</span> i)</span>&#123;\t<span class=\"comment\">//函数返回值LNode *是想强调其返回结果是一个结点；</span></span><br><span class=\"line\">    \t\t\t\t\t\t\t\t<span class=\"comment\">//参数L类型LinkList是想强调这是一个单链表（头结点代表单链表）</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> j = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tLNode *p = L-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(i==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(i&lt;<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(p!=<span class=\"literal\">NULL</span> &amp;&amp; j&lt;i)&#123;</span><br><span class=\"line\">\t\tp = p-&gt;next;</span><br><span class=\"line\">\t\tj++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p;\t<span class=\"comment\">//最终返回一个结点，类型为LNode *</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：此段代码中，并没有将LNode *全部写为LinkList。可以注意到，在我使用LNode *的地方，我往往是想要强调这是一个结点(例如函数返回值LNode *，例如其中用来索引的指针p是LNode *)，而在使用LinkList的地方，我想要强调的是这是一个单链表（例如函数的参数L是LinkList，它虽然是一个头结点，但它根本上是代表着一个单链表）</p>\n</blockquote>\n<p><strong>总之，这种重命名的方法（typedef），以及对重命名之后的别名的使用（是有所强调的，而不是一概而论的），希望能够好好体会。</strong></p>\n<h4 id=\"不带头结点的单链表\"><a href=\"#不带头结点的单链表\" class=\"headerlink\" title=\"不带头结点的单链表\"></a>不带头结点的单链表</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span>\t\t<span class=\"comment\">//定义单链表结点的结构类型</span></span><br><span class=\"line\">\tElemType data;\t\t<span class=\"comment\">//数据域 </span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">next</span>;</span>\t<span class=\"comment\">//指针域 </span></span><br><span class=\"line\">&#125;LNode, *LinkList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化一个空的单链表（不带头结点）</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">InitList</span><span class=\"params\">(LinkList &amp;L)</span> &#123;</span><br><span class=\"line\">\tL = <span class=\"literal\">NULL</span>;\t<span class=\"comment\">//空表，暂时还没有任何结点\t//初始并设为空，防止脏数据</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\tLinkList L;\t<span class=\"comment\">//声明一个指向单链表的指针\t//（1）</span></span><br><span class=\"line\">\tInitList(L);\t<span class=\"comment\">//初始化一个空表</span></span><br><span class=\"line\">\t<span class=\"comment\">//...... </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong>（1）处并没有创建一个结点。</p>\n<p>要始终去体会，<strong>别名的使用是在含义上有所强调的</strong>，而不仅仅是理论上来说代码能否编译问题</p>\n<h4 id=\"带头结点的单链表\"><a href=\"#带头结点的单链表\" class=\"headerlink\" title=\"带头结点的单链表\"></a>带头结点的单链表</h4><p>单链表第一个结点之前附加一个结点，称为头结点。</p>\n<p><a href=\"https://blog.csdn.net/zhenyusoso/article/details/6092843\">https://blog.csdn.net/zhenyusoso/article/details/6092843</a></p>\n<p>引入头结点后，可用带来两个优点:</p>\n<ol>\n<li>由于第一个数据结点的位置被存放在头结点的指针域中，因此在链表的第一个位置上的操作和在表的其他位置上的操作一致，无须进行特殊处理。</li>\n<li>无论链表是否为空，其头指针都指向头结点的非空指针(空表中头结点的指针域为空)，因此空表和非空表的处理也就得到了统一。</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span>&#123;</span></span><br><span class=\"line\">\tElemType data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;LNode, *LinkList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化一个单链表（带头结点） </span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">InitList</span><span class=\"params\">(LinkList &amp;L)</span>&#123;</span><br><span class=\"line\">\tL = (LNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));\t<span class=\"comment\">//分配一个头结点</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(L == <span class=\"literal\">NULL</span>)  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t<span class=\"comment\">//内存不足，分配失败</span></span><br><span class=\"line\">\tL-&gt;next = <span class=\"literal\">NULL</span>;\t<span class=\"comment\">//头结点之后暂时还没有结点</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\tLinkList L;\t<span class=\"comment\">//声明一个指向头结点的指针</span></span><br><span class=\"line\">\tInitList(L);\t<span class=\"comment\">//初始化一个空表</span></span><br><span class=\"line\">\t<span class=\"comment\">//...... </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong>：此头结点的数据域是不存储数据元素的，只有指针域有意义。这是为了方便后续的链表操作。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//判断单链表是否为空（带头结点） </span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Empty</span><span class=\"params\">(LinkList L)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(L-&gt;next == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"不带-带头结点的区别\"><a href=\"#不带-带头结点的区别\" class=\"headerlink\" title=\"不带/带头结点的区别\"></a>不带/带头结点的区别</h4><ul>\n<li>不带头结点，写代码更麻烦。对第一个数据结点和后续数据结点的处理需要用不同的代码逻辑。对空表和非空表的处理需要用不同的代码逻辑。</li>\n<li>带头结点，写代码更方便。一般都是带头结点的。</li>\n<li>不带头结点，头指针L所指向的下一个结点，就是实际用于存放数据的结点。而带头结点，头指针所指向的结点，也就是头结点，是不存放实际的数据元素的，而头结点指向的下一个结点才会用于存放数据。</li>\n<li>不带头结点，空表判断：<code>L==NULL</code>；带头结点，空表判断：<code>L-&gt;next==NULL</code></li>\n</ul>\n<h3 id=\"单链表上基本操作的实现\"><a href=\"#单链表上基本操作的实现\" class=\"headerlink\" title=\"单链表上基本操作的实现\"></a>单链表上基本操作的实现</h3><h4 id=\"采用头插法建立单链表\"><a href=\"#采用头插法建立单链表\" class=\"headerlink\" title=\"采用头插法建立单链表\"></a>采用头插法建立单链表</h4><ul>\n<li>头插法建立单链表时，读入数据的顺序与生成的链表中的元素的顺序是相反的。每个结点插入的时间为O(1),设单链表长n,时间复杂度O(n)。</li>\n<li><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-9.png\"  /></li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">LinkList <span class=\"title function_\">List_HeadInsert</span><span class=\"params\">(LinkList &amp;L)</span>&#123;<span class=\"comment\">//逆向建立单链表</span></span><br><span class=\"line\">    LNode *s; <span class=\"type\">int</span> x;</span><br><span class=\"line\">    L=(LinkList)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));<span class=\"comment\">//创建头结点；</span></span><br><span class=\"line\">    L-&gt;next=<span class=\"literal\">NULL</span>;                    <span class=\"comment\">//初始为空链表[*]</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;x);                   <span class=\"comment\">//输入结点的值</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x! = <span class=\"number\">9999</span>)&#123;                 <span class=\"comment\">//输入9999表示结束</span></span><br><span class=\"line\">        s=(LNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));<span class=\"comment\">//创建新结点</span></span><br><span class=\"line\">        s- &gt;data=x;</span><br><span class=\"line\">        s- &gt;next=L- &gt;next;</span><br><span class=\"line\">        L- &gt;next=s;                   <span class=\"comment\">//将新结点插入表中，L为头指针</span></span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"http://data.biancheng.net/view/93.html\">头插法创建单链表（带源码+解析）</a></p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-8.png\" style=\"zoom: 75%;\" />\n\n<blockquote>\n<p>注意:在代码[*]处，初始化空链表的时候，必须将L的next置为NULL。否则插入若干数据结点后，表尾的next会是一个脏数据，而不是NULL。而尾插法为什么不用，是因为尾插法在最后执行了尾结点指针域置空的操作。但总之，你只要是初始化单链表，都先把头指针指向NULL，这是一个好习惯。</p>\n</blockquote>\n<blockquote>\n<p><strong>重要应用：链表的逆置</strong>！！<a href=\"https://www.bilibili.com/video/BV1yU4y1U7L2?spm_id_from=333.337.search-card.all.click&vd_source=278af11bcc7fe34571197ce600d488f4\">B站-链表逆置的两种方法</a></p>\n<p>在使用头插法插入数据的时候，你依次插入a、b、c。那么在此单链表中，从头结点开始，依次为：c、b、a。于是这里引起了一个重要的应用，<strong>链表的逆置</strong>。</p>\n<p>也就是再建立一个新的链表，之后将原来的链表从头到尾依次头插法插入新链表中，新链表就是原链表的逆置。</p>\n<p>当然，你也可以不建立新链表，而是在原链表，直接依次对每个结点，向原链表的头结点后执行头插，最终得到的结果也是原链表的逆置。</p>\n</blockquote>\n<h4 id=\"采用尾插法建立单链表\"><a href=\"#采用尾插法建立单链表\" class=\"headerlink\" title=\"采用尾插法建立单链表\"></a>采用尾插法建立单链表</h4><ul>\n<li><p>时间复杂度O(n)</p>\n</li>\n<li><p><strong>头插法</strong>建立单链表的算法虽然简单，但生成的链表中结点的次序和输入数据的顺序<strong>不一致</strong>。若希望两者次序一致，可采用尾插法。该方法是将新结点插入到当前链表的表尾上，为此必须增加一个尾指针r,使其始终指向当前链表的尾结点，如图所示。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-10.png\"  /></li>\n</ul>\n<p><strong>初始化单链表后，向单链表末尾进行后插操作</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在第i个位置插入元素e（带头结点）</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">ListInsert</span><span class=\"params\">(LinkList &amp;L, <span class=\"type\">int</span> i, ElemType e)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(i&lt;<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\tLNode *p;\t<span class=\"comment\">//指针p指向当前扫描到的结点</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> j=<span class=\"number\">0</span>;\t<span class=\"comment\">//当前p指向的是第几个结点</span></span><br><span class=\"line\">\tp = L;\t<span class=\"comment\">//L指向头结点</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(p!=<span class=\"literal\">NULL</span> &amp;&amp; j&lt;i<span class=\"number\">-1</span>) &#123;\t<span class=\"comment\">//循环找到第i-1个结点 </span></span><br><span class=\"line\">\t\tp = p-&gt;next;</span><br><span class=\"line\">\t\tj++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(p == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t<span class=\"comment\">//i值不合法</span></span><br><span class=\"line\">\tLNode *s = (LNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));</span><br><span class=\"line\">\ts-&gt;data = e;</span><br><span class=\"line\">\ts-&gt;next = p-&gt;next;</span><br><span class=\"line\">\tp-&gt;next = s;\t<span class=\"comment\">//将结点s连到p之后 </span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>但是此时有一个问题。即每次向表尾插入一个元素，都要从表头开始循环，找到表尾结点。那么若要插入n个元素进去，则时间复杂度为O(n²)。</p>\n<p>但是实际上，我们每次向表尾插入新的元素，没有必要每次都从表头再全部遍历一次。我们可以设立一个表尾指针r，专门用于指向表尾。之后若要插入新元素，对表尾指针r做一个后插操作即可。</p>\n<p>如何对表尾指针r做后插操作，见指定结点的后插操作。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">LinkList <span class=\"title function_\">List_TailInsert</span><span class=\"params\">(LinkList &amp;L)</span>&#123;<span class=\"comment\">//正向建立单链表</span></span><br><span class=\"line\">    <span class=\"type\">int</span> x;                            <span class=\"comment\">//设元素类型为整型</span></span><br><span class=\"line\">    L=(LinkList)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));<span class=\"comment\">//创建头结点；</span></span><br><span class=\"line\">    LNode *s,*r=L;                    <span class=\"comment\">//r为表尾指针</span></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;x);                   <span class=\"comment\">//输入结点的值</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x! =<span class=\"number\">9999</span>)&#123;                   <span class=\"comment\">//输入9999表示结束</span></span><br><span class=\"line\">        s=(LNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));</span><br><span class=\"line\">        s- &gt;data=x;</span><br><span class=\"line\">        r- &gt;next=s;                  <span class=\"comment\">//在r结点之后插入元素x</span></span><br><span class=\"line\">        r=s;                         <span class=\"comment\">//r指向新的表尾结点</span></span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    r- &gt;next=<span class=\"literal\">NULL</span>;                   <span class=\"comment\">//尾结点指针置空</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"按序号查找结点值\"><a href=\"#按序号查找结点值\" class=\"headerlink\" title=\"按序号查找结点值\"></a>按序号查找结点值</h4><p>在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止，否则返回最后一个结点指针域NULL。</p>\n<p>时间复杂度O(n)</p>\n<p><code>GetElem(L,i)</code>：按位查找操作。获取表L中第i个位置的元素的值。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//按位查找,返回第i个元素(带头结点)</span></span><br><span class=\"line\">LNode *<span class=\"title function_\">GetElem</span><span class=\"params\">(LinkList L,<span class=\"type\">int</span> i)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LNode *p;\t<span class=\"comment\">//指针p指向当前扫描到的结点</span></span><br><span class=\"line\">    <span class=\"type\">int</span> j = <span class=\"number\">0</span>;\t<span class=\"comment\">//当前p指向的是第几个结点</span></span><br><span class=\"line\">    p = L;\t\t<span class=\"comment\">//L指向头结点,头结点是第0个结点(不存数据)</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p!=<span class=\"literal\">NULL</span> &amp;&amp; j&lt;i)\t<span class=\"comment\">//循环找到第i个结点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p = p-&gt;next;\t\t<span class=\"comment\">//让p指针依次向后移</span></span><br><span class=\"line\">        j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果i=0</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-44.png\" style=\"zoom: 50%;\" />\n\n<p>如果i=8(i大于链表长度)</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-45.png\" style=\"zoom: 50%;\" />\n\n<p><strong>王道书版本</strong>:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">LLNode <span class=\"title function_\">GetElem</span><span class=\"params\">(LinkList L,<span class=\"type\">int</span> i)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//本算法取出单链表L（带头结点）中第i个位置的结点指针</span></span><br><span class=\"line\">    <span class=\"type\">int</span> j=<span class=\"number\">1</span>;  <span class=\"comment\">//计数，初始为1</span></span><br><span class=\"line\">    LNode *p = L-&gt;next;  <span class=\"comment\">//头结点指针赋给p</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i==<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> L;  <span class=\"comment\">//若i等于0，则返回头结点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i&lt;<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;  <span class=\"comment\">//若 i 无效，则返回 NULL</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>( p &amp;&amp; j&lt;i ) &#123;  <span class=\"comment\">//从第1个结点开始找，查找第i个结点</span></span><br><span class=\"line\">        p=p-&gt;next;</span><br><span class=\"line\">        j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p; <span class=\"comment\">//返回第i个结点的指针，如果i大于表长，p=NULL，直接返回p即可</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么，封装之后。我们下面会提到的<strong>按位插入</strong>、<strong>按位删除</strong>中相应的代码段就都可以直接调用这个封装好的函数来实现。</p>\n<p>如下所示:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在第i个位置插入元素e（带头结点）</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">ListInsert</span><span class=\"params\">(LinkList &amp;L, <span class=\"type\">int</span> i, ElemType e)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(i&lt;<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\tLNode *p = GetElem(L, i<span class=\"number\">-1</span>);\t<span class=\"comment\">//找到第i-1个结点</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> InsertNextNode(p, e);\t<span class=\"comment\">//p后插入新元素e</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"按值查找表结点\"><a href=\"#按值查找表结点\" class=\"headerlink\" title=\"按值查找表结点\"></a>按值查找表结点</h4><p>从单链表第一个结点开始，由前往后依次比较表中各结点数据域的值，若某结点数据域的值等于给定值e，则返回该结点的指针。若整个单链表中没有这样的结点，则返回NULL。按值查找结点的算法如下：</p>\n<p>时间复杂度O(n)</p>\n<p><code>LocateElem(L,e)</code>：按值查找操作。在表L中查找具有给定关键字值的元素</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">LNode *<span class=\"title function_\">LocateElem</span> <span class=\"params\">(LinkList L, ElemType e)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//本算法查找单链表 L （带头结点）中数据域值等于e的结点指针，否则返回NULL</span></span><br><span class=\"line\">    LNode *p=L-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p!=<span class=\"literal\">NULL</span> &amp;&amp; p-&gt;data!=e)  <span class=\"comment\">//从第1个结点开始查找data域为e的结点</span></span><br><span class=\"line\">        p=p-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;  <span class=\"comment\">//找到后返回该结点指针，否则返回NULL</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>此处同样需要注意一点：由于e的类型是ElemType，其有可能是基本类型，也有可能是结构类型。当其为结构类型时，就不能直接通过”! =”来判断了。原理同前文一致，不再赘述。</p>\n</blockquote>\n<p><a href=\"https://blog.csdn.net/pikaqiu_JBR99/article/details/107616129\">单链表的两种查找方式</a></p>\n<h4 id=\"插入结点操作-单链表的插入和删除\"><a href=\"#插入结点操作-单链表的插入和删除\" class=\"headerlink\" title=\"插入结点操作 单链表的插入和删除\"></a>插入结点操作 <a href=\"https://itcn.blog/p/1649535832.html\">单链表的插入和删除</a></h4><h5 id=\"按位序插入\"><a href=\"#按位序插入\" class=\"headerlink\" title=\"按位序插入\"></a>按位序插入</h5><h6 id=\"带头结点\"><a href=\"#带头结点\" class=\"headerlink\" title=\"带头结点\"></a>带头结点</h6><p><code>ListInsert(&amp;L,i,e)</code>：插入操作。<strong>在表L中的第i个位置上插入指定元素e</strong></p>\n<p>(找到第i-1个结点，将新结点插入其后)</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-36.png\" style=\"zoom:67%;\" />\n\n<p><strong>此时，带头结点的好处就体现出来了。当我插入的位置为1时，可以把头结点看作第0个结点，向头结点后进行插入。由此，我不论在何处插入一个结点，我的处理逻辑都是统一的</strong>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">ListInsert</span><span class=\"params\">(LinkList &amp;L,<span class=\"type\">int</span> i,ElemType e)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i&lt;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LNode *p;\t\t<span class=\"comment\">//指针p指向当前扫描到的结点</span></span><br><span class=\"line\">    <span class=\"type\">int</span> j=<span class=\"number\">0</span>;\t\t<span class=\"comment\">//当前p指向的是第几个结点</span></span><br><span class=\"line\">    p = L;\t\t\t<span class=\"comment\">//L指向头结点,头结点是第0个结点(不存是数据)</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(P! =<span class=\"literal\">NULL</span> &amp;&amp; j&lt;i<span class=\"number\">-1</span>)&#123;\t<span class=\"comment\">//循环找到第 i-1 个结点</span></span><br><span class=\"line\">        p=p-&gt;next;</span><br><span class=\"line\">        j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p==<span class=\"literal\">NULL</span>)\t\t<span class=\"comment\">//i值不合法</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LNode *s = (LNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));</span><br><span class=\"line\">    s-&gt;data=e;</span><br><span class=\"line\">    <span class=\"comment\">//将s指向结点的next指针指向p指向结点的next指针</span></span><br><span class=\"line\">    s-&gt;next = p-&gt;next;\t </span><br><span class=\"line\">    p-&gt;next = s;\t<span class=\"comment\">//将p指向结点的next指针指向s</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;\t<span class=\"comment\">//插入成功</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><font color='red'>分析</font>:</p>\n<p>如果 i=1(也就是在表头插入元素)：时间复杂度O(1)</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-37.png\" style=\"zoom: 50%;\" />\n\n<p>如果 i = 3(也就是在表中插入元素)</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-38.png\" style=\"zoom: 50%;\" />\n\n<p>如果 i = 5(也就是在表尾插入元素)：时间复杂度O(n)</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-39.png\" style=\"zoom: 50%;\" />\n\n<h6 id=\"不带头结点\"><a href=\"#不带头结点\" class=\"headerlink\" title=\"不带头结点\"></a>不带头结点</h6><p><code>ListInsert(&amp;L,i,e)</code>：插入操作。<strong>在表L中的第i个位置上插入指定元素e</strong></p>\n<p>(找到第i-1个结点，将新结点插入其后)</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-40.png\" style=\"zoom: 50%;\" />\n\n\n\n<p><strong>此时，由于不带头结点，也就是不存在“第0个”结点。因此i=1时需要特殊处理。</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">ListInsert</span><span class=\"params\">(LinkList &amp;L,<span class=\"type\">int</span> i,ElemType e)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i&lt;<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i==<span class=\"number\">1</span>)\t\t<span class=\"comment\">//插入第1个结点的操作与其他结点操作不同</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        LNode *s =(LNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));</span><br><span class=\"line\">        s-&gt;data = e;</span><br><span class=\"line\">        s-&gt;next = L;</span><br><span class=\"line\">        L = s;\t\t<span class=\"comment\">//头指针指向新结点</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LNode *p;\t\t<span class=\"comment\">//指针p指向当前扫描到的结点</span></span><br><span class=\"line\">    <span class=\"type\">int</span> j=<span class=\"number\">1</span>;\t\t<span class=\"comment\">//当前p指向的是第几个结点</span></span><br><span class=\"line\">    p = L;\t\t\t<span class=\"comment\">//p指向第1个结点(注意:不是头结点)</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(P!=<span class=\"literal\">NULL</span> &amp;&amp; j&lt;i<span class=\"number\">-1</span>)&#123;\t<span class=\"comment\">//循环找到第 i-1 个结点</span></span><br><span class=\"line\">        p=p-&gt;next;</span><br><span class=\"line\">        j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p==<span class=\"literal\">NULL</span>)\t\t<span class=\"comment\">//i值不合法</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LNode *s = (LNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));</span><br><span class=\"line\">    s-&gt;data=e;</span><br><span class=\"line\">    <span class=\"comment\">//将s指向结点的next指针指向p指向结点的next指针</span></span><br><span class=\"line\">    s-&gt;next = p-&gt;next;\t</span><br><span class=\"line\">    p-&gt;next = s;\t<span class=\"comment\">//将p指向结点的next指针指向s</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;\t<span class=\"comment\">//插入成功</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果不带头结点，则插入、删除第1个元素时，需要更改头指针L。</p>\n<p>如果带头结点的话，头指针肯定永远都是指向头结点的。</p>\n<p>但是除了第1个元素外，后续的元素操作，其逻辑和带头结点的一样。</p>\n</blockquote>\n<p><strong>结论</strong>：不带头结点写代码不方便，推荐用带头结点</p>\n<h5 id=\"指定结点的后插操作\"><a href=\"#指定结点的后插操作\" class=\"headerlink\" title=\"指定结点的后插操作\"></a>指定结点的后插操作</h5><p>后插操作：在结点之后插入元素</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-41.png\" style=\"zoom:67%;\" />\n\n<blockquote>\n<p>给定一个结点，在这个结点之后插入一个数据元素e。</p>\n<p>由于单链表的链接指针只能往后寻找，所以如果给定一个结点p的话，那么p之后的那些结点我们都是可知的，我们都可以用循环的方式把它们都找出来。</p>\n<p>但是p结点之前的，我们就没办法知道了。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//后插操作:在p结点之后插入元素e</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">InsertNextNode</span><span class=\"params\">(LNode *p,ElemType e)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LNode *s =(LNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s==<span class=\"literal\">NULL</span>)\t\t<span class=\"comment\">//某些情况下有可能分配失败,比如内存不足</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s-&gt;data = e;</span><br><span class=\"line\">    s-&gt;next = p-&gt;next;</span><br><span class=\"line\">    p-&gt;next = s;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，这个函数只是在已经找到p结点后执行的操作。其时间复杂度为O(1)。</p>\n<p>但是真正进行插入的时候，首先肯定是要先通过循环，找到结点p的。即如下代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在第i个位置插入元素e（带头结点）</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">ListInsert</span><span class=\"params\">(LinkList &amp;L, <span class=\"type\">int</span> i, ElemType e)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(i&lt;<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\tLNode *p;\t<span class=\"comment\">//指针p指向当前扫描到的结点</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> j = <span class=\"number\">0</span>;\t<span class=\"comment\">//当前p指向的是第几个结点</span></span><br><span class=\"line\">\tp = L;\t<span class=\"comment\">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(p!=<span class=\"literal\">NULL</span> &amp;&amp; j&lt;i<span class=\"number\">-1</span>) &#123;\t<span class=\"comment\">//循环找到第i-1个结点 </span></span><br><span class=\"line\">\t\tp = p-&gt;next;</span><br><span class=\"line\">\t\tj++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> InsertNextNode(p, e);\t<span class=\"comment\">//封装（当然，上面那几行也可以封装）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"指定结点的前插操作\"><a href=\"#指定结点的前插操作\" class=\"headerlink\" title=\"指定结点的前插操作\"></a>指定结点的前插操作</h5><p>前插操作是指在某结点的前面插入一个新结点，后插操作的定义刚好与之相反，在单链表插入算法中，通常都是釆用后插操作的。</p>\n<h6 id=\"单链表的基本插入算法\"><a href=\"#单链表的基本插入算法\" class=\"headerlink\" title=\"单链表的基本插入算法\"></a>单链表的基本插入算法</h6><p>插入操作是将值为x的新结点插入到单链表的第i个位置上。先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第i-1个结点，再在其后插入新结点。</p>\n<p>算法首先调用上面的按序号查找算法GetElem(L, i-1)，查找第i-1个结点。假设返回的第i-1个结点为 *p，然后令新结点 *s的指针域指向 *p的后继结点，再令结点 *p的指针域指向新插入的结点 *s。其操作过程如图所示。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-11.png\" style=\"zoom:80%;\" />\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">p=GetElem(L, i<span class=\"number\">-1</span>) ;  <span class=\"comment\">// 语句①，查找插入位置的前驱结点</span></span><br><span class=\"line\">s-&gt;next=p-&gt;next;  <span class=\"comment\">// 语句②，图 2-6 中辑作步骤 1</span></span><br><span class=\"line\">p-&gt;next=s;  <span class=\"comment\">// 语句③，图2-6中操作步骤2</span></span><br></pre></td></tr></table></figure>\n\n<p>算法中，语句②③的顺序不能颠倒，否则，当先执行p-&gt;next=s后，指向其原后继的指针就不存在了，再执行s-&gt;next = p-&gt;next时，相当于执行了 s-&gt;next=s,显然是错误的。本算法主要的时间开销在于查找第i-1个元素，时间复杂度为O(n)。若是在给定的结点后面插入新结点，则时间复杂度仅为O(1)。</p>\n<p>以上面的算法为例，首先调用函数GetElem()找到第i-1个结点，即待插入结点的前驱结点后，再对其执行后插操作。由此可知，对结点的前插操作均可以转化为后插操作，前提是从单链表的头结点开始顺序查找到其前驱结点，时间复杂度为O(n)。</p>\n<h6 id=\"拓展-对某一结点的前插操作\"><a href=\"#拓展-对某一结点的前插操作\" class=\"headerlink\" title=\"拓展:对某一结点的前插操作\"></a>拓展:对某一结点的前插操作</h6><p>此外，可以釆用另一种方式将其转化为后插操作来实现，设待插入结点为s，将插入到p的前面。我们仍然将s插入到p的后面，然后将p-&gt;data与s-&gt;data交换即可，这样既满足了逻辑关系，又能使得时间复杂度为O(1)。算法的代码片段如下：</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-42.png\" style=\"zoom:67%;\" />\n\n<blockquote>\n<p>在p结点之前插入元素e。</p>\n<p>此时就会出现一个问题：如何找到p结点的前驱？</p>\n<p>思路一：</p>\n<p>我们可以传入一个头指针。当给出头指针之后，那么我们链表的所有信息就都能够知道了。</p>\n<p>我们可以从头指针开始，依次遍历各个结点，从而找到p结点的前驱结点，再对p的前驱进行后插操作。</p>\n<p>那么用这种方法进行前插，时间复杂度是O(n)。</p>\n<p>思路二：</p>\n<p>我依然是对p进行后插。但是后插过后，我将p结点和新结点，之中的数据域进行互换。最终也能实现前插的效果。</p>\n<p>这种的本质是后插，时间复杂度O(1)。</p>\n</blockquote>\n<p><strong>思路二代码实现</strong>:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//前插操作:在p结点之前插入元素e</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">InsertPriorNode</span><span class=\"params\">(LNode *p,ElemType e)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LNode *s =(LNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s==<span class=\"literal\">NULL</span>)\t\t\t<span class=\"comment\">//内存分配失败</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s-&gt;next = p-&gt;next;\t</span><br><span class=\"line\">    p-&gt;next = s;\t\t<span class=\"comment\">//新结点 s 连接到 p 之后</span></span><br><span class=\"line\">    s-&gt;data = p-&gt;data;\t<span class=\"comment\">//将p中元素复制到s中</span></span><br><span class=\"line\">    p-&gt;data = e;\t\t<span class=\"comment\">//p中元素覆盖为e</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>王道书中的版本</strong>:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-43.png\" style=\"zoom:67%;\" />\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//前插操作:在p结点之前插入结点s</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">InsertPriorNode</span><span class=\"params\">(LNode *p,LNode *s)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p==<span class=\"literal\">NULL</span> || s==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s-&gt;next = p-&gt;next;</span><br><span class=\"line\">    p-&gt;next = s;\t\t\t\t<span class=\"comment\">//s连到p之后</span></span><br><span class=\"line\">    ElemType temp = p-&gt;data;\t<span class=\"comment\">//交换数据域部分</span></span><br><span class=\"line\">    p-&gt;data = s-&gt;data;</span><br><span class=\"line\">    s-&gt;data = temp;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"删除结点操作-单链表的插入和删除\"><a href=\"#删除结点操作-单链表的插入和删除\" class=\"headerlink\" title=\"删除结点操作 单链表的插入和删除\"></a>删除结点操作 <a href=\"https://itcn.blog/p/1649535832.html\">单链表的插入和删除</a></h4><p>删除操作是将单链表的第i个结点删除。先检查删除位置的合法性，然后查找表中第i-1个结点，即被删结点的前驱结点，再将其删除。其操作过程如图所示。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-12.png\"  />\n\n<p>假设结点p为找到的被删结点的前驱结点，为了实现这一操作后的逻辑关系的变化，仅需修改p的指针域，即将p的指针域next指向q的下一结点。</p>\n<p>时间复杂度O(n)</p>\n<h5 id=\"带头结点按位序删除\"><a href=\"#带头结点按位序删除\" class=\"headerlink\" title=\"带头结点按位序删除\"></a>带头结点按位序删除</h5><p><code>ListDelete(&amp;L,i,&amp;e)</code>：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值(找到第i-1个结点，将其指针指向第i+1个结点，并释放第i个结点)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">ListDelete</span><span class=\"params\">(LinkList &amp;L,<span class=\"type\">int</span> i,ElemType &amp;e)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i&lt;<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LNode *p;\t<span class=\"comment\">//指针p指向当前扫描到的结点</span></span><br><span class=\"line\">    <span class=\"type\">int</span> j = <span class=\"number\">0</span>;\t<span class=\"comment\">//当前p指向的是第几个结点</span></span><br><span class=\"line\">    p = L;\t\t<span class=\"comment\">//L指向头结点,头结点是第0个结点(不存数据)</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p!=<span class=\"literal\">NULL</span> &amp;&amp; j&lt;i<span class=\"number\">-1</span>)\t<span class=\"comment\">//循环找到第 i-1 个结点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        j++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p==<span class=\"literal\">NULL</span>)  \t\t\t<span class=\"comment\">// i值不合法</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p-&gt;next == <span class=\"literal\">NULL</span>)\t\t<span class=\"comment\">//第 i-1 个结点之后已无其他结点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LNode *q = p-&gt;next;\t\t<span class=\"comment\">//令q指向被删除结点</span></span><br><span class=\"line\">    e = q-&gt;data;\t\t\t<span class=\"comment\">//用e返回元素的值</span></span><br><span class=\"line\">    p-&gt;next = q-&gt;next;\t\t<span class=\"comment\">//将*q结点从链中断开</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(q);\t\t\t\t<span class=\"comment\">//释放结点的存储空间</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;\t\t\t<span class=\"comment\">//删除成功</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"扩展：删除指定结点p\"><a href=\"#扩展：删除指定结点p\" class=\"headerlink\" title=\"扩展：删除指定结点p\"></a>扩展：删除指定结点p</h5><p>要实现删除某一个给定结点p，通常的做法是先从链表的头结点开始顺序找到其前驱结点，然后再执行删除操作即可，算法的时间复杂度为O(n)。</p>\n<p>其实，删除结点p的操作可以用删除p的后继结点操作来实现，实质就是将其后继结点的值赋予其自身，然后删除后继结点，也能使得时间复杂度为O(1)。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//删除指定结点p</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">DeleteNode</span><span class=\"params\">(LNode *p)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LNode *q = p-&gt;next;\t\t<span class=\"comment\">//令q指向*p的后继结点</span></span><br><span class=\"line\">    p-&gt;data = p-&gt;next-&gt;data;<span class=\"comment\">//和后继结点交换数据域</span></span><br><span class=\"line\">    p-&gt;next = q-&gt;next;\t\t<span class=\"comment\">//将*q结点从链中&quot;断开&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(q);\t\t\t\t<span class=\"comment\">//释放后继结点的存储空间</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>但是有个问题:如果要删除的这个结点，刚好是单链表的最后一个结点。那么在进行p结点与其后继结点数据域的互换的时候，就会出现问题。即<code>p-&gt;data = p-&gt;next-&gt;data</code>;的时候，就会出现空指针的错误。</p>\n<p>那么如果是最后一个结点，该怎么办呢。那就只能从头结点开始，循环找到p的前驱，进行删除。时间复杂度O(n)。</p>\n</blockquote>\n<h4 id=\"求表长操作\"><a href=\"#求表长操作\" class=\"headerlink\" title=\"求表长操作\"></a>求表长操作</h4><p>求表长操作就是计算单链表中数据结点（不含头结点）的个数，需要从第一个结点开始顺序依次访问表中的每一个结点，为此需要设置一个计数器变量，每访问一个结点，计数器加1，直到访问到空结点为止。算法的时间复杂度为O(n)。</p>\n<p>需要注意的是，因为单链表的长度是不包括头结点的，因此，不带头结点和带头结点的单链表在求表长操作上会略有不同。对不带头结点的单链表，当表为空时，要单独处理。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//求表的长度</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Length</span><span class=\"params\">(LinkList L)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> len = <span class=\"number\">0</span>;\t\t\t<span class=\"comment\">//统计表长</span></span><br><span class=\"line\">    LNode *p = L;\t\t</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p-&gt;next !=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        len++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"双链表-双链表的基本操作\"><a href=\"#双链表-双链表的基本操作\" class=\"headerlink\" title=\"双链表 双链表的基本操作\"></a>双链表 <a href=\"https://blog.csdn.net/qq_16933601/article/details/105351119\">双链表的基本操作</a></h3><p>单链表结点中只有一个指向其后继的指针，这使得单链表只能从头结点依次顺序地向后遍历。若要访问某个结点的前驱结点（插入、删除操作时），只能从头开始遍历，访问后继结点的时间复杂度为O(1)，访问前驱结点的时间复杂度为O(n)。</p>\n<p>为了克服单链表的上述缺点，引入了双链表，双链表结点中有两个指针prior和next，分别指向其前驱结点和后继结点，如图所示。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-13.png\" style=\"zoom: 75%;\" />\n\n<p>结点类型定义</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DNode</span> &#123;</span>  <span class=\"comment\">//定义双链表结点类型</span></span><br><span class=\"line\">    ElemType data;  <span class=\"comment\">//数据域</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DNode</span> *<span class=\"title\">prior</span>, *<span class=\"title\">next</span>;</span>  <span class=\"comment\">//前驱和后继指针</span></span><br><span class=\"line\">&#125;DNode, *DLinklist;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"双链表的初始化\"><a href=\"#双链表的初始化\" class=\"headerlink\" title=\"双链表的初始化\"></a>双链表的初始化</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//初始化双链表(带头结点)</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">InitDLinkList</span><span class=\"params\">(DLinklist &amp;L)</span>&#123;</span><br><span class=\"line\">    L = (DNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(DNode));\t\t\t<span class=\"comment\">//分配一个头结点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L==<span class=\"literal\">NULL</span>)\t\t\t\t\t\t\t\t\t<span class=\"comment\">//内存不足,分配失败</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    L-&gt;prior = <span class=\"literal\">NULL</span>;\t\t\t\t\t\t\t<span class=\"comment\">//头结点的prior永远指向NULL</span></span><br><span class=\"line\">    L-&gt;next = <span class=\"literal\">NULL</span>;\t\t\t\t\t\t\t\t<span class=\"comment\">//头结点之后暂时还没有结点</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">testDLinkList</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//初始化双链表</span></span><br><span class=\"line\">    DLinklist L;</span><br><span class=\"line\">    InitDLinkList(L);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>DLinklist</code> 等价于<code>DNode *</code></li>\n<li><code>DLinklist</code> 强调这是一个链表</li>\n<li><code>DNode *</code> 强调这是一个结点</li>\n</ul>\n<h4 id=\"判断双链表是否为空\"><a href=\"#判断双链表是否为空\" class=\"headerlink\" title=\"判断双链表是否为空\"></a>判断双链表是否为空</h4><p>判断双链表是否为空:判断头结点的下一个是否为空</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//判断双链表是否为空(带头结点)</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Empty</span><span class=\"params\">(DLinklist L)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L-&gt;next == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"双链表的插入操作\"><a href=\"#双链表的插入操作\" class=\"headerlink\" title=\"双链表的插入操作\"></a>双链表的插入操作</h4><p>在双链表中p所指的结点之后插入结点s，其指针的变化过程如图所示</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-14.png\"  />\n\n<p>时间复杂度O(n)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">s-&gt;next=p-&gt;next;  <span class=\"comment\">// 语句①，将结点*s插入到结点*p之后</span></span><br><span class=\"line\">p-&gt;next-&gt;prior=s;  <span class=\"comment\">// 语句②</span></span><br><span class=\"line\">s-&gt;prior=p;  <span class=\"comment\">// 语句③</span></span><br><span class=\"line\">p-&gt;next=s;  <span class=\"comment\">// 语句④</span></span><br></pre></td></tr></table></figure>\n\n<p>上述代码的语句顺序不是唯一的，但也不是任意的，①②两步必须在④步之前，否则p的后继结点的指针就丢掉了，导致插入失败。</p>\n<blockquote>\n<p>但是，<strong>会有一个问题</strong>。</p>\n<p>当p结点为双链表最后一个结点时，在执行该操作时。其中<code>p-&gt;next-&gt;prior = s;</code>会出现空指针错误。</p>\n<p>因此我们要优化一下这段代码，如下所示。</p>\n</blockquote>\n<h5 id=\"后插操作\"><a href=\"#后插操作\" class=\"headerlink\" title=\"后插操作\"></a>后插操作</h5><p>如果p结点是最后一个结点(特殊情况)：</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-46.png\" style=\"zoom: 50%;\" />\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在p结点之后插入s结点</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">InsertNextDNode</span><span class=\"params\">(DNode *p,DNode *s)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p=<span class=\"literal\">NULL</span> || s=<span class=\"literal\">NULL</span>)\t\t\t\t\t\t\t<span class=\"comment\">//非法参数</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s-&gt;next = p-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p-&gt;next != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//如果p结点有后继结点</span></span><br><span class=\"line\">        p-&gt;next-&gt;prior = s;</span><br><span class=\"line\">    &#125;<span class=\"comment\">//如果p没有后继节点，则当然不需要修改p的后继节点的前驱指针</span></span><br><span class=\"line\">    s-&gt;prior = p;</span><br><span class=\"line\">    p-&gt;next = s;\t</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果p是中间一个结点:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-47.png\" style=\"zoom:67%;\" />\n\n<blockquote>\n<p>同样要注意赋值时的顺序。有些能调换，有些调换了就是错误的逻辑。</p>\n<p>实现了双链表后，在对p结点执行前插操作时。就可以立即找到p结点的前驱结点q，再对q进行后插操作即可。实际上都是可以转化为，利用后插来实现。</p>\n</blockquote>\n<h5 id=\"按位序插入-1\"><a href=\"#按位序插入-1\" class=\"headerlink\" title=\"按位序插入\"></a>按位序插入</h5><p>按位序插入：只需从头结点开始，找到某一个位序的前驱结点，然后对这个前驱结点执行后插操作</p>\n<h5 id=\"前插操作\"><a href=\"#前插操作\" class=\"headerlink\" title=\"前插操作\"></a>前插操作</h5><p>前插操作：只需找到此结点的前驱结点，然后对其前驱结点进行后插操作，即为前插操作</p>\n<h4 id=\"双链表的删除操作\"><a href=\"#双链表的删除操作\" class=\"headerlink\" title=\"双链表的删除操作\"></a>双链表的删除操作</h4><p>删除双链表中结点p的后继结点q，其指针的变化过程如图所示。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-15.png\"  />\n\n<p>时间复杂度O(n)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">p-&gt;next=q-&gt;next;  <span class=\"comment\">// 图2-10中步骤①</span></span><br><span class=\"line\">q-&gt;next-&gt;prior=p;  <span class=\"comment\">//图 2-10 中步骤②</span></span><br><span class=\"line\"><span class=\"built_in\">free</span> (q) ; <span class=\"comment\">//释放结点空间</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>但这样写，同样会有一个问题。就是q为最后一个结点的时候。q的后继节点为NULL，没有前驱结点prior。也就是[*]会引起空指针错误。</p>\n</blockquote>\n<p>当q结点不是最后一个结点时：</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-48.png\" style=\"zoom:67%;\" />\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//删除p结点的后继结点</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">DeleteNextDNode</span><span class=\"params\">(DNode *p)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    DNode *q = p-&gt;next;\t\t\t\t<span class=\"comment\">//找到p的后继结点q</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(q = <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t\t\t\t<span class=\"comment\">//p没有后继结点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    p-&gt;next = q-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(q-&gt;next != <span class=\"literal\">NULL</span>)\t\t\t\t<span class=\"comment\">//q结点不是最后一个结点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        q-&gt;next-&gt;prior = p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(q);\t\t\t\t\t\t<span class=\"comment\">//释放结点空间</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当q结点是最后一个结点时:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-49.png\" style=\"zoom: 50%;\" />\n\n<h4 id=\"双链表的销毁\"><a href=\"#双链表的销毁\" class=\"headerlink\" title=\"双链表的销毁\"></a>双链表的销毁</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">DestoryList</span><span class=\"params\">(DLinklist &amp;L)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//循环释放各个数据结点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(L-&gt;next !=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        DeleteNextDNode(L);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(L);\t\t<span class=\"comment\">//释放头结点</span></span><br><span class=\"line\">    L=<span class=\"literal\">NULL</span>;\t\t\t<span class=\"comment\">//头指针指向NULL</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"双链表的遍历\"><a href=\"#双链表的遍历\" class=\"headerlink\" title=\"双链表的遍历\"></a>双链表的遍历</h4><h5 id=\"后向遍历\"><a href=\"#后向遍历\" class=\"headerlink\" title=\"后向遍历\"></a>后向遍历</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//对结点p做相应处理</span></span><br><span class=\"line\">    p = p-&gt;next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"前向遍历\"><a href=\"#前向遍历\" class=\"headerlink\" title=\"前向遍历\"></a>前向遍历</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//对结点p做相应处理</span></span><br><span class=\"line\">    p = p-&gt;prior;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"前向遍历-跳过头结点\"><a href=\"#前向遍历-跳过头结点\" class=\"headerlink\" title=\"前向遍历(跳过头结点)\"></a>前向遍历(跳过头结点)</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(p-&gt;prior!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//对结点p做相应处理</span></span><br><span class=\"line\">    p = p-&gt;prior;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>知道怎么前向、后向遍历，那么按位查找、按值查找也就没什么问题。</p>\n<ul>\n<li>按位查找：在知道如何前后向遍历的基础上，设置一个遍历次数i，每遍历一次，执行i++，即可实现按位查找。</li>\n<li>按值查找：在知道如何前后向遍历的基础上，每遍历到一个结点，判断该结点的数据域是否等于e，即可实现按值查找。</li>\n</ul>\n<p>时间复杂度O(n)。</p>\n</blockquote>\n<h3 id=\"循环链表\"><a href=\"#循环链表\" class=\"headerlink\" title=\"循环链表\"></a>循环链表</h3><h4 id=\"循环单链表\"><a href=\"#循环单链表\" class=\"headerlink\" title=\"循环单链表\"></a>循环单链表</h4><p>循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-16.png\" style=\"zoom:67%;\" />\n\n<p>在循环单链表中，表尾结点的next域指向L，故表中没有指针域为NULL的结点，因此，<font color='orange'>循环单链表的判空条件不是头结点的指针是否为空，而是它是否等于头指针</font>。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-21.png\" style=\"zoom: 75%;\" />\n\n<p>循环单链表的插入、删除算法与单链表的几乎一样，所不同的是如果操作是在表尾进行，则执行的操作不相同，以让单链表继续保持循环的性质。当然，正是因为循环单链表是一个 “环”，因此，在任何一个位置上的插入和删除操作都是等价的，无须判断是否是表尾。</p>\n<p>在单链表中只能从表头结点开始往后顺序遍历整个链表，而循环单链表可以从表中的任一结点开始遍历整个链表。有时对单链表常做的操作是在表头和表尾进行的，此时可对循环单链表不设头指针而仅设尾指针，从而使得操作效率更高。</p>\n<h5 id=\"初始化循环单链表\"><a href=\"#初始化循环单链表\" class=\"headerlink\" title=\"初始化循环单链表\"></a>初始化循环单链表</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span>&#123;</span>\t\t<span class=\"comment\">//定义单链表结点类型</span></span><br><span class=\"line\">    ElemType data;\t\t\t<span class=\"comment\">//每个结点存放一个数据元素</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">next</span>;</span>\t\t<span class=\"comment\">//指针指向下一个结点</span></span><br><span class=\"line\">&#125;LNode,*LinkList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化一个循环单链表</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">InitList</span><span class=\"params\">(LinkList &amp;L)</span>&#123;</span><br><span class=\"line\">    L = (LNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LNode));\t\t<span class=\"comment\">//分配一个头结点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    L-&gt;next = L;\t\t\t\t\t\t\t<span class=\"comment\">//头结点next指向头结点</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"判断循环单链表是否为空\"><a href=\"#判断循环单链表是否为空\" class=\"headerlink\" title=\"判断循环单链表是否为空\"></a>判断循环单链表是否为空</h5><p>判断循环单链表是否为空:判断头结点的next指针是否指向它自己</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Empty</span><span class=\"params\">(LinkList L)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L-&gt;next == L)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"判断循环单链表表尾结点\"><a href=\"#判断循环单链表表尾结点\" class=\"headerlink\" title=\"判断循环单链表表尾结点\"></a>判断循环单链表表尾结点</h5><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-50.png\" style=\"zoom: 33%;\" />\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//判断结点p是否是循环单链表的表尾结点</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">isTail</span><span class=\"params\">(LinkList L,LNode *p)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p-&gt;next == L)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"循环单链表的好处\"><a href=\"#循环单链表的好处\" class=\"headerlink\" title=\"循环单链表的好处\"></a>循环单链表的好处</h5><p><strong>单链表</strong></p>\n<ul>\n<li>从一个结点出发，只能找到后续的各个结点，而前驱的各个结点，除非获得单链表的表头指针，否则无法得知。</li>\n<li>从头结点找到尾部，依次循环遍历，时间复杂度为O(n)。</li>\n</ul>\n<p><strong>循环单链表</strong></p>\n<ul>\n<li>从一个结点出发可以找到其他任意一个结点。</li>\n<li><strong>我们让L不再指向头结点，而是指向尾结点</strong>。那么从尾部找到头部，时间复杂度为O(1)。那么此时，我既有尾结点，又有头结点了（往后找一个即可）。而很多时候，链表的操作都是在头部或尾部。那么这样一来，就大大方便了操作，时间复杂度为O(1)。</li>\n</ul>\n<h4 id=\"循环双链表\"><a href=\"#循环双链表\" class=\"headerlink\" title=\"循环双链表\"></a>循环双链表</h4><p>由循环单链表的定义不难推出循环双链表，不同的是在循环双链表中，头结点的prior 指针还要指向表尾结点</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-17.png\" style=\"zoom: 80%;\" />\n\n<p>在循环双链表L中，某结点*p为尾结点时，p-&gt;next=L;当循环双链表为空表时，其头结点的prior域和next域都等于L</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-18.png\" style=\"zoom: 75%;\" />\n\n<p>循环双链表的<strong>优势</strong>:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-19.png\" style=\"zoom: 75%;\" />\n\n<p>我们知道，在p为表尾结点的时候，<font color='orange'>箭头</font>处的语句会出现空指针错误。但如果我们是<strong>循环双链表</strong>的话，那么上述代码的逻辑就是<strong>完全正确</strong>的。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-20.png\" style=\"zoom: 75%;\" />\n\n<p>我们知道，在q为表尾结点的时候，<font color='orange'>箭头</font>处的语句会出现空指针错误。但如果我们是<strong>循环双链表</strong>的话，那么上述代码的逻辑就是<strong>完全正确</strong>的。</p>\n<h3 id=\"静态链表\"><a href=\"#静态链表\" class=\"headerlink\" title=\"静态链表\"></a>静态链表</h3><p>静态链表是<font color='cornflowerblue'>借助数组来描述线性表的链式存储结构</font>，结点也有数据域data和指针域next，与前面所讲的链表中的指针不同的是，这里的指针是<strong>结点的相对地址</strong>(数组下标)，又称为<strong>游标</strong>。和顺序表一样，静态链表也要预先分配一块连续的内存空间。</p>\n<p><strong>静态链表和单链表的对应关系如图</strong></p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-22.png\" style=\"zoom: 75%;\" />\n\n<blockquote>\n<p>单链表中的结点是离散的，分布在内存中的各个角落。每个节点包括一个数据域（数据元素），还有一个指针域（指向下一个结点的指针（地址））。</p>\n</blockquote>\n<blockquote>\n<p>静态链表分配一整片的内存空间，其中的数据元素存放在这片内存空间的某些位置。静态链表中的每个结点包含了数据元素，还有下一个结点的数组下标（游标）。</p>\n<p>静态链表中，0号结点充当“头结点”，它是不存放数据元素的。</p>\n<p>静态链表中每个结点的游标相当于单链表中的指针域。只不过指针域是指明了下一个结点的具体地址，而游标只是指明了在此数组中的下标。</p>\n<p>静态链表如果要表示该结点为最后一个结点的话，可以将它的游标的值设为-1。</p>\n</blockquote>\n<blockquote>\n<p>这样一来，若0号结点的游标为2，那么就可以直接寻找到下标为2的结点的地址。（即静态链表的起始地址<code>addr + sizeof(Node) * 2</code>，实际上就是数组）</p>\n</blockquote>\n<h4 id=\"结点类型定义\"><a href=\"#结点类型定义\" class=\"headerlink\" title=\"结点类型定义\"></a>结点类型定义</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 50  <span class=\"comment\">//静态链表的最大长度</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span>  <span class=\"comment\">//静态链表结构类型的定义</span></span><br><span class=\"line\">    ElemType data;  <span class=\"comment\">//存储数据元素</span></span><br><span class=\"line\">    <span class=\"type\">int</span> next;  <span class=\"comment\">//下一个元素的数组下标</span></span><br><span class=\"line\">&#125;SLinkList[MaxSize];</span><br></pre></td></tr></table></figure>\n\n<p>上下的代码定义等价</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 50  <span class=\"comment\">//静态链表的最大长度</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span>  <span class=\"comment\">//静态链表结构类型的定义</span></span><br><span class=\"line\">    ElemType data;  <span class=\"comment\">//存储数据元素</span></span><br><span class=\"line\">    <span class=\"type\">int</span> next;  <span class=\"comment\">//下一个元素的数组下标</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> <span class=\"title\">SLinkList</span>[<span class=\"title\">MaxSize</span>];</span><span class=\"comment\">//可用SLinkList定义&quot;一个长度为MaxSize的Node型数组&quot;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>问题</strong>：</p>\n<p>用typedef给一个结构类型起别名我理解，但是这个别名怎么是一个“数组”呢？</p>\n<p>实际上这样写以后。你就可以直接通过<strong>SLinkList</strong>定义“<strong>一个长度为MaxSize的Node型数组</strong>”了。</p>\n<p>即如下所示，这两个写法是等价的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">testSLinkList</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\tSLinkList a;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">testSLinkList2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> <span class=\"title\">a</span>[<span class=\"title\">MaxSize</span>];</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>追问：</strong></p>\n<p>我理解了这种定义方式的作用了。但是为什么要这样写呢？这样写不别扭吗？为什么不用我们传统的<code>struct Node a[MaxSize];</code>呢？</p>\n<p>其实这个地方，和我们之前提到过的<code>LinkLise</code>和<code>LNode *</code>其想要<strong>强调含义</strong>是一个道理。</p>\n<p>我使用<code>SLinkList a;</code>来定义，是想<strong>强调</strong>我这里正在定义一个<strong>静态链表</strong>。你一看就明白了，a是一个静态链表。</p>\n<p>但是使用<code>struct Node a[MaxSize];</code>，它仅仅是定义一个Node型的数组a。</p>\n</blockquote>\n<h4 id=\"基本操作的实现\"><a href=\"#基本操作的实现\" class=\"headerlink\" title=\"基本操作的实现\"></a>基本操作的实现</h4><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-24.png\" style=\"zoom: 75%;\" />\n\n<h3 id=\"顺序表和链表的比较\"><a href=\"#顺序表和链表的比较\" class=\"headerlink\" title=\"顺序表和链表的比较\"></a>顺序表和链表的比较</h3><p><strong>逻辑结构</strong>:都属于线性表，都是线性结构</p>\n<p><strong>物理结构</strong>:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-25.png\" style=\"zoom: 75%;\" />\n\n<p><strong>基本操作</strong>:</p>\n<ul>\n<li><p><strong>创建</strong>:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-52.png\" style=\"zoom:55%;\" /></li>\n<li><p><strong>销毁</strong>:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-53.png\" style=\"zoom:55%;\" /></li>\n<li><p><strong>增、删</strong>:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-54.png\" style=\"zoom:55%;\" /></li>\n<li><p><strong>查</strong>:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-55.png\" style=\"zoom:55%;\" /></li>\n</ul>\n<p><strong>在实际应用中应该怎样选取存储结构呢</strong>？</p>\n<ul>\n<li><p><strong>基于存储的考虑</strong></p>\n<p>难以估计线性表的长度或存储规模时，不宜采用顺序表；链表不用事先估计存储规模，但链表的存储密度较低，显然链式存储结构的存储密度是小于1的。</p>\n</li>\n<li><p><strong>基于运算的考虑</strong></p>\n<p>在顺序表中按序号访问ai的时间复杂度为O(1)，而链表中按序号访问的时间复杂度为O(n)，因此若经常做的运算是按序号访问数据元素，则显然顺序表优于链表。</p>\n<p>在顺序表中进行插入、删除操作时，平均移动表中一半的元素，当数据元素的信息量较大且表较长时，这一点是不应忽视的；在链表中进行插入、删除操作时，虽然也要找插入位置，但操作主要是比较操作，从这个角度考虑显然后者优于前者。</p>\n</li>\n<li><p><strong>基于环境的考虑</strong></p>\n<p>顺序表容易实现，任何高级语言中都有数组类型；链表的操作是基于指针的，相对来说前者实现较为简单，这也是用户考虑的一个因素。</p>\n</li>\n</ul>\n<p><strong>开放式问题的回答思路</strong></p>\n<p><strong>注意</strong>：对于一些开放式问题的答题思路，例如</p>\n<ul>\n<li>请描述顺序表和链表的…（区别、联系…）</li>\n<li>实现线性表时，用顺序表还是链表好？</li>\n</ul>\n<p>你都可以用这样的思路（框架），来让自己的答题逻辑更加的清晰。</p>\n<p><strong>这样的思路（框架）</strong>：指的是本节中，对顺序表和链表分别从<strong>逻辑结构</strong>、<strong>存储结构</strong>、<strong>基本操作</strong>三个角度进行了对比，并指出<strong>优缺点</strong>、<strong>效率</strong>上的差异等。</p>\n<blockquote>\n<p>具体的回答思路，例如：</p>\n<p>顺序表和链表的逻辑结构都是线性结构，都属于线性表。</p>\n<p>但是二者的存储结构不同，顺序表采用顺序存储…，具有…的特点，从而导致其优点…，缺点…；而链表采用链式存储，具有…的特点，从而导致其优点…，缺点…。</p>\n<p>由于采用不同的存储方式实现，因此基本操作的实现效率也不同。当初始化时…；当插入一个数据元素时…；当删除一个数据元素时…；当查找一个数据元素时…。</p>\n</blockquote>\n<p>当然，也并不是说这其中的每一个点都必须写出来，意思就是，你可以根据实际情况，按照这个大致思路进行回答，并且选择把哪些点答上去，哪些可以不答上去。总之，思路是清晰的。</p>\n<p>此外，这样的框架性的思路除了便于答题外，也有助于自己的复习、回顾。</p>\n<h3 id=\"习题\"><a href=\"#习题\" class=\"headerlink\" title=\"习题\"></a>习题</h3><ul>\n<li><p>【2016】已知一个带有表头结点的双向循环链表L，结点结构为<code>prev|data|next</code>,其中，prev 和 next 分别是指向其直接前驱和直接后继结点的指针。现要删除指针 p 所指的结点，正确的语句序列是</p>\n<blockquote>\n<p> p-&gt;next-&gt;prev=p-&gt;prev; p-&gt;prev-&gt;next=p-&gt;next; free(p);</p>\n</blockquote>\n</li>\n<li><p>【2016】已知表头元素为 c 的单链表在内存中的存储状态如下表所示。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-30.png\"  />\n\n<p>现将 f 存放于 1014H 处并插入到单链表中，若 f 在逻辑上位于 a 和 e 之间，则 a, e, d 的“链接地址”依次是–&gt;1014H 1004H NULL</p>\n<blockquote>\n<p>链表的遍历顺序c（1008H）-&gt;a（1000H）-&gt;e（1010H）-&gt;b（1004H）-&gt;d（100CH）-&gt;null，然后你插入f到a,e 之间，则a要链接的地址就变成了f的地址，则a的链接地址为1014H ，而f的链接地址则是为e的地址1010H，最后的e后面的链接是没有变的依然是到b。总结：插入后链表的遍历顺序c（1008H）-&gt;a（1000H）-&gt;f(1014H)-&gt;e（1010H）-&gt;b（1004H）-&gt;d（100CH）-&gt;null</p>\n</blockquote>\n</li>\n<li><p>【2021】已知头指针h指向一个带头结点的非空单循环链表，结点结构为<code>data|next</code>,其中next是指向直接后继结点的指针，p是尾指针，q是临时指针。现要删除该链表的第一个元素，正确的语句序列是–&gt; </p>\n<p>q= h-&gt;next; h-&gt;next=q-&gt;next; if(p==q) p=h; free(q);</p>\n<blockquote>\n<p>删除该链表的第一个元素就是让你删除头结点后面的第一个结点。</p>\n<p>普通情况:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-31.png\" style=\"zoom:67%;\" />\n\n<p>特殊情况:要注意当我们删除head后面的节点以后，整个链表就只剩下head节点一个了。 那尾指针只能指向head，所以D选项里的if(p==q)  p=h; free(q);就非常正确。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-32.png\" style=\"zoom:67%;\" /></blockquote>\n</li>\n<li><p>综合【2009】已知一个带有表头结点的单链表，结点结构为<code>data|link</code> 假设该链表只给出了头指针list。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第k个位置上的结点（k为正整数）。若查找成功，算法输出该结点的data域的值，并返回1；否则，只返回0。要求： </p>\n<p>① 描述算法的基本设计思想 </p>\n<p>② 描述算法的详细实现步骤 </p>\n<p>③ 根据设计思想和实现步骤，采用程序设计语言描述算法，关键之处请给出简要注释</p>\n<blockquote>\n<p>1)关键是设计尽可能高效的算法，通过链表的一次遍历，找到倒数第k个结点的位置。算法的基本设计思想是:定义两个指针变量p和q，初始时均指向头结点的下一个结点(链表的第一个结点)，p指针沿链表移动；当p指针移动到第k个结点时，q指针开始与p指针同步移动；当p指针移动到最后一个结点时，q指针所指示结点为倒数第k个结点。</p>\n<p>2)算法详细实现步骤:</p>\n<p>1.count=0,p和q指向链表表头结点的下一个结点。</p>\n<p>2.若p为空，转5</p>\n<p>3.若count等于k，则q指向下一个结点；否则，count=count+1。</p>\n<p>4.p指向下一个结点，转2</p>\n<p>5.若count等于k，则查找成功，输出该结点的data域的值，返回1；否则，说明k值超过了线性表的长度，查找失败，返回0.</p>\n<p>6.算法结束。</p>\n<p>3)算法实现如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">link</span>;</span></span><br><span class=\"line\">&#125;LNode, *LinkList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Search_k</span><span class=\"params\">(LinkList <span class=\"built_in\">list</span>,<span class=\"type\">int</span> k)</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//查找链表list倒数第k个结点，并输出该结点data域的值</span></span><br><span class=\"line\">\tLNode *p=<span class=\"built_in\">list</span>-&gt;link;<span class=\"comment\">//指针p,q指向链表的第一个结点 </span></span><br><span class=\"line\">\tLNode *q=<span class=\"built_in\">list</span>-&gt;link;</span><br><span class=\"line\">\t<span class=\"type\">int</span> count=<span class=\"number\">0</span>;<span class=\"comment\">//计数器初始化为0 </span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(p! =<span class=\"literal\">NULL</span>)&#123;<span class=\"comment\">//指针p依次遍历链表直至最后一个结点 </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(count&lt;k) count++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>  q=q-&gt;link;</span><br><span class=\"line\">\t\t p=p-&gt;link;</span><br><span class=\"line\">\t&#125; <span class=\"comment\">//while</span></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t上面这几行是这个算法的核心思想，我来解释一下</span></span><br><span class=\"line\"><span class=\"comment\">\t首先算法开始运行时，p在动，而q不动</span></span><br><span class=\"line\"><span class=\"comment\">\t直到p向右移动了k次，此时k和count相等，这时候p和q一起向右移动</span></span><br><span class=\"line\"><span class=\"comment\">\t如果k小于链表的长度，则返回q指针指向的数据域 </span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(count&lt;k)<span class=\"comment\">//若k值大于链表的长度，则找不到该结点，返回0 </span></span><br><span class=\"line\">\t   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,q-&gt;data);<span class=\"comment\">//找到该结点则返回该结点的数据域 </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure></blockquote>\n</li>\n<li><p>综合【2012】假定采用带头结点的单链表保存单词，当两个单词有相同的后缀时，可共享相同的后缀存储空间，例如,”loading”和”being”的存储影像如下图所示。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-33.png\"  />\n\n<p>设str1和str2分别指向两个单词所在单链表的头结点，链表结点结构为<code>data|next</code>，请设计一个时间上尽可能高效的算法，找出由str1和str2所指向两个链表共同后缀的起始位置(如图中字符i所在结点的位置p)。要求:</p>\n<p>1)给出算法的设计思想</p>\n<p>2)根据设计思想，采用程序语言描述算法，关键之处给出注释</p>\n<p>3)说明你所设计算法的时间复杂度</p>\n<blockquote>\n<p>1)分别求出str1和str2所指的两个链表的长度m和n；<br>将两个链表以表尾对齐：令指针p、q分别指向str1和str2的头结点；如果m&gt;=n，则p指针先走，使p指向链表中的第m-n+1个结点；如果m&lt;n，则使q指针指向链表的第n-m+1个结点；即：使得指针p、q所指的结点到表尾的长度相等；<br>反复将指针q和q同步向后移动，当p、q指向同一位置时停止，即：共同后缀的起始位置。算法结束。<br>2）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span>&#123;</span></span><br><span class=\"line\"> <span class=\"type\">char</span> data;</span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;LNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//求链表的长度;</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">GetListLen</span><span class=\"params\">(LNode *head)</span>&#123;</span><br><span class=\"line\"> <span class=\"type\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\"> <span class=\"keyword\">while</span>(head-&gt;next != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">     len++;</span><br><span class=\"line\">     head = head-&gt;next;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//找出共同后缀的起始位置；</span></span><br><span class=\"line\">LNode* <span class=\"title function_\">find_addr</span><span class=\"params\">(LNode *str1,LNode *str2)</span>&#123;</span><br><span class=\"line\"> <span class=\"type\">int</span> m,n;</span><br><span class=\"line\"> m = GetListLen(str1);</span><br><span class=\"line\"> n = GetListLen(str2);</span><br><span class=\"line\"></span><br><span class=\"line\"> LNode *p,*q;</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(m &gt;= n)&#123;</span><br><span class=\"line\">     <span class=\"keyword\">for</span>(p = str1;m&gt;n;m--)&#123;</span><br><span class=\"line\">         p = p-&gt;next;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">for</span>(q = str2;n&gt;m;n--)&#123;</span><br><span class=\"line\">         q = q-&gt;next;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">//得到p和q的起始位置后，找出共同后缀的起始地址；</span></span><br><span class=\"line\"> <span class=\"keyword\">while</span>(p-&gt;next !=<span class=\"literal\">NULL</span> &amp;&amp; p-&gt;next != q-&gt;next)&#123;</span><br><span class=\"line\">     p = p-&gt;next;</span><br><span class=\"line\">     q = q-&gt;next;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> p-&gt;next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3)**O(max(m,n))**（m、n分别为两个链表的长度）；</p>\n</blockquote>\n</li>\n<li><p>综合【2015】用单链表保存m个整数，结点的结构为[data]|[link]，且|data|&lt;=n(n为正整数)。现要求设计一个时间复杂度尽可能高效的算法，对于链表中data的绝对值相等的结点，仅保留第一次出现的结点而删除其余绝对值相等的结点。例如，若给定的单链表head如下:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-34.png\" style=\"zoom:80%;\" />\n\n<p>则删除结点后的head为：</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-35.png\" style=\"zoom:80%;\" />\n\n<p>要求：  </p>\n<p>   1）给出算法的基本设计思想。  </p>\n<p>   2）使用C或C++语言，给出单链表结点的数据类型定义。  </p>\n<p>   3）根据设计思想，采用C或C++语言描述算法，关键之处给出注释。  </p>\n<p>   4）说明你所设计算法的时间复杂度和空间复杂度。</p>\n<blockquote>\n<p>1）算法的基本设计思想 </p>\n<p>算法的核心思想是用空间换时间。使用辅助数组记录链表中已出现的数值，从而只需对链表进行一趟扫描。 因为|data|≤n，故辅助数组q的大小为n+1，各元素的初值均为0。依次扫描链表中的各结点，同时检查q[|data|]的值，如果为0，则保留该结点，并令q[|data|]=1；否则，将该结点从链表中删除。 </p>\n<p>2）使用C语言描述的单链表结点的数据类型定义</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span></span><br><span class=\"line\"><span class=\"type\">int</span>         data;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>   *<span class=\"title\">link</span>;</span></span><br><span class=\"line\">&#125;NODE;</span><br><span class=\"line\">Typedef NODE *PNODE;</span><br></pre></td></tr></table></figure>\n\n<p>3）算法实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">func</span> <span class=\"params\">(PNODE h,<span class=\"type\">int</span> n)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">PNODE p=h,r;</span><br><span class=\"line\"><span class=\"type\">int</span> *q,m;</span><br><span class=\"line\">q=(<span class=\"type\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>)*(n+<span class=\"number\">1</span>));  <span class=\"comment\">//申请n+1个位置的辅助空间</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n+<span class=\"number\">1</span>;i++)                <span class=\"comment\">//数组元素初值置0</span></span><br><span class=\"line\">*(q+i)=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(p-&gt;link!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">m=p-&gt;link-&gt;data&gt;<span class=\"number\">0</span>? p-&gt;link-&gt;data:-p-&gt;link-&gt;data;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(*(q+m)==<span class=\"number\">0</span>)                      <span class=\"comment\">//判断该结点的data是否已出现过</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">*(q+m)=<span class=\"number\">1</span>;                      <span class=\"comment\">//首次出现</span></span><br><span class=\"line\">p=p-&gt;link;                     <span class=\"comment\">//保留</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span>                               <span class=\"comment\">//重复出现</span></span><br><span class=\"line\">&#123;   r=p-&gt;link;                     <span class=\"comment\">//删除</span></span><br><span class=\"line\">p-&gt;link=r-&gt;link</span><br><span class=\"line\"><span class=\"built_in\">free</span>(r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">free</span>(q);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4）时间复杂度为O(m)，空间复杂度为O(n)</p>\n</blockquote>\n</li>\n<li><p>【2019】设线性表L=(a1,a2,a3,…,a(n-2),a(n-1),an)采用带头结点的单链表保存，链表中的结点定义如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>* <span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125; NODE;</span><br></pre></td></tr></table></figure>\n\n<p>请设计一个空间复杂度为 <code>O(1)</code> 且时间上尽可能高效的算法，重新排列 L 中的各节点，得到线性表 <code>L&#39;=(a1, an, a2, a(n-1), a3, a(n-2), ...)</code>。要求:</p>\n<p>1)给出算法的设计思想</p>\n<p>2)根据设计思想，采用程序语言描述算法，关键之处给出注释</p>\n<p>3)说明你所设计算法的时间复杂度</p>\n<blockquote>\n<p>1)先观察L=(a1,a2,a3,…,a(n-2),a(n-1),an)和L’=(a1,an,a2,a(n-1),a3,a(n-2),…)，发现L’是由L摘取第一个元素，再摘取倒数第一个元素……依次合并而成的。为了方便链表后半段取元素，需要先将L后半段原地逆置[题目要求空间复杂度为O(1)，不能借助栈]，否则每取最后一个结点都需要遍历一次链表。1.先找出链表L的中间结点，为此设置两个指针p和q,指针p每次走一步，指针q每次走两步，当指针q到达链尾时，指针p正好在链表的中间结点；2.然后将L的后半段结点原地逆置。3.从单链表前后两段中依次各取一个结点，按要求重排。</p>\n<p>2)算法实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Change_list</span><span class=\"params\">(Linklist h)</span>&#123;</span><br><span class=\"line\">\tLNode *p,*q,*r,*s;</span><br><span class=\"line\">\tp=q=h;</span><br><span class=\"line\">\t<span class=\"comment\">/*双指针找链表的中点*/</span> </span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(q-&gt;next!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">\t\tp=p-&gt;next;\t\t\t\t\t<span class=\"comment\">//p走一步 </span></span><br><span class=\"line\">\t\tq=q-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(q-&gt;next!=<span class=\"literal\">NULL</span>)q=q-&gt;next; <span class=\"comment\">//q走两步 </span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">/*链表的逆置*/</span></span><br><span class=\"line\">\tq=p-&gt;next;\t\t\t<span class=\"comment\">//p所指结点为中点 </span></span><br><span class=\"line\">\tp-&gt;next=<span class=\"literal\">NULL</span>;\t\t<span class=\"comment\">//q为后半链表的首结点 </span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(q!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">\t\tr=q-&gt;next;</span><br><span class=\"line\">\t\tq-&gt;next=p-&gt;next;</span><br><span class=\"line\">\t\tp-&gt;next=q;</span><br><span class=\"line\">\t\tq=r;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">/*后半部分的链表头插进入前半部分*/</span></span><br><span class=\"line\">\ts=h-&gt;next;</span><br><span class=\"line\">\tq=p-&gt;next;</span><br><span class=\"line\">\tp-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(q!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">\t\tq-&gt;next=s-&gt;next;<span class=\"comment\">//将q所指结点插入到s所指结点之后 </span></span><br><span class=\"line\">\t\ts-&gt;next=q;</span><br><span class=\"line\">\t\ts=q-&gt;next;\t\t<span class=\"comment\">//将s指向前半段的下一个插入点 </span></span><br><span class=\"line\">\t\tq=r;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>3)第一步找中间结点的时间复杂度为O(n),第二步逆置的时间复杂度为O(n)，第3步合并链表的时间复杂度为O(n),所以该算法的时间复杂度为O(n)。</p>\n</blockquote>\n</li>\n</ul>\n","categories":["408数据结构"],"tags":["408数据结构"]},{"title":"第三章 栈和队列(上)","url":"/p/63528/","content":"<h2 id=\"3-1-栈-Stack\"><a href=\"#3-1-栈-Stack\" class=\"headerlink\" title=\"3.1 栈 Stack\"></a>3.1 栈 Stack</h2><h3 id=\"栈的基本概念\"><a href=\"#栈的基本概念\" class=\"headerlink\" title=\"栈的基本概念\"></a>栈的基本概念</h3><ul>\n<li><p>栈的定义</p>\n<ul>\n<li><p>栈是<font color='orange'>只允许在一端进行插入或删除操作的线性表</font>。限定这种线性表只能在某一端进行插入和删除操作。</p>\n<ul>\n<li>栈顶:线性表允许进行插入删除的那一端。</li>\n<li>栈底:固定的，不允许进行插入和删除的另一端。</li>\n<li>空栈:栈里没有存任何数据元素，相当于线性表的空表。</li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-2.svg\"  /></li>\n<li><p><strong>特性</strong>：后进先出 Last In First Out, LIFO</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-1.png\" style=\"zoom: 75%;\" /></li>\n<li><p>栈的数学性质：卡特兰数 Catalan Number</p>\n<p>卡特兰数一般可用于这种结论:n个不同元素进栈，出栈元素不同排列的个数为:</p>\n<ul>\n<li>$$<br>\\frac 1{n+1}C^n_{2n}<br>$$</li>\n</ul>\n<p>所以，如果像上面那样有五个元素进栈，那么所有合法的出栈顺序有:<br>$$<br>\\frac 1{5+1}C^5_{10}=42<br>$$<br>可见，即使只有5个元素进栈，合法的出栈顺序就有42种，就很多了。所以考试题基本不会让你全部写出所有的，而是以选择题的形式让你选出一个合法的出栈顺序。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"栈的基本操作\"><a href=\"#栈的基本操作\" class=\"headerlink\" title=\"栈的基本操作\"></a>栈的基本操作</h3><ul>\n<li>InitStack(&amp;S)：<font color='red'>初始化</font>栈操作。构造一个空栈S，分配内存空间。</li>\n<li>DestroyStack(&amp;S)：<font color='red'>销毁</font>栈操作，并<font color='red'>释放</font>栈S所占的内存空间</li>\n<li>StackEmpty(S)：判定S是否为空栈。空，则返回ture,否则返回false</li>\n<li>StackLength(S)：求栈的长度 <a href=\"https://cplusplus.com/reference/stack/stack/size/\">cpp::std::stack::size</a></li>\n<li>GetTop(S, &amp;e)：取栈顶元素 <a href=\"https://cplusplus.com/reference/stack/stack/top/\">cpp::std::stack::top</a></li>\n<li>ClearStack(&amp;S)：栈置空操作 <a href=\"https://cplusplus.com/reference/stack/stack/empty/\">cpp::std::stack::empty</a></li>\n<li>Push(&amp;S, e)：入栈操作（压栈）<a href=\"https://cplusplus.com/reference/stack/stack/push/\">cpp::std::stack::push</a></li>\n<li>Pop(&amp;S, &amp;e)：出栈操作（弹栈）</li>\n</ul>\n<h3 id=\"栈的顺序存储结构\"><a href=\"#栈的顺序存储结构\" class=\"headerlink\" title=\"栈的顺序存储结构\"></a>栈的顺序存储结构</h3><ul>\n<li><p>结点的类型定义</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAXSIZE 100 <span class=\"comment\">//定义栈中元素的最大个数</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">  ElemType data[MAXSIZE];<span class=\"comment\">//静态数组存放栈中元素</span></span><br><span class=\"line\">  <span class=\"type\">int</span> top;  <span class=\"comment\">// 栈顶指针</span></span><br><span class=\"line\">&#125; SqStack;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">testStack</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\tSqStack S;\t<span class=\"comment\">//声明一个顺序栈</span></span><br><span class=\"line\">\t<span class=\"comment\">//......</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>栈顶指针：S.top，初始时设置 S.top = -1;</p>\n<p>栈顶元素：s.data[s.Top]；</p>\n<p>进栈操作：栈不满时，栈顶指针先加1，再送值到栈顶元素。</p>\n<p>出栈操作：栈非空时，先去栈顶元素值，再将栈顶指针减1。</p>\n<p>栈空条件：S.top == -1；</p>\n<p>栈满条件：S.top == MaxSize-1;</p>\n<p>栈长：S.top +1 。</p>\n<p>此类一开始分配了最大空间的顺序栈要对栈溢出有相应的处理机制。</p>\n</li>\n<li><p>顺序栈的基本运算</p>\n<ul>\n<li><p>初始化<code>InitStack(&amp;S)</code>:初始化栈，构造一个空栈S，分配内存空间</p>\n<p>初始化栈就是让栈顶指针 top 指向 -1，因为栈顶指针指向的是栈顶元素，开始的时候没有元素，所以栈顶指针指向 0 这个位置是不合适的</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-3.png\" style=\"zoom: 75%;\" /></li>\n<li><p>判栈空<code>StackEmpty(S)</code>:如上图，由于栈空的时候，数组中是没有任何元素的。如果要让栈顶指针指向0，显然是不合适的。所以空栈让栈顶指针的值为-1。因此，判断是否栈空时，只需要判断它的栈顶指针top是否等于-1就可以。</p>\n</li>\n<li><p>进栈<code>Push(&amp;S,x)</code>:进栈，若栈S未满，则将 x 加入使之成为新栈顶；进栈时先让栈顶指针 top 加一，之后将新元素放在 top 指针所指向的位置</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-4.png\" style=\"zoom: 75%;\" />\n\n<p>或者写的更简洁一点，如下。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//新元素入栈</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Push</span><span class=\"params\">(SqStack &amp;S, ElemType x)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S.top == MaxSize<span class=\"number\">-1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t<span class=\"comment\">//栈满，报错</span></span><br><span class=\"line\">\tS.data[++S.top] = x;\t<span class=\"comment\">//合并两句 </span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>出栈<code>Pop(&amp;S,&amp;x)</code>:出栈，若栈S非空，则弹出栈顶元素，并用x返回</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-5.png\" style=\"zoom:75%;\" />\n\n<p>同上文，此处也可以将其中两句合并成一句更简洁的写法，如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//出栈操作</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Pop</span><span class=\"params\">(SqStack &amp;S, ElemType &amp;x)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S.top == <span class=\"number\">-1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t<span class=\"comment\">//栈空，报错</span></span><br><span class=\"line\">\tx = S.data[S.top--];\t<span class=\"comment\">//合并两句</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>读栈顶元素<code>GetTop(S,&amp;x)</code>:读取栈顶元素，若栈 S 非空，则用 x 返回栈顶元素</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-6.png\" style=\"zoom: 75%;\" /></li>\n</ul>\n</li>\n<li><p>另一种操作方式</p>\n<p><strong>初始化</strong>时，令栈顶指针指向0，而不是-1。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 10</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\tElemType data[MaxSize];</span><br><span class=\"line\">\t<span class=\"type\">int</span> top;</span><br><span class=\"line\">&#125;SqStack; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化栈</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitStack</span><span class=\"params\">(SqStack &amp;S)</span> &#123;</span><br><span class=\"line\">\tS.top = <span class=\"number\">0</span>;\t<span class=\"comment\">//初始指向0 </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//判断栈空</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">StackEmpty</span><span class=\"params\">(SqStack S)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S.top == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;<span class=\"comment\">//此时注意栈空条件</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>进栈、出栈</strong>时。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//新元素入栈</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Push</span><span class=\"params\">(SqStack &amp;S, ElemType x)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S.top == MaxSize) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t<span class=\"comment\">//判断栈满的条件不同</span></span><br><span class=\"line\">\tS.data[S.top++] = x;\t<span class=\"comment\">//赋值操作与指针移动操作顺序不同</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//出栈操作</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Pop</span><span class=\"params\">(SqStack &amp;S, ElemType &amp;x)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S.top == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\tx = S.data[--S.top];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>栈顶指针为-1和0的区别<br>在遇到相关问题时，一定要注意看清初始化栈顶指针的值。<br>（1）当初始化为-1时，栈顶指针指向的是当前栈中的实际位置，而当初始化为为0时，栈顶指针指向的是下一次要插入的位置。<br>（2）在进行入栈和出栈的操作时，二者核心操作是相反的。<br>（3）在获取栈顶元素的操作中，如果初始化栈顶为0，那么需要先对指针减1才能取到栈顶元素的值，这点与初始化栈顶为-1时的操作有所不同。并且，如果函数定义中参数使用了引用传递，那么栈顶指针还需要再加1，保持栈顶指针原来的位置。如果使用值传递，则不需要，因为值传递不会改变原来的栈。</p>\n</blockquote>\n</li>\n<li><p>共享栈</p>\n<p><strong>顺序栈的缺点</strong>：栈的大小不可变。</p>\n<ul>\n<li>可以用链式存储的方式进行存储。</li>\n<li>也可以在初始化的时候就声明一个较大的存储空间。</li>\n</ul>\n<blockquote>\n<p>但我们知道，若一开始就申请较大空间的话，会造成空间的浪费。但是，我们可以通过<strong>共享栈</strong>的方式，来提高这一大片内存空间的利用率。</p>\n<p>共享栈的意思就是，两个栈共享同一片空间。</p>\n</blockquote>\n<p>我们可以设置两个栈顶指针。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-7.png\" style=\"zoom:75%;\" />\n\n<p>如果要往0号栈存放数据元素的话，是由下到上依次递增的；</p>\n<p>如果要往1号栈存放数据元素的话，是由上到下依次递减的。</p>\n<p>这两个栈，从逻辑上来说是两个不同的栈，但是在物理上，它们又共享同一片存储空间。这样就提高了空间利用率。</p>\n<p>共享栈也是会满的。判断共享栈是否满了的条件，就是看<code>top0 + 1 == top1</code></p>\n<p><a href=\"https://www.cxymm.net/article/zag666/105600288\">一文搞懂共享栈</a></p>\n</li>\n</ul>\n<p><font color='green'>用一个数组实现两个栈</font></p>\n<p><strong>思路</strong>:从 <strong>两头开始向中间生长</strong>，当两个栈的 <strong>栈顶指针相遇</strong> 时，表示两个栈都满了</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAXSIZE 100</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ElementType int</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ERROR -1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DStack</span> &#123;</span></span><br><span class=\"line\">    ElementType Data[MAXSIZE];</span><br><span class=\"line\">    <span class=\"type\">int</span> Top1;  <span class=\"comment\">// 栈 1 的栈顶指针</span></span><br><span class=\"line\">    <span class=\"type\">int</span> Top2;  <span class=\"comment\">// 栈 2 的栈顶指针</span></span><br><span class=\"line\">&#125; S;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Push</span><span class=\"params\">(<span class=\"keyword\">struct</span> DStack* PtrS, ElementType item, <span class=\"type\">int</span> Tag)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Tag 作为区分两个堆栈的标志，取值为 1 和 2 */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PtrS-&gt;Top2 - PtrS-&gt;Top1 == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;栈满\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Tag == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        PtrS-&gt;Data[++(PtrS-&gt;Top1)] = item;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        PtrS-&gt;Data[--(PtrS-&gt;Top2)] = item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ElementType <span class=\"title function_\">Pop</span><span class=\"params\">(<span class=\"keyword\">struct</span> DStack* PtrS, <span class=\"type\">int</span> Tag)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Tag 作为区分两个堆栈的标志，取值为 1 和 2 */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Tag == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (PtrS-&gt;Top1 == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;栈1空\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> PtrS-&gt;Data[(PtrS-&gt;Top1)--];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (PtrS-&gt;Top2 == MAXSIZE) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;栈2空\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> PtrS-&gt;Data[(PtrS-&gt;Top2)++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"栈的链式存储结构\"><a href=\"#栈的链式存储结构\" class=\"headerlink\" title=\"栈的链式存储结构\"></a>栈的链式存储结构</h3><ul>\n<li><p>采用链式存储的栈称为<font color='purple'>链栈</font>，其优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况</p>\n</li>\n<li><p>结点的类型定义</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StackNode</span> &#123;</span></span><br><span class=\"line\">  SElemType data;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StackNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125; StackNode, *LinkStack;</span><br></pre></td></tr></table></figure>\n\n<p>进栈和出栈操作就对应于单链表的插入和删除操作（只在头结点那一端进行）。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-112.png\" style=\"zoom:55%;\" />\n\n<p>那么对于单链表在头结点处的插入删除，我们在第二章已经讲的很详细了，这里就不再赘述。</p>\n<p>和单链表类似。对于链栈，我们也可以实现<strong>带头结点</strong>的版本，和<strong>不带头结点</strong>的版本，道理同单链表是一样的。</p>\n</li>\n<li><p>初始化</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stack <span class=\"title function_\">CreateStack</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 构建一个栈的头结点，返回指针 */</span></span><br><span class=\"line\">    Stack S;</span><br><span class=\"line\">    S = (Stack)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> SNode));</span><br><span class=\"line\">    S-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> S;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>入栈</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Push</span><span class=\"params\">(ElementType item, Stack S)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 将元素 item 压入栈 S */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SNode</span>* <span class=\"title\">TmpCell</span>;</span></span><br><span class=\"line\">    TmpCell = (<span class=\"keyword\">struct</span> SNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> SNode));</span><br><span class=\"line\">    TmpCell-&gt;Data = item;</span><br><span class=\"line\">    TmpCell-&gt;next = S-&gt;next;</span><br><span class=\"line\">    S-&gt;next = TmpCell;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>出栈</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">ElementType <span class=\"title function_\">Pop</span><span class=\"params\">(Stack S)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 删除并返回栈 S 的栈顶元素 */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SNode</span>* <span class=\"title\">FirstCell</span>;</span></span><br><span class=\"line\">    ElementType TopElem;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IsEmpty(S)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;栈空\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        FirstCell = S-&gt;next;</span><br><span class=\"line\">        S-&gt;next = FirstCell-&gt;next;</span><br><span class=\"line\">        TopElem = FirstCell-&gt;Data;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(FirstCell);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> TopElem;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>判栈空</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">IsEmpty</span><span class=\"params\">(Stack S)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 判断栈 S 是否为空，若为空函数返回整数 1，否则返回 0 */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (S-&gt;next == <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"习题\"><a href=\"#习题\" class=\"headerlink\" title=\"习题\"></a>习题</h3><ul>\n<li><p>【2010】若元素 abcdef 依次进栈，允许出栈、退栈操作交替进行，但不允许连续 3 次进行退栈操作，不可能得到的出栈序列是→D</p>\n<p>A. d c e b f a<br>B. c b d a e f<br>C. b c a e f d<br>D. a f e d c b</p>\n<blockquote>\n<p>选项A,可由a入栈，b入栈，c入栈，d入栈，<font color='red'>d出栈</font>，<font color='red'>c出栈</font>，e入栈，<font color='red'>e出栈</font>，<font color='red'>b出栈</font>，f入栈，<font color='red'>f出栈</font>，<font color='red'>a出栈</font>得到</p>\n<p>选项B,可由a入栈，b入栈，c入栈，<font color='red'>c出栈</font>，<font color='red'>b出栈</font>，d入栈，<font color='red'>d出栈</font>，<font color='red'>a出栈</font>，e入栈，<font color='red'>e出栈</font>，f入栈，<font color='red'>f出栈</font>得到</p>\n<p>选项C，可由a入栈，b入栈，<font color='red'>b出栈</font>，c入栈，<font color='red'>c出栈</font>，<font color='red'>a出栈</font>，d入栈，e入栈，<font color='red'>e出栈</font>，f入栈，<font color='red'>f出栈</font>，<font color='red'>d出栈</font>得到</p>\n<p>选项D，可由a入栈，<font color='red'>a出栈</font>，b入栈，c入栈，d入栈，e入栈，f入栈，<font color='red'>f出栈</font>，<font color='red'>e出栈</font>，<font color='red'>d出栈</font>，<font color='red'>c出栈</font>，<font color='red'>b出栈</font>得到  但不允许连续3次退栈</p>\n</blockquote>\n</li>\n<li><p>【2009】设栈S和队列Q的初始状态均为空，元素abcdefg依次进入栈S。若每个元素出栈后立即进入队列Q，且7个元素出队的顺序是bdcfeag，则栈S的容量至少是–&gt;3</p>\n<blockquote>\n<p>由于<strong>队列的特点是先进先出</strong>，即栈S的出栈顺序就是队Q的出队顺序。故本题只需注意栈的特点是先进后出。出入栈的详细过程见下表。</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>说明</th>\n<th>栈内</th>\n<th>栈外</th>\n<th>序号</th>\n<th>说明</th>\n<th>栈内</th>\n<th>栈外</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>a入栈</td>\n<td>a</td>\n<td></td>\n<td>8</td>\n<td>e入栈</td>\n<td>ae</td>\n<td>bdc</td>\n</tr>\n<tr>\n<td>2</td>\n<td>b入栈</td>\n<td>ab</td>\n<td></td>\n<td>9</td>\n<td>f入栈</td>\n<td>aef</td>\n<td>bdc</td>\n</tr>\n<tr>\n<td>3</td>\n<td>b出栈</td>\n<td>a</td>\n<td>b</td>\n<td>10</td>\n<td>f出栈</td>\n<td>ae</td>\n<td>bdcf</td>\n</tr>\n<tr>\n<td>4</td>\n<td>c入栈</td>\n<td>ac</td>\n<td>b</td>\n<td>11</td>\n<td>e出栈</td>\n<td>a</td>\n<td>bdcfe</td>\n</tr>\n<tr>\n<td>5</td>\n<td>d入栈</td>\n<td>acd</td>\n<td>b</td>\n<td>12</td>\n<td>a出栈</td>\n<td></td>\n<td>bdcfea</td>\n</tr>\n<tr>\n<td>6</td>\n<td>d出栈</td>\n<td>ac</td>\n<td>bd</td>\n<td>13</td>\n<td>g入栈</td>\n<td>g</td>\n<td>bdcfea</td>\n</tr>\n<tr>\n<td>7</td>\n<td>c出栈</td>\n<td>a</td>\n<td>bdc</td>\n<td>14</td>\n<td>g出栈</td>\n<td></td>\n<td>bdcfeag</td>\n</tr>\n</tbody></table>\n<p>栈内的最大深度为3，故栈S的容量至少是3。</p>\n<p>【另解】元素的出栈顺序是b，d，c，f，e，a，g，可推出进栈出栈顺序为Push(S,a)，Push(S,b)，Pop(S,b)，Push(S,c)，Push(S,d)，Pop(S,d)，Pop(S,c)，Push(S,e)，Push(S,f)，Pop(S,f)，Pop(S,e)，Pop(S,a)，Push(S,g)，Pop(S,g)。假设初始所需容量为0，每做一次Push进行一次“+1”操作，每做一次Pop进行一次“-1”操作，记录容量的最大值为3。</p>\n</blockquote>\n</li>\n<li><p>【2011】元素a,b,c,d,e依次进入初始为空的栈中，若元素进栈后可停留、可出栈，直到所有元素都出栈，则在所有可能的出栈序列中，以元素d开头的序列个数是–&gt;4</p>\n<blockquote>\n<p>考虑到题目要求是d先出栈，所以abcd的入栈顺序已经确定，e的入栈和出栈决定有几种顺序。 </p>\n<p>1.abcd依次入栈，d出栈，e入栈，然后剩下的出栈顺序为ecba </p>\n<p>2.abcd依次入栈，d出栈，c出栈，e入栈，e出栈，剩下的出栈顺序ba </p>\n<p>3.abcd依次入栈，d出栈，c出栈，b出栈，e入栈，e出栈，a出栈 </p>\n<p>4.abcd依次入栈，d出栈，c出栈，b出栈，a出栈，e入栈，e出栈，a出栈</p>\n</blockquote>\n</li>\n<li><p>【2013】一个栈的入栈序列为1,2,3,…,n,出栈序列是P1,P2,P3,…,Pn。若P2 = 3，则 P3 可能取值的个数是–&gt;(n-1)个</p>\n<blockquote>\n<p>首先，栈的先进后出原则大家应该是知道的。</p>\n<p>根据题意 P2 = 3，可以知道P1的可能情况有三种：<strong>1,2或4</strong> 。（看到有些人只想到了1，2）</p>\n<p>为啥这样想呢？这里估计还有一个关键是要<strong>考虑到 n 的大小</strong>。</p>\n<p><strong>当 n = 3 时</strong>， P2 = 3 的话，那么 P1 有两种情况 1 和 2 。</p>\n<ul>\n<li>如果 P1 = 1 ，那么 P3 = 2 ；</li>\n<li>如果 P1 = 2 ，那么 P3 = 1 ；</li>\n</ul>\n<p>此时的话我们就可以看到 P3 只有两种可能 1或者2       （n - 1）个。</p>\n<p><strong>当 n &gt; 3 时</strong>： P2 = 3 的话，那么 P1 有三种情况1,2和4。</p>\n<ul>\n<li>如果 P1 = 1 ，那么 P3 = 2，4，5，…  n     （n - 2）个    </li>\n<li>如果 P1 = 2 ，那么 P3 = 1，4，5，…  n     （n - 2）个    </li>\n<li>如果 P1 = 4 ，那么 P3 = 2，5，6，…  n     （n - 3）个  </li>\n</ul>\n<p>此时的话我们就可以看到 P3 的情况有 1，2，4，5，… n （n - 1）个。</p>\n<p>综上所述就是 P3 可能取值的个数是 （n - 1）个。</p>\n</blockquote>\n</li>\n<li><p>【2017】下列关于栈的叙述中，错误的是-&gt;I、Ⅲ、Ⅳ</p>\n<p>Ⅰ．采用非递归方式重写递归程序时必须使用栈 </p>\n<p>Ⅱ．函数调用时，系统要用栈保存必要的信息 </p>\n<p>Ⅲ．只要确定了入桟次序，即可确定出栈次序</p>\n<p>Ⅳ．栈是一种受限的线性表，允许在其两端进行操作</p>\n<blockquote>\n<p>I. 尾递归可以直接使用循环</p>\n<p>II.确定了入桟次序，不能确定出栈次序</p>\n<p>IV．栈是一种受限的线性表，允许在其一端（栈顶）进行操作</p>\n</blockquote>\n</li>\n<li><p>【2018】若栈S1中保存整数，栈S2中保存运算符，函数F()依次执行下述各步操作:</p>\n<p>（1）从S1中依次弹出两个操作数a和b；<br>（2）从S2中弹出一个运算符op；<br>（3）执行相应的运算b op a；<br>（4）将运算结果压入S1中。</p>\n<p>  假定S1中的操作数依次是5,8,3,2（2在栈顶），S2中的运算符依次是*,-,+（+在栈顶） </p>\n<p>  调用3次F()后，S1栈顶保存的值是–&gt;15</p>\n<blockquote>\n<p>S1第一次弹出a,b 即 2,3  S2 弹出 “ +”  操作为 b + a  即 （3 + 2） 压入 S1 现在 S1 为 5 8 5 </p>\n<p>S1第二次弹出a,b 即 5，8 S2弹出”-“ 操作为 b - a 即（8-5）压入S1 现在 S1 为 5 3 </p>\n<p>S1第三次弹出a,b 即 3,5  S2弹出 “<em>” 操作为 b</em>a  即 5*3 压入S 现在S1 为 15<br>所以三次后S1 栈顶为15</p>\n</blockquote>\n</li>\n<li><p>【2020】对空栈S进行Push和Pop操作，入栈序列为a,b,c,d,e，经过Push，Push，Pop，Push，Pop，Push，Push，Pop 操作后得到的出栈序列是–&gt;b,c,e</p>\n<blockquote>\n<p>根据题意，出入栈操作的过程如下:</p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>栈内元素</th>\n<th>出栈元素</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Push</td>\n<td>a</td>\n<td></td>\n</tr>\n<tr>\n<td>Push</td>\n<td>a b</td>\n<td></td>\n</tr>\n<tr>\n<td>Pop</td>\n<td>a</td>\n<td>b</td>\n</tr>\n<tr>\n<td>Push</td>\n<td>a c</td>\n<td></td>\n</tr>\n<tr>\n<td>Pop</td>\n<td>a</td>\n<td>c</td>\n</tr>\n<tr>\n<td>Push</td>\n<td>a d</td>\n<td></td>\n</tr>\n<tr>\n<td>Push</td>\n<td>a d e</td>\n<td></td>\n</tr>\n<tr>\n<td>Pop</td>\n<td>a d</td>\n<td>e</td>\n</tr>\n</tbody></table>\n<p>所以出栈元素序列为b,c,e</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"3-2-队列-Queue\"><a href=\"#3-2-队列-Queue\" class=\"headerlink\" title=\"3.2 队列 Queue\"></a>3.2 队列 Queue</h2><h3 id=\"队列的基本概念\"><a href=\"#队列的基本概念\" class=\"headerlink\" title=\"队列的基本概念\"></a>队列的基本概念</h3><h3 id=\"队列的定义\"><a href=\"#队列的定义\" class=\"headerlink\" title=\"队列的定义\"></a>队列的定义</h3><ul>\n<li><p>队列简称队，也是一种操作受限的线性表，<font color='orange'>只允许在表的一端进行插入，而在表的另一端进行删除</font></p>\n</li>\n<li><p>向队列中插入元素称为<strong>入队</strong>或<strong>进队</strong></p>\n</li>\n<li><p>删除元素称为<strong>出队</strong>或<strong>离队</strong></p>\n</li>\n<li><p>特性：先进先出 First In First Out, FIFO</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-8.png\" style=\"zoom: 75%;\" /></li>\n</ul>\n<h3 id=\"队列常见的基本操作\"><a href=\"#队列常见的基本操作\" class=\"headerlink\" title=\"队列常见的基本操作\"></a>队列常见的基本操作</h3><ul>\n<li>InitQueue(&amp;Q)：初始化队列。</li>\n<li>DestoryQueue(&amp;Q)：销毁队列。并释放队列Q所占用的内存空间。</li>\n<li>ClearQueue(&amp;Q)：清空队列。</li>\n<li>QueueLength(Q)：求队列长度。</li>\n<li>GetHead(Q,&amp;e)：得到队头元素，若队列Q非空，则将队头元素赋值给e。</li>\n<li>EnQueue(&amp;Q, e)：入队，若队列Q未满，将e加入，使之成为新的<font color='purple'>队尾</font>font&gt;。</li>\n<li>DeQueue(&amp;Q, &amp;e)：出队，若队列Q非空，删除<font color='purple'>队头</font>font&gt;元素，并用e返回。</li>\n<li>QueueEmpty(Q)：判队列空，若队列Q为空返回true，否则返回false。</li>\n</ul>\n<h3 id=\"队列的顺序存储结构\"><a href=\"#队列的顺序存储结构\" class=\"headerlink\" title=\"队列的顺序存储结构\"></a>队列的顺序存储结构</h3><h4 id=\"队列的顺序存储\"><a href=\"#队列的顺序存储\" class=\"headerlink\" title=\"队列的顺序存储\"></a>队列的顺序存储</h4><p>队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针：队头指针front指向队头元素。队尾指针rear指向队尾元素的下一个位置（其实和单链表有无头结点是一样的，队尾指针你想指向最后一个元素或者最后一个元素的下一位都行，注意相应的操作随之变动就行）。</p>\n<ul>\n<li><p><strong>结点类型定义</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAXSIZE 100 <span class=\"comment\">// 最大队列长度</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    QElemType *base; <span class=\"comment\">// 初始化的动态分配存储空间</span></span><br><span class=\"line\">    <span class=\"type\">int</span> front;       <span class=\"comment\">// 队头指针</span></span><br><span class=\"line\">    <span class=\"type\">int</span> rear;        <span class=\"comment\">// 队尾指针</span></span><br><span class=\"line\">&#125; SqQueue;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">testQueue</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    SqQueue Q;\t<span class=\"comment\">//声明一个队列（顺序存储）</span></span><br><span class=\"line\">    <span class=\"comment\">//......</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>初始状态（队空条件）：Q.front == Q.rear == 0。</p>\n<p>进队操作：队不满时，先送值到队尾元素，再将队尾指针加1。</p>\n<p>出队操作：队不空时，先去队头元素值，再将队头指针加1。</p>\n</li>\n<li><p><strong>初始化操作</strong></p>\n<p><code>InitQueue(&amp;Q)</code> : 初始化队列，构造一个空队列 Q</p>\n<p>我们可以规定，让队头指针指向队头元素；让队尾指针指向队尾元素的后一个位置（接下来应该插入数据元素的位置）。那么在初始化的时候，我们可以令队头、队尾指针均指向0。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 10\t\t\t\t\t<span class=\"comment\">// 定义队列中元素的最大个数</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    ELemType data[MaxSize];\t\t\t<span class=\"comment\">// 用静态数组存放队列元素</span></span><br><span class=\"line\">    <span class=\"type\">int</span> front,rear;\t\t\t\t\t<span class=\"comment\">// 队头指针和队尾指针</span></span><br><span class=\"line\">&#125;SqQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化队列</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitQueue</span><span class=\"params\">(SqQueue &amp;Q)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始时,队头、队尾指针指向0</span></span><br><span class=\"line\">    Q.rear = Q.front = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>队头指针 front 指向队头元素</p>\n</li>\n<li><p>队尾指针 rear 指向队尾元素的后一个位置(下一个应该插入的位置)</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-15.png\" style=\"zoom: 50%;\" /></li>\n</ul>\n</li>\n<li><p><strong>判断队列是否为空</strong></p>\n<p><code>QueueEmpty(Q)</code> : 判断队列是否为空，若队列Q为空则返回 true，否则返回 false</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 判断队列是否为空</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">QueueEmpty</span><span class=\"params\">(SqQueue Q)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.rear == Q.front)&#123;\t\t\t<span class=\"comment\">// 队空条件</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-16.png\" style=\"zoom: 50%;\" /></li>\n<li><p><strong>入队操作</strong></p>\n<p><code>EnQueue(&amp;Q,x)</code> : 入队，若队列 Q 未满，将 x 加入，使之称为新的队尾</p>\n<p>只能从队尾入队。把这一次要插入的数据元素，把它放到队尾指针所指向的位置。把队尾指针加1。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//入队</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">EnQueue</span><span class=\"params\">(SqQueue &amp;Q, ElemType x)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(队列已满) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t<span class=\"comment\">//队满则报错</span></span><br><span class=\"line\">\tQ.data[Q.rear] = x;\t<span class=\"comment\">//将x插入队尾</span></span><br><span class=\"line\">\tQ.rear = Q.rear + <span class=\"number\">1</span>;\t<span class=\"comment\">//队尾指针后移</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><font color='cornflowerblue'>那么我们是否可以认为，队列已满的条件，就是<code>rear == MaxSize</code>呢？</font></p>\n<p>并不是这样。</p>\n<p>因为，在<code>rear == MaxSize</code>的情况下，若队头出队了一些元素，则队列显然不满。但rear仍然是等于MaxSize的。</p>\n<p>同时，接下来的新元素，是要插入到队头元素之前的空位当中的。</p>\n<p><font color='cornflowerblue'>那么怎样让队尾指针指向接下来要插入的队头元素前的空位处呢？</font></p>\n<p>只需进行一个<strong>取余操作</strong>即可。</p>\n<p>看下列图</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-17.png\" style=\"zoom:55%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-19.png\" style=\"zoom:55%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-20.png\" style=\"zoom:55%;\" />\n\n<p>所以队尾指针 rear 其实是从队头指向队尾，再从队尾指向队头，这样循环移动。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-21.png\" style=\"zoom:55%;\" />\n\n<p>这样使用模运算将存储空间在逻辑上变成了 “<strong>环状</strong>”，我们也称之为<font color='red'>循环队列</font>(稍后引出)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 10\t\t\t\t\t<span class=\"comment\">// 定义队列中元素的最大个数</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">  ELemType data[MaxSize];\t\t\t<span class=\"comment\">// 用静态数组存放队列元素</span></span><br><span class=\"line\">    <span class=\"type\">int</span> front,rear;\t\t\t\t\t<span class=\"comment\">// 队头指针和队尾指针</span></span><br><span class=\"line\">&#125;SqQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 入队</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">EnQueue</span><span class=\"params\">(SqQueue &amp;Q,ElemeType x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((Q.rear + <span class=\"number\">1</span>)%MaxSize == Q.front)&#123;\t<span class=\"comment\">// 判断队满</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t\t\t\t\t\t<span class=\"comment\">// 队满则报错</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Q.data[Q.rear] = x;\t\t\t\t\t\t<span class=\"comment\">// 将 x 插入队尾</span></span><br><span class=\"line\">    Q.rear = (Q.rear + <span class=\"number\">1</span>)%MaxSize;\t\t\t<span class=\"comment\">// 队尾指针加1取模,用模运算将存储空间在逻辑上变成了&quot;环状&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么此时就可以知道，队列已满的条件为：队尾指针的下一个位置是队头，即<code>(Q.rear + 1) % MaxSize == Q.front</code>。</p>\n<blockquote>\n<p>此处，有些人会认为。队尾指针指向的就是“接下来应该插入元素的位置”，也就是队尾指针指向的位置是一个空闲空间。<strong>那么为什么队尾指针所指向的位置的下一个是队头时，就判满了呢？</strong>不是还有一个空间空间吗？如果“真正满了”的话，应该是队尾指针指向队头指针呀。</p>\n<p>要知道，队尾指针和队头指针相等，那是我们在初始化队列的时候，让队头指针和队尾指针指向同一个位置的。此外，我们也根据队尾指针与队头指针是否指向同一个位置，来判断队列是否为空。</p>\n</blockquote>\n<blockquote>\n<p>这样就没办法。所以我们必须牺牲一个存储单元。来将判满与判空区分开来。</p>\n</blockquote>\n</li>\n<li><p><strong>出队操作</strong></p>\n<p><code>DeQueue(&amp;Q,&amp;x)</code> : 出队，若队列 Q 非空，删除队头元素，并用 x 返回</p>\n<p>只能从队头出队</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-110.png\" style=\"zoom: 33%;\" />\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 10\t\t\t\t\t<span class=\"comment\">// 定义队列中元素的最大个数</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    ELemType data[MaxSize];\t\t\t<span class=\"comment\">// 用静态数组存放队列元素</span></span><br><span class=\"line\">    <span class=\"type\">int</span> front,rear;\t\t\t\t\t<span class=\"comment\">// 队头指针和队尾指针</span></span><br><span class=\"line\">&#125;SqQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 出队(删除一个队头元素,并用 x 返回)</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">DeQueue</span><span class=\"params\">(SqQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.rear ==Q.front)&#123;\t\t\t\t\t<span class=\"comment\">// 判断队空</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t\t\t\t\t\t<span class=\"comment\">// 队空则报错</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    X = Q.data[Q.front];</span><br><span class=\"line\">    Q.front = (Q.front +<span class=\"number\">1</span>)%MaxSize;\t\t\t<span class=\"comment\">// 队头指针后移</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;\t\t\t\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>获得队头元素值</strong></p>\n<p><code>GetHead(Q,&amp;x)</code> ：读取队头元素，若队列Q非空，则将队头元素</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 10\t\t\t\t\t<span class=\"comment\">// 定义队列中元素的最大个数</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    ELemType data[MaxSize];\t\t\t<span class=\"comment\">// 用静态数组存放队列元素</span></span><br><span class=\"line\">    <span class=\"type\">int</span> front,rear;\t\t\t\t\t<span class=\"comment\">// 队头指针和队尾指针</span></span><br><span class=\"line\">&#125;SqQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获得队头元素的值,用 x 返回</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">GetHead</span><span class=\"params\">(SqQueue Q,ElemType &amp;x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.rear == Q.front)&#123;\t\t\t<span class=\"comment\">// 判断队空</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;   \t\t\t<span class=\"comment\">// 队空则报错</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    X = Q.data[Q.front];\t\t\t<span class=\"comment\">// 获得队头元素值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>假溢出</strong></p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-11.png\" style=\"zoom:67%;\" />\n\n<p>(a)所示为队列的初始状态，有Q.front == Q.front == 0成立，该条件可以作为队列判空的条件。但能否用Q.rear == MaxSize作为队列满的条件呢？显然不能，图(d)中，队列中仅有一个元素，但仍然满足该条件，这时队列出现“上溢出”，按理说，此时就不能将其他元素加入队列。但这种溢出并不是真正的溢出，在data数组中仍然存在可以存放元素的空位置，所以这是一种“<font color='red'>假溢出</font>”。</p>\n</li>\n</ul>\n<h4 id=\"循环队列\"><a href=\"#循环队列\" class=\"headerlink\" title=\"循环队列\"></a>循环队列</h4><p>为了解决顺序队列的“<font color='red'>假溢出</font>”也就是空间只能用一次，严重浪费的问题，我们引出一个<strong>循环队列</strong>的概念。</p>\n<p>循环队列就是将顺序队列臆造为一个环状的空间，即把存储队列元素的表从逻辑上视为一个环（用链表来的指针来向下会清晰很多），称为循环队列。当队首指针<code>Q.front=MaxSize-1</code>后，再前进一个位置就自动到0，实现上可以用取余来实现。</p>\n<p>初始时：<code>Q.front = Q.rear = 0</code>;</p>\n<p>队首指针进1：<code>Q.front = (Q.front+1)%MaxSize</code></p>\n<p>队尾指针进1：<code>Q.rear = (Q.rear+1)%MaxSize</code></p>\n<p>对列长度：<code>（Q.rear+MaxSize-Q.front）%MaxSize</code></p>\n<p>出队入队时：指针都按顺时针方向进1。<br><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-12.png\" style=\"zoom:67%;\" /></p>\n<p>根据我们前面所述，队空的时候：<code>Q.front = Q.rear</code>；那这样的话考虑一下队满的时候咋表示，顺着思路走，位指针要指向队尾的下一个，那不就是：<code>Q.rear = Q.front</code> 。这样不就队空队满无法区分了吗？</p>\n<p><font color='orange'>为了区分队空队满的情况</font>，有以下三种处理方式：</p>\n<ol>\n<li><p>牺牲一个单元来区分队空还是队满，如队时少用一个队列单元，约定以“队头指针在队尾指针的下一位置作为队满的标志”。如图(d2)所示。</p>\n<p><strong>队满</strong>：<code>(Q.rear+1)%MaxSize  == Q.front</code>；</p>\n<p><strong>队空</strong>：<code>Q.front == Q.rear</code>。</p>\n<p><strong>队列中元素个数</strong>：<code>(Q.rear - Q.front + MaxSize)%MaxSize</code>。</p>\n</li>\n<li><p>类型中增设一个数据成员，专门记录队列中元素的个数。</p>\n</li>\n<li><p>类型中增设tag数据成员，以区分是队满还是队空。tag等于0时，若因删除导致<code>Q.front == Q.rear</code>，则为队空；tag等于1时，若因插入导致<code>Q.front == Q.rear</code>，则为队满。</p>\n</li>\n</ol>\n<p><font color='red'>接下来会具体谈到如何判断队列已满</font></p>\n<h4 id=\"循环队列的操作\"><a href=\"#循环队列的操作\" class=\"headerlink\" title=\"循环队列的操作\"></a>循环队列的操作</h4><ul>\n<li><p><strong>初始化</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitQueue</span><span class=\"params\">(SqQueue &amp;Q)</span>&#123;</span><br><span class=\"line\">    Q.base = new QElemType[MAXSIZE];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!Q.base) <span class=\"built_in\">exit</span>(OVERFLOW);</span><br><span class=\"line\">    Q.front = Q.rear = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>判队空</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">isEmpty</span><span class=\"params\">(SqQueue Q)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.rear == Q.front) <span class=\"comment\">// 队空条件</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-13.png\" style=\"zoom:67%;\" />\n\n<ul>\n<li><p><strong>入队</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">EnQueue</span><span class=\"params\">(SqQueue &amp;Q, QElemType e)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>((Q.rear+<span class=\"number\">1</span>) % MAXQSIZE == Q.front)  <span class=\"comment\">//判断队满</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 队满则报错</span></span><br><span class=\"line\">  Q.base[Q.rear] = e;<span class=\"comment\">//新元素插入队尾</span></span><br><span class=\"line\">  Q.rear = (Q.rear + <span class=\"number\">1</span>) % MAXQSIZE;<span class=\"comment\">//队尾指针加1取模  用模运算将存储空间在逻辑上变成了&quot;环状&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>出队</strong></p>\n<p><code>DeQueue(&amp;Q,&amp;x)</code> : 出队，若队列 Q 非空，删除队头元素，并用 x 返回</p>\n<p>只能从队头出队</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-22.png\" style=\"zoom:55%;\" />\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">DeQueue</span><span class=\"params\">(SqQueue &amp;Q, QElemType &amp;e)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(Q.rear == Q.front)  <span class=\"comment\">//判断队空</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 队空则报错</span></span><br><span class=\"line\">    e = Q.base[Q.front];</span><br><span class=\"line\">    Q.front = (Q.front + <span class=\"number\">1</span>) % MAXQSIZE;<span class=\"comment\">//队头指针后移</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-14.png\" style=\"zoom:67%;\" />\n\n<ul>\n<li><p><strong>获得队头元素</strong></p>\n<p><code>GetHead(Q,&amp;x)</code> ：读取队头元素，若队列Q非空，则将队头元素</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">GetHead</span><span class=\"params\">(SqQueue Q, ElemType &amp;e)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.rear==Q.front)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  <span class=\"comment\">//队空则报错</span></span><br><span class=\"line\">    e=Q.data[Q.front];<span class=\"comment\">//获得队头元素</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"判断队列已满-已空\"><a href=\"#判断队列已满-已空\" class=\"headerlink\" title=\"判断队列已满/已空\"></a>判断队列已满/已空</h4><p>我们前面说判断队列满的时候，不得不牺牲一个存储单元，否则就与我们的队空相互矛盾，但是有时候出题老师可不想让我们浪费这一个存储单元，所以判断队列已满/已空有两种方案</p>\n<ul>\n<li>方案一：浪费一个存储单元</li>\n<li>方案二：不浪费一个存储单元，用一个 size</li>\n<li>方案三：不浪费存储单元，用一个 tag 标记</li>\n</ul>\n<h5 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h5><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-26.png\" style=\"zoom:75%;\" />\n\n<ul>\n<li><p>队列已满的条件：队尾指针的再下一个位置是队头，即 <code>(Q.rear+1)%MaxSize == Q.front</code></p>\n</li>\n<li><p>队空的条件是：队尾指针和队头指针指向相同，<code>Q.rear == Q.front</code></p>\n</li>\n<li><p>队列元素个数：<code>(rear + MaxSize - front)%MaxSize</code></p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-23.png\" style=\"zoom: 67%;\" /></li>\n</ul>\n<p><font color='orange'>这种方案其实算是牺牲了一个存储空间来区分队满、队空</font></p>\n<h5 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h5><p><strong>但有时在题目中，不允许牺牲那一个存储空间，因此我们要另想一种方案</strong>:</p>\n<p>在队列的结构体类型中，额外定义一个属性<code>int size;</code>，用来表示队列当前长度。刚开始我们将size设为0，之后每次插入一个元素，就size++，每删除一个元素，就size–-。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-27.png\" style=\"zoom:75%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-24.png\" style=\"zoom: 55%;\" />\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-25.png\" style=\"zoom:55%;\" />\n\n<p>虽然队头和队尾指针都指向了同一位置，但是由于 size 的存在，所以仍然可以判断队列是满的还是空的。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 10\t\t\t\t\t<span class=\"comment\">// 定义队列中元素的最大个数</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    ELemType data[MaxSize];\t\t\t<span class=\"comment\">// 用静态数组存放队列元素</span></span><br><span class=\"line\">    <span class=\"type\">int</span> front,rear;\t\t\t\t\t<span class=\"comment\">// 队头指针和队尾指针</span></span><br><span class=\"line\">    <span class=\"type\">int</span> size;\t\t\t\t\t\t<span class=\"comment\">// 队列当前长度</span></span><br><span class=\"line\">&#125;SqQueue;</span><br><span class=\"line\"><span class=\"comment\">// 初始化队列</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitQueue</span><span class=\"params\">(SqQueue &amp;Q)</span>&#123;</span><br><span class=\"line\">    Q.rear = Q.front = <span class=\"number\">0</span>;<span class=\"comment\">// 初始时,队头、队尾指针指向0</span></span><br><span class=\"line\">    size = <span class=\"number\">0</span>;<span class=\"comment\">// 队列长度也为0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 入队</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">EnQueue</span><span class=\"params\">(SqQueue &amp;Q,ElemeType x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.size == MaxSize)&#123;\t\t\t\t\t<span class=\"comment\">// 判断队满</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t\t\t\t\t\t<span class=\"comment\">// 队满则报错</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Q.data[Q.rear] = x;\t\t\t\t\t\t<span class=\"comment\">// 将 x 插入队尾</span></span><br><span class=\"line\">    Q.rear = (Q.rear + <span class=\"number\">1</span>)%MaxSize;\t\t\t<span class=\"comment\">// 队尾指针加1取模,用模运算将存储空间在逻辑上变成了&quot;环状&quot;</span></span><br><span class=\"line\">    size++;\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 每一次入队成功我们让队列长度 + 1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 出队(删除一个队头元素,并用 x 返回)</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">DeQueue</span><span class=\"params\">(SqQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.size == <span class=\"number\">0</span>)&#123;\t\t\t\t\t\t<span class=\"comment\">// 判断队空</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t\t\t\t\t\t<span class=\"comment\">// 队空则报错</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    X = Q.data[Q.front];</span><br><span class=\"line\">    Q.front = (Q.front +<span class=\"number\">1</span>)%MaxSize;\t\t\t<span class=\"comment\">// 队头指针后移</span></span><br><span class=\"line\">    size--;\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 每一次出队成功我们让队列长度 - 1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;\t\t\t\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"方案三\"><a href=\"#方案三\" class=\"headerlink\" title=\"方案三\"></a>方案三</h5><p>在队列的结构类型中，定义一个<code>int tag;</code>，当tag为0的时候，表示最近一次执行的操作是删除操作；当tag为1的时候，表示最近一次执行的操作是插入操作。</p>\n<p>那么，也就是每次删除操作后，都将tag置为0；每次插入操作后，都将tag置为1。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-28.png\" style=\"zoom:75%;\" />\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 10\t\t\t\t\t<span class=\"comment\">// 定义队列中元素的最大个数</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    ELemType data[MaxSize];\t\t\t<span class=\"comment\">// 用静态数组存放队列元素</span></span><br><span class=\"line\">    <span class=\"type\">int</span> front,rear;\t\t\t\t\t<span class=\"comment\">// 队头指针和队尾指针</span></span><br><span class=\"line\">    <span class=\"type\">int</span> tag;\t\t\t\t\t\t<span class=\"comment\">// 最近进行的是删除(0)/插入(1)</span></span><br><span class=\"line\">&#125;SqQueue;</span><br><span class=\"line\"><span class=\"comment\">// 初始化队列</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitQueue</span><span class=\"params\">(SqQueue &amp;Q)</span>&#123;</span><br><span class=\"line\">    Q.rear = Q.front = <span class=\"number\">0</span>;<span class=\"comment\">// 初始时,队头、队尾指针指向0</span></span><br><span class=\"line\">    tag = <span class=\"number\">0</span>;<span class=\"comment\">// 标志为0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 入队</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">EnQueue</span><span class=\"params\">(SqQueue &amp;Q,ElemeType x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.front == Q.rear &amp;&amp; tag == <span class=\"number\">1</span>)&#123;\t\t<span class=\"comment\">// 判断队满,只有插入操作,才可能导致队满</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t\t\t\t\t\t<span class=\"comment\">// 队满则报错</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Q.data[Q.rear] = x;\t\t\t\t\t\t<span class=\"comment\">// 将 x 插入队尾</span></span><br><span class=\"line\">    Q.rear = (Q.rear + <span class=\"number\">1</span>)%MaxSize;\t\t\t<span class=\"comment\">// 队尾指针加1取模,用模运算将存储空间在逻辑上变成了&quot;环状&quot;</span></span><br><span class=\"line\">    tag == <span class=\"number\">1</span>;\t\t\t\t\t\t\t\t<span class=\"comment\">// 每次插入操作成功时,都令 tag = 1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 出队(删除一个队头元素,并用 x 返回)</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">DeQueue</span><span class=\"params\">(SqQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.front == Q.rear &amp;&amp; tag == <span class=\"number\">0</span>)&#123;\t\t<span class=\"comment\">// 判断队空,只有删除操作,才可能导致队空</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t\t\t\t\t\t<span class=\"comment\">// 队空则报错</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    X = Q.data[Q.front];</span><br><span class=\"line\">    Q.front = (Q.front +<span class=\"number\">1</span>)%MaxSize;\t\t\t<span class=\"comment\">// 队头指针后移</span></span><br><span class=\"line\">    tag == <span class=\"number\">0</span>;\t\t\t\t\t\t\t\t<span class=\"comment\">// 每次删除操作成功时,都令 tag = 0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;\t\t\t\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"其他出题方法\"><a href=\"#其他出题方法\" class=\"headerlink\" title=\"其他出题方法\"></a>其他出题方法</h4><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-114.png\" style=\"zoom:69%;\" />\n\n<p>还有一种出题方法，就是队尾指针 rear 指向的不是队尾元素的下一个，而是队尾元素的位置</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-113.png\" style=\"zoom: 33%;\" />\n\n<ul>\n<li><p>初始化</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化队列</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitQueue</span><span class=\"params\">(SqQueue &amp;Q)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始时,队头指针指向0,队尾指针指向 n - 1</span></span><br><span class=\"line\">    Q.front = <span class=\"number\">0</span>;</span><br><span class=\"line\">    Q.rear = n - <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-40.png\" style=\"zoom:55%;\" /></li>\n<li><p>入队操作</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 入队</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">EnQueue</span><span class=\"params\">(SqQueue &amp;Q,ElemeType x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((Q.rear + <span class=\"number\">1</span>)%MaxSize == Q.front)&#123;\t<span class=\"comment\">// 判断队满</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t\t\t\t\t\t<span class=\"comment\">// 队满则报错</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Q.rear = (Q.rear + <span class=\"number\">1</span>)%MaxSize;\t\t\t<span class=\"comment\">// 先将队尾指针向上移一位</span></span><br><span class=\"line\">    Q.data[Q.rear] = x;\t\t\t\t\t\t<span class=\"comment\">// 再将 x 插入队尾</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"队列的链式存储结构\"><a href=\"#队列的链式存储结构\" class=\"headerlink\" title=\"队列的链式存储结构\"></a>队列的链式存储结构</h3><h4 id=\"队列的链式存储\"><a href=\"#队列的链式存储\" class=\"headerlink\" title=\"队列的链式存储\"></a>队列的链式存储</h4><p>队列的链式表示称为<strong>链队列</strong>，它实际上是一个同时带有队头指针和队尾指针的单链表。 头指针指向队头结点，尾指针指向队尾结点，即单链表的最后一个结点（注意与顺序存储的不同）。</p>\n<p><strong>结点类型定义</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span>  <span class=\"comment\">//链式队列结点</span></span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;LinkNode;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span>  <span class=\"comment\">//链式队列</span></span><br><span class=\"line\">    LinkNode *front, *rear;  <span class=\"comment\">//队列的队头和队尾指针</span></span><br><span class=\"line\">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>\n\n<p>当<code>Q.front == NULL &amp;&amp; Q.rear == NULL</code>时，链式队列为空。</p>\n<p>出队时，首先判断队是否为空，若不空，则取出队头元素，将其从链表中华摘除，并让<code>Q.front = Q.front-&gt;next</code>；</p>\n<p>入队时，建立一个新的结点，将该结点插入到链表的尾部，并让<code>Q.rear = Q.rear-&gt;next</code>。</p>\n<p>从上述描述看出，出现了和顺序队列同样的问题，就是操作浪费空间（空间只能用一次），且耗时。</p>\n<h4 id=\"链式队列的基本操作\"><a href=\"#链式队列的基本操作\" class=\"headerlink\" title=\"链式队列的基本操作\"></a>链式队列的基本操作</h4><h5 id=\"带头结点\"><a href=\"#带头结点\" class=\"headerlink\" title=\"带头结点\"></a>带头结点</h5><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-29.png\" style=\"zoom:67%;\" />\n\n<ul>\n<li><p><strong>初始化</strong></p>\n<p>先申请一个结点，然后让队头指针 front、队尾指针 rear 都指向这个结点</p>\n<p>之后让此结点的指针域指向NULL</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-30.png\" style=\"zoom: 50%;\" />\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化队列(带头结点)</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitQueue</span><span class=\"params\">(LinkQueue &amp;Q)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始时, front、rear 都指向头结点</span></span><br><span class=\"line\">    Q.front = Q.rear = (LinkNode*)<span class=\"built_in\">malloc</span>(size(LinkNode));</span><br><span class=\"line\">    Q.front-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>判队空</strong></p>\n<p>判断队列是否为空，只需要看队头指针和队尾指针是否指向相同，指向相同队列为空，指向不相同队列不为空</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 判断队列是否为空(带头结点)</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">IsEmpty</span><span class=\"params\">(LinkQueue Q)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.front == Q.rear)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>入队</strong></p>\n<p>入队只能在队尾入队</p>\n<ul>\n<li>先申请一个结点s，将新入队元素 x 放入这个结点中</li>\n</ul>\n</li>\n</ul>\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-31.png\" style=\"zoom: 50%;\" />\n\n<ul>\n<li>将 s 结点的指针域指向 NULL，之后将 s 结点插入到 rear 之后</li>\n</ul>\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-32.png\" style=\"zoom: 50%;\" />\n\n<ul>\n<li>修改表尾指针为 s 结点</li>\n</ul>\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-33.png\" style=\"zoom: 50%;\" />\n\n  <figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 新元素入队(带头结点)</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EnQue</span><span class=\"params\">(LinkQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class=\"line\">    LinkNode *s =(LinkNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LinkNode));\t\t\t\t<span class=\"comment\">// 用 malloc 申请一个新结点</span></span><br><span class=\"line\">    s-&gt;data = x;\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 将 x 放入这个结点中</span></span><br><span class=\"line\">    s-&gt;next = <span class=\"literal\">NULL</span>;\t\t\t\t<span class=\"comment\">// 插入操作在表尾进行,新插入的结点x肯定是在表尾,所以将x结点指针域设为NULL</span></span><br><span class=\"line\">    Q.rear-&gt;next = s;\t\t\t\t\t\t<span class=\"comment\">// 新结点插入到 rear 之后</span></span><br><span class=\"line\">    Q.rear = s;\t\t\t\t\t\t\t\t<span class=\"comment\">// 修改表尾指针</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>出队</strong></p>\n<p>带头结点出队只能从队头出队</p>\n<ul>\n<li>申请一个新结点 p 指向头结点后面的一个结点(也就是队头结点)，用变量 x 返回队头结点元素</li>\n</ul>\n</li>\n</ul>\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-34.png\" style=\"zoom: 50%;\" />\n\n<ul>\n<li>修改头结点的 next 指针，使其指向 p 结点的下一个结点</li>\n</ul>\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-35.png\" style=\"zoom: 50%;\" />\n\n<ul>\n<li>如果出队的结点是最后一个结点，我们要修改队尾指针rear，让其指向头结点</li>\n</ul>\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-36.png\" style=\"zoom:45%;\" />\n\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-37.png\" style=\"zoom:45%;\" />\n\n<ul>\n<li>释放 p 结点</li>\n</ul>\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-38.png\" style=\"zoom: 50%;\" />\n\n  <figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 队头元素出队(不带头结点)</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">DeQueue</span><span class=\"params\">(LinkQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.front == Q.rear)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t\t\t\t\t\t<span class=\"comment\">// 空队</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LinkNode *p = Q.front-&gt;next;\t\t\t<span class=\"comment\">// 申请新结点p 指向头结点的后面一个结点</span></span><br><span class=\"line\">    x = p-&gt;data;\t\t\t\t\t\t\t<span class=\"comment\">// 用变量 x 返回队头元素</span></span><br><span class=\"line\">    Q.front-&gt;next = p-&gt;next;\t\t\t\t<span class=\"comment\">// 修改头结点的 next 指针</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.rear == p)&#123;\t\t\t\t\t\t<span class=\"comment\">// 如果此次是最后一个结点出队</span></span><br><span class=\"line\">        Q.rear = Q.front;\t\t\t\t\t<span class=\"comment\">// 修改 rear 指针</span></span><br><span class=\"line\">    &#125;\t\t</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(p);\t\t\t\t\t\t\t\t<span class=\"comment\">// 释放结点空间</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"不带头结点\"><a href=\"#不带头结点\" class=\"headerlink\" title=\"不带头结点\"></a>不带头结点</h5><img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-41.png\" style=\"zoom:67%;\" />\n\n<ul>\n<li><p>初始化</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-42.png\" style=\"zoom: 50%;\" />\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化队列(不带头结点)</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitQueue</span><span class=\"params\">(LinkQueue &amp;Q)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始时, front、rear 都指向NULL</span></span><br><span class=\"line\">    Q.front = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    Q.rear = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>判队列空</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 判断队列是否为空(不带头结点)</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">IsEmpty</span><span class=\"params\">(LinkQueue Q)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.front == <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>入队操作</p>\n<p>不带头结点的队列，第一个元素入队时需要特别处理</p>\n<ul>\n<li>先申请一个新结点 s，将新入队元素 x 放入这个结点中，将此结点的 next 指针域 指向 NULL</li>\n</ul>\n</li>\n</ul>\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-43.png\" style=\"zoom: 50%;\" />\n\n<ul>\n<li>需要判断如果这个队列为空，那么就意味着新结点 s 是这个队列的第一个结点，需要将 front、rear 都指向这个新结点 s</li>\n</ul>\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-44.png\" style=\"zoom: 50%;\" />\n\n<ul>\n<li>如果队列不为空，就是执行后插操作了</li>\n</ul>\n  <figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 新元素入队(不带头结点)</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EnQue</span><span class=\"params\">(LinkQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class=\"line\">    LinkNode *s =(LinkNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LinkNode));\t\t<span class=\"comment\">// 申请新结点</span></span><br><span class=\"line\">    s-&gt;data = x;\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 向此结点写入数据元素 x</span></span><br><span class=\"line\">    s-&gt;next = <span class=\"literal\">NULL</span>;\t\t\t\t<span class=\"comment\">// 插入操作在表尾进行,新插入的结点x肯定是在表尾,所以将x结点指针域设为NULL</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.front == <span class=\"literal\">NULL</span>)&#123;\t\t\t\t\t<span class=\"comment\">// 如果队列为空\t</span></span><br><span class=\"line\">        Q.front = s;\t\t\t\t\t\t<span class=\"comment\">// 不带头结点的队列，第一个元素入队时需要特别处理\t</span></span><br><span class=\"line\">        Q.rear = s;\t\t\t\t\t\t\t<span class=\"comment\">// 在空队列中插入第一个元素,修改队头队尾指针</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        Q.rear-&gt;next = s;\t\t\t\t\t\t<span class=\"comment\">// 新结点插入到 rear 之后</span></span><br><span class=\"line\">    \tQ.rear = s;\t\t\t\t\t\t\t\t<span class=\"comment\">// 修改表尾指针</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>出队操作</p>\n<p>不带头结点出队只能从队头出队</p>\n<ul>\n<li>首先申请新结点 p 指向此次出队的结点(队头结点)，用变量 x 返回队头元素</li>\n</ul>\n</li>\n</ul>\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-45.png\" style=\"zoom: 50%;\" />\n\n<ul>\n<li>修改队头指针 front 指向，需要将 front 、rear 指针指向 NULL(将其恢复为空队的状态)</li>\n</ul>\n  <img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-46.png\" style=\"zoom: 50%;\" />\n\n<ul>\n<li>释放结点 p</li>\n</ul>\n  <figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 队头元素出队(不带头结点)</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">DeQueue</span><span class=\"params\">(LinkQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.front == <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t\t\t\t\t\t\t\t<span class=\"comment\">// 空队</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LinkNode *p = Q.front;\t\t\t\t\t\t\t<span class=\"comment\">// 申请新结点 p 指向此次出队的结点</span></span><br><span class=\"line\">    x = p-&gt;data;\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 用变量 x 返回队头元素</span></span><br><span class=\"line\">    Q.front = p-&gt;next;\t\t\t\t\t\t\t\t<span class=\"comment\">// 修改 front 指针</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.rear == p)&#123;</span><br><span class=\"line\">        Q.front = <span class=\"literal\">NULL</span>;\t\t\t\t\t\t\t\t<span class=\"comment\">// front 指向 NULL</span></span><br><span class=\"line\">        Q.rear = <span class=\"literal\">NULL</span>;\t\t\t\t\t\t\t\t<span class=\"comment\">// rear 指向 NULL</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(P);\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 释放结点空间</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"队列满的条件\"><a href=\"#队列满的条件\" class=\"headerlink\" title=\"队列满的条件\"></a>队列满的条件</h5><p>之前顺序存储实现的队列，由于是用静态数组分配的，其空间是有限的、不可拓展的，所以其最大空间被耗尽时队满。</p>\n<p>而此处用链式存储实现的队列，它的容量是可以扩展的，一般不会队满，除非内存不足。</p>\n<p>因此，在顺序存储的队列当中，我们花了很多办法去判断队列是否已满；而在链式存储实现的队列当中，我们一般不用关心已满的问题。</p>\n<h3 id=\"双端队列\"><a href=\"#双端队列\" class=\"headerlink\" title=\"双端队列\"></a>双端队列</h3><ul>\n<li><p>双端队列是指<font color='orange'>允许两端都可以进行入队和出队操作的队列</font>，其元素的逻<font color='orange'>辑结构仍是线性结构</font>font&gt;</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-47.png\" style=\"zoom:67%;\" /></li>\n<li><p>将队列的两端分别称为前端和后端，两端都可以入队和出队</p>\n</li>\n<li><p>输出受限的双端队列：允许在一端进行插入和删除，另一端只允许插入</p>\n</li>\n<li><p>输入受限的双端队列：允许在一端进行插入和删除，另一端只允许删除</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-48.png\" style=\"zoom:67%;\" /></li>\n</ul>\n<blockquote>\n<p>若对于一个双端队列，我只使用其中一端的插入、删除操作，那么我的使用效果就等同于使用一个栈。</p>\n<p>也就是说，栈能够实现的功能，双端队列一定能实现。</p>\n<p>队列同理。</p>\n</blockquote>\n<p><strong>考点</strong></p>\n<p>此处双端队列比较喜欢考察的考点，就是<strong>判断输出序列的合法性</strong>。（类似于栈那里的考点）</p>\n<h3 id=\"习题-1\"><a href=\"#习题-1\" class=\"headerlink\" title=\"习题\"></a>习题</h3><ul>\n<li><p>【2010】某队列允许在其两端进行入队操作，但仅允许在一端进行出队操作。若元素a,b,c,d,e依次入此队列后再进行出队操作，则不可能得到的出队序列是-&gt;d b c a e</p>\n<blockquote>\n<p>双端队列的题可以用以下技巧： </p>\n<p>入队顺序为a b c d e，则出队顺序必然包含在序列e d c b a b c d e中，找出选项中不符合条件的序列即可。 </p>\n<ul>\n<li> A e d c <strong>b</strong> <strong>a</strong> b <strong>c d e</strong> 符合      </li>\n<li> B e <strong>d</strong> c <strong>b</strong> <strong>a</strong> b <strong>c</strong> d <strong>e</strong> 符合      </li>\n<li> C e <strong>d</strong> c <strong>b</strong> a b <strong>c</strong> d e 不符合      </li>\n<li> D <strong>e</strong> d <strong>c</strong> <strong>b a</strong> b c <strong>d</strong> e 符合</li>\n</ul>\n</blockquote>\n</li>\n<li><p>【2011】已知循环队列存储在一维数组A[0…n-1]中，且队列非空时front和rear分别指向队头元素和队尾元素。若初试队列为空，且要求第一个进入队列的元素存储在A[0]处，则初始时front和rear的值分别是→0，n-1</p>\n<blockquote>\n<p>循环队列需要留出一个空间，方便判断队列是否为满（循环队列解决假溢出）； </p>\n<p>常用的队列实现： </p>\n<p>当队列为空时，front == rear；其中rear指向队尾元素的下一个位置，即下一个元素入队的位置 </p>\n<p>入队操作：先赋值，再rear = (rear+1)%MAXSIZE；此时rear仍然指向队尾元素的下一个位置 </p>\n<p>但是题目中！！！有一句！！！front和rear分别指向队头元素和队尾元素！！！  </p>\n<p>rear指向队尾元素！！！  </p>\n<p>把常用的队列实现方法来了个886  </p>\n<p>那么，在这道题中，判断队满和队空我是一时半会想不下去了。。。（front == (rear + 1)%MAXSIZE 既可以是满，也可以是空啊= =，除非说还要留一个空间出来）  </p>\n<p>但是！！！  </p>\n<p>这道题说，初始时队列为空，无论如何还是front == (rear + 1)%MAXSIZE.  </p>\n<p>简单的说就是，队列是空的，rear指向队尾元素，front指向队头元素，入队了，（rear +1）%n，这个时候A[0]既是队头元素，也是队尾元素，rear = front = 0；所以是rear = n-1</p>\n</blockquote>\n</li>\n<li><p>【2014】循环队列放在一维数组A[0…M-1]中，end1指向队头元素，end2指向队尾元素的后一个位置。假设队列两端均可进行入队和出队操作，队列中最多能容纳M-1个元素。初始时为空。下列判断队空和队满的条件中，正确的是–&gt;队空：end1 == end2；                                  队满：end1 == (end2+1)mod M</p>\n<blockquote>\n<p>end1指向队头元素，那么可知出队的操作是先从A[end1]读数，然后end1再加1。end2指向队尾元素的后一个位置，那么可知入队操作是先存数到A[end2]，然后end2再加1。若把A[0]储存第一个元素，当队列初始时，入队操作是先把数据放到A[0]，然后end2自增，即可知end2初值为0；而end1指向的是队头元素，队头元素的在数组A中的下标为0，所以得知end1初值也为0，可知队空条件为end1==end2；然后考虑队列满时，因为队列最多能容纳M-1个元素，假设队列存储在下标为0到下标为M-2的M-1个区域，队头为A[0]，队尾为A[M-2]，此时队列满，考虑在这种情况下end1和end2的状态，end1指向队头元素，可知end1=0，end2指向队尾元素的后一个位置，可知end2=M-2+1=M-1，所以可知队满的条件为end1= =(end2+1)mod M</p>\n</blockquote>\n</li>\n<li><p>用链式存储方式的队列进行删除操作时需要→D</p>\n<p>A 仅修改头指针</p>\n<p>B 仅修改尾指针</p>\n<p>C 头尾指针都要修改</p>\n<p>D 头尾指针可能都要修改</p>\n<blockquote>\n<p>当队列元素&gt;1时，删除操作只修改头指针；当队列元素=1时，删除操作头尾指针都要修改</p>\n</blockquote>\n</li>\n<li><p>16 假设循环单链表表示的队列长度为n，队头固定在链表尾，若只设头指针，则进队操作的时间复杂度为→O(n)</p>\n</li>\n<li><p>【2018】现有队列Q与栈S，初始时Q中的元素依次是1,2,3,4,5,6(1在队头)，s为空。若仅允许下列3种操作:①出队并输出出队元素；②出队并将出队元素入栈；③出栈并输出出栈元素，则不能得到的输出序列是–&gt;C</p>\n<p>A. 1, 2, 5, 6, 4, 3</p>\n<p>B. 2, 3, 4, 5, 6, 1</p>\n<p>C. 3, 4, 5, 6, 1, 2</p>\n<p>D. 6, 5, 4, 3, 2, 1</p>\n<blockquote>\n<p>A的操作顺序为①①②②①①③③。B的操作顺序为②①①①①①③。D的操作顺序为②②②②②①③③③③③。对于C:首先输出3，说明1和2必须先依次入栈，而此后2肯定比1先输出，因此无法得到1，2的输出顺序。</p>\n</blockquote>\n</li>\n<li><p>【2016】设有如下图所示的火车车轨，入口到出口之间有n条轨道，列车的行进方向均为从左至右，列车可驶入任意一条轨道。现有编号为1～9的9列列车，驶入的次序依次是8，4，2，5，3，9，1，6，7。若期望驶出的次序依次为1~9，则n至少是–&gt;C</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-49.png\" style=\"zoom:50%;\" />\n\n<p>A.2       B.3<br>C.4       D.5</p>\n<blockquote>\n<p>将其视为多条队列，每条队列满足：先入队的元素小于**队的元素(如果8和4在同一队列，8在4的后面），这样8入队列1，4入队列2，2入队列3，5入队列2（也可以将5入队列3，但这时剩下的元素就必须放到一个新的队列中，无法使其“至少”），3入队列3，9入队列1，这时共占了3个队列，后面还有元素1，直接再占用一个新的队列4，1从队列4出队后，6、7可以入队到队列2、3、4，综上：最少占用4个队列。其中，确保满足：1）队列中后面的元素大于前面的元素；2）确保占用最少</p>\n</blockquote>\n</li>\n<li><p>【2021】初始为空的队列Q的一端仅能进行入队操作，另外一段既能进行入队操作又能进行出队操作。若Q的入队序列是1，2，3，4，5，则不能得到的出队序列是–&gt;D</p>\n<p>A. 5、4、3、1、2</p>\n<p>B. 5、3、1、2、4</p>\n<p>C. 4、2、1、3、5</p>\n<p>D. 4、1、3、2、5</p>\n<blockquote>\n<p>假设队列左端允许入队和出队，右端允许入队。对于A，依次从右端入队1,2，再从左端入队3,4,5。对于B，从右端入队1,2，然后从左端入队3，再从右端入队4，最后从左端入队5。对于C，从左端入队1,2，然后从右端入队3，再从左端入队4，最后从右端入队5。无法验证D的序列。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-124.png\" style=\"zoom: 67%;\" /></blockquote>\n</li>\n<li><p>综合题4【2019】请设计一个队列，要求满足：</p>\n<p>① 初始队列为空；</p>\n<p>② 入队时，允许增加队列占用空间；</p>\n<p>③ 出队后，出队元素所占用的空间可重复使用，即整个队列所占用的空间只增不减；</p>\n<p>④ 入队操作和出队操作的时间复杂度始终保持为O(1</p>\n<p>请回答下列问题</p>\n<p>① 该队列是选择链式存储结构，还是应选择顺序存储结构？</p>\n<p>② 画出队列的初始状态，并给出判断队空和队满的条件</p>\n<p>③ 画出第一个元素入队后的队列状态</p>\n<p>④ 给出入队操作和出队操作的基本过程  </p>\n<blockquote>\n<p>1）顺序存储无法满足要求②的队列占用空间随着入队操作而增加。根据要求来分析：要 求①容易满足；链式存储方便开辟新空间，要求②容易满足；对于要求③，出队后的结点并不 真正释放，用队头指针指向新的队头结点，新元素入队时，有空余结点则无须开辟新空间，赋 值到队尾后的第一个空结点即可，然后用队尾指针指向新的队尾结点，这就需要设计成一个首 尾相接的循环单链表，类似于循环队列的思想。设置队头、队尾指针后，链式队列的入队操作 和出队操作的时间复杂度均为 O(1)，要求④可以满足。 </p>\n<p>因此，采用链式存储结构（两段式单向循环链表），队头指针为 front，队尾指针为 rear。</p>\n<p>2）该循环链式队列的实现，可以参考循环队列，不同之处在于循环链式队列可以方便增 加空间，出队的结点可以循环利用，入队时空间不够也可以动态增加。同样，循环链式队列也 要区分队满和队空的情况，这里参考循环队列牺牲一个单元来判断。初始时，创建只有一个空 闲结点的循环单链表，头指针 front 和尾指针 rear 均指向空闲结点，如下图所示。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-50.png\" style=\"zoom:67%;\" />\n\n<p>队空的判定条件：<code>front == rear</code>。 队满的判定条件：<code>front == rear-&gt;next</code>。</p>\n<p>3）插入第一个元素后的状态如下图所示。</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-51.png\" style=\"zoom:67%;\" />\n\n<p>4）操作的基本过程如下:</p>\n<img src=\"https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-52.png\" style=\"zoom: 55%;\" /></blockquote>\n</li>\n</ul>\n","categories":["408数据结构"],"tags":["408数据结构"]}]