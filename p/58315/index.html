<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>第三章 栈、队列和数组(下) | 派总</title><meta name="keywords" content="408数据结构"><meta name="author" content="kailin2eis"><meta name="copyright" content="kailin2eis"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="3.3 栈和队列的应用栈在括号匹配中的应用问题分析在我们写代码的过程中，不论是大括号、小括号，还是中括号，它们总是成双成对的出现的。 我们如果只写了左括号，而没有写与它对应的右括号，那么编辑器就会检测出来错误。 此外，左括号、右括号除了在数量上要匹配以外，在形状上也要匹配。   遇到左括号就入栈，遇到右括号就出栈 例如：扫描下方括号，碰到左括号就将其压入栈底，碰到右括号就将其出栈匹配     这里">
<meta property="og:type" content="article">
<meta property="og:title" content="第三章 栈、队列和数组(下)">
<meta property="og:url" content="http://tikxeis.fun/p/58315/index.html">
<meta property="og:site_name" content="派总">
<meta property="og:description" content="3.3 栈和队列的应用栈在括号匹配中的应用问题分析在我们写代码的过程中，不论是大括号、小括号，还是中括号，它们总是成双成对的出现的。 我们如果只写了左括号，而没有写与它对应的右括号，那么编辑器就会检测出来错误。 此外，左括号、右括号除了在数量上要匹配以外，在形状上也要匹配。   遇到左括号就入栈，遇到右括号就出栈 例如：扫描下方括号，碰到左括号就将其压入栈底，碰到右括号就将其出栈匹配     这里">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://tikxeis.fun/img/1.png">
<meta property="article:published_time" content="2022-09-28T04:30:19.000Z">
<meta property="article:modified_time" content="2022-09-28T04:36:55.971Z">
<meta property="article:author" content="kailin2eis">
<meta property="article:tag" content="408数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tikxeis.fun/img/1.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://tikxeis.fun/p/58315/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第三章 栈、队列和数组(下)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-28 12:36:55'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/1.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">派总</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">第三章 栈、队列和数组(下)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-28T04:30:19.000Z" title="发表于 2022-09-28 12:30:19">2022-09-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-28T04:36:55.971Z" title="更新于 2022-09-28 12:36:55">2022-09-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/408%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">408数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="第三章 栈、队列和数组(下)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="3-3-栈和队列的应用"><a href="#3-3-栈和队列的应用" class="headerlink" title="3.3 栈和队列的应用"></a>3.3 栈和队列的应用</h2><h3 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h3><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>在我们写代码的过程中，不论是大括号、小括号，还是中括号，它们总是成双成对的出现的。</p>
<p>我们如果只写了左括号，而没有写与它对应的右括号，那么编辑器就会检测出来错误。</p>
<p>此外，左括号、右括号除了在数量上要匹配以外，在形状上也要匹配。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-53.png" style="zoom:67%;" />

<p><strong>遇到左括号就入栈，遇到右括号就出栈</strong></p>
<p>例如：扫描下方括号，碰到左括号就将其压入栈底，碰到右括号就将其出栈匹配</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-54.png" style="zoom: 50%;" />



<p>这里的算法演示动画非常好理解：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1b7411N798?p=26">王道考研 栈在括号匹配中的应用</a></p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-55.png" style="zoom: 50%;" />

<p><strong>流程图</strong>:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-56.png" style="zoom: 75%;" />

<h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 考试中可直接食用基本操作,建议简要说明接口</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10							<span class="comment">// 定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>							    </span><br><span class="line">    <span class="type">char</span> data[MaxSize];						<span class="comment">// 静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;								<span class="comment">// 栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack &amp;S)</span></span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack &amp;S)</span></span><br><span class="line"><span class="comment">// 新元素入栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S,<span class="type">char</span> x)</span></span><br><span class="line"><span class="comment">// 栈顶元素出栈,用x返回</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S,<span class="type">char</span> &amp;x)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 字符数组(存储括号字符)和字符数组长度  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">bracketCheck</span><span class="params">(<span class="type">char</span> str[],<span class="type">int</span> length)</span>&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    InitStack(S);							<span class="comment">// 初始化一个栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27;(&#x27;</span> || str[i] == <span class="string">&#x27;[&#x27;</span> || str[i] == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">            Push(S.str[i]);					<span class="comment">// 扫描到左括号,入栈</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(StackEmpty(S))&#123;				<span class="comment">// 扫描到右括号,且当前栈空</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;				<span class="comment">// 匹配失败</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span> topElem;</span><br><span class="line">            Pop(S,topElem);					<span class="comment">// 栈顶元素出栈</span></span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">&#x27;)&#x27;</span> &amp;&amp; topElem!= <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">&#x27;]&#x27;</span> &amp;&amp; topElem!= <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; topElem!= <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> StackEmpty(S);					<span class="comment">// 检索完全部括号后,栈空说明匹配成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意一个小问题</strong>：</p>
<p>由于我们要写的是括号匹配的算法实现，使用栈这种数据结构。</p>
<p>关键是要说明其中通过栈进行括号匹配的算法逻辑。</p>
<p>那么其中，栈的初始化、判空、入栈、出栈等操作，就可以不写详细细节，而直接使用。但是还是要简要声明操作函数的接口。用注释讲明其大概作用</p>
</blockquote>
<p>这种方法是用<strong>顺序存储</strong>的方式，有可能存满。其实实际开发的时候还是使用链栈为好。但是在考试的时候，使用顺序栈去写会更简单，也没什么问题。</p>
<h3 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h3><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-57.png" style="zoom:67%;" />

<p><strong>前缀表达式</strong>：前缀表达式(也叫波兰表达式)，运算符在两个操作数<strong>前面</strong></p>
<p><strong>后缀表达式</strong>：后缀表达式(也叫逆波兰表达式)，运算符在两个操作数<strong>后面</strong></p>
<p><strong>中缀表达式</strong>：运算符在两个操作数中间</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-58.png" style="zoom:67%;" />

<p><font color='cornflowerblue'>这里做一下解释：例如中缀表达式为：a + b - c</font></p>
<p><strong>后缀表达式计算</strong>：</p>
<ul>
<li><p>我们可以先计算 a + b，转换为后缀表达式为 ab+，再将 ab+ 作为一个整体与 c 进行减法操作，(ab+)-c</p>
<p>转换为后缀表达式为 ab+c-</p>
</li>
<li><p>我们也可以先计算 b - c，转换为后缀表达式为 bc-，再将 bc- 作为一个整体与 a 进行加法操作，a+(bc-)</p>
<p>转换为后缀表达式为 abc-+</p>
</li>
</ul>
<blockquote>
<p>这两个后缀表达式的结果，肯定都是正确的，表达的都是同一个中缀表达式。</p>
<p>但是，如果我们要用计算机来实现中缀转后缀的算法的话，我们只应该得到一种输出结果（因为算法应该具有确定性，即同样的输入只能得到同样的输出），那么实际上，用算法实现的结果，应该是前一种后缀表达式的结果。</p>
<p>以下几种情况同理。<strong>那么，怎样能够保证得到的是前一种后缀表达式的结果呢？</strong>接下来要提到“左优先“原则。</p>
</blockquote>
<p><strong>前缀表达式计算</strong>：</p>
<ul>
<li><p>我们可以先计算 a + b，转换为前缀表达式为 +ab，再将 +ab 作为一个整体与 c 进行减法操作，(+ab)-c</p>
<p>转换为前缀表达式为 -+abc</p>
</li>
<li><p>我们也可以先计算 b - c,转换为前缀表达式为 -bc，再将 -bc 作为一个整体与 a 进行加法操作，a+(-bc)</p>
<p>转换为前缀表达式为 +a-bc</p>
</li>
</ul>
<p><font color='orange'>这里做一下解释：例如中缀表达式为：a + b - c * d</font></p>
<p><strong>后缀表达式计算</strong>：</p>
<ul>
<li>我们可以先计算 a + b，转换为后缀表达式为 ab+，再接着计算 c * d，转换为后缀表达式为 cd* ，接着让 ab+ 和 cd * 分别作为两个整体进行减法操作，(ab+)-(cd*) 转换为后缀表达式为 ab+cd *-</li>
</ul>
<p><strong>前缀表达式计算</strong>：</p>
<ul>
<li>我们可以先计算 a + b，转换为前缀表达式为 +ab，再接着计算 c * d，转换为前缀表达式为 *cd，接着让 +ab 和 cd * 分别作为两个整体进行减法操作，(+ab)-(*cd) 转换为前缀表达式为 -+ab *cd</li>
</ul>
<h4 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h4><p><strong>方法</strong>：</p>
<ol>
<li>确定中缀表达式中各个运算符的运算顺序</li>
<li>选择下一个运算符，按照 [<strong>左操作数 右操作数 运算符</strong>] 的方式组合成一个新的操作数</li>
</ol>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-59.png" style="zoom: 85%;" />

<ul>
<li><p>左优先原则：只要左边的运算符能先计算，就优先算左边的。</p>
</li>
<li><p>我们知道运算符的运算顺序不唯一，对应的后缀表达式也不唯一。但是如果我们遵从左优先原则，那么就可以保证对应的后缀表达式唯一，而且机算也是按照左优先原则，这样我们就可以保证手算和机算的结果相同。</p>
</li>
<li><p>例如如下案例：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-60.png" style="zoom:69%;" /></li>
</ul>
<h5 id="后缀表达式的手算"><a href="#后缀表达式的手算" class="headerlink" title="后缀表达式的手算"></a>后缀表达式的手算</h5><p><font color='orange'>我们将中缀表达式转换为后缀表达式，我们怎么计算这个后缀表达式呢？</font></p>
<p><font color='cornflowerblue'>计算方法：从左往右扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对应运算，合体为一个操作数。</font></p>
<p>我们来看一个例子</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-61.png" style="zoom:67%;" />

<p>如上图后缀表达式</p>
<ul>
<li>我们从左向右扫描，先扫描到 ➕ 号，我们让 ➕ 号前面最近的两个操作数执行 ➕ 运算，合体为 2，于是变为 <ul>
<li>15 7 2 ➖ ➗ 3 ✖ 2 1 1 ➕ ➕ ➖</li>
</ul>
</li>
<li>我们继续将上述后缀表达式从左向右扫描，先扫描到 ➖ ，我们让 ➖ 前面最近的两个操作数执行 ➖ 运算，合体为 5<ul>
<li>15 5 ➗ 3 ✖ 2 1 1 ➕ ➕ ➖</li>
</ul>
</li>
<li>我们继续将上述后缀表达式从左向右扫描，先扫描到 ➗，我们让 ➗ 前面最近的两个操作数执行 ➗ 运算，合体为 3<ul>
<li>3 3 ✖ 2 1 1 ➕ ➕ ➖</li>
</ul>
</li>
<li>我们继续将上述后缀表达式从左向右扫描，先扫描到 ✖，我们让 ✖ 前面最近的两个操作数执行 ✖ 运算，合体为 9<ul>
<li>9 2 1 1 ➕ ➕ ➖</li>
</ul>
</li>
<li>我们继续将上述后缀表达式从左向右扫描，先扫描到 ➕，我们让 ➕ 前面最近的两个操作数执行 ➕ 运算，合体为 2<ul>
<li>9 2 2 ➕ ➖</li>
</ul>
</li>
<li>我们继续将上述后缀表达式从左向右扫描，先扫描到 ➕，我们让 ➕ 前面最近的两个操作数执行 ➕ 运算，合体为 4<ul>
<li>9 4 ➖</li>
</ul>
</li>
<li>最后从左向右扫描，扫描到 ➖，我们让 ➖ 前面最近的两个操作数执行 ➖ 运算，合体为 5<ul>
<li>5</li>
</ul>
</li>
<li>所以最终结果为 5</li>
</ul>
<h5 id="后缀表达式的机算"><a href="#后缀表达式的机算" class="headerlink" title="后缀表达式的机算"></a>后缀表达式的机算</h5><p>我们让运算符前面最近的两个操作数执行对应运算，最后出现的操作数最先被运算，这符合栈<strong>后进先出</strong>的特点，所以我们机算后缀表达式是用栈实现的。步骤如下:</p>
<p>①从左往右扫描下一个元素，直到处理完所有元素。</p>
<p>②若扫描到操作数，则压入栈，并回到①；否则执行③。</p>
<p>③若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到①。</p>
<p>例如：</p>
<ol>
<li><p>我们扫描如图的后缀表达式，扫描到 A，压入栈，扫描到 B，压入栈</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-62.png" style="zoom:67%;" /></li>
<li><p>扫描到运算符 +，弹出两个栈顶元素 B、A，执行 + 运算，A + B，再将运算结果压入栈顶</p>
<ul>
<li>注意,<font color='orange'>先出栈的是右操作数</font>，这里 B 先出栈，所以 B 为右操作数</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-63.png" style="zoom:67%;" /></li>
<li><p>接着继续从左向右扫描，扫描到 C，压入栈，扫描到 D，压入栈。</p>
<p>扫描到运算符 *，弹出两个栈顶元素 D、C，执行 * 运算，C * D，再将运算结果压入栈顶</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-64.png" style="zoom:67%;" /></li>
<li><p>接着继续从左向右扫描，扫描到 E，压入栈中。</p>
<p>扫描到运算符 / ，弹出栈顶元素 E、C*D，执行 / 运算，(C * D)/E，再将结果压入栈顶</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-65.png" style="zoom:67%;" />

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-66.png" style="zoom:67%;" /></li>
<li><p>接着扫描到运算符 -，弹出两个栈顶元素 (C * D)/E 、A+B，执行 - 操作，(A+B)-((C*D)/E)</p>
<p>将运算结果压入栈顶</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-67.png" style="zoom:67%;" /></li>
<li><p>接着从左向右扫描，扫描到 F ，压入栈</p>
<p>扫描到运算符 +，弹出两个栈顶元素 F、(A+B)-((C*D)/E)，执行 + 操作，(A+B)-((C * D)/E) + F</p>
<p>将结果压入栈顶</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-68.png" style="zoom:67%;" /></li>
<li><p>若表达式合法，则最后栈中只会留下一个元素，就是后缀表达式的最终结果</p>
</li>
</ol>
<blockquote>
<p>由于本例中的元素均设成未知数，所以最后计算出的后缀表达式的结果是一个中缀表达式。若有具体数的话则栈中只会有一个元素，即为运算结果。这种后缀表达式的机算方式可以粗略理解为将后缀转中缀后再计算。</p>
</blockquote>
<p><font color='red'>所以其实人喜欢看中缀表达式，计算机更喜欢看后缀表达式。</font></p>
<h4 id="后缀表达式转中缀表达式"><a href="#后缀表达式转中缀表达式" class="headerlink" title="后缀表达式转中缀表达式"></a>后缀表达式转中缀表达式</h4><p><font color='cornflowerblue'>我们知道了中缀表达式转换后缀表达式，那么后缀表达式如何转换为中缀表达式呢？</font></p>
<p>从左往右扫描，每遇到一个运算符，就让<font color='orange'>运算符插入前面最近的两个操作数之间，然后操作数两边带上括号</font></p>
<p>我们来看一个例子:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-69.png" style="zoom:67%;" />

<p>如上图后缀表达式:</p>
<ol>
<li>从左向右扫描，先扫描到运算符 ➕ ，变为栈在递归中的应用<ul>
<li>15 7 (1+1) ➖ ➗ 3 ✖ 2 1 1 ➕ ➕ ➖</li>
</ul>
</li>
<li>接着继续从左到右扫描，先扫描到运算符 ➖<ul>
<li>15 (7-(1+1)) ➗ 3 ✖ 2 1 1 ➕ ➕ ➖</li>
</ul>
</li>
<li>接着继续从左到右扫描，先扫描到运算符 ➗<ul>
<li>( 15 ÷ (7-(1+1)) ) 3 ✖ 2 1 1 ➕ ➕ ➖</li>
</ul>
</li>
<li>接着继续从左到右扫描，先扫描到运算符 ✖<ul>
<li>(( 15 ÷ (7-(1+1)) ) * 3) 2 1 1 ➕ ➕ ➖</li>
</ul>
</li>
<li>接着继续从左到右扫描，先扫描到运算符 ➕<ul>
<li>(( 15 ÷ (7-(1+1)) ) * 3) 2 (1+1) ➕ ➖</li>
</ul>
</li>
<li>接着继续从左到右扫描，先扫描到运算符 ➕<ul>
<li>(( 15 ÷ (7-(1+1)) ) * 3) (2+(1+1)) ➖</li>
</ul>
</li>
<li>接着继续从左到右扫描，先扫描到运算符 ➖<ul>
<li>(( 15 ÷ (7-(1+1)) ) * 3) - (2+(1+1))</li>
</ul>
</li>
</ol>
<h4 id="中缀表达式转前缀表达式"><a href="#中缀表达式转前缀表达式" class="headerlink" title="中缀表达式转前缀表达式"></a>中缀表达式转前缀表达式</h4><ul>
<li><p>①确定中缀表达式中<strong>各个运算符的运算顺序</strong>。</p>
</li>
<li><p>②选择下一个运算符，按照「<strong>运算符 左操作数 右操作数</strong>」的方式组合成一个新的操作数。</p>
</li>
<li><p>③如果还有运算符没被处理，就继续②。</p>
</li>
</ul>
<p>注意:</p>
<ul>
<li><p>中缀表达式转后缀表达式是 <strong>左优先</strong> 原则</p>
</li>
<li><p>中缀表达式转前缀表达式是 <strong>右优先</strong> 原则</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-70.png" style="zoom: 50%;" />

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-71.png" style="zoom: 50%;" /></li>
</ul>
<p>右优先原则：只要右边的运算符能先机算，就优先算右边的</p>
<h5 id="前缀表达式的机算"><a href="#前缀表达式的机算" class="headerlink" title="前缀表达式的机算"></a>前缀表达式的机算</h5><p>用栈实现前缀表达式的计算：</p>
<ul>
<li><p>①<strong>从右往左</strong>扫描下一个元素，直到处理完所有元素。</p>
</li>
<li><p>②若扫描到操作数，则压入栈，并回到①；否则执行③。</p>
</li>
<li><p>③若扫描到运算符，则弹出两个栈顶元素，执行响应运算，运算结果压回栈顶，回到①。</p>
</li>
</ul>
<p><strong>注意</strong>：先出栈的是“左操作数”。</p>
<h4 id="中缀表达式转后缀表达式机算"><a href="#中缀表达式转后缀表达式机算" class="headerlink" title="中缀表达式转后缀表达式机算"></a>中缀表达式转后缀表达式机算</h4><p>初始化一个栈，用于<font color='orange'>保存暂时还不能确定运算顺序的运算符</font>。</p>
<p>从左到右处理各个元素，直到末尾。可能遇到三种情况：</p>
<ol>
<li>遇到<strong>操作数</strong>。直接加入后缀表达式</li>
<li>遇到<strong>界限符</strong>。遇到左括号 <code>(</code> 直接入栈；遇到右括号 <code>)</code> 则依次弹出栈内运算符并加入后缀表达式，直到弹出左括号<code>(</code> 为止。注意：左括号<code>(</code> 不加入后缀表达式。</li>
<li>遇到<strong>运算符</strong>。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到 <code>(</code> 或栈空则停止。之后再把当前运算符入栈。</li>
</ol>
<p>按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</p>
<hr>
<p>我们来看一下例子：</p>
<ol>
<li><p>如下图的中缀表达式转后缀表达式，从左到右扫描</p>
<ul>
<li>先扫描到操作数 A，直接加入后缀表达式</li>
<li>再扫描到运算符 ➕，由于栈是空栈，所以将运算符 ➕ 入栈</li>
<li>再扫描到操作数 B，直接加入后缀表达式</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-72.png" style="zoom:70%;" /></li>
<li><p>继续从左到右扫描</p>
<ul>
<li>扫描到运算符 ➖，此时栈中有运算符 ➕，加号和减号的运算符优先级相同，则弹出 ➕，并加入后缀表达式，此时后缀表达式为 AB+，此时栈空，将运算符 ➖ 入栈</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-73.png" style="zoom:70%;" /></li>
<li><p>继续从左到右扫描</p>
<ul>
<li>扫描到操作数 C，直接加入后缀表达式，此时后缀表达式为 AB+C</li>
<li>扫描到运算符 <code>*</code> ，栈中此时只有 ➖ 减法运算符，没有比乘法运算符优先级高的，所以将 <code>*</code> 压入栈中</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-74.png" style="zoom:70%;" /></li>
<li><p>继续从左到右扫描</p>
<ul>
<li>扫描到操作数 D，直接加入后缀表达式，此时后缀表达式为 AB+CD</li>
<li>扫描到运算符<code>/</code>，此时栈中有 <code>*</code> <code>-</code> 两个运算符，乘法运算符和除法运算符优先级相同，所以将 <code>*</code> 乘法运算符弹出，并加入后缀表达式，此时后缀表达式为 AB+CD*</li>
<li>此时栈中只剩下 <code>-</code> 减法运算符，没有比 <code>/</code> 除法运算符优先级更高或相同的了，所以将 <code>/</code> 除法运算符压入栈中</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-75.png" style="zoom:70%;" /></li>
<li><p>继续从左到右扫描</p>
<ul>
<li>扫描到操作数 E，直接加入后缀表达式，此时后缀表达式为 AB+CD*E</li>
<li>扫描到运算符 ➕，此时栈中有 <code>/</code> <code>-</code> 两个运算符，依次弹出栈中优先级高于或等于 ➕ 加号运算符的所有运算符，所以将 <code>/</code> <code>-</code> 依次弹出并加入后缀表达式，此时后缀表达式为 AB+CD*E/-</li>
</ul>
</li>
<li><p>继续从左到右扫描</p>
<ul>
<li>扫描到操作数 F，直接加入后缀表达式，此时后缀表达式为 AB+CD*E/-F</li>
<li>扫描完成，将栈中剩余运算符弹出栈并加入后缀表达式，所以弹出 ➕ 运算符并加入后缀表达式，最终后缀表达式为AB+CD*E/-F+</li>
</ul>
</li>
</ol>
<hr>
<p><strong>我们接着来看一个带有界限符的例子</strong>：</p>
<ol>
<li><p>如下图的中缀表达式转后缀表达式，从左到右扫描</p>
<ul>
<li>扫描到操作数 A， 直接加入后缀表达式。</li>
<li>扫描到运算符 ➕，此时栈为空，所以入栈。</li>
<li>扫描到操作数 B，直接加入后缀表达式。</li>
<li>扫描到运算符 <code>*</code> ，此时栈中只有加法运算符 ➕，没有比 <code>*</code> 乘法运算符优先级更高或相同的，所以将 <code>*</code> 入栈。</li>
<li>扫描到左括号 <code>(</code> ，直接入栈。</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-76.png" style="zoom:67%;" /></li>
<li><p>继续从左到右扫描</p>
<ul>
<li>扫描到操作数 C，直接加入后缀表达式。</li>
<li>扫面描到运算符 ➖，此时本该依次弹出运算符高于或等于 ➖ 运算符的所有运算符，但是由于碰到了左括号<code>(</code> ，所以停止进行弹出。将 ➖ 减法运算符压入栈中。</li>
<li>扫描到操作数 D，直接加入后缀表达式。</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-77.png" style="zoom: 67%;" /></li>
<li><p>继续从左到右扫描</p>
<ul>
<li>扫描到右括号 <code>)</code> ，则依次弹出栈内运算符并加入后缀表达式，直到遇到左括号 <code>(</code> 为止。</li>
<li>所以先弹出 ➖ 运算符，加入后缀表达式。</li>
<li>再弹出左括号<code>(</code> ，但是<strong>左括号不加入后缀表达式</strong>。</li>
<li>所以此时后缀表达式为 ABCD-。</li>
<li>此时栈中运算符有 <code>*</code> <code>+</code>。</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-78.png" style="zoom:67%;" /></li>
<li><p>继续从左到右扫描</p>
<ul>
<li>扫描到 ➖ 运算符，依次弹出优先级高于或者等于 ➖ 运算符并加入后缀表达式中</li>
<li>所以将 <code>*</code> <code>+</code> 运算符弹出并加入后缀表达式，此时后缀表达式为 ABCD-*+</li>
<li>然后将扫描到的 ➖ 运算符加入栈中</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-79.png" style="zoom:67%;" /></li>
<li><p>继续从左到右扫描</p>
<ul>
<li>扫描到操作数 E，直接加入后缀表达式</li>
<li>扫描到运算符 <code>/</code> ，栈中没有优先级高于或者等于 <code>/</code> 除法运算符的，所以将 <code>/</code> 压入栈</li>
<li>扫描到 F，直接加入后缀表达式，此时后缀表达式为 ABCD-*+EF</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-80.png" style="zoom:67%;" /></li>
<li><p>最后将栈中剩余运算符依次弹出，并加入后缀表达式</p>
<ul>
<li>所以最终的后缀表达式为：ABCD-*+EF/-</li>
</ul>
</li>
</ol>
<h4 id="中缀表达式的计算-用栈实现"><a href="#中缀表达式的计算-用栈实现" class="headerlink" title="中缀表达式的计算(用栈实现)"></a>中缀表达式的计算(用栈实现)</h4><p>用栈实现中缀表达式的计算</p>
<p>初始化两个栈，<strong>操作数栈</strong>和<strong>运算符栈</strong>。</p>
<ul>
<li>若扫描到操作数，则压入操作数栈</li>
<li>若扫描到运算符或界限符，则按照 “中缀转后缀” 相同的逻辑压入运算符栈(<font color='orange'>期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈</font>)</li>
</ul>
<hr>
<p>我们来看一个例子:</p>
<ol>
<li><p>我们从左向右扫描中缀表达式</p>
<ul>
<li>扫描到操作数 A，压入操作数栈</li>
<li>扫描到运算符 ➕，此时栈为空，则压入栈</li>
<li>扫描到操作数 B，压入操作数栈</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-81.png" style="zoom:67%;" /></li>
<li><p>继续从左向右扫描</p>
<ul>
<li>扫描到运算符 ➖，弹出栈中优先级高于或等于 ➖ 运算符的所有运算符<ul>
<li>所以弹出 ➕ 运算符，并将扫描到的运算符 ➖ 压入运算符栈</li>
</ul>
</li>
<li>每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈<ul>
<li>所以弹出 B、A，运算结果为 A + B，然后将运算结果压回操作数栈。</li>
</ul>
</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-82.png" style="zoom:67%;" /></li>
<li><p>继续从左向右扫描</p>
<ul>
<li>扫面描到操作数 C，压入操作数栈中</li>
<li>扫描到运算符 <code>*</code> ，运算符栈中没有优先级高于或者等于 <code>*</code> 乘法运算符的，所以将 <code>*</code> 压入运算符栈</li>
<li>扫描到操作数 D，压入操作数栈中</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-83.png" style="zoom:67%;" /></li>
<li><p>继续从左向右扫描</p>
<ul>
<li>扫描到运算符 <code>/</code>，弹出运算符优先级高于或者等于 <code>/</code> 除号运算符的所有运算符，并将扫描到的 <code>/</code> 压入运算符栈</li>
<li>运算符栈中此时有 <code>*</code> <code>-</code> 两个运算符，所以弹出 <code>*</code> 乘法运算符</li>
<li>每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈</li>
<li>所以弹出 D、C 两个操作数，并执行 * 运算，运算结果为 C * D，将运算结果压入操作数栈中</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-84.png" style="zoom:67%;" /></li>
<li><p>继续从左向右扫描</p>
<ul>
<li>扫描到操作数 E，直接压入操作数栈</li>
<li>扫描到运算符 ➕，弹出运算符优先级高于或者 ➕ 加法运算符的所有运算符，并将扫描到的运算符 ➕ 压入运算符栈</li>
<li>所以将 / 除法运算符弹出，一个运算符弹出则需要两个操作数栈的栈顶元素弹出，运算结果为 (C*D)/E，然后将运算结果压入操作数栈</li>
<li>之后将 - 减法运算符弹出，一个一个运算符弹出则需要两个操作数栈的栈顶元素弹出，运算结果为 (A+B)-((C*D)/E) ,然后将运算结果压入操作数栈</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-85.png" style="zoom:67%;" /></li>
<li><p>继续从左向右扫描</p>
<ul>
<li>扫描到操作数 F，直接压入操作数栈</li>
<li>扫描中缀表达式完成，运算符栈中还有 ➕ 运算符，弹出 ➕ 运算符，对应弹出两个操作数栈的栈顶元素进行计算，则最终结果为 (A+B)-((C*D)/E)+F</li>
</ul>
</li>
</ol>
<h3 id="栈在递归中的应用"><a href="#栈在递归中的应用" class="headerlink" title="栈在递归中的应用"></a>栈在递归中的应用</h3><p><strong>函数调用的特点</strong>：最后被调用的函数最先执行结束(LIFO)</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-86.png" style="zoom:75%;" />

<p>例如，对于上述函数调用</p>
<ol>
<li>开始运行main函数，将main函数里面的返回地址、实参、局部变量先压入栈中</li>
<li>执行func1函数，将其返回地址、实参、局部变量再压入栈中</li>
<li>执行func2函数，将其返回地址、实参、局部变量再压入栈中</li>
</ol>
<hr>
<p>计算正整数的阶乘n！</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-87.png" style="zoom:67%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算正整数的阶乘n！</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n*factorial(n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x = factorial(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(x);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归算法可以把原始问题转换为属性相同，但规模较小的问题</p>
<p>每进入一层递归，就将递归调用所需信息压入栈顶；每退出一层递归，就从栈顶弹出相应信息</p>
<p><strong>缺点</strong>：太多层递归可能会导致栈溢出</p>
<h3 id="队列在层次遍历中的应用"><a href="#队列在层次遍历中的应用" class="headerlink" title="队列在层次遍历中的应用"></a>队列在层次遍历中的应用</h3><p>树的层次遍历(在”树”章节)</p>
<p>图的层次遍历(在”图”章节)</p>
<h3 id="队列在操作系统中的应用"><a href="#队列在操作系统中的应用" class="headerlink" title="队列在操作系统中的应用"></a>队列在操作系统中的应用</h3><p>多个进程争抢着使用有限的系统资源时，FCFS(First Come First Service,<strong>先来先服务</strong>)是一种常用策略</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-88.png" style="zoom:67%;" />

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-89.png" style="zoom:67%;" />

<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><ul>
<li><p>【2009】为解决计算机主机与打印机之间速度不匹配的问题，通常设置一个打印数据缓冲区，主机将要输出的数据依次写入该缓冲区，而打印机则依次从该缓冲区中取出数据。该缓冲区的逻辑结构应该是→B</p>
<p>A 栈<br>B 队列<br>C 树<br>D 图 </p>
<blockquote>
<p>这是典型的一种队列结构，一端放入另一端依次取出，也就是先进入的先取出</p>
</blockquote>
</li>
<li><p>执行什么操作时，需要使用队列作为辅助存储空间→B</p>
<p>A 查找散列（哈希）表<br>B 广度优先搜索图<br>C 前序（根）遍历二叉树<br>D 深度优先搜索图 </p>
</li>
<li><p>【2012】已知操作符包括+、-、_、/、(和)。将中缀表达式<code>a + b - a * ( ( c + d) / e - f ) + g </code>转换为等价的后缀表达式<code>a b + a c d + e / f - * - g + </code>时，用栈来存放暂时还不能确定运算次序的操作符。若栈初始为空，则转换过程中同时保存在栈中的操作符的最大个数是 →5</p>
<blockquote>
<p>写成伪代码是这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span> 操作符栈;</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span> to n&#123;</span><br><span class="line">	<span class="keyword">if</span> 当前操作符是操作数</span><br><span class="line">		直接打印;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> 当前操作符是操作符&#123;</span><br><span class="line">		<span class="keyword">if</span> 当前操作符是<span class="string">&#x27;(&#x27;</span></span><br><span class="line">			压入栈内;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> 当前操作符是<span class="string">&#x27;)&#x27;</span></span><br><span class="line">			不断弹出并打印栈顶元素直至栈顶为<span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">			弹出栈顶;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> 当前操作符优先级高于栈顶操作符 || 栈为空</span><br><span class="line">			压入栈内;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			不断弹出并打印栈顶元素直至栈顶优先级不大于当前元素;</span><br><span class="line">			当前操作符入栈;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">打印栈中剩余操作符; </span><br></pre></td></tr></table></figure>

<p>优先级从低至高：(、+、-、*、/、^</p>
<p>回到本题，流程如下：（数字标明当前栈中元素个数）</p>
<ol>
<li>遇+，入栈，1个</li>
<li>遇-，-的优先级不大于+，弹出+，压入-，1个</li>
<li>遇 *， * 的优先级大于-，入栈，2个</li>
<li>遇(，入栈，3个</li>
<li>遇(，入栈，4个</li>
<li>遇+，+的优先级大于(，入栈，5个</li>
<li>遇)，弹出+，弹出(，3个</li>
<li>遇/，/的优先级大于(，入栈，4个</li>
<li>遇-，-的优先级不大于/，弹出/，压入-，4个</li>
<li>遇)，弹出-，弹出(，2个</li>
<li>遇+，+的优先级不大于*，弹出 *，压入+，2个</li>
</ol>
<p>操作符遍历完毕，栈中最后自底而上为-和+，依次弹出。</p>
<p>综上，栈中元素最多的时候有5个</p>
</blockquote>
</li>
<li><p>【2014】假设栈初始为空，将中缀表达式 <code>a / b + ( c * d - e * f ) / g</code> 转化为等价 的后缀表达式的过程中，当扫描到 f 时，栈中的元素依次是 →<code>+ ( - *</code></p>
<blockquote>
<p>将中缀表达式转换为后缀表达式的算法思想如下：从左向右开始扫描中缀表达式；  </p>
<p>遇到数字时，加入后缀表达式；遇到运算符时：  </p>
<p>a. 若为’(‘，入栈；  </p>
<p>b. 若为’)’，则依次把栈中的的运算符加入后缀表达式中，直到出现’(‘，从栈中删除’(‘ ；  </p>
<p>c. 若为除括号外的其他运算符，当其优先级高于除’(‘以外的栈顶运算符时，直接入栈。否则从栈顶开始，依次弹出比当前处理的运算符优先级高和优先级相等的运算符，直到一个比它优先级低的或者遇到了一个左括号为止。  </p>
<p>当扫描的中缀表达式结束时，栈中的所有运算符依次出栈加入后缀表达式。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-90.png" style="zoom:67%;" />

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-91.png" style="zoom: 80%;" />

<p>由此可知，当扫描到f 的时候，栈中的元素依次是+(-*，选B。 </p>
<p>在此，再给出中缀表达式转换为前缀或后缀表达式的一种手工做法，以上面给出的中缀表达式为例： </p>
<p>第一步：按照运算符的优先级对所有的运算单位加括号。式子变成了：<code>((a/b)+(((c*d)-(e*f))/g))</code> </p>
<p>第二步：转换为前缀或后缀表达式。 </p>
<p>前缀：把运算符号移动到对应的括号前面，则变成了：<code>+(/(ab)/(-(*(cd)*(ef))g))</code> 把括号去掉：<code>+/ab/-*cd*efg</code> 前缀式子出现。 </p>
<p>后缀：把运算符号移动到对应的括号后面，则变成了：<code>((ab)/(((cd)*(ef)*)-g)/)+</code> 把括号去掉：<code>ab/cd*ef*-g/+</code> 后缀式子出现。 </p>
<p>当题目要求直接求前缀或后缀表达式时，这种方法会比上一种快捷得多。</p>
</blockquote>
</li>
<li><p>【2015】已知程序如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">S</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (n&lt;=<span class="number">0</span>)?<span class="number">0</span>:s(n<span class="number">-1</span>) +n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;S(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行时使用栈来保存调用过程的信息，自栈底到栈顶保存的信息依次对应的是-&gt;</p>
<p>main()→S(1)→S(0)</p>
<blockquote>
<p>1.程序执行顺序main()-&gt;S(1)-&gt;S(2)。 </p>
<p>2.函数在调用过程中PC（程序计数器）的操作是保护现场-&gt;将所有数据拷贝到栈-&gt;跳转到子函数 </p>
<p>3.根据栈的数据结构的特点（首先栈的数据结构是处理函数调用这个情况最好的办法），先入后出，因此，栈底为main()，栈顶为S(1)</p>
</blockquote>
</li>
</ul>
<h2 id="3-4-特殊矩阵和压缩存储"><a href="#3-4-特殊矩阵和压缩存储" class="headerlink" title="3.4 特殊矩阵和压缩存储"></a>3.4 特殊矩阵和压缩存储</h2><h3 id="数组的存储结构"><a href="#数组的存储结构" class="headerlink" title="数组的存储结构"></a>数组的存储结构</h3><h4 id="一维数组的存储结构"><a href="#一维数组的存储结构" class="headerlink" title="一维数组的存储结构"></a>一维数组的存储结构</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-92.png" style="zoom:67%;" />

<p>各数组元素大小相同，且物理上连续存放。</p>
<p>因此，只需要知道其起始地址，就可以知道任何一个数组下标所对应元素的存放地址是多少。</p>
<h4 id="二维数组的存储结构"><a href="#二维数组的存储结构" class="headerlink" title="二维数组的存储结构"></a>二维数组的存储结构</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-93.png" style="zoom:67%;" />

<p>在内存空间中存储时，由于要进行线性存储，因此要将逻辑上的非线性给改变为线性的存储模式。因此，有两种存储策略：<strong>行优先存储</strong>、<strong>列优先存储</strong>。</p>
<ul>
<li>行优先：先存行，一行存完存第二行</li>
<li>列优先：先存列，一列存完存第二列</li>
</ul>
<p><font color='orange'>我们采用行优先或者列优先的存储方式存放二维数组，这样我们就可以通过二维数组的行号和列号来计算出这个元素所对应的存储地址。</font></p>
<h5 id="行优先"><a href="#行优先" class="headerlink" title="行优先"></a>行优先</h5><p>我们来看行优先的一个例子</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-94.png" style="zoom:70%;" />

<p>(i*N+j)指的是 b[i] [j] 之前有多少个元素，每个元素再乘存储空间，就是 b[i] [j] 元素前面的存储空间</p>
<p>再加上起始地址 LOC，就得到 b[i] [j] 的存储地址</p>
<h5 id="列优先"><a href="#列优先" class="headerlink" title="列优先"></a>列优先</h5><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-95.png" style="zoom:70%;" />

<p>(j*M+i)指的是 b[i] [j] 之前有多少个元素, 每个元素再乘存储空间，就是 b[i] [j] 元素前面的存储空间</p>
<p>再加上起始地址 LOC，就得到 b[i] [j] 的存储地址</p>
<blockquote>
<p>M行N列的二维数组<code>b[M][N]</code>中，</p>
<ul>
<li>若按行优先存储，则<code>b[i] [j]</code>的存储地址 =<code>LOC + (i*N + j) * sizeof(ElemType)</code></li>
</ul>
<p>即每一行有多少个元素，乘它前面有多少行，再加上它位于第几列。</p>
<ul>
<li>若按列优先存储，则<code>b[i] [j]</code>的存储地址 =<code>LOC + (j*M + i) * sizeof(ElemType)</code></li>
</ul>
<p>即每一列有多少个元素，乘它前面有多少列，再加上它位于第几行。</p>
</blockquote>
<h3 id="矩阵的存储"><a href="#矩阵的存储" class="headerlink" title="矩阵的存储"></a>矩阵的存储</h3><h4 id="普通矩阵的存储"><a href="#普通矩阵的存储" class="headerlink" title="普通矩阵的存储"></a>普通矩阵的存储</h4><p>最容易想到的就是用一个<strong>二维数组存储</strong>。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-96.png" style="zoom: 85%;" />

<h4 id="对称矩阵的压缩存储"><a href="#对称矩阵的压缩存储" class="headerlink" title="对称矩阵的压缩存储"></a>对称矩阵的压缩存储</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-115.png" style="zoom: 80%;" />

<blockquote>
<p>由于上三角区和下三角区的数据是完全相同的，因此我们在存储数据的时候，只需要存储主对角线及上下某一个三角区即可。</p>
<p>以只存储<strong>主对角线</strong>与<strong>下三角区</strong>为例。</p>
<p>按<strong>行优先</strong>原则将各元素存入一维数组中。（第一行存1个数据，第二行存2个数据，第三行存3个数据…）</p>
</blockquote>
<p>策略：只存储主对角线 + 下三角区</p>
<ul>
<li>按行优先原则将各元素存入一维数组中，共存 (1+n)*n/2 个元素，由于一维数组下标从 0 开始，所以最后一个元素下标是 (1+n) * n/2 - 1</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-116.png" style="zoom: 60%;" />

<p><font color='cornflowerblue'>我们最终的目的是将矩阵压缩存储后怎样才能方便使用</font>，这样我们就可以建立一个映射函数，矩阵下标 -&gt; 一维数组下标，这样我们想要访问矩阵中某一行某一列的元素时，只需要通过映射函数一转，就可以知道它存放在一维数组的哪个位置。如何做呢？</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-117.png" style="zoom:60%;" />

<ul>
<li>按行优先的原则，a[i] [j] 是第 (1+2+…+(i-1)) + j 个元素，但是由于一维数组下标是从 0 开始的，所以对应的一维数组下标为(1+2+…+(i-1)) + j -1</li>
</ul>
<ul>
<li><p><font color='cornflowerblue'>但是如果我们想访问上三角区的元素呢？</font>虽然上三角区并没有进行存储，但是由于对称矩阵的特性，a[i] [j] = a[j] [i]，我们可以进行转换，相当于我们访问的仍然是下三角区的元素</p>
</li>
<li><p>按列优先的原则，第一列存储n个元素，第二列存储n-1个元素，第三列存储n-2个元素，第(j-1)列总共有[n+(n-1)+(n-2)+…+(n-j+2)]个元素，所以a[i] [j] 是第 [[n+(n-1)+(n-2)+…+(n-j+2)]+(i-j)+1] 个元素</p>
</li>
</ul>
<h4 id="三角矩阵的压缩存储"><a href="#三角矩阵的压缩存储" class="headerlink" title="三角矩阵的压缩存储"></a>三角矩阵的压缩存储</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/co4-35.png" style="zoom:55%;" />

<p>策略：如图</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/co4-36.png" style="zoom:55%;" />

<p><font color='cornflowerblue'>那我们如何用呢？</font>还是建立一个映射函数，这里的映射函数与对称矩阵的映射函数一样，不同的是如果我们访问上三角区常量，我们需要将其映射为一维数组的最后一个元素，因为<strong>一维数组最后一个元素存储常量C</strong>。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-118.png" style="zoom:55%;" />

<p>按行优先的原则，a[i] [j]前面有 i-1 行，第一行存储n个元素，第二行存储n-1个元素，第三行存储n-3个元素，第(i-1)行存储(n-i+2)个元素，所以a[i] [j]前面共有[[n+(n-1)+(n-2)+…+(n-i+2)+(j-i)]]个元素</p>
<h4 id="三对角矩阵的压缩存储"><a href="#三对角矩阵的压缩存储" class="headerlink" title="三对角矩阵的压缩存储"></a>三对角矩阵的压缩存储</h4><p>三对角矩阵，主对角线上的元素可以不为0，主对角线上元素的上下左右相邻元素也可以不为0，但是其余元素必须为0</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-119.png" style="zoom: 55%;" />

<p>按<strong>行优先的原则</strong>，只存储带状部分，除了第一行和最后一行为 2 个元素，其余行均为 3 个元素，所以总共需要存储 (3n-2) 个元素,由于数组下标默认从0开始，所以最后一个数组下标为 (3n-3)</p>
<blockquote>
<p>怎么把a(i,j)映射到与之对应的一维数组下标处？</p>
<p>若|i-j| &gt;1，其值肯定是0。反之则去数组里面找。</p>
<p>按行优先的原则，a(i,j)是一维数组中的第几个元素？</p>
<p>它是第i行，在它前面有i-1行，共3(i-1)-1个元素。而且它是第i行的第j-i+2个元素。</p>
<p>所以a(i,j)是第2i+j-2个元素。数组下标若从0开始，则以上数字均需减1。</p>
</blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-120.png" style="zoom:55%;" />

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-121.png" style="zoom:55%;" />

<blockquote>
<p>反过来考虑，假设我们已知一维数组下标k，如何得知其在矩阵中的行、列，即i、j？</p>
<p>由于数组下标是从0开始的，因此下标k的元素是第k+1个元素。</p>
<p>第k+1个元素在第几行、第几列？</p>
<p>设其在第i行、第j列。</p>
<p>前i-1行共3(i-1)-1个元素。</p>
<p>所以显然，3(i-1)-1 &lt; k+1 ≤ 3i-1</p>
<p>根据这个不等式，将i解出即可。同时j也轻易能够得出了。</p>
</blockquote>
<h4 id="稀疏矩阵的压缩存储"><a href="#稀疏矩阵的压缩存储" class="headerlink" title="稀疏矩阵的压缩存储"></a>稀疏矩阵的压缩存储</h4><h5 id="顺序存储——三元组"><a href="#顺序存储——三元组" class="headerlink" title="顺序存储——三元组"></a>顺序存储——三元组</h5><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-122.png" style="zoom:55%;" />

<p>显然，用这种方法存储稀疏矩阵的数据的话，若要访问某一行某一列的数据，就要从头顺序的依次扫描三元组，对其行号、列号遍历，直到查找到目标。就不具备随机存取的特性了。</p>
<h5 id="链式存储——十字链表法"><a href="#链式存储——十字链表法" class="headerlink" title="链式存储——十字链表法"></a>链式存储——十字链表法</h5><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-123.png" style="zoom:55%;" />

<p>在“上侧”定义一个数组，用来存放每一列的指针，叫做<strong>向下域</strong>（down），指向第j列的第一个元素；</p>
<p>在“左侧”定义一个数组，用来存放每一行的指针，叫做<strong>向右域</strong>（right），指向第i行的第一个元素。</p>
<p>每个非零元素成为一个数据结点，被存放着。</p>
<p>（也就是向下域、向右域都指向当前列/行的第一个非零数据所形成的数据结点）</p>
<p>其中，每个非零数据结点，除存放三元组（<strong>行，列，值</strong>）外，还存放两个指针，分别指向<strong>同列的下一个元素</strong>、<strong>同行的下一个元素</strong>。</p>
<h3 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h3><ul>
<li><p>【2016】有一个100阶的三对角矩阵M，其元素m{i,j}(1&lt;=i,j&lt;=100),按行优先依次压缩存入下标从0开始的一维数组N中。元素m{30,30} 在N中的下标是→87</p>
<blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-111.png" style="zoom: 50%;" /></blockquote>
</li>
<li><p>【2017】适用于压缩存储稀疏矩阵的两种存储结构是–&gt;A</p>
<p>A 三元组表和十字链表</p>
<p>B 三元组表和邻接矩阵</p>
<p>C 十字链表和二叉链表</p>
<p>D 邻接矩阵和十字链表</p>
<blockquote>
<p>三元组表的结点存储了行row、列col、值value三种信息，是主要用来存储稀疏矩阵的一种数据结构。十字链表将行单链表和列单链表结合起来存储稀疏矩阵。邻接矩阵空间复杂度达O(n2)，不适于存储稀疏矩阵。二叉链表又名左孩子右兄弟表示法，可用于表示树或森林。</p>
</blockquote>
</li>
<li><p>【2018】设有一个12x12的对称矩阵M，将其上三角部分的元素m{i,j}(1&lt;=i&lt;=j&lt;=12)按行优先存入C语言的一维数组N中，元素m{6,6}在N中的下标是–&gt;50</p>
<blockquote>
<p>上三角矩阵从第一行开始元素数量依次是：<strong>12，11，10，9，8，7，6，5，4，3，2，1</strong>，m6,6表示上三角区域的第<strong>6</strong>行第<strong>1</strong>个，所以m6,6为第51个元素，占数组位置为a[50]。</p>
</blockquote>
</li>
<li><p>【2020】将一个10x10对称矩阵M的上三角部分的元素m{i,j}(1&lt;=i&lt;=j&lt;=10)按列优先存入C语言的一维数组N中，元素𝑚{7,2}在 N 中的下标是–&gt;22</p>
<blockquote>
<p>上三角矩阵列优先的存储模式：先存储具有一个元素第一列，再存储具有两个元素 的第二列，以此类推</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds3-109.png"  />

<p>𝑚{7,2} 说明 1-6 列均已存满，，故此元素是第 1+2+3+4+5+6+2 个被存储单元 </p>
<p>【注意】C 语言数组的下标从 0 开始 故𝑚7,2在 N 中的下标为 23-1=22，即 N[22]</p>
</blockquote>
</li>
<li><p>【2021】二维数组A按行优先方式存储，每个元素占用1个存储单元。若元素A[0] [0]的存储地址是100，A[3] [3]的存储地址是220，则元素 A[5] [5] 的存储地址是-&gt;300</p>
<blockquote>
<p>二维数组A按行优先存储，每个元素占用1个存储单元，由A[0] [0]和A[3] [3]的存储地址可知A[3] [3]是二维数组A的第121个元素，假设二维数组A的每行有n个元素，则nx3+4=121,则n=39,故元素A[5] [5]的存储地址为100+39x5+6-1=300</p>
</blockquote>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://tikxeis.fun">kailin2eis</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://tikxeis.fun/p/58315/">http://tikxeis.fun/p/58315/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://tikxeis.fun" target="_blank">派总</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/408%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">408数据结构</a></div><div class="post_share"><div class="social-share" data-image="/img/1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/17647/"><img class="prev-cover" src="/img/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第四章 串</div></div></a></div><div class="next-post pull-right"><a href="/p/63528/"><img class="next-cover" src="/img/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第三章 栈、队列和数组(上)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/p/24523/" title="第一章 绪论"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第一章 绪论</div></div></a></div><div><a href="/p/14457/" title="第二章 线性表(上)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第二章 线性表(上)</div></div></a></div><div><a href="/p/12625/" title="第二章 线性表(下)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第二章 线性表(下)</div></div></a></div><div><a href="/p/63528/" title="第三章 栈、队列和数组(上)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第三章 栈、队列和数组(上)</div></div></a></div><div><a href="/p/17647/" title="第四章 串"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-28</div><div class="title">第四章 串</div></div></a></div><div><a href="/p/63944/" title="第五章 树与二叉树(上)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-28</div><div class="title">第五章 树与二叉树(上)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">kailin2eis</div><div class="author-info__description">派总's blog</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">3.3 栈和队列的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%9C%A8%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">栈在括号匹配中的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-text">问题分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">算法实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%9C%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">栈在表达式求值中的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">中缀表达式转后缀表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%89%8B%E7%AE%97"><span class="toc-text">后缀表达式的手算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%9C%BA%E7%AE%97"><span class="toc-text">后缀表达式的机算</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">后缀表达式转中缀表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">中缀表达式转前缀表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%9C%BA%E7%AE%97"><span class="toc-text">前缀表达式的机算</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9C%BA%E7%AE%97"><span class="toc-text">中缀表达式转后缀表达式机算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0"><span class="toc-text">中缀表达式的计算(用栈实现)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%9C%A8%E9%80%92%E5%BD%92%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">栈在递归中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%9C%A8%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">队列在层次遍历中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%9C%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">队列在操作系统中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98"><span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E5%92%8C%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-text">3.4 特殊矩阵和压缩存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">数组的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">一维数组的存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">二维数组的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%8C%E4%BC%98%E5%85%88"><span class="toc-text">行优先</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%97%E4%BC%98%E5%85%88"><span class="toc-text">列优先</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-text">矩阵的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-text">普通矩阵的存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-text">对称矩阵的压缩存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-text">三角矩阵的压缩存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-text">三对角矩阵的压缩存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-text">稀疏矩阵的压缩存储</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E2%80%94%E2%80%94%E4%B8%89%E5%85%83%E7%BB%84"><span class="toc-text">顺序存储——三元组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E2%80%94%E2%80%94%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E6%B3%95"><span class="toc-text">链式存储——十字链表法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-1"><span class="toc-text">习题</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/63944/" title="第五章 树与二叉树(上)">第五章 树与二叉树(上)</a><time datetime="2022-09-28T04:50:11.000Z" title="发表于 2022-09-28 12:50:11">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/17647/" title="第四章 串">第四章 串</a><time datetime="2022-09-28T04:38:35.000Z" title="发表于 2022-09-28 12:38:35">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/58315/" title="第三章 栈、队列和数组(下)">第三章 栈、队列和数组(下)</a><time datetime="2022-09-28T04:30:19.000Z" title="发表于 2022-09-28 12:30:19">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/63528/" title="第三章 栈、队列和数组(上)">第三章 栈、队列和数组(上)</a><time datetime="2022-09-25T06:31:31.000Z" title="发表于 2022-09-25 14:31:31">2022-09-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/12625/" title="第二章 线性表(下)">第二章 线性表(下)</a><time datetime="2022-09-25T06:14:10.000Z" title="发表于 2022-09-25 14:14:10">2022-09-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By kailin2eis</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="关关雎鸠,在河之洲,窈窕淑女,what' your qq" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>