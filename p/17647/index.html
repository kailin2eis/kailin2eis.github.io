<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>第四章 串 | 派总</title><meta name="keywords" content="408数据结构"><meta name="author" content="kailin2eis"><meta name="copyright" content="kailin2eis"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="*4.1 串的定义和实现什么是串字符串，简称串，是由零个或多个字符组成的有限序列。一般记为 S &#x3D; ‘a1a2…an’(n≥0) 其中，S 是串名，单引号括起来的字符序列是串的值，ai 可以是字母、数字或其他字符；串中字符的个数 n 称为串的长度。n &#x3D; 0 时的串称为空串。   串是一种特殊的线性表，数据元素之间呈线性关系 它们的区别是:  普通的线性表里面可以存放各种各样的数据类型，是不做限制">
<meta property="og:type" content="article">
<meta property="og:title" content="第四章 串">
<meta property="og:url" content="http://tikxeis.fun/p/17647/index.html">
<meta property="og:site_name" content="派总">
<meta property="og:description" content="*4.1 串的定义和实现什么是串字符串，简称串，是由零个或多个字符组成的有限序列。一般记为 S &#x3D; ‘a1a2…an’(n≥0) 其中，S 是串名，单引号括起来的字符序列是串的值，ai 可以是字母、数字或其他字符；串中字符的个数 n 称为串的长度。n &#x3D; 0 时的串称为空串。   串是一种特殊的线性表，数据元素之间呈线性关系 它们的区别是:  普通的线性表里面可以存放各种各样的数据类型，是不做限制">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://tikxeis.fun/img/1.png">
<meta property="article:published_time" content="2022-09-28T04:38:35.000Z">
<meta property="article:modified_time" content="2022-09-28T04:42:19.209Z">
<meta property="article:author" content="kailin2eis">
<meta property="article:tag" content="408数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tikxeis.fun/img/1.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://tikxeis.fun/p/17647/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第四章 串',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-28 12:42:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><style>.mjpage .MJX-monospace {
  font-family: monospace;
}

.mjpage .MJX-sans-serif {
  font-family: sans-serif;
}

.mjpage {
  display: inline;
  font-style: normal;
  font-weight: normal;
  line-height: normal;
  font-size: 100%;
  font-size-adjust: none;
  text-indent: 0;
  text-align: left;
  text-transform: none;
  letter-spacing: normal;
  word-spacing: normal;
  word-wrap: normal;
  white-space: nowrap;
  float: none;
  direction: ltr;
  max-width: none;
  max-height: none;
  min-width: 0;
  min-height: 0;
  border: 0;
  padding: 0;
  margin: 0;
}

.mjpage * {
  transition: none;
  -webkit-transition: none;
  -moz-transition: none;
  -ms-transition: none;
  -o-transition: none;
}

.mjx-svg-href {
  fill: blue;
  stroke: blue;
}

.MathJax_SVG_LineBox {
  display: table !important;
}

.MathJax_SVG_LineBox span {
  display: table-cell !important;
  width: 10000em !important;
  min-width: 0;
  max-width: none;
  padding: 0;
  border: 0;
  margin: 0;
}

.mjpage__block {
  text-align: center;
  margin: 1em 0em;
  position: relative;
  display: block !important;
  text-indent: 0;
  max-width: none;
  max-height: none;
  min-width: 0;
  min-height: 0;
  width: 100%;
}
</style></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/1.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">派总</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">第四章 串</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-28T04:38:35.000Z" title="发表于 2022-09-28 12:38:35">2022-09-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-28T04:42:19.209Z" title="更新于 2022-09-28 12:42:19">2022-09-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/408%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">408数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="第四章 串"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="4-1-串的定义和实现"><a href="#4-1-串的定义和实现" class="headerlink" title="*4.1 串的定义和实现"></a>*4.1 串的定义和实现</h2><h3 id="什么是串"><a href="#什么是串" class="headerlink" title="什么是串"></a>什么是串</h3><p>字符串，简称串，是由零个或多个字符组成的<font color='orange'>有限序列</font>。一般记为 S = ‘a1a2…an’(n≥0)</p>
<p>其中，S 是串名，单引号括起来的字符序列是串的值，ai 可以是字母、数字或其他字符；串中字符的个数 n 称为串的长度。n = 0 时的串称为空串。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-42.png" style="zoom:55%;" />

<p>串是一种<font color='orange'>特殊</font>的<font color='orange'>线性表</font>，数据元素之间呈<font color='orange'>线性关系</font></p>
<p>它们的区别是:</p>
<ul>
<li><p>普通的线性表里面可以存放各种各样的数据类型，是不做限制的。串的数据对象限定为字符集(如中文字符、英文字符、数字字符、标点字符等)</p>
</li>
<li><p>普通的线性表，我们在进行增删改查等基本操作时，一般是对线性表中的某<strong>一个数据元素</strong>进行操作。</p>
<p>而我们对串的基本操作，如增删改查等，<strong>通常以子串为操作对象</strong>。也就是一次是对一堆字符进行操作的。</p>
</li>
</ul>
<h3 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h3><h4 id="串的顺序存储"><a href="#串的顺序存储" class="headerlink" title="串的顺序存储"></a>串的顺序存储</h4><p>结构类型定义（本质上就是字符数组）</p>
<p><strong>静态数组实现</strong>:定长顺序存储</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255			<span class="comment">// 预定义最大串长为255</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[MAXLEN];		<span class="comment">// 每个分量存储一个字符</span></span><br><span class="line">    <span class="type">int</span> lenght;				<span class="comment">// 串的实际长度</span></span><br><span class="line">&#125;SString;		</span><br></pre></td></tr></table></figure>

<p><font color='orange'>静态数组的缺点</font>就是它的<strong>缺点</strong>：长度不可变。</p>
<p>用静态数组实现串，因此它也叫<strong>串的定长顺序存储</strong>。</p>
<p>顺序存储在内存中有如下四种方案：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-43.png" style="zoom:55%;" />

<ul>
<li>方案一：会在串的末尾增添一个存储单元，用来存储串的长度变量 Length</li>
</ul>
<ul>
<li>方案二：让 ch[0] 的位置来存储串的长度变量 Length，这样做的优点是字符的位序就和数组下标相同。但缺点是 ch[0] 相当于一个存储单元 1B，这样也只能存储 0~255 的数字范围</li>
</ul>
<ul>
<li>方案三：去掉 Length 变量，在串末尾插入 \0 表示结尾。缺点是如果经常需要访问串的长度，那么每次都需要对串进行遍历</li>
</ul>
<p>由方案一和方案二，我们可以想到一个两者兼备的方案，如下方案四所示。</p>
<ul>
<li>方案四：是王道书上的，ch[0] 位置不存储元素，并在串的末尾增添一个存储单元，用来存储串的长度变量 Length。这样既保证了字符的位序就和数组下标相同，也可以记录串的长度</li>
</ul>
<p><strong>动态数组实现</strong>:堆分配存储</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *ch;				<span class="comment">// 按串长分配存储区,ch指向串的基地址</span></span><br><span class="line">    <span class="type">int</span> lenght;				<span class="comment">// 串的长度</span></span><br><span class="line">&#125;HString;</span><br><span class="line"></span><br><span class="line">S.ch = (<span class="type">char</span> *)<span class="built_in">malloc</span>(MAXLEN * <span class="keyword">sizeof</span>(<span class="type">char</span>));			<span class="comment">// 用完需要手动 free</span></span><br><span class="line">S.lenght = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>malloc方式申请的存储空间，在内存中是在堆区当中的，因此这种方法实现的，叫<strong>堆分配存储</strong>。同时，堆区中分配的内存空间需要手动的free释放。</p>
<p><font color='orange'>这两种方式的优缺点，和顺序表的不同实现方式的优缺点是一样的。</font></p>
<h4 id="串的链式存储"><a href="#串的链式存储" class="headerlink" title="串的链式存储"></a>串的链式存储</h4><p>用一个结点存字符，再用一个指针指向下一个结点。</p>
<ul>
<li>char 的大小只有 1B，指针大小 4B</li>
<li>这就意味着我们使用 1 个字节的大小来存储信息，还要使用 4 个字节的大小来存储辅助信息。</li>
</ul>
<p>和线性表的链式存储的一样的，只不过我们每个结点保存的数据的类型为<code>char</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch;				<span class="comment">// 每个结点存1个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StringNode,*String;</span><br></pre></td></tr></table></figure>

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-3.png" style="zoom: 67%;" />

<p>这种情况，我们把它称为<strong>存储密度低</strong>。即实际存储的信息比例很小。</p>
<p>如何解决存储密度低的问题呢？<font color='cornflowerblue'>我们可以让每个结点存多个字符</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[<span class="number">4</span>];				<span class="comment">// 每个结点存多个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StringNode,*String;</span><br></pre></td></tr></table></figure>

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-4.png" style="zoom: 55%;" />

<blockquote>
<p>此处写的是4个，实际也可以更多。</p>
<p>那么这样一来，每个结点中，实际存放的信息所占大小就是4B，因此存储密度就会提高。</p>
<p>因此，若使用链式存储来实现串的话，一般推荐采用这种方式。</p>
<p>通过这种方式实现，若最后一个结点存不满字符，那么你可以用一些特殊字符（如#，也可以用我们上面提到的’\0’）将其填充进去。</p>
</blockquote>
<h3 id="串的基本操作"><a href="#串的基本操作" class="headerlink" title="串的基本操作"></a>串的基本操作</h3><p>可以看下面两个链接</p>
<p><a target="_blank" rel="noopener" href="https://cplusplus.com/reference/cstring/">c 语言的库：<cstring></a></p>
<p><a target="_blank" rel="noopener" href="https://cplusplus.com/reference/string/string/">c++的库：<string></a></p>
<p>主要包括构造、销毁、清空、求串长、求字串等</p>
<p> 基本操作</p>
<ul>
<li>StrAssign(&amp;T, chars)：串赋值。把串T赋值为chars</li>
<li>StrCompare(S, T)：串比较。若S&gt;T，返回值&gt;0;….</li>
<li>StrLength(S)：求串长。返回串S的元素个数</li>
<li>Concat(&amp;T, S1, S2)：串连结。用T返回由S1和S2联接而成的新串</li>
<li>SubString(&amp;Sub, S, pos, len)：求子串。用Sub返回串S的第pos个字符起长度为len的字串。</li>
<li>StrCopy(&amp;T, S)：串拷贝。由串S复制得到串T。</li>
<li>StrEmpty(S)：串判空。若S为空串，则返回TRUE，否则返回FALSE。</li>
<li>ClearString(&amp;S)：清空串</li>
<li>Index(S,T,pos)：子串的位置。用Sub返回串S的第pos个字符起长度为len的子串。</li>
<li>Repalce(&amp;S, T, V)：串替换</li>
<li>StrInsert(&amp;S, pos, T)：子串插入</li>
<li>StrDelete(&amp;S, pos, len)：子串删除</li>
<li>DestoryString(&amp;S)：串销毁 </li>
</ul>
<h4 id="求字串"><a href="#求字串" class="headerlink" title="求字串"></a>求字串</h4><p><code>SubString(&amp;Sub,S,pos,len)</code> 求子串。用 Sub 返回串 S 的第 pos 个字符起长度为 len 的子串</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-5.png" style="zoom: 60%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255			<span class="comment">// 预定义最大串长为255</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[MAXLEN];		<span class="comment">// 每个分量存储一个字符</span></span><br><span class="line">    <span class="type">int</span> length;				<span class="comment">// 串的实际长度</span></span><br><span class="line">&#125;SString;		</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求子串</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SubString</span><span class="params">(SString &amp;Sub,SString S,<span class="type">int</span> pos,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="comment">// 子串范围越界</span></span><br><span class="line">    <span class="keyword">if</span>(pos+len<span class="number">-1</span> &gt; S.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=pos; i&lt;pos+len; i++)&#123;</span><br><span class="line">        Sub.ch[i-pos+<span class="number">1</span>] = S.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Sub.length = len;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="比较操作"><a href="#比较操作" class="headerlink" title="比较操作"></a>比较操作</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-6.png" style="zoom: 60%;" />

<p><code>StrCompare(S,T)</code> 比较两个串操作。若 S &gt; T，则返回值 &gt; 0；若 S = T，则返回值 = 0；若 S &lt; T，则返回值 &lt; 0</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-7.png" style="zoom:55%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较两个串操作。若 S &gt; T，则返回值 &gt; 0；若 S = T，则返回值 = 0；若 S &lt; T，则返回值 &lt; 0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StrCompare</span><span class="params">(SString S,SString T)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=S.length &amp;&amp; i&lt;= T.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i] != T.ch[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> S.ch[i] - T.ch[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫描过的所有字符都相同,则长度更长的串更大</span></span><br><span class="line">    <span class="keyword">return</span> S.lenth - T.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定位操作"><a href="#定位操作" class="headerlink" title="定位操作"></a>定位操作</h4><p><code>Index(S,T)</code>： 定位操作。若主串 S 中存在与串 T 值相同的子串，则返回它在主串 S 中第一次出现的位置，否则函数值为 0</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-8.png" style="zoom:67%;" />

<p>其实在此处，我们可以通过使用之前实现的求子串操作<code>SubString(&amp;Sub, S, pos, len)</code>来帮助我们完成，将要检查的子串T，和主串S的所有子串依次对比即可，而且，比较两个串是否相等，也可以使用我们之前已经实现的比较操作（StrCompare(S, T)）来完成。</p>
<p>我们可以在主串 S 中从第一个元素开始取下长度为 3 的子串，然后对比这个子串与串 T 看是否相等，如果不相等，可以再在主串 S 中从第二个元素开始取下长度为 3 的子串，然后对比这个子串与串 T 看是否相等，如果相等，那么我们只需要返回这个子串的第一个字符的位序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S,SString T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>; </span><br><span class="line">    <span class="type">int</span> n=StrLength(S);				<span class="comment">// 求S串长,返回串中元素的个数</span></span><br><span class="line">    <span class="type">int</span> m=StrLength(T);				<span class="comment">// 求T串长,返回串中元素的个数</span></span><br><span class="line">    SString sub;					<span class="comment">// 用于暂存子串</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n-m+<span class="number">1</span>)&#123;</span><br><span class="line">        SubString(sub,S,i,m);		<span class="comment">// 取子串,用 Sub 返回串 S 的第 i 个字符起长度为 m 的子串。</span></span><br><span class="line">        <span class="keyword">if</span>(StrCompare(sub,T) != <span class="number">0</span>)&#123; <span class="comment">// 对比</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;				<span class="comment">// 返回子串在主串中的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;						<span class="comment">// S中不存在与Tx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-串的匹配模式"><a href="#4-2-串的匹配模式" class="headerlink" title="4.2 串的匹配模式"></a>4.2 串的匹配模式</h2><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-9.png" style="zoom:60%;" />

<p>统一一些术语:</p>
<ul>
<li><p>从哪个字符串里面进行搜索，那个字符串就叫<strong>主串</strong>。</p>
</li>
<li><p>你输入的内容，叫模式串。</p>
<ul>
<li>为什么叫模式串，不叫子串？因为子串必定是能够在主串中找到的一个串。而模式串只是我们试图去搜索的一个串，并不一定能够找到，因此叫模式串而不能叫子串。</li>
</ul>
</li>
<li><p><strong>串的模式匹配</strong>：在主串中找到与模式串相同的子串，并返回其所在位置</p>
</li>
</ul>
<h3 id="简单的模式匹配算法–BF算法"><a href="#简单的模式匹配算法–BF算法" class="headerlink" title="简单的模式匹配算法–BF算法"></a>简单的模式匹配算法–BF算法</h3><p>也叫朴素模式匹配算法，其核心思想就是:<font color='red'>暴力求解</font></p>
<p>之所以叫做朴素模式匹配算法，是因为我们这里不会用其他串的基本操作，而是通过访问数组元素的方式来实现这个过程。</p>
<p>在主串当中找出所有有可能与模式串相匹配的子串，然后将每个子串与模式串一一进行对比。这样肯定就没有遗漏地进行一遍对比。</p>
<blockquote>
<p>因此，如果主串长度为n，模式串长度为m，则</p>
<p>朴素模式匹配算法：将<strong>主串中所有长度为m的子串</strong>依次与模式串对比，直到找到一个完全匹配的，或直到所有的子串都不匹配为止。</p>
<p>问题：在长度为n的主串当中，长度为m的子串共有多少个？</p>
<p>答：共有<code>n-m+1</code>个。</p>
</blockquote>
<p>到这里，事实上我们已经发现了，这一系列操作，是和之前我们学过的串的定位操作<code>Index(S, T)</code>是一致的，只是换了个马甲。</p>
<p>因此，我们所谓的朴素模式匹配算法，就可以使用之前的串定位操作来进行实现，如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和上节写过的那个定位操作是一模一样的内容</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S, SString T)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">1</span>,n = StrLength(S),m = StrLength(T);</span><br><span class="line">	SString sub;	<span class="comment">//用于暂存子串</span></span><br><span class="line">	<span class="keyword">while</span>(i &lt;= n-m+<span class="number">1</span>) &#123;</span><br><span class="line">		SubString(sub, S, i, m);<span class="comment">//取出从位置i开始，长度为m的子串</span></span><br><span class="line">		<span class="keyword">if</span>(StrCompare(sub, T) != <span class="number">0</span>) ++i;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> i;	<span class="comment">//返回子串在主串中的位置 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">//没有匹配到 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们不借助字符串的基本操作，而是<strong>直接通过数组下标来实现朴素模式匹配算法</strong>。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-10.png" style="zoom: 69%;" />

<p>1.我们会使用 k 来记录当前检查的子串的起始位置，然后比对这个子串与模式串，如果不能匹配，就让 k++（这里在比对时，只要有一个字符不同，就可以停止检查当前子串）</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-11.png" style="zoom: 42%;" />

<p>2.如果对比的子串和模式串不相等，让 k 的值 ++，也就是对比下一个子串，然后让 i 和 j 分别指向子串和模式串的第一个字符</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-12.png" style="zoom:41%;" />

<p>3.循环执行操作 2，当被比对的子串和模式串的第一个值相同，这个时候让 i 和 j 的值同时向后移，对比第二个字符，第二个字符也相等，那继续让 i 和 j 的值向后移，对比第三个字符</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-13.png" style="zoom:41%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S,SString T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i=k,j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j &lt;= T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i] == T.ch[j])&#123;				<span class="comment">// 当对比的子串和模式串的第一个字符相等</span></span><br><span class="line">            ++i;							<span class="comment">// 让 i 和 j 向后移</span></span><br><span class="line">            ++j;							<span class="comment">// 继续比较后继字符</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            k++;							<span class="comment">// 检查下一个子串</span></span><br><span class="line">            i=k;							<span class="comment">// i 指向被对比子串的第一个字符</span></span><br><span class="line">            j=<span class="number">1</span>;							<span class="comment">// j 指向模式串的第一个字符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>王道课本代码是这样的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index_BF</span><span class="params">(SString S, SString T)</span> &#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= S.length &amp;&amp; j &lt;= T.length) &#123;</span><br><span class="line"><span class="keyword">if</span> (S.ch[i] == T.ch[j]) &#123;<span class="comment">// 比较成功则继续匹配下一个字符串</span></span><br><span class="line">    ++i;</span><br><span class="line">    ++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// 比较不成功则回溯</span></span><br><span class="line">    i = i-j+<span class="number">2</span>;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt; T.length)  <span class="keyword">return</span>  i-T.length;  <span class="comment">// 看下文注释</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">j &gt;= T.length 是错误的，举个反例：</span></span><br><span class="line"><span class="comment">S = &#123;&quot;abcdef&quot;&#125;; T = &#123;&quot;fg&quot;&#125;</span></span><br><span class="line"><span class="comment">when i = 6;</span></span><br><span class="line"><span class="comment">S.ch[i] = T.ch[j] = &#x27;f&#x27;;</span></span><br><span class="line"><span class="comment">Then i=7; j=2;</span></span><br><span class="line"><span class="comment">此时不符合循环条件跳出。明显j = 2匹配成功了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><font color='purple'>算法性能分析</font>:</p>
<p>若模式串长度为 m，主串长度为 n，则匹配成功的最好时间复杂度为：O(m)</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-14.png" style="zoom:50%;" />

<p>若模式串长度为 m，主串长度为 n，则匹配失败的最好时间复杂度为：O(n-m+1) = O(n-m) ≈ O(n)</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-15.png" style="zoom: 36%;" />

<p>最坏情况：每个子串的前 m-1 个字符都和模式串匹配，只有第 m 个字符不匹配</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-16.png" style="zoom:73%;" />

<p><font color='orange'>再回顾一下</font>:</p>
<ul>
<li>串的模式匹配：在主串中找到与模式串相同的子串，并返回其所在位置。</li>
<li>朴素模式匹配算法(简单模式匹配算法)思想：将主串中的模式串长度相同的子串搞出来，挨个与模式串对比，当子串与模式串某个对应字符不匹配时，就立即放弃当前子串，转而检索下一个子串</li>
<li>若模式串长度为 m，主串长度为 n，则直到匹配成功/匹配失败最多需要 (n-m+1)*m 次比较</li>
</ul>
<h3 id="改进的模式匹配算法——KMP-算法"><a href="#改进的模式匹配算法——KMP-算法" class="headerlink" title="改进的模式匹配算法——KMP 算法"></a>改进的模式匹配算法——KMP 算法</h3><p>KMP 算法：朴素模式匹配算法的优化</p>
<p>KMP 算法之所以叫做 KMP 算法，是因为发明它的三个人的名字第一个开头字母组成的。✌️</p>
<p>朴素模式匹配算法的缺点：<strong>当某些子串与模式串能部分匹配时，主串的扫描指针 i 经常回溯，导致时间开销增加</strong>。这是为什么呢。因为我们在进行匹配之前，并不知道主串里面有什么，我们只能根据下标、模式串串长，进行一个一个的对比。即使是上一轮中对比过的相等的字符，我们也并没有记录。总之每次循环前，主串中有什么内容，都是我们不知道的，我们<strong>只知道开始匹配的下标位置，与要匹配的长度</strong>。</p>
<p>但是实际上，由于上一轮循环，对于字符的逐个对比，到某个字符匹配失败时结束，这一过程当中，我们必然能够通过一部分“i指向的字符与j指向的字符相等”，来得知主串当中有哪些字符。即，在遇到不匹配的字符之前的字符，一定是和模式串一致的字符。</p>
<p>因此，对于主串中的信息，虽然刚开始我们一无所知。但是通过模式串的部分匹配，我们可以确定主串里面前边一小部分到底是什么内容。内容就是模式串失配位置前的所有字符。</p>
<p>那么，根据模式串失配位置前的内容，映射到主串相应位置，之后去执行朴素模式匹配的话，它会寻找到某个位置之后再进行真正的匹配。</p>
<p>而且从逻辑上来讲，这一操作过程与主串是什么无关，只是与模式串本身的信息内容、失配位置相关。</p>
<p><font color='red'>改进思路</font>：主串指针不回溯，只有模式串指针回溯</p>
<hr>
<p>我们来看一个例子，例如指向模式串的指针 j = 6 时发生了不匹配</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-17.png" style="zoom: 67%;" />

<p>那么也就是说，前 5 个字符都与模式串匹配上了，这个时候我们让模式串回溯到起始位置，只需要比较子串的最后一个字符与模式串的起始字符是否相同</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-18.png" style="zoom: 67%;" />

<p>如果子串的最后一个字符与模式串的起始字符相同，我们让指向子串和模式串的指针 i++，j++，从而比较第二个字符是否相同</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-19.png" style="zoom:67%;" />

<p>如果子串的最后一个字符与模式串的起始字符不相同，我们让指向子串的 i 后移，检查后继元素是否与模式串的起始元素相同，而指向模式串的指针 j 依然是 1</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-20.png" style="zoom:67%;" />

<p>那如果指向模式串的指针 j = 5 时发生了不匹配，如图:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-21.png" style="zoom:67%;" />

<p>那么说明我们前4个字符都匹配上了，并且此时子串有第二个 g 开头，我们只需要比对模式串的第二个字符，看子串的 ？号处的字符是否与 o 相同，所以我们让指向模式串的指针 j 回到 2</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-22.png" style="zoom:67%;" />

<p>如果说指向模式串的指针 j = 3 时不匹配</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-23.png" style="zoom:67%;" />

<p>让指向模式串的指针 j 回到1</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-24.png" style="zoom:67%;" />

<p><font color='red'>总结</font>：当我们的指针 j 扫描到某一个字符时，如果发生了不匹配，那么说明前面的字符和我们的主串是能够完全匹配上的，那我们就可以利用模式串前缀的信息，就可以分析出指针 j 接下来应该指向什么位置。</p>
<hr>
<p>我们将 j 应该指向什么位置的信息放在一个数组里，数组名字叫 <strong>next</strong></p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-25.png" style="zoom:67%;" />

<p>这个数组的意思是当指针 j 指向的位置发生不匹配，那么它应该回到某一个位置。这里我们发现当 j = 1时发生不匹配，应该让 j 仍然是1，但是 next 数组里面让 j 回到 0，这是为了写代码的时候考虑。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-26.png" style="zoom: 33%;" />

<hr>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-44.png" style="zoom:67%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(SString S,SString T,<span class="type">int</span> next[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;= T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || S.ch[i] == T.ch[j])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;								<span class="comment">// 继续比较后继字符</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];							<span class="comment">// j指回相应位置,模式串向右移动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> i-T.length;						<span class="comment">// 匹配成功</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>KMP算法，最坏时间复杂度O(m+n)；其中，求next数组时间复杂度O(m),模式匹配过程最坏时间复杂度O(n)。</p>
<h3 id="求next数组🔥-王卓"><a href="#求next数组🔥-王卓" class="headerlink" title="求next数组🔥(王卓)"></a>求next数组🔥(王卓)</h3><p><strong>所以其实 KMP 算法的关键在于我们需要先搞出一个和模式串相对应的数组 next。</strong></p>
<p>我们先来观察几个例子:</p>
<p>当 j = 6 时，匹配失败，我们要让模式串向右移动到 j = 3</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-27.png" style="zoom:64%;" />

<p>当 j = 7 时，匹配失败，我们要让模式串向右移动到 j = 5</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-28.png" style="zoom: 55%;" />

<p>当 j = 5时匹配失败，我们要让模式串向右移动到 j = 4</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-29.png" style="zoom:59%;" />

<p>当 j = 5 时匹配失败，我们要让模式串向右移动到 j = 1</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-30.png" style="zoom:58%;" />

<p>当 j = 1 时就发生匹配失败，我们让 j = 0</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-31.png" style="zoom:60%;" />

<p>串的前缀：包含第一个字符，且不包含最后一个字符的子串</p>
<p>串的后缀：包含最后一个字符，且不包含第一个字符的子串</p>
<p><font color='orange'>当第 j 个字符匹配失败，由前 1 ~ j-1 个字符组成的串记为 S，则： next[j] = S的最大公共前后缀长度 +1</font></p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-32.png" style="zoom:65%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Get_next</span><span class="params">(SString T, <span class="type">int</span> next[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T.ch[i] == T.ch[j]) &#123;</span><br><span class="line">            ++i; ++j;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j = next[j]; <span class="comment">// 隐含着非常厉害的递归思想</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(m+n) ，其中O(m) 来自于求next数组，O(n) 来自KMP算法的里层循环（普通模式匹配算法的时间复杂度是O(mn)</p>
<hr>
<h3 id="求next数组-王道"><a href="#求next数组-王道" class="headerlink" title="求next数组(王道)"></a>求next数组(王道)</h3><p>这个有两种方法：一种是王道讲的这个；一种是王卓上面讲的，根据当前要判断的元素的前面的模式串的子串中公共前后缀的长度加1来确定当前next数组的值（不过要注意模式串下标，有的题目是j从0开始，然后这里需要加1是因为next数组第一个是0，第二个是1）。</p>
<hr>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-45.png" style="zoom:67%;" />

<ul>
<li><p>首先分析next[1]</p>
<blockquote>
<p>next[1]的含义是，当模式串的第一个字符发生失配时，模式串指针j应该指向什么位置？</p>
<p>应该是让j=0，然后执行i++,j++。</p>
</blockquote>
<p>对于任何一个模式串都是一样的，第一个字符不匹配时，只能匹配下一个子串。因此，<strong>next[1]均直接写0</strong>即可。</p>
</li>
<li><p>分析next[2]</p>
<blockquote>
<p>next[2]的含义是，如果第二个字符发生失配，接下来指针j应该指向哪？</p>
<p>对于这个例子来说，我们应该让j=1。</p>
</blockquote>
<p>事实上，对于任何一个模式串都一样，第2个字符不匹配时，应该尝试匹配模式串的第1个字符。因此，<strong>next[2]均直接写1</strong>即可。</p>
</li>
<li><p>分析next[3]</p>
<blockquote>
<p>在不匹配位置前边，画一个分界线。然后，让模式串一步一步往后退，直到在分界线之前“能对上”，或模式串完全跨过分界线。</p>
</blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-46.png" style="zoom:67%;" />

<p>分界线右边的内容是未知的，模式串一步一步右移，观察分界线左边能不能匹配得上</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-47.png" style="zoom:67%;" />

<p>即此模式串对应的<code>next[3] = 1</code>。</p>
</li>
<li><p>分析next[4]</p>
<p>同理可知，<code>next[4] = 1</code>。</p>
</li>
<li><p>分析next[5]</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-48.png" style="zoom:67%;" />

<p>同理可知，<code>next[5] = 2</code>。</p>
</li>
<li><p>分析next[6]</p>
<p>同理可知，<code>next[6] = 1</code>。</p>
</li>
</ul>
<h4 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h4><p><font color='green'>这里直接用算法算</font></p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-33.png" style="zoom:67%;" />

<p>如题:</p>
<ol>
<li>next[1] == 0</li>
<li>next[2] 的意思是当我们匹配到第二个字符的时候发现匹配失败，那么前 1~(2-1) 个字符组成的串记为S，也就是串S此时只有一个字符为a，<code>&#39;a&#39;</code> 的前缀是空集，后缀也是空集，所以最长相等前后缀长度+1 = 1，所以 next[2] = 1(<strong>其实，无脑写1即可</strong>)</li>
<li>next[3] 的意思是当我们匹配到第三个字符的时候发现匹配失败，那么前 1~(3-1) 个字符组成的串记为S，也就是串S此时为 <code>&#39;ab&#39;</code> ,前缀为{a}，后缀为{b},所以最长相等前后缀长度+1 = 1,所以 next[3] = 1</li>
<li>next[4] 的意思是当我们匹配到第四个字符的时候发现匹配失败，那么前 1~(4-1) 个字符组成的串记为S，也就是串S此时为 <code>&#39;aba&#39;</code> ,前缀为{a,ab}，后缀为{a,ba},所以最长相等前后缀长度+1 = 2,所以 next[4] = 2</li>
<li>next[5] 的意思是当我们匹配到第五个字符的时候发现匹配失败，那么前 1~(5-1) 个字符组成的串记为S，也就是串S此时为 <code>&#39;abab&#39;</code> ,前缀为{a,ab,aba}，后缀为{b,ab,bab},所以最长相等前后缀长度+1 = 3,所以 next[3] = 3</li>
<li>next[6] 的意思是当我们匹配到第六个字符的时候发现匹配失败，那么前 1~(6-1) 个字符组成的串记为S，也就是串S此时为 <code>&#39;ababa&#39;</code> ,前缀为{a,ab,aba,abab}，后缀为{a,ba,aba,baba},所以最长相等前后缀长度+1 = 4,所以 next[6] = 4</li>
</ol>
<p>所以答案为：</p>
<table>
<thead>
<tr>
<th>序号j</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody><tr>
<td>模式串</td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>a</td>
</tr>
<tr>
<td>next[j]</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
</tbody></table>
<h4 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-34.png" style="zoom:67%;" />

<p>如题:</p>
<ol>
<li>next[1] == 0</li>
<li>next[2] 的意思是当我们匹配到第二个字符的时候发现匹配失败，那么前 1~(2-1) 个字符组成的串记为S，也就是串S此时只有一个字符为a，<code>&#39;a&#39;</code> 的前缀是空集，后缀也是空集，所以最长相等前后缀长度+1 = 1，所以 next[2] = 1</li>
<li>next[3] 的意思是当我们匹配到第三个字符的时候发现匹配失败，那么前 1~(3-1) 个字符组成的串记为S，也就是串S此时为 <code>&#39;aa&#39;</code> ,前缀为{a}，后缀为{a},所以最长相等前后缀长度+1 = 1,所以 next[3] = 2</li>
<li>next[4] 的意思是当我们匹配到第四个字符的时候发现匹配失败，那么前 1~(4-1) 个字符组成的串记为S，也就是串S此时为 <code>&#39;aaa&#39;</code> ,前缀为{a,aa}，后缀为{a,aa},所以最长相等前后缀长度+1 = 3,所以 next[4] = 3</li>
<li>next[5] 的意思是当我们匹配到第五个字符的时候发现匹配失败，那么前 1~(5-1) 个字符组成的串记为S，也就是串S此时为 <code>&#39;aaaa&#39;</code> ,前缀为{a,aa,aaa}，后缀为{a,aa,aaa},所以最长相等前后缀长度+1 = 4,所以 next[5] = 4</li>
</ol>
<p>答案为:</p>
<table>
<thead>
<tr>
<th>序号j</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>模式串</td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>b</td>
</tr>
<tr>
<td>next[j]</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
</tbody></table>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>朴素模式匹配算法的缺点：当某些子串与模式串能部分匹配时，主串的扫描指针i经常回溯，导致时间开销增加。最坏的时间复杂度O(nm)</p>
<p>KMP算法：当子串和模式串不匹配时，主串指针i不回溯，模式串指针 j=next[j] ，算法的平均时间复杂度：<code>O(n+m)</code></p>
<p>next数组手算方法：当第j个字符匹配失败，由前 <code>1~j-1</code> 个字符组成的串记为S，则：<code>next[j]=S的最长相等前后缀长度+1</code></p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-35.png" style="zoom:67%;" />

<p><strong>感兴趣看</strong>:</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ns_code/article/details/19286279">从BF算法到KMP算法</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jingmoxukong/p/4343770.html">字符串 模式匹配</a></p>
<h3 id="KMP-算法优化-nextval数组"><a href="#KMP-算法优化-nextval数组" class="headerlink" title="KMP 算法优化-nextval数组"></a>KMP 算法优化-nextval数组</h3><h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><p><font color='purple'>举个例子</font></p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-49.png" style="zoom:67%;" />

<p>当第三个元素不匹配时，让j指针指回next[3]，即从模式串T第一个字符开始匹配</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-50.png" style="zoom:67%;" />

<p>主串前面两个元素是已经确定的了，第三个元素虽然具体不知道是什么，也可以肯定不是a，但此时查找next[3]为1，而模式串的第一个元素也还是a，根据前一节讲过的KMP算法，是会让模式串的第一个元素跟主串第三个元素比较的，就有点多余了，增加了时间复杂度</p>
<p>所以改良一下，完全可以让j直接等于0,next[3]=next[1]</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-51.png" style="zoom:80%;" />

<p>j指向0的时候，i、j再同时++</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-52.png" style="zoom:67%;" />

<hr>
<p>==再举个例子==</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-53.png" style="zoom:67%;" />

<p>根据KMP算法应该让j=2，但同样的问题，匹配到5这个字符时发现匹配失败，虽然不知道主串i指针指向的元素是什么，但确定的是一定不是b，因为模式串中2这个字符和5这个字符是一样的</p>
<p>这次再匹配失败后，j的值应该改成next[2]。与其多比较一次，不如直接让next[5]=next[2]=1</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-54.png" style="zoom:67%;" />

<hr>
<p><font color='cornflowerblue'>那么是不是所有next数组的值都可被优化呢？</font></p>
<p>==来看这样一个例子==</p>
<p>假设模式串匹配到第6个字符时才发现匹配失败，那么能确定是主串中i指向的字符一定不是c</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-55.png" style="zoom:67%;" />

<p>原本next[6]对应的是3，即应将j指向3，从3开始往后匹配。此时只知道主串匹配失败的字符一定不是c，但有可能是a，所以next[6]=3是有必要的。</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>KMP原本是根据模式串T，求出next数组，再利用next数组进行匹配，主串不回溯而模式串回溯。</p>
<p>对KMP算法的优化本质是只是优化了next数组，将next数组按照上述思想优化成nextval数组，用nextval数组替代next数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Get_next</span><span class="params">(SString T, <span class="type">int</span> next[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T.ch[i] == T.ch[j]) &#123;</span><br><span class="line">            ++i; ++j;</span><br><span class="line">            <span class="keyword">if</span>(T.ch[i]! =T.ch[j]) nextval[i]=j;</span><br><span class="line">            <span class="keyword">else</span> nextval[i] = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j = nextval[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="练习1：求nextval数组"><a href="#练习1：求nextval数组" class="headerlink" title="练习1：求nextval数组"></a>练习1：求nextval数组</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cherryljr/p/6519748.html">KMP算法的优化与详解</a></p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-56.png" style="zoom:67%;" />

<p>首先nextval[1]无脑写0，然后从前往后依次求nextval[]，如果当前的next[j]所指的字符和目前j所指的字符不相等，nextval[j]=next[j]。反之，则nextval[j]=nextval[next[j]]。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-36.png" style="zoom:50%;" />

<p>例如，对于上述模式串<code>&quot;aaaab&quot;</code>,它的next数组如图，其nextval数组分析如下：</p>
<ol>
<li>nextval[1] == 0</li>
<li>nextval[2] ,第二个字符的next[2] == 1，但是由于第二个字符与第一个字符是相同的，所以将第一个字符的 nextval[1] 赋值给第二个字符的nextval[2] == 0</li>
<li>nextval[3] ,第三个字符的next[3] == 2，但是由于第三个字符与第二个字符是相同的，所以将第二个字符的 nextval[2] 赋值给第三个字符的 nextval[3] == 0</li>
<li>nextval[4] ,第四个字符的next[4] == 3，但是由于第四个字符与第三个字符是相同的，所以将第三个字符的 nextval[3] 赋值给第四个字符的 nextval[4] == 0</li>
<li>nextval[5] ,第五个字符的next[5] == 4，第五个字符b与第四个字符不相同，所以让其保持以前的 next 值不变，则nextval[5] = next[5] =4</li>
</ol>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-37.png" style="zoom:50%;" />

<p>获得 nextval 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Get_next</span><span class="params">(SString T, <span class="type">int</span> nextval[])</span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span> || T.ch[i] == T.ch[j]) &#123;</span><br><span class="line">    i++;j++;</span><br><span class="line">    <span class="keyword">if</span>(T.ch[i] != T.ch[j]) nextval[i] = j;</span><br><span class="line">    <span class="keyword">else</span> nextval[i] = nextval[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> j = nextval[j]; <span class="comment">// 隐含着非常厉害的递归思想</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-38.png" style="zoom:67%;" />

<p>若题目中需要求 nextval 数组，那我们需要先手算出 next 数组，然后令 nextval[1] = 0,之后从左向右算出 nextval 值</p>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><ul>
<li><p>思考：手算next数组→①next[ 1 ] = 0②next[ 2 ] = 1③next[ i ] = 前缀 和 后缀 最大交集 + 1</p>
</li>
<li><p>思考：<code>&#123;aba&#125;</code> 的前缀和后缀分别是什么?→前缀{a, ab}（没有b，必须连续且包含第一个字符），后缀{a, ba}（必须连续且包含最后一个字符）</p>
</li>
<li><p>思考：模式串为<code>a b a b a a</code> 求next数组→0 1 1 2 3 4</p>
</li>
<li><p>思考：模式串为<code>a a a a b</code>，求next和nextval数组?→0 1 2 3 4；0 0 0 0 4</p>
</li>
<li><p>5 和 7，串 <code>a b a b a a a b a b a a</code> 的next数组和nextval值为?→011234223456 ；010104210104</p>
<blockquote>
<p>1、前两位：next数组前两位规定是0，1 即前两位ab对应的next数组为01，则：</p>
<table>
<thead>
<tr>
<th align="left">模式串</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">a</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">a</th>
</tr>
</thead>
<tbody><tr>
<td align="left">下标</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">5</td>
<td align="left">6</td>
<td align="left">7</td>
<td align="left">8</td>
<td align="left">9</td>
<td align="left">10</td>
<td align="left">11</td>
<td align="left">12</td>
</tr>
<tr>
<td align="left">next数组</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>2、接下来看第三位，按照next数组求解方法。第三位a的前一位为第二位的b，b的next值为1对应内容为a，b与a不同，向前继续寻找next值对应的内容来与前一位进行比较。因为找到第一位都没有找到与前一位相等的内容，所以第三位a的next值为1，则：</p>
<table>
<thead>
<tr>
<th align="left">模式串</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">a</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">a</th>
</tr>
</thead>
<tbody><tr>
<td align="left">下标</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">5</td>
<td align="left">6</td>
<td align="left">7</td>
<td align="left">8</td>
<td align="left">9</td>
<td align="left">10</td>
<td align="left">11</td>
<td align="left">12</td>
</tr>
<tr>
<td align="left">next数组</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>3、接下来看第四位b，b的前一位a的next值1对应内容为a，相同，所以该位b的next值就是前一位a的next值加上1，即为2</p>
<table>
<thead>
<tr>
<th align="left">模式串</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">a</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">a</th>
</tr>
</thead>
<tbody><tr>
<td align="left">下标</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">5</td>
<td align="left">6</td>
<td align="left">7</td>
<td align="left">8</td>
<td align="left">9</td>
<td align="left">10</td>
<td align="left">11</td>
<td align="left">12</td>
</tr>
<tr>
<td align="left">next数组</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>4、接下来看第五位a，a的前一位b的next值2对应内容为b，相等，所以该位a的next值就是前一位b的next值加上1，即为3</p>
<table>
<thead>
<tr>
<th align="left">模式串</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">a</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">a</th>
</tr>
</thead>
<tbody><tr>
<td align="left">下标</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">5</td>
<td align="left">6</td>
<td align="left">7</td>
<td align="left">8</td>
<td align="left">9</td>
<td align="left">10</td>
<td align="left">11</td>
<td align="left">12</td>
</tr>
<tr>
<td align="left">next数组</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>5、接下来看第六位a，a的前一位a的next值3对应内容为a，相等，所以该位a的next值就是前一位a的next值加上1，即为4</p>
<table>
<thead>
<tr>
<th align="left">模式串</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">a</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">a</th>
</tr>
</thead>
<tbody><tr>
<td align="left">下标</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">5</td>
<td align="left">6</td>
<td align="left">7</td>
<td align="left">8</td>
<td align="left">9</td>
<td align="left">10</td>
<td align="left">11</td>
<td align="left">12</td>
</tr>
<tr>
<td align="left">next数组</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>6、接下来看第七位a，a的前一位a的next值4对应内容为b，不相等，向前继续寻找next值对应的内容来与前一位进行比较，b的next值2对应的内容为b，依旧不相等，继续向前寻找，第二位b的next值1对应内容为a，相等。因为是在第二位b处实现的相等，所以第七位a的next值为第二位b的next值上加1，即为2</p>
<table>
<thead>
<tr>
<th align="left">模式串</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">a</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">a</th>
</tr>
</thead>
<tbody><tr>
<td align="left">下标</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">5</td>
<td align="left">6</td>
<td align="left">7</td>
<td align="left">8</td>
<td align="left">9</td>
<td align="left">10</td>
<td align="left">11</td>
<td align="left">12</td>
</tr>
<tr>
<td align="left">next数组</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">2</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>7、看第八位b，b的前一位a的next值2对应内容为b，不相等，向前继续寻找next值对应的内容来与前一位进行比较，b的next值1对应的内容为a，相等。因为是在第二位b处实现的相等，所以第八位a的next值为第二位b的next值上加1，即为2：</p>
<table>
<thead>
<tr>
<th align="left">模式串</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">a</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">a</th>
</tr>
</thead>
<tbody><tr>
<td align="left">下标</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">5</td>
<td align="left">6</td>
<td align="left">7</td>
<td align="left">8</td>
<td align="left">9</td>
<td align="left">10</td>
<td align="left">11</td>
<td align="left">12</td>
</tr>
<tr>
<td align="left">next数组</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">2</td>
<td align="left">2</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>8.看第九位，前一位b的next值2对应内容为b，相等，所以此处next值为3：</p>
<table>
<thead>
<tr>
<th align="left">模式串</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">a</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">a</th>
</tr>
</thead>
<tbody><tr>
<td align="left">下标</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">5</td>
<td align="left">6</td>
<td align="left">7</td>
<td align="left">8</td>
<td align="left">9</td>
<td align="left">10</td>
<td align="left">11</td>
<td align="left">12</td>
</tr>
<tr>
<td align="left">next数组</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">2</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>9.第十位同理上面第8可得，为4：</p>
<table>
<thead>
<tr>
<th align="left">模式串</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">a</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">a</th>
</tr>
</thead>
<tbody><tr>
<td align="left">下标</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">5</td>
<td align="left">6</td>
<td align="left">7</td>
<td align="left">8</td>
<td align="left">9</td>
<td align="left">10</td>
<td align="left">11</td>
<td align="left">12</td>
</tr>
<tr>
<td align="left">next数组</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">2</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>10、第十一位a的前一位b的next值4对应内容为b，相等，所以此处next值为5</p>
<table>
<thead>
<tr>
<th align="left">模式串</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">a</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">a</th>
</tr>
</thead>
<tbody><tr>
<td align="left">下标</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">5</td>
<td align="left">6</td>
<td align="left">7</td>
<td align="left">8</td>
<td align="left">9</td>
<td align="left">10</td>
<td align="left">11</td>
<td align="left">12</td>
</tr>
<tr>
<td align="left">next数组</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">2</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">5</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>11.最后，第十二位也是同理可以得到next值位6：</p>
<table>
<thead>
<tr>
<th align="left">模式串</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">a</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">a</th>
<th align="left">a</th>
</tr>
</thead>
<tbody><tr>
<td align="left">下标</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">5</td>
<td align="left">6</td>
<td align="left">7</td>
<td align="left">8</td>
<td align="left">9</td>
<td align="left">10</td>
<td align="left">11</td>
<td align="left">12</td>
</tr>
<tr>
<td align="left">next数组</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">2</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">5</td>
<td align="left">6</td>
</tr>
</tbody></table>
<p>另一种解法:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-40.png"  />

<p>nextval数组</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-39.png" style="zoom: 67%;" />
</blockquote>
</li>
<li><p>【2015】已知字符串S为’abaabaabacacaabaabcc’，模式串t为’abaabc’。采用KMP算法进行匹配，第一次出现”失配”(S[i]!=t[j])时，i=j=5，则下次开始匹配时，i和j的值分别是–&gt;i=5,j=2</p>
<blockquote>
<p>由题中“失配s[i]≠t[j]时，i=j=5”，可知题中的主串和模式串的位序都是从0开始的（要注意灵活应变）。按照next数组生成算法，对于t有：</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>t</td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>a</td>
<td>b</td>
<td>c</td>
</tr>
<tr>
<td>next</td>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
</tbody></table>
<p>依据KMP算法“当失配时，i不变，j回退到next[j]的位置并重新比较”，当失配s[i]≠t[j]时，i=j=5，由上表不难得出next[j]=next[5]=2（位序从0开始）。从而最后结果应为：i=5（i保持不变），j=2。</p>
</blockquote>
</li>
<li><p>【2019】设主串<code>a b a a b a a b c a b a a b c</code> ，模式串 S = <code>a b a a b c</code>，采用KMP算法进行模式匹配，到匹配成功时为止，在匹配过程中进行的单个字符间的比较次数是?→10次</p>
<blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds4-41.png" style="zoom: 67%;" />
</blockquote>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://tikxeis.fun">kailin2eis</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://tikxeis.fun/p/17647/">http://tikxeis.fun/p/17647/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://tikxeis.fun" target="_blank">派总</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/408%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">408数据结构</a></div><div class="post_share"><div class="social-share" data-image="/img/1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/63944/"><img class="prev-cover" src="/img/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第五章 树与二叉树(上)</div></div></a></div><div class="next-post pull-right"><a href="/p/58315/"><img class="next-cover" src="/img/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第三章 栈、队列和数组(下)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/p/14457/" title="第二章 线性表(上)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第二章 线性表(上)</div></div></a></div><div><a href="/p/24523/" title="第一章 绪论"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第一章 绪论</div></div></a></div><div><a href="/p/12625/" title="第二章 线性表(下)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第二章 线性表(下)</div></div></a></div><div><a href="/p/58315/" title="第三章 栈、队列和数组(下)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-28</div><div class="title">第三章 栈、队列和数组(下)</div></div></a></div><div><a href="/p/63528/" title="第三章 栈、队列和数组(上)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第三章 栈、队列和数组(上)</div></div></a></div><div><a href="/p/63944/" title="第五章 树与二叉树(上)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-28</div><div class="title">第五章 树与二叉树(上)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">kailin2eis</div><div class="author-info__description">派总's blog</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-text">*4.1 串的定义和实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%B2"><span class="toc-text">什么是串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">串的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-text">串的顺序存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-text">串的链式存储</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">串的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E5%AD%97%E4%B8%B2"><span class="toc-text">求字串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C"><span class="toc-text">比较操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="toc-text">定位操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E4%B8%B2%E7%9A%84%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F"><span class="toc-text">4.2 串的匹配模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E2%80%93BF%E7%AE%97%E6%B3%95"><span class="toc-text">简单的模式匹配算法–BF算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94KMP-%E7%AE%97%E6%B3%95"><span class="toc-text">改进的模式匹配算法——KMP 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82next%E6%95%B0%E7%BB%84%F0%9F%94%A5-%E7%8E%8B%E5%8D%93"><span class="toc-text">求next数组🔥(王卓)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82next%E6%95%B0%E7%BB%84-%E7%8E%8B%E9%81%93"><span class="toc-text">求next数组(王道)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A01"><span class="toc-text">练习1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A02"><span class="toc-text">练习2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KMP-%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96-nextval%E6%95%B0%E7%BB%84"><span class="toc-text">KMP 算法优化-nextval数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-text">举例说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-text">优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%B1%82nextval%E6%95%B0%E7%BB%84"><span class="toc-text">练习1：求nextval数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98"><span class="toc-text">习题</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/44803/" title="第八章 排序(四)">第八章 排序(四)</a><time datetime="2022-09-28T11:54:17.000Z" title="发表于 2022-09-28 19:54:17">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/14847/" title="第八章 排序(三)">第八章 排序(三)</a><time datetime="2022-09-28T11:52:50.000Z" title="发表于 2022-09-28 19:52:50">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/43357/" title="第八章 排序(二)">第八章 排序(二)</a><time datetime="2022-09-28T11:50:30.000Z" title="发表于 2022-09-28 19:50:30">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/27129/" title="第八章 排序(一)">第八章 排序(一)</a><time datetime="2022-09-28T11:47:17.000Z" title="发表于 2022-09-28 19:47:17">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/15017/" title="第七章 查找(四)">第七章 查找(四)</a><time datetime="2022-09-28T11:33:21.000Z" title="发表于 2022-09-28 19:33:21">2022-09-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By kailin2eis</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="关关雎鸠,在河之洲,窈窕淑女,what' your qq" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>