<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>第五章 树与二叉树(下) | 派总</title><meta name="keywords" content="408数据结构"><meta name="author" content="kailin2eis"><meta name="copyright" content="kailin2eis"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="5.4 树、森林 Tree Forest树的存储结构树的逻辑结构回顾树是 n(n≥0)个结点的有限集合，n&#x3D;0时，称为空树，这是一种特殊情况。在任意一棵非空树中应满足：  有且仅有一个特定的称为根的结点 当 n&gt;1 时，其余结点可分为 m(m&gt;0) 个互不相交的有限集合 T1、T2、T3、…Tm ,其中每个集合本身又是一棵树，并且称为树结点的子树。    双亲表示法(顺序存储)双亲表示">
<meta property="og:type" content="article">
<meta property="og:title" content="第五章 树与二叉树(下)">
<meta property="og:url" content="http://tikxeis.fun/p/56280/index.html">
<meta property="og:site_name" content="派总">
<meta property="og:description" content="5.4 树、森林 Tree Forest树的存储结构树的逻辑结构回顾树是 n(n≥0)个结点的有限集合，n&#x3D;0时，称为空树，这是一种特殊情况。在任意一棵非空树中应满足：  有且仅有一个特定的称为根的结点 当 n&gt;1 时，其余结点可分为 m(m&gt;0) 个互不相交的有限集合 T1、T2、T3、…Tm ,其中每个集合本身又是一棵树，并且称为树结点的子树。    双亲表示法(顺序存储)双亲表示">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://tikxeis.fun/img/1.png">
<meta property="article:published_time" content="2022-09-28T06:47:26.000Z">
<meta property="article:modified_time" content="2022-09-28T06:55:06.299Z">
<meta property="article:author" content="kailin2eis">
<meta property="article:tag" content="408数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tikxeis.fun/img/1.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://tikxeis.fun/p/56280/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第五章 树与二叉树(下)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-28 14:55:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><style>.mjpage .MJX-monospace {
  font-family: monospace;
}

.mjpage .MJX-sans-serif {
  font-family: sans-serif;
}

.mjpage {
  display: inline;
  font-style: normal;
  font-weight: normal;
  line-height: normal;
  font-size: 100%;
  font-size-adjust: none;
  text-indent: 0;
  text-align: left;
  text-transform: none;
  letter-spacing: normal;
  word-spacing: normal;
  word-wrap: normal;
  white-space: nowrap;
  float: none;
  direction: ltr;
  max-width: none;
  max-height: none;
  min-width: 0;
  min-height: 0;
  border: 0;
  padding: 0;
  margin: 0;
}

.mjpage * {
  transition: none;
  -webkit-transition: none;
  -moz-transition: none;
  -ms-transition: none;
  -o-transition: none;
}

.mjx-svg-href {
  fill: blue;
  stroke: blue;
}

.MathJax_SVG_LineBox {
  display: table !important;
}

.MathJax_SVG_LineBox span {
  display: table-cell !important;
  width: 10000em !important;
  min-width: 0;
  max-width: none;
  padding: 0;
  border: 0;
  margin: 0;
}

.mjpage__block {
  text-align: center;
  margin: 1em 0em;
  position: relative;
  display: block !important;
  text-indent: 0;
  max-width: none;
  max-height: none;
  min-width: 0;
  min-height: 0;
  width: 100%;
}
</style></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/1.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">派总</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">第五章 树与二叉树(下)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-28T06:47:26.000Z" title="发表于 2022-09-28 14:47:26">2022-09-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-28T06:55:06.299Z" title="更新于 2022-09-28 14:55:06">2022-09-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/408%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">408数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="第五章 树与二叉树(下)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="5-4-树、森林-Tree-Forest"><a href="#5-4-树、森林-Tree-Forest" class="headerlink" title="5.4 树、森林 Tree Forest"></a>5.4 树、森林 Tree Forest</h2><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><h4 id="树的逻辑结构回顾"><a href="#树的逻辑结构回顾" class="headerlink" title="树的逻辑结构回顾"></a>树的逻辑结构回顾</h4><p>树是 n(n≥0)个结点的有限集合，n=0时，称为空树，这是一种特殊情况。在任意一棵<strong>非空树</strong>中应满足：</p>
<ol>
<li>有且仅有一个特定的称为根的结点</li>
<li>当 n&gt;1 时，其余结点可分为 m(m&gt;0) 个互不相交的有限集合 T1、T2、T3、…Tm ,其中每个集合本身又是一棵树，并且称为树结点的子树。</li>
</ol>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-222.png" style="zoom:55%;" />

<h4 id="双亲表示法-顺序存储"><a href="#双亲表示法-顺序存储" class="headerlink" title="双亲表示法(顺序存储)"></a>双亲表示法(顺序存储)</h4><p>双亲表示法：每个结点中保存指向双亲的指针。</p>
<p>因为在一棵树中，除了根结点外，每个结点都有且仅有一个它的父节点。</p>
<p>所以，利用这一特性，我们在保存每个结点本身的数据之外，再保存一个指向它双亲的指针。</p>
<blockquote>
<p>即使用顺序存储，每个数据元素存放了数据data、双亲索引parent。</p>
<p>根结点固定存储在0号位置，parent = -1表示没有双亲。</p>
<p>当然，这个“指针”实际上是个int型变量。</p>
</blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-223.png" style="zoom:55%;" />

<p>该存储结构利用了每个结点(根结点除外)只有唯一双亲的性质，可以很快得到每个结点的双亲结点，但求结点的孩子时需要遍历整个结构。</p>
<p>若要<font color='red'>增加</font>一个结点，只需要在数组的空闲位置写入一个结点即可，写入其数据值，并绑定其与双亲的关系即可。而结点在数组中存放的先后顺序是无所谓的，没必要按照树中层次的先后顺序来存储。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-224.png" style="zoom: 55%;" />

<p>若我们要<font color='red'>删除</font>G这个结点，有两种删除方法。方案一，把该结点的指针域置为-1，让此位置无效。方案二：将数组中最后一个结点置于此节点上将之覆盖，方案二可以保证每个位置都是有效的存储位置。最后再将树的结点数n减一即可。（方案二是较好的，见下方查找操作中的描述可知）</p>
<p><font color='cornflowerblue'>思考一个问题，若删除的结点不是一个叶子结点，而是某一个分支结点，该怎么进行删除操作呢？</font></p>
<p>那此时就不能只删除这个结点在数组中存放的位置了，因为如果这样删除，就意味着以这个结点为根的整棵子树都被删除了。我们还要将这个结点的孩子结点找到，并且用一定的办法保留在原树中。</p>
<p>那么此时就涉及到树的<strong>查找</strong>操作了。</p>
<p>在这种存储结构中，给定一个结点，对于查找它的双亲节点是很简单的，只需访问其parent指针即可（<strong>优点</strong>）。但如果要找到它的孩子，我们就只能从头到尾依次遍历，然后匹配出它的所有孩子结点（<strong>缺点</strong>）。（此处也暴露出删除一个结点操作中，方案一的缺点，会导致遍历操作的时候访问很多无效的结点，导致遍历的速度更慢）</p>
<p><font color='orange'>注意:区别树的顺序存储结构与二叉树的顺序存储结构。在树的顺序存储结构中，数组下标代表结点的编号，下标中所存的内容指示了结点之间的关系。而在二叉树的顺序存储结构中，数组下标既代表了结点的编号，又指示了二叉树中各结点之间的关系。当然，二叉树属于树，因此二叉树都可以用树的存储结构来存储，但树却不能用二叉树的存储结构来存储。</font></p>
<h4 id="孩子表示法-顺序-链式存储"><a href="#孩子表示法-顺序-链式存储" class="headerlink" title="孩子表示法(顺序+链式存储)"></a>孩子表示法(顺序+链式存储)</h4><p>孩子表示法：顺序存储各个结点，每个结点中保存孩子链表头指针。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-164.png" style="zoom: 33%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> child;	<span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span>	<span class="comment">//下一个孩子 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">firstChild</span>;</span>	<span class="comment">//第一个孩子 </span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">	<span class="type">int</span> n, r;	<span class="comment">//结点数和根的位置 </span></span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure>

<p>思考这种存储方式，在进行增/删/查时的操作。以及其优缺点。此处不再展开。</p>
<h4 id="孩子兄弟表示法-链式存储-🔥"><a href="#孩子兄弟表示法-链式存储-🔥" class="headerlink" title="孩子兄弟表示法(链式存储)🔥"></a>孩子兄弟表示法(链式存储)🔥</h4><p><font color='cornflowerblue'>这是最重要的一种表示法。就是用纯链式存储的方式来表示一棵树。</font></p>
<p>从存储的角度来看，这就是个二叉链表（每个结点有两个指针）。其实和二叉树的存储是相似的，只是变量的含义、命名有所区别。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-225.png" style="zoom:55%;" />

<ul>
<li>左指针指向第一个孩子结点，右指针指向兄弟结点</li>
<li>A 是根节点，A的第一个孩子是B，所以A左连接B，B的兄弟结点是C，所以让B右连接C，D是C的兄弟结点，所以让C右连接D</li>
<li>B的第一个孩子是E，所以让B左连接E，E的兄弟结点是F，所以让E右连接F</li>
<li>E的第一个孩子是K，所以让E左连接K</li>
<li>C的第一个孩子是G，所以让C左连接G</li>
<li>D的第一个孩子是H，所以让D左连接H，I、J都是是H的兄弟结点，所以让H右连接I、J</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-214.png" style="zoom:55%;" />

<ul>
<li>A是根节点，左边的B是第一个孩子，B的右边C、F、L都是B的兄弟</li>
<li>D连在B的左边，所以D是B的第一个孩子，H是D的兄弟</li>
<li>G连在D的左边，所以G是D的孩子</li>
<li>E连在C的左边，所以E是C的第一个孩子，I连在E的左边，所以I是E的第一个孩子，J连在E的右边，所以J是E的兄弟</li>
</ul>
<h3 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h3><h4 id="树和二叉树的转换"><a href="#树和二叉树的转换" class="headerlink" title="树和二叉树的转换"></a>树和二叉树的转换</h4><ul>
<li>将树转化为二叉树进行处理，利用二叉树的算法来实现对树的操作</li>
<li>由于树和二叉树都可以用二叉链表作存储结构，则以二叉链表作媒介可以导出树与二叉树之间的一个对应关系。</li>
</ul>
<p><code>树转化为二叉树</code></p>
<p>每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟，这个规则称”<strong>左孩子右兄弟</strong>“。由于根结点没兄弟。所以对应的二叉树没有右子树。</p>
<p><strong>画法</strong>:</p>
<ol>
<li>加线：在兄弟之间加一条线</li>
<li>抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系</li>
<li>旋转：以树的根节点为轴心，将整树顺时针转45°</li>
</ol>
<p><font color='orange'>树变二叉树：兄弟相连留长子</font></p>
<p><strong>看个例子</strong>:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-142.png" style="zoom:67%;" />

<p><code>二叉树转化为树</code></p>
<p><strong>画法</strong>:</p>
<ol>
<li>加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子…沿分支找到所有右孩子，都与p的双亲用线连起来</li>
<li>抹线：抹掉原二叉树中双亲与右孩子之间的连线</li>
<li>调整：将结点按层序排列，形成树结构</li>
</ol>
<p><font color='orange'>二叉树变树：左孩右右连双亲，去掉原来右孩线</font></p>
<p><strong>看个例子</strong>:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-143.png" style="zoom:67%;" />

<h4 id="森林和二叉树的转换"><a href="#森林和二叉树的转换" class="headerlink" title="森林和二叉树的转换"></a>森林和二叉树的转换</h4><p><code>森林转化为二叉树</code></p>
<p>先将森林中的每棵树转换为二叉树，由于任何一棵和树对应的二叉树的右子树必空，若把森林中的第二棵树根视为第一棵树根的右兄弟，即将第二棵树对应的二叉树当作第一棵二叉树根的右子树，将第三棵树对应的二叉树当作第二棵二叉树根的右子树…以此类推</p>
<p><strong>画法</strong>:</p>
<ol>
<li>将各棵树分别转换成二叉树</li>
<li>将每棵树的根结点用线相连</li>
<li>以第一课树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构</li>
</ol>
<p><font color='orange'>森林变二叉树，树变二叉根相连</font></p>
<p><strong>看个例子</strong>:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-226.png" style="zoom:55%;" />

<ul>
<li>B、C、D 是兄弟结点，各个树的根节点视为兄弟关系，所以将C、D右连接B</li>
<li>E是B的第一个孩子，所以将E左连接B，F是E的兄弟结点，所以将F右连接E</li>
<li>K是E的第一个孩子，所以将K左连接E，L是K的兄弟结点，所以将L右连接L</li>
</ul>
<p><strong>再看一个例子</strong>:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-144.png" style="zoom:67%;" />

<p><code>二叉树转化为森林</code></p>
<p>若二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形式，故将根的右链断开。二叉树根的右子树又可视为一个由除第一棵树外的森林转换后的二叉树，应用同样的方法，直到最后只剩一棵没有右子树的二叉树为止，最后再将每棵二叉树依次转换成树，就得到了原森林。 </p>
<p><strong>画法</strong>:</p>
<ol>
<li>抹线：将二叉树中<strong>根节点</strong>与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树</li>
<li>还原：将孤立的二叉树还原成树</li>
</ol>
<p><font color='orange'>去掉全部右孩线，孤立二叉再还原</font></p>
<p><strong>看个例子</strong>:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-227.png" style="zoom:55%;" />

<ul>
<li>A、C、F、L是兄弟结点，分别为二叉树的跟结点</li>
<li>A的左边连接了B，所以B是A的第一个孩子，B的左边连接了D，所以D是B的第一个孩子，D的左边连接了G，所以G是D的第一个孩子，D的右边连接了H，所以D和H是兄弟结点</li>
<li>C的左边连接了E，所以E是C的第一个孩子，E的左边连接了I，所以I是E的第一个孩子，E的右边连接了J，所以E和J是兄弟结点。</li>
<li>F的左边连了K，所以K是F的第一个孩子</li>
</ul>
<p><strong>再看个例子</strong>:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-146.png" style="zoom:67%;" />

<p><font color='red'>二叉树转换为树或森林是唯一的</font></p>
<p><code>小结</code></p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-228.png" style="zoom:60%;" />

<h3 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h3><h4 id="树的先根遍历"><a href="#树的先根遍历" class="headerlink" title="树的先根遍历"></a>树的先根遍历</h4><p>先根遍历：若树非空，先访问根节点，再依次对每棵子树进行先根遍历。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-200.png" style="zoom: 42%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树的先根遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(TreeNode *R)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(R!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        visit(R); <span class="comment">// 访问根结点</span></span><br><span class="line">        <span class="keyword">while</span>(R还有下一个子树T)&#123;</span><br><span class="line">            PreOrder(T);			<span class="comment">// 先根遍历下一棵子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把这棵树转化为与之对应的二叉树后，会发现，对<strong>树的先根遍历序列</strong>，和与之对应的<strong>二叉树的先序遍历序列</strong>相同。</p>
<h4 id="树的后根遍历"><a href="#树的后根遍历" class="headerlink" title="树的后根遍历"></a>树的后根遍历</h4><p>后根遍历：若树非空，先依次对每棵子树进行后根遍历，最后再访问根结点。</p>
<p>树的后根遍历也叫做深度优先遍历。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-201.png" style="zoom:42%;" />

<p><strong>树的后根遍历与这棵树对应的二叉树的中序遍历序列相同</strong>。</p>
<h4 id="树的层次遍历"><a href="#树的层次遍历" class="headerlink" title="树的层次遍历"></a>树的层次遍历</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-202.png" style="zoom:42%;" />

<p>不难发现，对于层次遍历来说，我们在探索这些结点的时候，是尽可能的横向在探索，也就是探索的范围尽可能的广，所以对<strong>树的层次遍历</strong>也叫<strong>广度优先遍历</strong>。</p>
<p>那么与之相对的，树的<strong>先根遍历</strong>和<strong>后根遍历</strong>，我们在探索结点的时候，是尽可能的往深处探索，所以<strong>后根遍历和先根遍历也叫深度优先遍历</strong>。</p>
<h4 id="森林的先序遍历"><a href="#森林的先序遍历" class="headerlink" title="森林的先序遍历"></a>森林的先序遍历</h4><p>先序遍历森林：</p>
<ul>
<li>若森林为空，则按如下规则进行遍历</li>
<li>访问森林中第一棵树的根结点，先序遍历第一棵树中根结点的子树森林，先序遍历除去第一棵树之后剩余的树构成的森林。(效果等同于依次对各个树进行先根遍历)</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-203.png" style="zoom:42%;" />

<ul>
<li>或者将其转化为对应的二叉树，先序遍历森林效果等同于依次对二叉树的先序遍历</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-204.png" style="zoom:42%;" />

<h4 id="森林的中序遍历"><a href="#森林的中序遍历" class="headerlink" title="森林的中序遍历"></a>森林的中序遍历</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-205.png" style="zoom:42%;" />

<p>另一种方法就是将其转换成与之对应的二叉树，中序遍历森林效果等同于依次对二叉树的中序遍历</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-206.png" style="zoom:42%;" />

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th>树</th>
<th>森林</th>
<th>二叉树</th>
</tr>
</thead>
<tbody><tr>
<td>先根遍历</td>
<td>先序遍历</td>
<td>先序遍历</td>
</tr>
<tr>
<td>后根遍历</td>
<td>中序遍历</td>
<td>中序遍历</td>
</tr>
</tbody></table>
<blockquote>
<p>考试中，一般只涉及到森林的先序、中序遍历序列的求解，此时，我们将其转化为对各个树的先根、后根遍历即可很快得出其序列。</p>
<p>但是万一考察到了对森林的代码题、算法题，那么也不要慌张，将森林转化为与之对应的二叉树，然后对二叉树进行相关代码、算法的书写即可。对于二叉树的代码我们应该是很熟悉的。</p>
</blockquote>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><ul>
<li><p>利用二叉链表存储森林时，根结点的右指针是</p>
<p>A 指向最左兄弟<br>B 指向最右兄弟<br>C 一定为空<br>D 不一定为空 →D</p>
</li>
<li><p>【2009】将森林转换为对应的二叉树，若在二叉树中，结点 u 是结点 v 的父结点的父结点，则在原来的森林中，u 和 v 可能具有的关系是→①②<br>① 父子关系<br>② 兄弟关系<br>③ u 的父结点与 v 的父结点是兄弟关系</p>
<blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-101.png" style="zoom: 33%;" />

<p>第三个说的是在森林当中u的父节点和v的父节点是兄弟关系，而不是说在二叉树中u的父节点和v的父节点是森林关系</p>
</blockquote>
</li>
<li><p>【2011】已知一棵有2011个结点的树，其叶结点个数为116，该树对应的二叉树中无右孩子的结点个数–&gt;1896</p>
<blockquote>
<p>树——&gt;二叉树，大孩子变左孩子，兄弟变右孩子<br>因此对应的二叉树没有右孩子，说明该节点在树里右边没有兄弟，也就是说，该节点是其父节点最右边的孩子。有多少个有孩子的节点，就有多少个“最右的孩子节点”，因此2011-116=1895<br>此外，对于根节点而言，它没有父节点当然也没有兄弟，因此也是没有右孩子的。所以+1=1896</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-177.png" style="zoom:30%;" />

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-178.png" style="zoom:30%;" /></blockquote>
</li>
<li><p>【2014】将森林 F 转换为对应的二叉树 T，F 中叶结点的个数等于→C</p>
<p>A T 中叶结点的个数<br>B T 中度为 1 的结点的个数<br>C T 中左孩子指针为空的结点个数<br>D T 中右孩子指针为空的结点个数 </p>
<blockquote>
<p>在森林转换为二叉树时候。 </p>
<p>左指针指向该节点的孩子， 有指针指向该节点的兄弟节点。 </p>
<p>如果该节点左指针为NULL,那么说明在原来森林中， 该节点也没有孩子——是叶子节点。 </p>
<p>如果该节点右指针为NULL， 那么说明咋原来森林中， 该节点没有右边的兄弟节点。 </p>
<p>因此， 森林中叶子节点等于二叉树中左指针为NULL的个数。  选C</p>
</blockquote>
</li>
<li><p>【2016】若森林F有15条边、25个结点，则F包含树的个数是–&gt;10</p>
<blockquote>
<p>森林不一定是二叉树，三叉。。有多个孩子节点。</p>
<p>当一棵树时，假设5个结点，得到4条边，形成一棵树。5-4=1； </p>
<p>形成两棵树的情况下，浪费一个结点，得到3条边，形成两棵树。5-3=2； </p>
<p>因此递推出关系：一棵树的边数为15，有25个结点，形成25-15=10棵。</p>
</blockquote>
</li>
<li><p>【2019】若将一棵树T转化为对应的二叉树BT，则下列对BT的遍历中，其遍历序列与T的后根遍历序列相同的是–&gt;B</p>
<p>A. 先序遍历   B. 中序遍历</p>
<p>C. 后序遍历   D. 按层遍历</p>
<blockquote>
<p>后根遍历树可分为两步：① 从左到右访问双亲结点的每个孩子（转化为二叉树后就是先访问根结点再访问右子树）；② 访问完所有孩子后再访问它们的双亲结点（转化为二叉树后就是先访问左子树再访问根结点）因此树T的后根序列与其相应的二叉树BT的中序遍历序列相同。</p>
</blockquote>
</li>
<li><p>【2020】已知森林 F 及与之对应的二叉树 T，若 F 的先根遍历序列是 a, b, c, d, e, f，中根遍历序列是 b, a, d, f, e, c，则 T 的后根遍历序列是？→ b, f, e, d, c, a </p>
<blockquote>
<p>由先根遍历序列a,b,c,d,e,f和中根遍历序列b,a,d,f,e,c可知，a为T的根，{b}为a的左子树结点，{dfec}为a的右子树结点。由先根遍历序列c,d,e,f和中根遍历序列d,f,e,c可知a的右子树为c，c的左子树中的结点有{d,e,f}，右子树为空。由先根遍历序列d,e,f和中根遍历序列d,f,e可知c的左子树为d，d的左子树为空，右子树的结点有{e,f}。由先根遍历序列e,f和中根遍历序列f,e可知d的右子树为e，e的右子树为空，左子树的结点有{f}。所以，T的后遍历序列为：bfedca</p>
</blockquote>
</li>
<li><p>【2021】某森林F对应的二叉树为T，若T的先序遍历序列是a,b,d,c,e,g,f,中序遍历序列是b,d,a,e,g,c,f,则F中树的棵树是–&gt;3</p>
<blockquote>
<p>先根据先序遍历序列和中序遍历序列还原二叉树T如下：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-102.png" style="zoom:50%;" />

<p>由森林转化成二叉树的规则可知，森林中每棵树的根结点以右子树的方式相连，所以T中的结点a,c,f为F中树的根结点，森林F有三棵树</p>
</blockquote>
</li>
<li><p>综合题【2016】若一棵非空k(k&gt;=2)叉树T中的每个非叶结点都有k个孩子，则称T为正则k叉树。请回答下列问题并给出推导过程。</p>
<p>（1）若 T 有 m 个非叶结点，则 T 中的叶结点有多少个？ </p>
<p>（2）若 T 的高度为 h（单结点的树 h=1），则 T 的结点数最多为多少个？最少为多少个？</p>
<blockquote>
<p>（1）根据定义，正则 k 叉树中仅含有两类结点；叶结点（个数记为 n0）和度为 k 的分支结点（个数记为 n1）。树 T 中的结点总数n=n0+nk=n0+m。树中所含的边数e=n-1，这些边均为m个度为k的结点发出的，即e=m×k。整理得：n0+m=m ×k+1，故 n0=（k-1）×m+1</p>
<p>（2）高度为 h 的正则 k 叉树 T 中，含最多结点的树形为：除第 h 层外，第 1 到第 h-1 层的结点都是度为 k 的分支 结点；而第 h 层均为叶结点，即树是“满”树。此时第 j（1≤j≤h）层结点数为 k j-1，结点总数 M1为：</p>
<p>$$<br>M1=\sum_{j=1}^hk^{j-1}=\frac{k^h-1}{k-1}<br>$$<br>含最少结点的正则 k 叉树的树形为：第 1 层只有根结点，第 2 到第 h-1 层仅含 1 个分支结点和 k-1 个叶结点，第 h 层有 k 个叶结点。即除根外第 2 到第 h 层中每层的结点数均为 k，故 T 中所含结点总数 M2 为： M2=1+(h-1)×k</p>
</blockquote>
</li>
</ul>
<h2 id="5-5-树与二叉树的应用"><a href="#5-5-树与二叉树的应用" class="headerlink" title="5.5 树与二叉树的应用"></a>5.5 树与二叉树的应用</h2><h3 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h3><h4 id="带权路径长度"><a href="#带权路径长度" class="headerlink" title="带权路径长度"></a>带权路径长度</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-135.png" style="zoom:55%;" />

<p>结点的权：有某种现实含义的数值(如：表示结点的重要性等)</p>
<p>结点的带权路径长度：从树的根到该结点的路径长度(经过的边数)与该结点上权值的乘积。</p>
<ul>
<li>例如上图结点为3的带权路径长度 = 3 × 3 = 9</li>
</ul>
<p>树的带权路径长度：树中所有<strong>叶结点</strong>的带权路径长度之和<br>$$<br>WPL=\sum_{i=1}^{n}{w_il_i}<br>$$</p>
<h4 id="哈夫曼树的定义"><a href="#哈夫曼树的定义" class="headerlink" title="哈夫曼树的定义"></a>哈夫曼树的定义</h4><p>在含有n个带权叶节点的二叉树中，其中<strong>带权路径长度（WPL）最小的二叉树</strong>称为<strong>哈夫曼树</strong>，也称<strong>最优二叉树</strong>。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-197.png" style="zoom:55%;" />

<p>像这个例子中，我们给出了四个叶子结点，它们的权值分别为1、3、4、5。</p>
<p>我们可以构造各种形态的二叉树，把这些结点依次放到不同的位置，并保证这四个为叶子结点。</p>
<p>那么这些不同的二叉树，其带权路径长度WPL有可能相同，也有可能不同。但是对于这四个叶子结点，无论如何改变二叉树的形态，其WPL是不可能小于25的。也就是说，25就是有可能出现的最小的树的带权路径长度。</p>
<p>因此，上图中间的那两棵树，就是哈夫曼树。</p>
<h4 id="哈夫曼树的构造-王道"><a href="#哈夫曼树的构造-王道" class="headerlink" title="哈夫曼树的构造(王道)"></a>哈夫曼树的构造(王道)</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-147.png" style="zoom:80%;" />

<p>对于哈夫曼树并不唯一，如上图情况，我们还可以构造一个与之不同的哈夫曼树，如下所示：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-199.png" style="zoom:55%;" />

<p>而其WPL依然是最小值31。</p>
<p><strong>这里的构造可能对于初学者不好理解，推荐听青岛大学王卓老师的课</strong></p>
<h4 id="哈夫曼树的构造-王卓"><a href="#哈夫曼树的构造-王卓" class="headerlink" title="哈夫曼树的构造(王卓)"></a>哈夫曼树的构造(王卓)</h4><p>路径：<strong>从树中的一个结点到另一个结点之间的分支构成这两个结点间的路径</strong></p>
<p>结点的路径长度：<strong>两结点间路径上的分支数</strong></p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-137.png" style="zoom:80%;" />

<p>树的路径长度：从树根到每一个结点的路径长度之和。记作TL</p>
<p><font color='orange'>结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树。</font></p>
<p>权：将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。</p>
<p>结点的带权路径长度：从<strong>根</strong>结点到该结点之间的<strong>路径长度</strong>与该节点的权的<strong>乘积</strong>。</p>
<p>树的带权路径长度：树中所有<strong>叶子结点</strong>的<strong>带权路径长度之和</strong>。记作WPL(Weighted Path Length)</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-138.png" style="zoom:67%;" />

<p>哈夫曼树：最优树(带权路径长度(WPL)最短的树)</p>
<p>注意：”带权路径长度最短”是在”度相同”的树中比较而得的结果，因此有最优二叉树、最优三叉树之称等等。</p>
<p>哈夫曼树：最优二叉树(带权路径长度(WPL)最短的二叉树)</p>
<hr>
<p>构造哈夫曼树的方法：</p>
<ol>
<li>根据n个给定的权值{W1,W2,W3,…Wn}构成n棵二叉树的森林F={T1,T2,…Tn},其中Ti只有一个带权为Wi的根节点</li>
<li>在F中选取两棵根节点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根节点的权值为其左右子树上根节点的权值之和。</li>
<li>在F中删除这两棵树，同时将新的到的二叉树加入森林中。</li>
<li>重复2和3，直到森林中只有一棵树为止，这颗树即为哈夫曼树。</li>
</ol>
<p>口诀：1.构造森林全是根，2.选用两小造新树，3.删除两小添新人，4.重复2、3剩单根</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-139.png" style="zoom:80%;" />

<ol>
<li>构造森林全是根。有几个结点就有几个根节点，从而组成森林。<ul>
<li>例如上方有4个结点，则将其都作为根节点组成森林。</li>
</ul>
</li>
<li>选择两个权值最小的结点，将其权值加和，得到的权值为父结点，两个权值最小的结点为左右子树。<ul>
<li>例如上方权值最下的两个结点为 2 和 4，将其权值加和为6，则 6 为父结点， 2 和 4 为左右子树。</li>
</ul>
</li>
<li>删除刚才选择的那两个权值最小的结点，将剩余结点与第二步得到的父结点排成一排结成森林。<ul>
<li>删除2和4结点，将 7、5、6三个结点作为根组成森林</li>
</ul>
</li>
<li>继续选择两个权值最小的结点，将其权值加和，得到的权值为父结点，两个权值最小的结点为左右子树。<ul>
<li>继续选择 5、6 两个结点，权值加和为11，则 11 为父结点，5、6为左右子树。</li>
</ul>
</li>
</ol>
<blockquote>
<p>包含n个叶子结点的哈夫曼树中共有 2n-1 个结点。(n个结点，两两合并，总共合并n-1次，产生n-1个新结点)</p>
<p>哈夫曼树的结点的度为0或2，没有度为1的结点。</p>
<p>度为1的结点是n个，度为2的结点是 n-1 个</p>
</blockquote>
<h3 id="哈夫曼树的应用"><a href="#哈夫曼树的应用" class="headerlink" title="哈夫曼树的应用"></a>哈夫曼树的应用</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wkfvawl/p/9783271.html#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81">https://www.cnblogs.com/wkfvawl/p/9783271.html#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81</a></p>
<h4 id="哈夫曼编码-王道"><a href="#哈夫曼编码-王道" class="headerlink" title="哈夫曼编码(王道)"></a>哈夫曼编码(王道)</h4><p>如电报——点、划两个信号（二进制的0、1）</p>
<p><strong>固定长度编码</strong>–每个字符用相等长度的二进制表示</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-149.png" style="zoom:80%;" />

<p>刚才我们算的所有答案的二进制长度，其实就是算了这棵树的带权路径长度。</p>
<p>那么接下来要思考，还有没有比这种编码方案更优秀的方案？也就是要让它们之间传递的二进制长度的这个bit信息尽可能的少。就是要尽可能追求我们最终构造的这棵编码树，它的带权路径长度尽可能的小。</p>
<p>那么就又回到了我们哈夫曼树的构造问题了。给出四个叶子结点以及权值，构造哈夫曼树。</p>
<p><strong>可变长度编码</strong>–允许对不同字符用不等长的二进制位表示</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-150.png" style="zoom:80%;" />

<blockquote>
<p>到这里，有人会有疑问了：既然C是0，A是10，我想要把A与C区分开来，A是1的话，也可以区分啊？好的，那么我们来试一下：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-167.png" style="zoom:33%;" />
</blockquote>
<blockquote>
<p>也就是说，不同的字符结点不一定是叶子结点。</p>
<p>并且C——0；A——1；B——111；D——110。</p>
<p>那么我们尝试发送一下：CAAABD这串答案。</p>
<p>发送方：0111111110</p>
<p>接收方翻译：CBBD。</p>
<p>会发现，对这个二进制码的解码发生错误，有歧义。</p>
</blockquote>
<p>所以，对于一个字符集，我们若要设计一系列<strong>可变长度编码</strong>的话，所有字符对应到编码树里面，只能当做叶子结点，不能当做某一个分支结点。</p>
<p>换一个角度来说，这种编码方式，没有一个编码是另一个编码的前缀。则称这样的编码为<strong>前缀编码</strong>。前缀码解码无歧义，而非前缀编码在解码的时候有歧义。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-151.png" style="zoom:80%;" />

<p>由哈夫曼树得到<strong>哈夫曼编码</strong>–字符集中的每个字符作为一个叶子结点，各个字符出现的频度作为结点的权值，根据之前结点的方法构造哈夫曼树</p>
<p>左分支看成0，右分支看成1。（当然，反过来也无所谓）</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-152.png" style="zoom:80%;" />

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Bitter_Li/article/details/120939587">https://blog.csdn.net/Bitter_Li/article/details/120939587</a></p>
<h4 id="哈夫曼编码-王卓"><a href="#哈夫曼编码-王卓" class="headerlink" title="哈夫曼编码(王卓)"></a>哈夫曼编码(王卓)</h4><ol>
<li>统计字符集每个字符在电文中出现的平均概率(概率越大，要求编码越短)</li>
<li>利用哈夫曼树的特点：权越大的叶子离根越近，将每个字符的概率值作为权值，构造哈夫曼树。则概率越大的结点，路径越短。</li>
<li>在哈夫曼树的每个分支上标上0或1，结点的左分支标0，右分支标1，把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码。</li>
</ol>
<p><strong>例题</strong>：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-140.png" style="zoom: 67%;" />

<ol>
<li>构造哈夫曼树</li>
<li>左分支标0，右分支标1，把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码。</li>
</ol>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-141.png" style="zoom:80%;" />

<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-208.png" style="zoom:50%;" />

<h4 id="逻辑结构——集合"><a href="#逻辑结构——集合" class="headerlink" title="逻辑结构——集合"></a>逻辑结构——集合</h4><p>之前我们学习的逻辑结构有线性结构、树型结构和图结构。<strong>集合</strong>是我们没有学过的。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-209.png" style="zoom: 67%;" />

<p>对于一个全集S，我们可以按照某些想要的维度进行分类，将S划分为几个不同的子集。</p>
<p>比如根据不同人喜欢吃的水果不一样进行划分。</p>
<p>注意:划分后的子集是<font color='red'>互不相交</font>的。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-210.png" style="zoom:60%;" />

<p>集合这种逻辑结构之下，两个元素之间的关系要么从属于同一集合、要么从属于不同集合。</p>
<p><font color='cornflowerblue'>怎么用代码表示这种互不相交的集合关系呢？</font></p>
<p>联想一下树、森林这种表示方式，用这种思路来表达出各个集合是否属于同一子集。同属于一个集合的元素可以在物理上将它们组织成一棵树。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-211.png" style="zoom:60%;" />

<p>用互不相交的树，表示多个”集合“。</p>
<h4 id="为什么叫做并查集"><a href="#为什么叫做并查集" class="headerlink" title="为什么叫做并查集"></a>为什么叫做并查集</h4><p><font color='cornflowerblue'>如何“查”到一个元素到底属于哪一个集合？</font></p>
<p>从指定元素出发，一路向北，找到根节点，通过根节点来判断集合。</p>
<p><font color='cornflowerblue'>如何判断两个元素是否属于同一集合？</font></p>
<p>分别查到两个元素的根，判断根节点是否相同即可。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-212.png" style="zoom:60%;" />

<p><font color='orange'>如何把两个集合“并”为一个集合？</font></p>
<p>让一棵树成为另一棵树的子树即可。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-213.png" style="zoom:60%;" />

<p>想到这，应该知道为什么这个数据结构要叫做”并查集“了。(对集合实现并、查操作)</p>
<h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><h5 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h5><p>那么应该用什么样的存储结构来实现上述操作呢？——树的双亲表示法更适合</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-223.png" style="zoom:55%;" />

<p>容易通过数组来找到双亲结点，并且能通过一棵树根节点的parent指针指向另一棵树的根节点的编号来完成”并“操作。</p>
<h5 id="并查集的存储结构"><a href="#并查集的存储结构" class="headerlink" title="并查集的存储结构"></a>并查集的存储结构</h5><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-229.png" style="zoom:55%;" />

<p>对于n个数据元素，只需声明一个长度为n的int型数组S，即可表示集合关系。本质上就是树的双亲表示法。</p>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li><p>初始化</p>
<p>刚开始并不知道哪些数据元素是属于一个子集的，所以都初始化为各自独立的n个子集，将数组的值全部赋值为-1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 13</span></span><br><span class="line"><span class="type">int</span> UFsets[SIZE];<span class="comment">//集合元素数组</span></span><br><span class="line"><span class="comment">//初始化并查集</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Initial</span><span class="params">(<span class="type">int</span> S[])</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;SIZE;i++)</span><br><span class="line">        S[i]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-230.png" style="zoom:70%;" /></li>
<li><p>查操作——Find</p>
<p>非递归形式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找x所属集合(返回x所属根结点)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(S[x]&gt;=<span class="number">0</span>)<span class="comment">//循环寻找x的根</span></span><br><span class="line">        x=S[x];</span><br><span class="line">    <span class="keyword">return</span> x;<span class="comment">//根的s[]小于0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归形式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (S[x] == <span class="number">-1</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> x; <span class="comment">//若当前结点为根结点则返回该结点号</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Find(S[x]); <span class="comment">//否则递归查找其双亲结点的根结点</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>并操作——Union</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> Root1,<span class="type">int</span> Root2)</span>&#123;</span><br><span class="line">    <span class="comment">//要求Root1和Root2是不同的集合</span></span><br><span class="line">    <span class="keyword">if</span>(Root1==Root2) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//将根Root2连接到另一根Root1下面</span></span><br><span class="line">    S[Root2]=Root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码是已知两棵树的根节点的实现。如果不知道根节点呢？</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-231.png" style="zoom:67%;" />

<p>先对给定的两个元素进行Find操作确定根节点是谁后再执行Union操作即可。</p>
</li>
</ul>
<h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>首先并操作不需要多说了，已知根节点后其代码只有两行，时间复杂度O(1)</p>
<p>若结点数为n，Find最坏时间复杂度为O(n)</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-232.png" style="zoom:55%;" />

<p>可以看出来，查操作的最坏时间复杂度O(n)与树的高度h相关，顺着这个思路可以知道如何进行优化操作。</p>
<h4 id="Union操作的优化"><a href="#Union操作的优化" class="headerlink" title="Union操作的优化"></a>Union操作的优化</h4><p>优化思路:在每次Union操作构建树的时候，尽可能让树不长高</p>
<ul>
<li>用根节点的绝对值表示树的结点总是——表示树的大小</li>
<li>Union操作时，让小树合并到大树</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-233.png" style="zoom: 67%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> Root1,<span class="type">int</span> Root2)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Root1==Root2) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(S[Root2]&gt;S[Root1])&#123;<span class="comment">//Root2结点数更少</span></span><br><span class="line">        S[Root1]+=S[Root2];<span class="comment">//累加结点总数</span></span><br><span class="line">        S[Root2]=Root1;<span class="comment">//小树合并到大树</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        S[Root2]+=S[Root1];<span class="comment">//累加结点总数</span></span><br><span class="line">        S[Root1]=Root2;<span class="comment">//小数合并到大树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合并之后，将两棵树的根节点的绝对值累加成新的总数赋予大树的根节点。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-234.png" style="zoom:67%;" />
$$
该方法构造的树高不超过\lfloor log_2n\rfloor+1
$$
所以Union操作优化后，Find操作最坏时间复杂度为O(log₂n)

<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-235.png" style="zoom:67%;" />

<h3 id="并查集的终极优化"><a href="#并查集的终极优化" class="headerlink" title="并查集的终极优化"></a>并查集的终极优化</h3><h4 id="Find操作的优化-压缩路径"><a href="#Find操作的优化-压缩路径" class="headerlink" title="Find操作的优化(压缩路径)"></a>Find操作的优化(压缩路径)</h4><p>用前面讲到的Find操作找x所属集合(返回x所属根结点的值)，如Find(S[],11)查找L所属集合。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-236.png" style="zoom:67%;" />

<p>如上图所示，L-&gt;E-&gt;B-&gt;A就是查找L的查找路径。所谓”<strong>压缩路径</strong>“的这种优化方式，就是让查找路径变短。</p>
<p>压缩路径————Find操作，先找到根节点，再将查找路径上所有结点都挂到根节点下</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-237.png" style="zoom:67%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先找到根节点，再进行”压缩路径“</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> root=x;</span><br><span class="line">    <span class="keyword">while</span>(S[root]&gt;=<span class="number">0</span>)   root=S[root];<span class="comment">//循环找到根</span></span><br><span class="line">    <span class="keyword">while</span>(x! =root)&#123;<span class="comment">//压缩路径</span></span><br><span class="line">        <span class="type">int</span> t=S[x];<span class="comment">//t指向x的父节点</span></span><br><span class="line">        S[x]=root; <span class="comment">//x直接挂到根节点下</span></span><br><span class="line">        x=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;<span class="comment">//返回根节点编号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-238.png" style="zoom:67%;" />

<p>每次Find操作，先找根，再”压缩路径“，可使树的高度不超过0(a(n))。a(n)是一个增长很缓慢的函数，对于常见的n值，通常a(n)&lt;=4,因此优化后并查集的Find、Union操作时间都很低。</p>
<h4 id="并查集优化总结"><a href="#并查集优化总结" class="headerlink" title="并查集优化总结"></a>并查集优化总结</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-239.png" style="zoom:67%;" />

<p><a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">408快乐站</a></p>
<h3 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h3><ul>
<li><p>【2010】n(n&gt;=2)个权值均不相同的字符构成哈夫曼树，关于该树的叙述中，错误的是–&gt;A</p>
<p>A.该树一定是一棵完全二叉树</p>
<p>B.树中一定没有度为1的结点</p>
<p>C.树中两个权值最小的结点一定是兄弟结点</p>
<p>D.树中任一非叶结点的权值一定不小于下一层任一结点的权值</p>
<blockquote>
<p>A.哈夫曼树为带权路径长度最小的二叉树，不一定是完全二叉树。哈夫曼树中没有度为1的结点，B正确；构造哈夫曼树时，最先选取两个权值最小的结点作为左、右子树构造一棵新的二叉树，C正确；哈夫曼树中任一非叶结点P的权值为其左、右子树根结点权值之和，其权值不小于其左、右子树根结点的权值，在与结点P的左、右子树根结点处于同一层的结点中，若存在权值大于结点P权值的结点Q，那么结点Q的兄弟结点中权值较小的一个应该与结点P作为左、右子树构造新的二叉树。综上可知，哈夫曼树中任一非叶结点的权值一定不小于下一层任一结点的权值。</p>
</blockquote>
</li>
<li><p>【2014】5个字符有如下4种编码方案，不是前缀编码的是–&gt;D</p>
<p>A、01,0000,0001,001,1</p>
<p>B、011,000,001,010,1</p>
<p>C、000,001,010,011,100</p>
<p>D、0,100,110,1110,1100</p>
<blockquote>
<p><strong>前缀编码</strong>是指对字符集进行编码时，要求字符集中任一字符的编码都不是其它字符的编码的前缀。D不符合</p>
<p>构造方式： </p>
<p>1.构造<strong>哈夫曼树</strong>(哈夫曼树是<strong>同权不同构</strong>的，可以构造出不同结构的哈夫曼树但是带权路径长度是相等的)。 </p>
<p>2.<strong>前缀编码</strong>在构造好哈夫曼树的基础上，<strong>左0右1编码</strong></p>
</blockquote>
</li>
<li><p>【2015】下列选项给出的是从根分别到达两个叶结点路径上的权值序列，属于同一棵哈夫曼树的是–&gt;</p>
<p>A. 24,10,5和24,10,7</p>
<p>B. 24,10,5和24,12,7</p>
<p>C. 24,10,10和24,14,11</p>
<p>D. 24,10,5和24,14,6</p>
<blockquote>
<p>首先根据两个叶子，以及访问到叶子的前一个结点，这个结点一定是叶子的父亲结点。再根据哈夫曼树的结点一定有兄弟，即不存在度为1的结点。因此可以知道兄弟的<strong>权值</strong>，这样，给定的一个序列就可以推出两个叶子，两个序列推出四个叶子，这样就可以根据是否选择最小的两个叶子结点组合在一起作为判据，决定这个序列是否成立了。</p>
<p>我们一个一个来看。</p>
<p>1）首先看D  这里写图片描述</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-154.png" style="zoom: 23%;" />

<p>首先由第一个序列的10，5可以推出另一个叶子也是5，它们的父亲是10.到此为止，不能再瞎猜测其他叶子结点了。但我们知道两个叶子形成的结点有个权值为14的兄弟，但是不知道是叶子结点还是一个由叶子形成的结点，这个有待观察。</p>
<p>再看第二个序列，知道叶子结点6和父亲14，可以知道有个叶子兄弟是8，这个权值是14的结点有意思了，刚好可以和第一个结合成兄弟，且父亲为24，恰恰满足要求。</p>
<p>因此D是符合题目的树形。</p>
<p>2）再看C.这里写图片描述</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-155.png" style="zoom:23%;" />

<p>同样的分析思路再过一遍。<br>由第一个序列中的10，10可以得到有个叶子权值是0。第二个序列的14，11知道有个叶子是4.<br>OK，问题出来了，四个权值10，0，11，4是原始序列中的权值，按理说0，4最小，应该组合在一起，但是这里没有。所以是错误的树形。<br>当然需要明确的是，0和4不一定要组合在一起，要是序列中有1，那么0，1组合才是更小的。也就是说我们选择的是最小的，在不知道全局的情况下，局部的两个最小值最合理的是组合在一起。局部中不可能出现两个最小的分散的局面。这在哈夫曼树的构造中不可能出现的。</p>
<p>以上D,C从正反角度看了这种问题的解法。 同理B,A不再多说，给出图形如下：</p>
<p>3）B的树形：这里写图片描述</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-156.png" style="zoom:23%;" />

<p>如果24是第一个序列的，就不可能指到12，所以两个序列不是同一棵树的。</p>
<p>4)A也是同样的问题。A的树形：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-157.png" style="zoom:23%;" /></blockquote>
</li>
<li><p>若度为 m 的哈夫曼树中，叶子结点个数为 n，则非叶子结点的个数为 →（n-1)/(m-1)</p>
</li>
<li><p>【2017】已知字符集{a,b,c,d,e,f,g,h}，若各字符的哈夫曼编码依次是0100，10，0000，0101，001，011，11，0001，则编码序列 0100011001001011110101 的译码结果是–&gt;D</p>
<p>A. acgabfh    B. adbagbb<br>C. afbeagd    D. afeefgd</p>
<blockquote>
<p>哈夫曼编码是前缀编码，各个编码的前缀各不相同，因此直接拿编码序列与哈夫曼编码一一比对即可。序列可分割为0100 011 001 001 011 11 0101，译码结果是a f e e f g d，选项D正确</p>
</blockquote>
</li>
<li><p>【2018】已知字符集{a,b,c,d,e,f},若各字符出现的次数分别为6，3，8，2，10，4，则对应字符集中各字符的哈夫曼编码可能是-&gt;A</p>
<p>A. 00, 1011, 01, 1010, 11, 100</p>
<p>B. 00, 100, 110, 000, 0010, 01</p>
<p>C. 10, 1011, 11, 0011, 00, 010</p>
<p>D. 0011, 10, 11, 0010, 01, 000</p>
<blockquote>
<p>先将这串数字构造为哈夫曼树.</p>
<p>其实题目中，前半部分的字母已经不用看了，因为构造哈夫曼树正常是比大小，而这里比较出现次数大小。排序为2，3，4，6，8，10</p>
<p>哈夫曼树为</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-158.png" style="zoom:23%;" />

<p>将每个结点左右子树设为0，1，如下</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-159.png" style="zoom: 40%;" />

<p>将从头结点到此结点数合起来即为哈夫曼编码</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-160.png" style="zoom: 40%;" />

<p>此时可以得到题目中几个次数的字符集，即为对应字符的哈夫曼编码</p>
<ul>
<li>2-&gt;1010</li>
<li>3-&gt;1011</li>
<li>4-&gt;100</li>
<li>6-&gt;00</li>
<li>8-&gt;01</li>
<li>10-&gt;11</li>
</ul>
<p>所以各字符出现的次数分别为{ 6, 3, 8, 2, 10, 4 }，则对应字符集中各字符的哈夫曼编码可能是：00, 1011, 01, 1010, 11, 100</p>
</blockquote>
</li>
<li><p>【2019】对n个互不相同的符号进行哈夫曼编码。若生成的哈夫曼树共有115个结点，则n的值是–&gt;C</p>
<p>A.56  B.57<br>C.58  D.60</p>
<blockquote>
<p>哈夫曼树的特点性质：（节点为的度数为0 表示 n0,以此类推）<br>①哈夫曼树中只存在度为2和度为0的节点，及n1=0。<br>②哈夫曼树中，度为0和度为2的节点关系：n2=n0-1</p>
<p>由以上两个性质，本题就很好解出答案：<br>n0+n2=115 =&gt;<br>n0+n0-1=115 =&gt;<br>n0=(115+1)/2=58</p>
</blockquote>
</li>
<li><p>【2021】若某二叉树有5个叶结点，其权值分别为10，12，16，21，30，则其最小的带权路径长度WPL是–&gt;200</p>
<blockquote>
<p>首先对集合进行排序得到<code>&#123;10，12，16，21，30&#125;</code></p>
<p>我们找到权值最小的两个结点10和12合并；得到新的森林根结点为22。现在结点集合为<code>&#123;16,21,22,30&#125;</code></p>
<p>接着我们找到当前最小的结点16和21合并：得到新的森林根结点为37。现在结点集合为<code>&#123;22,30,37&#125;</code></p>
<p>接着我们找到当前最小的结点22和30合并：得到新的森林根结点为53。现在结点集合为<code>&#123;37,53&#125;</code></p>
<p>接着我们找到当前最小的结点37和53合并：得到新的森林根结点为90。现在结点集合为<code>&#123;90&#125;</code>；由于结点个数只剩一个，所以算法结束、构造哈夫曼树完毕</p>
<p>依次累加计算所有叶结点的带权路径长度 从上面构造的哈夫曼树可知所有结点的路径长度，例如结点”16“的路径长度为2</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-161.png" style="zoom: 50%;" />

<p>所以<code>WPL=(16+21+30)*2+(10+12)*3=200</code></p>
</blockquote>
</li>
<li><p>【综合2012】设有6个有序表A,B,C,D,E,F，分别含有10,35,40,50,60和200个数据元素，各表中元素按升序排列。要求通过 5 次两两合并，将 6 个表最终合并成 1 个升序表，并在最坏情况下比较的总次数达到最小。请回答下列问题。</p>
<p>1 ）给出完整的合并过程，并求出最坏情况下比较的总次数。</p>
<p>2 ）根据你的合并过程，描述 N （ N ≥ 2 ）个不等长升序表的合并策略，并说明理由。</p>
<blockquote>
<p>1）对于长度分别为 m ， n 的两个有序表的合并，最坏情况下是一直比较到两个表尾元素，比较次数为  m+n-1  次。故最坏情况的比较次数依赖于表长，为了缩短总的比较次数，根据哈夫曼树（最佳归并树）思想的启发，可采用如图所示的合并顺序。</p>
<p>根据上图中的哈夫曼树， 6个序列的合并过程为：</p>
<p>第 1 次合并：表 A 与表 B 合并，生成含有 45 个元素的表 AB ；</p>
<p>第 2 次合并：表 AB 与表 C 合并，生成含有 85 个元素的表 ABC ；</p>
<p>第 3 次合并：表 D 与表 E 合并，生成含有 110 个元素的表 DE ；</p>
<p>第 4 次合并：表 ABC 与表 DE 合并，生成含有 195 个元素的表 ABCDE ；</p>
<p>第 5 次合并：表 ABCDE 与表 F 合并，生成含有 395 个元素的最终表。</p>
<p><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-207.png"></p>
<p>由上述分析可知，最坏情况下的比较次数为：第1次合并，最多比较次数=10+35-1=44；第2次合并，最多比较次数=45+40-1=84  ；第3次合并，最多比较次数=50+60-1=109；第 4 次合并，最多比较次数=85+110-1=194；第5次合并，最多比较次数=195+200-1=394。故比较的总次数最多为：44+84+109+194+394=825 。</p>
<p>2）各表的合并策略是：在对多个有序表进行两两合并时，若表长不同，则最坏情况下总的比较次数依赖于表的合并次序。可以借用哈夫曼树的构造思想，依次选择最短的两个表进行合并，可以获得最坏情况下最佳的合并效率。</p>
</blockquote>
</li>
<li><p>【综合2020】若任意一个字符的编码都不是其他字符编码的前缀，则称这种编码具有前缀特性。现有某字符集(字符个数&gt;=2)的不等长编码，每个字符的编码均为二进制的0，1序列，最长为L位，且具有前缀特性。请回答下列问题</p>
<p>1)哪种数据结构适宜保存上述具有前缀特性的不等长编码？</p>
<p>2)基于你所设计的数据结构，简述从0/1串到字符串的译码过程</p>
<p>3)简述判定某字符集的不等长编码是否具有前缀特性的过程</p>
<blockquote>
<p>1)使用一棵二叉树保存字符集中各字符的编码，每个编码对应于从根开始到达某叶结点的一条路径，路径长度等于编码位数，路径到达的叶结点中保存该编码对应的字符</p>
<p>2)从左至右依次扫描0/1串中的各位。从根开始，根据串中当前位沿当前结点的左子指针或右子指针下移，直到移动到叶结点时为止。输出叶结点中保存的字符。输出叶结点中保存的字符。然后从根开始重复这个过程，直到扫描到0/1串结束，译码完成。</p>
<p>3)二叉树既可用于保存各字符的编码，又可用于检测编码是否具有前缀特性。判定编码是否具有前缀特性的过程，也是构建二叉树的过程。初始时，二叉树中仅含有根结点，其左子指针和右子指针均为空。</p>
<p>依次读入编码C，建立/寻找从根开始对应于该编码的一条路径，过程如下:</p>
<p>对每个编码，从左至右扫描C的各位，根据C的当前位(0或1)沿结点的指针(左子指针或右子指针)向下移动。当遇到空指针时，创建新结点，让空指针指向该新结点并继续移动。沿着指针移动的过程中，可能遇到三种情况:</p>
<p>①若遇到了叶结点(非根)，则表明不具有前缀特性，返回。</p>
<p>②若在处理C的所有位的过程中，均没有创建新结点，则表明不具有前缀特性，返回。</p>
<p>③若在处理C的最后一个编码位时创建了新结点，则继续验证下一个编码。</p>
<p>若所有编码均通过验证，则编码具有前缀特性。</p>
</blockquote>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://tikxeis.fun">kailin2eis</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://tikxeis.fun/p/56280/">http://tikxeis.fun/p/56280/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://tikxeis.fun" target="_blank">派总</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/408%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">408数据结构</a></div><div class="post_share"><div class="social-share" data-image="/img/1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/63800/"><img class="prev-cover" src="/img/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第六章 图(上)</div></div></a></div><div class="next-post pull-right"><a href="/p/48066/"><img class="next-cover" src="/img/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第五章 树与二叉树(中)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/p/24523/" title="第一章 绪论"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第一章 绪论</div></div></a></div><div><a href="/p/14457/" title="第二章 线性表(上)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第二章 线性表(上)</div></div></a></div><div><a href="/p/12625/" title="第二章 线性表(下)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第二章 线性表(下)</div></div></a></div><div><a href="/p/63528/" title="第三章 栈、队列和数组(上)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第三章 栈、队列和数组(上)</div></div></a></div><div><a href="/p/17647/" title="第四章 串"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-28</div><div class="title">第四章 串</div></div></a></div><div><a href="/p/58315/" title="第三章 栈、队列和数组(下)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-28</div><div class="title">第三章 栈、队列和数组(下)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">kailin2eis</div><div class="author-info__description">派总's blog</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97-Tree-Forest"><span class="toc-text">5.4 树、森林 Tree Forest</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E5%9B%9E%E9%A1%BE"><span class="toc-text">树的逻辑结构回顾</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-text">双亲表示法(顺序存储)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95-%E9%A1%BA%E5%BA%8F-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-text">孩子表示法(顺序+链式存储)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8-%F0%9F%94%A5"><span class="toc-text">孩子兄弟表示法(链式存储)🔥</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">树、森林与二叉树的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">树和二叉树的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">森林和二叉树的转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">树和森林的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%85%88%E6%A0%B9%E9%81%8D%E5%8E%86"><span class="toc-text">树的先根遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%90%8E%E6%A0%B9%E9%81%8D%E5%8E%86"><span class="toc-text">树的后根遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-text">树的层次遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E7%9A%84%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">森林的先序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">森林的中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98"><span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">5.5 树与二叉树的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%92%8C%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-text">哈夫曼树和哈夫曼编码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6"><span class="toc-text">带权路径长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">哈夫曼树的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0-%E7%8E%8B%E9%81%93"><span class="toc-text">哈夫曼树的构造(王道)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0-%E7%8E%8B%E5%8D%93"><span class="toc-text">哈夫曼树的构造(王卓)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">哈夫曼树的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81-%E7%8E%8B%E9%81%93"><span class="toc-text">哈夫曼编码(王道)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81-%E7%8E%8B%E5%8D%93"><span class="toc-text">哈夫曼编码(王卓)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%9B%86%E5%90%88"><span class="toc-text">逻辑结构——集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AB%E5%81%9A%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">为什么叫做并查集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-text">引言</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">并查集的存储结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-text">时间复杂度分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Union%E6%93%8D%E4%BD%9C%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">Union操作的优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E7%BB%88%E6%9E%81%E4%BC%98%E5%8C%96"><span class="toc-text">并查集的终极优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Find%E6%93%8D%E4%BD%9C%E7%9A%84%E4%BC%98%E5%8C%96-%E5%8E%8B%E7%BC%A9%E8%B7%AF%E5%BE%84"><span class="toc-text">Find操作的优化(压缩路径)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93"><span class="toc-text">并查集优化总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-1"><span class="toc-text">习题</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/44803/" title="第八章 排序(四)">第八章 排序(四)</a><time datetime="2022-09-28T11:54:17.000Z" title="发表于 2022-09-28 19:54:17">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/14847/" title="第八章 排序(三)">第八章 排序(三)</a><time datetime="2022-09-28T11:52:50.000Z" title="发表于 2022-09-28 19:52:50">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/43357/" title="第八章 排序(二)">第八章 排序(二)</a><time datetime="2022-09-28T11:50:30.000Z" title="发表于 2022-09-28 19:50:30">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/27129/" title="第八章 排序(一)">第八章 排序(一)</a><time datetime="2022-09-28T11:47:17.000Z" title="发表于 2022-09-28 19:47:17">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/15017/" title="第七章 查找(四)">第七章 查找(四)</a><time datetime="2022-09-28T11:33:21.000Z" title="发表于 2022-09-28 19:33:21">2022-09-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By kailin2eis</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="关关雎鸠,在河之洲,窈窕淑女,what' your qq" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>