<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>第五章 树与二叉树(中) | 派总</title><meta name="keywords" content="408数据结构"><meta name="author" content="kailin2eis"><meta name="copyright" content="kailin2eis"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="5.3 二叉树的遍历和线索二叉树二叉树的遍历遍历：按照某种次序把所有结点都访问一遍 对于一个线性结构，如a1 a2 a3 a4 a5 对其进行遍历，是很简单的，我们可以从前往后依次遍历，也可以从后往前。 但是对于树形结构，我们的遍历规则就会更复杂一些。 由于树这种结构呈现出了一层一层的效果，因此不难想到我们可以一层一层地访问这些结点。   这种方法叫做层次遍历，即基于树的层次特性确定的次序规则。">
<meta property="og:type" content="article">
<meta property="og:title" content="第五章 树与二叉树(中)">
<meta property="og:url" content="http://tikxeis.fun/p/48066/index.html">
<meta property="og:site_name" content="派总">
<meta property="og:description" content="5.3 二叉树的遍历和线索二叉树二叉树的遍历遍历：按照某种次序把所有结点都访问一遍 对于一个线性结构，如a1 a2 a3 a4 a5 对其进行遍历，是很简单的，我们可以从前往后依次遍历，也可以从后往前。 但是对于树形结构，我们的遍历规则就会更复杂一些。 由于树这种结构呈现出了一层一层的效果，因此不难想到我们可以一层一层地访问这些结点。   这种方法叫做层次遍历，即基于树的层次特性确定的次序规则。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://tikxeis.fun/img/1.png">
<meta property="article:published_time" content="2022-09-28T06:37:49.000Z">
<meta property="article:modified_time" content="2022-09-28T06:40:41.850Z">
<meta property="article:author" content="kailin2eis">
<meta property="article:tag" content="408数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tikxeis.fun/img/1.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://tikxeis.fun/p/48066/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第五章 树与二叉树(中)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-28 14:40:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/1.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">派总</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">第五章 树与二叉树(中)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-28T06:37:49.000Z" title="发表于 2022-09-28 14:37:49">2022-09-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-28T06:40:41.850Z" title="更新于 2022-09-28 14:40:41">2022-09-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/408%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">408数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="第五章 树与二叉树(中)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="5-3-二叉树的遍历和线索二叉树"><a href="#5-3-二叉树的遍历和线索二叉树" class="headerlink" title="5.3 二叉树的遍历和线索二叉树"></a>5.3 二叉树的遍历和线索二叉树</h2><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p><strong>遍历</strong>：按照某种次序把所有结点都访问一遍</p>
<p>对于一个线性结构，如a1 a2 a3 a4 a5</p>
<p>对其进行遍历，是很简单的，我们可以从前往后依次遍历，也可以从后往前。</p>
<p>但是对于树形结构，我们的遍历规则就会更复杂一些。</p>
<p>由于树这种结构呈现出了一层一层的效果，因此不难想到我们可以一层一层地访问这些结点。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-34.png" style="zoom:80%;" />

<p>这种方法叫做<strong>层次遍历</strong>，即基于树的层次特性确定的次序规则。</p>
<p>而我们此节主要说的<strong>先/中/后序遍历</strong>是基于树的递归特性确定的次序规则。</p>
<p><strong>二叉树的递归特性</strong>：</p>
<ol>
<li>要么是个空二叉树</li>
<li>要么就是由 “根节点 + 左子树 + 右子树” 组成的二叉树</li>
<li><strong>先序遍历：根左右</strong></li>
<li><strong>中序遍历：左根右</strong></li>
<li><strong>后序遍历：左右根</strong></li>
</ol>
<hr>
<p>我们先来看一个简单的例子：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-35.png" style="zoom:80%;" />

<p>上述是最简单的二叉树遍历，我们再来看一个:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-36.png" style="zoom: 80%;" />

<h4 id="先序遍历-PreOrder"><a href="#先序遍历-PreOrder" class="headerlink" title="先序遍历 PreOrder"></a>先序遍历 PreOrder</h4><p>先序遍历的操作过程如下：</p>
<ol>
<li>若二叉树为空，则什么也不做</li>
<li>若二叉树非空<ol>
<li>访问根节点</li>
<li>先序遍历左子树</li>
<li>先序遍历右子树</li>
</ol>
</li>
</ol>
<p><font color='orange'>先序遍历——第一次路过时访问结点</font></p>
<p>先序遍历的算法实现（递归）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (T != <span class="literal">NULL</span>)&#123;         <span class="comment">// 如果二叉树非空，则继续</span></span><br><span class="line">    visit(T);             <span class="comment">// 访问根结点内容</span></span><br><span class="line">    PreOrder(T-&gt;lchild);  <span class="comment">// 访问左子树内容</span></span><br><span class="line">    PreOrder(T-&gt;rchild);  <span class="comment">// 访问右子树内容</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="中序遍历-InOrder"><a href="#中序遍历-InOrder" class="headerlink" title="中序遍历 InOrder"></a>中序遍历 InOrder</h4><p>中序遍历的操作过程如下：</p>
<ol>
<li>若二叉树为空，则什么也不做</li>
<li>若二叉树非空<ol>
<li>中序遍历左子树</li>
<li>访问根节点</li>
<li>中序遍历右子树</li>
</ol>
</li>
</ol>
<p><font color='orange'>中序遍历——第二次路过时访问结点</font></p>
<blockquote>
<p>这里要提两个术语:前驱节点和后继节点</p>
<p>前驱节点：对一棵二叉树进行中序遍历，遍历后的顺序，当前节点的前一个节点为该节点的前驱节点；</p>
<p>后继节点：对一棵二叉树进行中序遍历，遍历后的顺序，当前节点的后一个节点为该节点的后继节点；</p>
</blockquote>
<p>中序遍历的算法实现（递归）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        InOrder(T -&gt; lchild);		<span class="comment">// 递归遍历左子树</span></span><br><span class="line">        visit(T);					<span class="comment">// 访问根节点</span></span><br><span class="line">        InOrder(T -&gt; rchild);		<span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="后续遍历-PostOrder"><a href="#后续遍历-PostOrder" class="headerlink" title="后续遍历 PostOrder"></a>后续遍历 PostOrder</h4><p>后序遍历的操作过程如下：</p>
<ol>
<li>若二叉树为空，则什么也不做</li>
<li>若二叉树非空:<ol>
<li>后序遍历左子树</li>
<li>后序遍历右子树</li>
<li>访问根节点</li>
</ol>
</li>
</ol>
<p><font color='orange'>后序遍历——第三次路过时访问结点</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line">Void <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        PostOrder(T-&gt;lchild);			<span class="comment">// 递归遍历左子树</span></span><br><span class="line">        PostOrder(T-&gt;rchild);			<span class="comment">// 递归遍历右子树</span></span><br><span class="line">        visit(T);						<span class="comment">// 访问根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="手算练习"><a href="#手算练习" class="headerlink" title="手算练习"></a>手算练习</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问一个结点:打印字符</span></span><br><span class="line">Void <span class="title function_">visit</span><span class="params">(BiTNode *p)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,p-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-37.png" style="zoom:80%;" />

<p><font color='orange'>这里的遍历和我们学习栈的表达式时很有关联，我们将这里的先序遍历的表达式转换为中缀表达式和后缀表达式，分别对应的就是中序遍历和后序遍历，只是中序遍历没有添加界限符</font></p>
<hr>
<blockquote>
<p>三种遍历算法中，递归遍历左、右子树的顺序都是固定的，只是访问根结点的顺序不同。不管采用哪种遍历算法，每个结点都访问一次且仅访问一次，故时间复杂度都是O(n)。在递归遍历中，递归工作栈的栈深恰好为树的深度，所以在最坏情况下，二叉树是有n个结点且深度为n的单支树，遍历算法的空间复杂度为O(n)。</p>
</blockquote>
<h4 id="求树的深度-应用"><a href="#求树的深度-应用" class="headerlink" title="求树的深度(应用)"></a>求树的深度(应用)</h4><p>对于求树的深度，我们只需要选择左子树和右子树中深度最大的子树 + 1 就是树的深度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求树的深度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">treeDepth</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)&#123;								<span class="comment">// 树是空树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;								<span class="comment">// 深度为0</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> l = treeDepth(T-&gt;lchild);			<span class="comment">// 求左子树的深度</span></span><br><span class="line">        <span class="type">int</span> r = treeDepth(T-&gt;rchild);			<span class="comment">// 求右子树的深度</span></span><br><span class="line">        <span class="comment">// 树的深度 = Max(左子树深度,右子树深度)+1</span></span><br><span class="line">        <span class="keyword">return</span> l&gt;r ? l+<span class="number">1</span> : r+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归算法和非递归算法的转换"><a href="#递归算法和非递归算法的转换" class="headerlink" title="递归算法和非递归算法的转换"></a>递归算法和非递归算法的转换</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_53144843/article/details/121127971">https://blog.csdn.net/qq_53144843/article/details/121127971</a></p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-1.jpg" style="zoom: 25%;" />

<p>上图中，用带箭头的虚线表示了这3种遍历算法的递归执行过程。其中，向下的箭头表示更深一层的递归调用，向上的箭头表示从递归调用退出返回；虚线旁的三角形、圆形和方形内的字符分别表示在先序、中序、后序遍历的过程中访问结点时输出的信息。如图，先序序列为A B D E C、中序序列为D B E A C、后序序列为D E B C A。</p>
<h5 id="中序遍历的非递归算法"><a href="#中序遍历的非递归算法" class="headerlink" title="中序遍历的非递归算法"></a>中序遍历的非递归算法</h5><p>借助栈，分析中序遍历的访问过程:</p>
<p>①<strong>沿着根的左孩子，依次入栈，直到左孩子为空</strong>，说明已找到可以输出的结点，此时栈内元素依次为A B D。②<strong>栈顶元素出栈并访问:若其右孩子为空，继续执行</strong>②；<strong>若其右孩子不空，将右子树转执行</strong>①。栈顶D出栈并访问，它是中序序列的第一个结点:D右孩子为空，栈顶B出栈并访问；B右孩子不空，将其右孩子E入栈，E左孩子为空，栈顶E出栈并访问；E右孩子为空，栈顶A出栈并访问；A右孩子不空，将其右孩子C入栈，C左孩子为空，栈顶C出栈并访问。由此得到中序序列D B E A C。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrder2</span><span class="params">(BiTree T, SqStack S)</span> &#123;</span><br><span class="line">  InitStack(S); BiTree p = T;<span class="comment">//初始化栈S；p是遍历指针</span></span><br><span class="line">  <span class="keyword">while</span> (p||!IsEmpty(S)) &#123;   <span class="comment">//栈不空或p不空时循环</span></span><br><span class="line">    <span class="keyword">if</span> (p) &#123;                 <span class="comment">//一路向左</span></span><br><span class="line">        Push(S, p);          <span class="comment">//当前结点入栈</span></span><br><span class="line">        p = p-&gt;lchild;       <span class="comment">//左孩子不空，一直向左走</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                   <span class="comment">//出栈，并转向出栈结点的右子树</span></span><br><span class="line">        Pop(S,p); visit(p);  <span class="comment">//栈顶元素出栈，访问出栈结点</span></span><br><span class="line">        p = p-&gt;rchild;       <span class="comment">//向右子树走，p赋值为当前结点的右孩子</span></span><br><span class="line">    &#125;                        <span class="comment">//返回while循环继续进入if-else语句</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="先序遍历的非递归算法"><a href="#先序遍历的非递归算法" class="headerlink" title="先序遍历的非递归算法"></a>先序遍历的非递归算法</h5><p>先序遍历和中序遍历的基本思想是类似的，只需把访问结点操作放在入栈操作的前面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrder2</span><span class="params">(BiTree T, SqStack S)</span> &#123;</span><br><span class="line">  InitStack(S); BiTree p = T;<span class="comment">//初始化栈S；p是遍历指针</span></span><br><span class="line">  <span class="keyword">while</span> (p||!IsEmpty(S)) &#123;   <span class="comment">//栈不空或p不空时循环</span></span><br><span class="line">    <span class="keyword">if</span> (p) &#123;                 <span class="comment">//一路向左</span></span><br><span class="line">        visit(p);Push(S,p);  <span class="comment">//访问当前结点，并入栈</span></span><br><span class="line">        p = p-&gt;lchild;       <span class="comment">//左孩子不空，一直向左走</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                   <span class="comment">//出栈，并转向出栈结点的右子树</span></span><br><span class="line">        Pop(S,p);            <span class="comment">//栈顶元素出栈</span></span><br><span class="line">        p = p-&gt;rchild;       <span class="comment">//向右子树走，p赋值为当前结点的右孩子</span></span><br><span class="line">    &#125;                        <span class="comment">//返回while循环继续进入if-else语句</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="后序遍历的非递归算法"><a href="#后序遍历的非递归算法" class="headerlink" title="后序遍历的非递归算法"></a>后序遍历的非递归算法</h5><blockquote>
<p>后序遍历的非递归实现是三种遍历算法中最难的。因为后序遍历中，要保证左孩子和右孩子都已被访问并且左孩子在右孩子前访问才能访问根结点，这就为流程的控制带来了难题。</p>
</blockquote>
<p>后序非递归遍历算法思想:后序非递归遍历二叉树是先访问左子树，再访问右子树，最后访问根结点。结合图来分析:①<strong>沿着根的左孩子，依次入栈，直到左孩子为空</strong>。此时栈内元素依次为A B D。②<strong>读栈顶元素:若其右孩子不空且未被访问过，将右子树转执行</strong>①；<strong>否则，栈顶元素出栈并访问</strong>。栈顶D的右孩子为空，出栈并访问，它是后序序列的第一个结点；栈顶B的右孩子不空且未被访问过，E入栈，栈顶E的左右孩子均为空，出栈并访问；栈顶B的右孩子不空但已被访问，B出栈并访问；栈顶A的右孩子不空且未被访问，C入栈，栈顶C的左右孩子均为空，出栈并访问；栈顶A的右孩子不空但已被访问，A出栈并访问。由此得到后序序列D E B C A。</p>
<p>在上述思想中的第②步，<strong>必须分清返回时是从左子树返回的还是从右子树返回的</strong>，因此设定<font color='red'>一个辅助指针r</font>，指向最近访问过的结点。<font color='orange'>也可在结点中增加一个标志域</font>，记录是否已被访问。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    p=T;</span><br><span class="line">    r=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p||!IsEmpty(s))&#123;</span><br><span class="line">        <span class="keyword">if</span>(P)&#123;   <span class="comment">//走到最左边</span></span><br><span class="line">            push(S,p);</span><br><span class="line">            p=p——&gt;lchild；</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;   <span class="comment">//向右</span></span><br><span class="line">            GetTop(S,p); <span class="comment">//读栈顶结点(非出栈)</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;rchild&amp;&amp;p-&gt;rchild! =r)<span class="comment">//若右子树存在，且未被访问过</span></span><br><span class="line">                p=p-&gt;rchild; <span class="comment">//转向右</span></span><br><span class="line">            <span class="keyword">else</span>&#123;    <span class="comment">//否则，弹出结点并访问</span></span><br><span class="line">                pop(S,p); <span class="comment">//弹出结点</span></span><br><span class="line">                visit(p-&gt;data); <span class="comment">//访问该结点</span></span><br><span class="line">                r=p;  <span class="comment">//记录最近访问过的结点</span></span><br><span class="line">                p=<span class="literal">NULL</span>;  <span class="comment">//结点访问完后，重置p指针</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//else</span></span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:每次出栈访问完一个结点就相当于遍历完以该结点为根的子树，需将p置NULL。</p>
</blockquote>
<h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-38.png" style="zoom: 80%;" />

<p>算法思想：</p>
<ol>
<li><p>初始化一个辅助队列</p>
</li>
<li><p>让根结点入队</p>
</li>
<li><p>若队列非空，则队头结点出队，访问该结点，并将其左、右孩子插入队尾(如果有的话)</p>
<ul>
<li>例如 A 结点在队头，让 A 出队，并将其左、右孩子 B、C 插入队</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-39.png" style="zoom:80%;" /></li>
<li><p>重复 3 直至队列为空</p>
<ul>
<li>B 此时为队头元素，B 出队，将 B 的左右孩子 D、E 插入队尾</li>
<li>C 此时为队头元素，C 出队，将 C 的左右孩子 F、G 插入队尾</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-40.png" style="zoom:80%;" /></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 层序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    LinkQueue Q;				<span class="comment">// 链队列</span></span><br><span class="line">    InitQueue(Q);				<span class="comment">// 初始化辅助队列</span></span><br><span class="line">    BiTree p;					</span><br><span class="line">    EnQueue(Q,T);				<span class="comment">// 将根结点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;			<span class="comment">// 队列不为空则循环</span></span><br><span class="line">        DeQueue(Q,p);			<span class="comment">// 队头结点出队</span></span><br><span class="line">        visit(p);				<span class="comment">// 访问出队结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            EnQueue(Q,p-&gt;lchild);<span class="comment">// 左孩子入队</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            EnQueue(Q,p-&gt;rchild);<span class="comment">// 右孩子入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里使用的是链队列，因为我们无法估计一棵树到底有多少个结点，使用链队列方便我们对空间进行扩展。</p>
<p>对于链队列的初始化、入队出队等操作，之前讲过就不再重复了。</p>
</blockquote>
<h3 id="由遍历序列构造二叉树"><a href="#由遍历序列构造二叉树" class="headerlink" title="由遍历序列构造二叉树"></a>由遍历序列构造二叉树</h3><blockquote>
<p>给定一棵二叉树，它的中序遍历序列是唯一的。</p>
<p>但是给定一个中序遍历序列，我们不能确切的说，它对应的是哪棵树。同一个中序遍历序列可能对应多种二叉树形态。</p>
<p>前序遍历、后序遍历、层序遍历同理。</p>
<p>因此，若只给出某一种遍历序列，就让逆推出二叉树，是不可能的。</p>
</blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-41.png" style="zoom:67%;" />

<p><font color='cornflowerblue'>结论：一个中序/前序/后序/层次遍历序列可能对应多种二叉树形态，若只给出一棵二叉树的 前/中/后/层 序遍历序列中的一种，不能唯一确定一棵二叉树</font></p>
<p><font color='orange'>怎样可以唯一确定一棵二叉树呢？</font></p>
<p>若要由二叉树的遍历序列构造二叉树，则</p>
<ul>
<li>前序 + 中序 遍历序列</li>
<li>后序 + 中序 遍历序列</li>
<li>层序 + 中序 遍历序列</li>
</ul>
<p><font color="red">注意：前序、后序、层序序列的两两组合无法唯一确定一棵二叉树，一定要有中序遍历序列，才能推出二叉树</font></p>
<h4 id="前序-中序遍历序列"><a href="#前序-中序遍历序列" class="headerlink" title="前序+中序遍历序列"></a>前序+中序遍历序列</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-42.png" style="zoom:80%;" />

<p>我们来看一个例子：</p>
<ul>
<li>已知前序遍历序列为：A D B C E</li>
<li>已知中序遍历序列为：B D C A E</li>
</ul>
<p>由中序遍历序列首先推出根节点为 A ，(B D C) 均为左子树，E 为右子树。如下图</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-43.png" style="zoom:50%;" />

<p>由前序遍历序列推出左子树的根节点为 D，则由中序序列推出结点 D 的左子树为 B，右子树为 C</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-176.png"  />

<hr>
<p>再来看一个复杂一点的例子</p>
<ul>
<li>已知前序遍历序列为：D A E F B C H G I</li>
<li>已知中序遍历序列为：E A F D H C B G I</li>
</ul>
<p>由前序遍历序列推出 D 为根结点，则由中序遍历序列可知 D 的左子树为 (D A F)，右子树为(H C B G I)</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-45.png" style="zoom:50%;" />

<p>根据前序遍历序列 A 为左子树的根节点，根据中序遍历序列 A 的左子树为 E，右子树则为 F</p>
<p>根据前序遍历序列 B 为右子树的根节点，根据中序遍历序列 B 的左子树为(H C)，右子树为(GI)</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-46.png" style="zoom:50%;" />

<p>根据前序遍历序列 C 为 根，根据中序遍历序列 C 的左子树为 H</p>
<p>根据前序遍历序列 G 为根，根据中序遍历序列 G 的右子树为 I</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-47.png" style="zoom:50%;" />

<h4 id="后续-中序遍历序列"><a href="#后续-中序遍历序列" class="headerlink" title="后续+中序遍历序列"></a>后续+中序遍历序列</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-48.png" style="zoom: 80%;" />

<p>我们来看一个例子：</p>
<ul>
<li>已知后序遍历序列：E F A H C I G B D (左 右 根)</li>
<li>已知中序遍历序列：E A F D H C B G I (左 根 右)</li>
</ul>
<p>根据后序遍历序列 D 为根节点，根据中序遍历序列 ，(E A F) 为左子树，(H C B G I) 为右子树</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-49.png" style="zoom: 50%;" />

<p>根据后序遍历序列 A 为左子树的根节点，根据中序遍历序列 E 为 A 结点的左子树，F为右子树</p>
<p>根据后序遍历序列 B 为右子树的根节点，根据中序遍历序列 (H C) 为左子树，(G I)为右子树</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-50.png" style="zoom:50%;" />

<p>根据后序遍历序列 C 为根，G 为根。根据中序遍历序列 H 为左子树，I 为右子树</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-51.png" style="zoom:50%;" />

<h4 id="层序-中序遍历序列"><a href="#层序-中序遍历序列" class="headerlink" title="层序+中序遍历序列"></a>层序+中序遍历序列</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-52.png" style="zoom: 80%;" />

<p>我们来看一个简单的例子：</p>
<ul>
<li>已知层序遍历序列：A B C D E (根 左子树的根 右子树的根)</li>
<li>已知中序遍历序列：A C B E D (左 根 右)</li>
</ul>
<p>根据层序遍历序列，首先访问第一层，根为 A。格局中序遍历序列，A 的左边没有元素，则 A 的左子树为空1</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-53.png" style="zoom: 50%;" />

<p>根据层序遍历序列，访问第二层，首先出现的是 B，则 B 是右子树的根节点。根据中序遍历序列，C 为 B 的左子树，(E D) 为 B 的右子树</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-54.png" style="zoom:50%;" />

<p>根据层序遍历，访问第三层，首先出现的是 C、D，则 D 为根，根据中序遍历，E 为 D 的左子树</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-55.png" style="zoom:50%;" />

<hr>
<p>我们来看一个例子：</p>
<ul>
<li>已知层序遍历序列：D A B E F C G H I (根 左子树的根 右子树的根)</li>
<li>已知中序遍历序列：E A F D H C B G I (左 根 右)</li>
</ul>
<p>根据层序遍历序列，访问第一层，D 为根结点，根据中序遍历序列，(E A F)为左子树，(H C B G I)为右子树</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-56.png" style="zoom:50%;" />

<p>根据层序遍历序列，访问第二层，首先出现的是A、B，则A 为左子树的根节点，B 为右子树的根节点。根据中序遍历，E 为 A 的左子树，F为 A 的右子树。 (H C )为 B 的左子树，(G I) 为 B 的右子树</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-57.png" style="zoom:50%;" />

<p>根据层序遍历序列，访问第三层，首先出现的是 E、F、C、G，则 根节点分别为 C、G</p>
<p>根据中序遍历，C 的左子树为 H，G 的右子树为 </p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-58.png" style="zoom:50%;" />

<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><h4 id="线索二叉树的作用"><a href="#线索二叉树的作用" class="headerlink" title="线索二叉树的作用"></a>线索二叉树的作用</h4><p>普通二叉树有如下两个<strong>问题</strong>：</p>
<ul>
<li>普通二叉树遍历只能从根节点开始遍历，不能从一个指定结点开始中序遍历。</li>
<li>普通二叉树中如果只知道指向当前结点的指针，没法找到当前结点在中序遍历序列的前驱。(例如下图中只知道指向 F 结点的指针 p，如何找到结点在中序遍历序列的前驱呢？)</li>
</ul>
<p>那么我们如何解决上述问题呢？</p>
<p><font color='red'>思路</font>：</p>
<ul>
<li>从根结点出发，重新进行一次中序遍历，指针 q 记录当前访问的结点，指针 pre 记录上一个被访问的结点(前驱)</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-59.png" style="zoom: 80%;" />

<ul>
<li>下一个结点被访问(visit)之前，我们需要将 pre 前驱指针指向 q 所指向的结点，然后 q 指针指向下一个要访问的结点</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-60.png" style="zoom: 33%;" />

<ul>
<li>所以现在 pre 指针所指向的结点就是 q 指针所指向结点的中序遍历的前驱。用这样的思路我们可以让 q 不断的指向后一个被访问的结点，然后 pre 也跟着依次的向后移动。</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-61.png" style="zoom: 33%;" />

<ul>
<li>当 q 和 p 指向了同一个结点，也就是 q == p，那么就说明 pre 所指向的结点就是 p 所指向结点的前驱</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-62.png" style="zoom: 33%;" />

<ul>
<li>继续 pre 向后移， q 也向后移。此时 pre == p，则 q 所指向的结点就是 p 所指向结点的后继</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-63.png" style="zoom: 33%;" />

<p><font color='orange'>上述的操作是非常不方便的，线索二叉树就是为了解决上述问题的。</font></p>
<p><strong>n 个结点的二叉树，有 n + 1 个空链域。我们可以利用这些空链域来记录前驱、后继的信息。</strong></p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-215.png" style="zoom:55%;" />

<ul>
<li>如上图，D 的左子树是空链域，因为 D 没有前驱结点，是第一个结点，所以让其左子树指向NULL</li>
<li>G 的左右子树都是空链域，让左子树指向其前驱结点 D，让右子树指向其后继结点 B</li>
<li>E 的左右子树都是空链域，让左子树指向其前驱结点 B，让右子树指向其后继结点 A</li>
<li>F 的左右子树都是空链域，让左子树指向其前驱结点 A，让右子树指向其后继结点 C</li>
<li>C 的右子树是空链域，因为 C 没有后继结点，是最后一个结点，所以让其右子树指向 NULL</li>
</ul>
<p><strong>定义</strong>：一个结点的左孩子指针和右孩子指针指向的是前驱和后继而不是其左右孩子的话，我们把这种类型的指针称为线索，指向前驱的是前驱线索，指向后继的是后继线索。</p>
<p><font color='cornflowerblue'>那么还存在一个问题，如果我们的右孩子指针指向的就是右孩子而不是后继，那么如何找后继呢？</font></p>
<h4 id="线索二叉树的存储结构"><a href="#线索二叉树的存储结构" class="headerlink" title="线索二叉树的存储结构"></a>线索二叉树的存储结构</h4><p><strong>普通二叉树</strong>的链式存储结点:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-65.png" style="zoom: 67%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的结点(链式存储)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>

<p><strong>线索二叉树</strong>的链式存储结点:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-66.png" style="zoom: 67%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线索二叉树的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag,rtag;						<span class="comment">// 左、右线索标志</span></span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br></pre></td></tr></table></figure>

<h5 id="中序线索二叉树的存储"><a href="#中序线索二叉树的存储" class="headerlink" title="中序线索二叉树的存储"></a>中序线索二叉树的存储</h5><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-216.png" style="zoom: 55%;" />

<p>以上是中序线索二叉树。而对于先序、后序线索二叉树来说，只不过是遍历序列的顺序变了，<strong>利用左孩子指针充当前驱线索、右孩子指针充当后继线索</strong>的思想是一样的。</p>
<blockquote>
<p>总之，线索二叉树的思想就是利用n个结点的二叉树的n+1个空链域，把这些空链域变成<strong>线索</strong>，指向前驱、后继。</p>
<p>而先序/中序/后续线索二叉树的区别，仅仅是遍历出来的序列是什么的区别。</p>
<p>一些术语：</p>
<p>先/中/后序前驱、先/中/后序后继——先/中/后序线索二叉树中的<strong>线索</strong></p>
</blockquote>
<h4 id="先序线索二叉树"><a href="#先序线索二叉树" class="headerlink" title="先序线索二叉树"></a>先序线索二叉树</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-68.png" style="zoom:80%;" />

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-69.png" style="zoom: 67%;" />

<h4 id="后序线索二叉树"><a href="#后序线索二叉树" class="headerlink" title="后序线索二叉树"></a>后序线索二叉树</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-217.png" style="zoom:55%;" />

<h4 id="三种线索二叉树的对比"><a href="#三种线索二叉树的对比" class="headerlink" title="三种线索二叉树的对比"></a>三种线索二叉树的对比</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-218.png" style="zoom:55%;" />

<ul>
<li>中序线索二叉树 ➡ 线索指向中序前驱、中序后继</li>
<li>先序线索二叉树 ➡ 线索指向先序前驱、先序后继</li>
<li>后序线索二叉树 ➡ 线索指向后序前驱、后序后继</li>
</ul>
<h3 id="二叉树的线索化"><a href="#二叉树的线索化" class="headerlink" title="二叉树的线索化"></a>二叉树的线索化</h3><h4 id="中序线索化"><a href="#中序线索化" class="headerlink" title="中序线索化"></a>中序线索化</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-72.png" style="zoom: 50%;" />

<p>中序遍历二叉树，<font color='orange'>一边遍历一边线索化</font></p>
<ul>
<li><p>首先中序遍历左子树，首先访问到的是 D 结点，D 结点没有前驱，所以将 pre 指针指向NULL，并将标志修改为 1 (代表这个孩子指针是线索)</p>
</li>
<li><p>之后访问下一个结点，pre 指向 q 指向的结点，q 指向下一个结点</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-73.png" style="zoom:50%;" /></li>
<li><p>此时 q 指向的结点为 G，判断左子树，如果为空，则建立前驱线索并修改标志为 1 ，判断其右子树，如果为空，则建立后继线索并修改标志为 1</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-74.png" style="zoom:50%;" /></li>
<li><p>当访问最后一个结点时，pre 和 q 均指向最后一个结点，要检查 pre-&gt; rchild 是否为 NULL，如果是，则令标志为 1</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-75.png" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线索二叉树的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag,rtag;						<span class="comment">// 左、右线索标志</span></span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历二叉树,一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        InThread(T-&gt;lchild);		<span class="comment">// 中序遍历左子树</span></span><br><span class="line">        visit(T);					<span class="comment">// 访问根节点</span></span><br><span class="line">        InThread(T-&gt;rchild);		<span class="comment">// 中序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量 pre,指向当前访问结点的前驱(开始访问第一个结点,无前驱,所以指向NULL)</span></span><br><span class="line">ThreadNode *pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;lchild == <span class="literal">NULL</span>)&#123;			<span class="comment">// 如果左子树为空,则建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        pre-&gt;rchild = q;			<span class="comment">// 建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    pre=<span class="literal">NULL</span>;						<span class="comment">// pre初始为NULL</span></span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;					<span class="comment">// 非空二叉树才能线索化</span></span><br><span class="line">        InThread(T);				<span class="comment">// 中序线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;			<span class="comment">// 处理遍历的最后一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="先序线索化"><a href="#先序线索化" class="headerlink" title="先序线索化"></a>先序线索化</h4><p>先序遍历二叉树，<font color='orange'>一边遍历一边线索化</font></p>
<ul>
<li><p>首先访问根结点，判断左右子树，发现左右子树都非空，则不操作，让 pre 指向 q所指向的结点，q指向下一结点</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-76.png" style="zoom:50%;" /></li>
<li><p>访问结点 B，发现 B 的左右子树都非空，则不操作，让 pre 指向 q所指向的结点，q指向下一结点</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-77.png" style="zoom:50%;" /></li>
<li><p>之后访问 D 结点，发现其左子树为空，则建立前驱线索(将其左子树指向前驱结点B)，之后我们就要先序遍历 D结点的左子树，但是发现此时左子树为 B，这样下去就会造成循环。所以我们在先序遍历二叉树时，要让左子树不是前驱线索时再进行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历二叉树,一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        visit(T);				<span class="comment">// 先处理根结点</span></span><br><span class="line">        <span class="keyword">if</span>(T-&gt;ltag == <span class="number">0</span>)&#123;		<span class="comment">// lchild不是前驱线索</span></span><br><span class="line">            PreThread(T-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">        PreThread(T-&gt;rchild);	<span class="comment">// 先序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量 pre,指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;lchild == <span class="literal">NULL</span>)&#123;			<span class="comment">// 如果左子树为空,则建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        pre-&gt;rchild = q;			<span class="comment">// 建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    pre=<span class="literal">NULL</span>;						<span class="comment">// pre初始为NULL</span></span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;					<span class="comment">// 非空二叉树才能线索化</span></span><br><span class="line">        InThread(T);				<span class="comment">// 中序线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;			<span class="comment">// 处理遍历的最后一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="后序线索化"><a href="#后序线索化" class="headerlink" title="后序线索化"></a>后序线索化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线索二叉树的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag,rtag;						<span class="comment">// 左、右线索标志</span></span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历二叉树,一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        PostThread(T-&gt;lchild);		<span class="comment">// 中序遍历左子树</span></span><br><span class="line">        PostThread(T-&gt;rchild);		<span class="comment">// 中序遍历右子树</span></span><br><span class="line">        visit(T);					<span class="comment">// 访问根节点</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量 pre,指向当前访问结点的前驱(开始访问第一个结点,无前驱,所以指向NULL)</span></span><br><span class="line">ThreadNode *pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;lchild == <span class="literal">NULL</span>)&#123;			<span class="comment">// 如果左子树为空,则建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        pre-&gt;rchild = q;			<span class="comment">// 建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    pre=<span class="literal">NULL</span>;						<span class="comment">// pre初始为NULL</span></span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;					<span class="comment">// 非空二叉树才能线索化</span></span><br><span class="line">        InThread(T);				<span class="comment">// 中序线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;			<span class="comment">// 处理遍历的最后一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-78.png"></p>
<h3 id="线索二叉树找前驱-后继"><a href="#线索二叉树找前驱-后继" class="headerlink" title="线索二叉树找前驱/后继"></a>线索二叉树找前驱/后继</h3><h4 id="中序线索二叉树找中序后继"><a href="#中序线索二叉树找中序后继" class="headerlink" title="中序线索二叉树找中序后继"></a>中序线索二叉树找中序后继</h4><p>例如：我们要在中序线索二叉树中找到指定结点 *p 的中序后继 next，next = p的右子树中最左下结点</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-219.png" style="zoom:55%;" />

<ul>
<li>若 p -&gt; rtag == 1, 说明右子树被线索化，那么右子树就是其中序后继，则 next = p -&gt; rchild</li>
<li>若 p-&gt; rtag == 0,说明右子树未被线索化，右子树肯定是非空，则 p 必然有右孩子。</li>
</ul>
<blockquote>
<p>由于我们是找中序后继，也就是从中序遍历来看，在访问这个结点后，访问的下一个结点是什么。而中序遍历的访问顺序是：左、根、右。所以按照中序遍历的规则，访问p结点这个根结点之后，需要再中序遍历p的右子树。那么，在p的右子树中第一个被访问的结点，就应该是p的后继。</p>
<p>假设p的右子树只有一个右孩子，也就是只有一个叶子结点，那么显然这个右孩子就是p的后继。</p>
<p>但是如果这个结点是一个分支节点，也就是再往下还有更深层的结点的话，那么要对这个右子树继续进行中序遍历（左、根、右）这样来看的话，那么这个右子树的最左下角的那个结点就应该是p的中序后继结点。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到以 P 为根的子树中,第一个被中序遍历的结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Firstnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">    <span class="comment">// 循环找到最左下结点(不一定是叶结点)</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)&#123;</span><br><span class="line">        p = p-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在中序线索二叉树中找到结点 p 的后继结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Nextnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">    <span class="comment">// 右子树最左下结点(右子树当中第一个被遍历到的结点)</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Firstnode(p-&gt;rchild);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild;		<span class="comment">// rtag == 1 直接返回后继线索</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然我们能遍历到结点的后继结点，那么我们就可以对中序线索二叉树进行遍历</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对中序线索二叉树进行中序遍历(利用线索实现的非递归算法) </span></span><br><span class="line"><span class="comment">// 传入我们要遍历的树的根节点的指针T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Inorder</span><span class="params">(ThreadNode *T)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = Firstnode(T);p != <span class="literal">NULL</span>;p=Nextnode(p))&#123;</span><br><span class="line">        visit(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="中序线索二叉树找中序前驱"><a href="#中序线索二叉树找中序前驱" class="headerlink" title="中序线索二叉树找中序前驱"></a>中序线索二叉树找中序前驱</h4><p>例如：我们要在中序线索二叉树中找到指定结点 *p 的中序前驱pre，pre= p的左子树中最右下结点</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-220.png" style="zoom:55%;" />

<ul>
<li>若 p -&gt; ltag == 1, 说明左子树被线索化，那么左子树就是其中序后继，则 pre = p -&gt; lchild</li>
<li>若 p-&gt; ltag == 0,说明左子树未被线索化，那么左子树肯定非空，则 p 必然有左孩子。</li>
</ul>
<blockquote>
<p>按照中序遍历的规则，（左、根、右），它的这个结点的前驱一定是它的左子树当中，按照中序遍历最后一个被访问的结点。</p>
<p>如果左子树只有一个叶子结点，那么显然它的这个左孩子就是它的中序前驱。</p>
<p>而如果左子树还有多层分级的话，总之，其左子树最右下的结点就是左子树当中最后一个被访问的结点。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到以p为根的子树中,最后一个被中序遍历的结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Lastnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">    <span class="comment">// 循环找到最右下结点(不一定是叶节点)</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;rtag == <span class="number">0</span>)&#123;</span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在中序线索二叉树中找到结点p的前驱结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Prenode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">    <span class="comment">// 左子树中最右下结点</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ltag == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Lastnode(p-&gt;lchild);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;lchild;			<span class="comment">//ltag==1 直接返回前驱结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然我们能遍历到结点的前驱结点，那么我们就可以对中序线索二叉树进行逆向中序遍历</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对中序线索二叉树进行逆向中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RevInorder</span><span class="params">(ThreadNode *T)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = Lstnode(T);p != <span class="literal">NULL</span>;p = Prenode(p)&#123;</span><br><span class="line">        visit(p);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="先序线索二叉树找先序后继"><a href="#先序线索二叉树找先序后继" class="headerlink" title="先序线索二叉树找先序后继"></a>先序线索二叉树找先序后继</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-221.png" style="zoom:55%;" />

<ul>
<li>若 p -&gt; rtag == 1, 说明右子树被线索化，那么右子树就是其先序后继，则 next= p -&gt; rchild</li>
<li>若 p-&gt; rtag == 0,说明右子树未被线索化，那么右子树肯定非空，则 p 必然有右孩子。</li>
</ul>
<blockquote>
<p>我们先假设它有左孩子。</p>
<p>然后按照先序遍历（根、左、右）的规则来看，p结点的后继结点肯定是它左子树当中第一个被访问的结点。也就是不论其左子树有多少层级，都是p的那一个左孩子结点。</p>
<p>再说，如果没有左孩子。</p>
<p>如果没有左孩子的话，根据根、左、右的原则，由于左为空，那么就是根、右。那么也就是它的右子树当中第一个被先序遍历的结点。也就是，无论它的右子树是叶子结点，还是多个层级的分支节点，都是p的右孩子结点。</p>
</blockquote>
<h4 id="先序线索二叉树找先序前驱"><a href="#先序线索二叉树找先序前驱" class="headerlink" title="先序线索二叉树找先序前驱"></a>先序线索二叉树找先序前驱</h4><p>在先序线索二叉树中找到指定结点p的<strong>先序前驱</strong>pre。</p>
<ul>
<li>若p-&gt;ltag == 1，则next = p-&gt;lchild。</li>
<li>若p-&gt;ltag == 0，（说明p一定有左孩子）。</li>
</ul>
<blockquote>
<p>按照先序遍历的规则（根、左、右）可知，p的左子树、右子树，都只可能是p的后继，而不可能是p的前驱。因此，我们不可能在它的左右子树当中，找到它的前驱。</p>
<p>而我们的线索二叉树，它只有指向它的孩子结点的指针，不可能往上找。</p>
<p>所以在这种情况下，我们是找不到p的先序前驱的。</p>
<p>除非，用从头遍历的土办法，来重新进行一次完整的先序遍历来找到p的前驱。</p>
</blockquote>
<blockquote>
<p>但是我们说过，二叉链表其实我们可以在某些应用场景下，根据需要，把它改为三叉链表，即增加一个指向其父节点的指针。</p>
<p>那么在这种能找到它的父节点的情况下，我们再看，能不能找到它的先序前驱。</p>
<p>第一种情况：<strong>能找到p的父节点，且p是左孩子</strong></p>
<p>按照先序遍历的规则（根、左、右）来看，p结点一定是在它的父节点被访问过之后，第一个被访问到的。因此<strong>p的父节点一定是p的先序前驱</strong>。</p>
<p>第二种情况：<strong>能找到p的父节点，且p是右孩子，其左兄弟为空</strong></p>
<p>也就是p的父节点的左孩子为空。那么按照先序遍历的规则就应该是：根、右。因此，<strong>p的父节点一定是它的先序前驱</strong>。</p>
<p>第三种情况：<strong>能找到p的父节点，且p是右孩子，其左兄弟非空</strong></p>
<p>按照先序遍历的规则（根、左、右），p这个结点的先序前驱，一定是它的左兄弟子树，按照先序遍历的顺序<strong>最后一个被访问到的结点，也就是最右下的结点</strong>。即<strong>p的先序前驱为其左兄弟子树中最后一个被先序遍历访问的结点</strong>。</p>
<p>第四种情况：<strong>如果p没有父节点，也就是p是根结点，则p没有先序前驱</strong>。</p>
</blockquote>
<h4 id="后序线索二叉树找后序前驱"><a href="#后序线索二叉树找后序前驱" class="headerlink" title="后序线索二叉树找后序前驱"></a>后序线索二叉树找后序前驱</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-163.png" style="zoom: 50%;" />

<p>在后序线索二叉树中找到指定结点p的<strong>后续前驱</strong>pre。</p>
<ul>
<li>若p-&gt;ltag == 1，则pre = p-&gt;lchild。</li>
<li>若p-&gt;ltag == 0（说明它一定有左孩子，但是不一定有没有右孩子）</li>
</ul>
<blockquote>
<p>先讨论假设它有右孩子的情况：</p>
<p>按照后序遍历的规则（左、右、根），可以看到，p的后序前驱，是p的右子树中，按照后序遍历的规则被访问到的最后一个结点，也就是右孩子结点本身。因此，<strong>若p有右孩子，则后序前驱为其右孩子</strong>。</p>
<p>假设它没有右孩子：</p>
<p>按照后序遍历的规则（左、根），可以看到，p的后序前驱，是p的左子树中，按照后序遍历的规则被访问到的最后一个结点，也就是左孩子本身。因此，<strong>若p没有右孩子，则后序前驱为其左孩子</strong>。</p>
</blockquote>
<h4 id="后序线索二叉树找后序后继"><a href="#后序线索二叉树找后序后继" class="headerlink" title="后序线索二叉树找后序后继"></a>后序线索二叉树找后序后继</h4><p>在后序线索二叉树中找指定结点p的<strong>后序后继</strong>next。</p>
<ul>
<li>若p-&gt;rtag == 1，则next = p-&gt;rchild。</li>
<li>若p-&gt;rtag == 0，（说明其一定有右孩子）</li>
</ul>
<blockquote>
<p>按照后序遍历的规则（左、右、根）来看，p的左右子树均只有可能是它的前驱，而不可能是它的后继。</p>
<p>因此，后序遍历中，左右子树中的结点只可能是p的前驱，不可能是后继。</p>
<p>因此我们只能利用土办法，即从头到尾重新进行一次完整的后序遍历，才有可能找到它的后序后继。</p>
</blockquote>
<blockquote>
<p>但是，还可以改用三叉链表找到父节点的方式来完成。</p>
<p>第一种情况，<strong>能找到p的父节点，且p是右孩子</strong>：</p>
<p>按照后序遍历的规则（左、右、根），无论p结点下面还有没有孩子，p结点一定是最后一个被访问的结点。而在访问过p结点之后，下一个一定紧接着是访问它的父节点。因此，<strong>p的后序后继为p的父节点</strong>。</p>
<p>第二种情况，<strong>能找到p的父节点，且p是左孩子，其右兄弟为空</strong>：</p>
<p>按照后序遍历的规则（左、根）。显然，无论如何，在访问完p结点之后，一定会紧接着访问它的父节点。因此，<strong>p的后序后继为p的父节点</strong>。</p>
<p>第三种情况，<strong>能找到p的父节点，且p是左孩子，其右兄弟非空</strong>：</p>
<p>按照后序遍历的规则（左、右、根）来看，p的后继，就应该是它的右兄弟子树当中，按照后序遍历第一个被访问的结点，也就是右兄弟子树最左下的结点。因此，<strong>p的后序后继为右兄弟子树中第一个被后序遍历到的结点</strong>。</p>
<p>第四种情况，<strong>如果p是根结点，则p没有后序后继</strong>。</p>
</blockquote>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>对以上所有情况的讨论，我们只需要理解其逻辑过程，而不要去背结论</p>
<table>
<thead>
<tr>
<th></th>
<th>中序线索二叉树</th>
<th>先序线索二叉树</th>
<th>后序线索二叉树</th>
</tr>
</thead>
<tbody><tr>
<td>找前驱</td>
<td>✔</td>
<td>×</td>
<td>✔</td>
</tr>
<tr>
<td>找后继</td>
<td>✔</td>
<td>✔</td>
<td>×</td>
</tr>
</tbody></table>
<p>对先序线索二叉树来说，找先序前驱是不可以的；同样地，对于后续线索二叉树来说，找后序后继是不可以的。除非采用<strong>三叉链表</strong>，或者用<strong>土办法</strong>从整棵树的根结点重新进行完整的遍历来寻找其<strong>父节点</strong>。</p>
<p>也就是，对于先序线索二叉树来说，给你一个结点，你只能从这个结点开始向后进行先序遍历。</p>
<p>对于后续线索二叉树来说，给你一个结点，你只能从这个结点开始进行逆向的后序遍历。</p>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><ul>
<li><p>在二叉树中有两个结点 m 和 n，若 m 是 n 的祖先，则使用什么遍历方法可以找到 m 到 n 的路径 → 后序遍历</p>
</li>
<li><p>在二叉树的前序序列、中序序列和后序序列中，所有叶子结点的先后顺序相同吗？若不全相同，则哪几种遍历方式的先后顺序相同 → 完全相同</p>
</li>
<li><p>【2009】给定二叉树如右图所示。设N代表二叉树的根，L代表根结点的左子树，R代表根结点的右子树。若遍历后的结点序列是(3, 1, 7, 5, 6, 2, 4)，则其遍历方式是–&gt;RNL</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-82.png" style="zoom:85%;" />

<blockquote>
<p>分析遍历后的结点序列，可以看出根结点是在中间访问，而右子树结点在左子树之前，即遍历的方式是 RNL 。本题考查的遍历方法并不是二叉树的 3 种基本遍历方法，对于考生而言，重要的是要掌握遍历的思想。</p>
<ul>
<li>前序遍历：根结点 -&gt; 左子树 -&gt; 右子树</li>
<li>中序遍历：左子树 -&gt; 根结点 -&gt; 右子树</li>
<li>后序遍历：左子树 -&gt; 右子树 -&gt; 根结点</li>
</ul>
</blockquote>
</li>
<li><p>【2011】若一棵二叉树的前序遍历序列和后序遍历序列分别为{ 1, 2, 3, 4}和{4, 3, 2, 1}，则该二叉树的中序遍历序列不会是→C</p>
<p>A. 1234   B. 2341<br>C. 3241   D. 4321</p>
<blockquote>
<p>前序序列为NLR，后序序列的逆序为LRN，要使NLR=NRL（后序序列的反序），则L或R为空，这样的二叉树每层就只有一个结点，高度为4。1为根结点，由于根结点只有左孩子或右孩子，因此在中序序列中，1或在序列首或在序列尾，ABCD皆满足。仅考虑以1的孩子结点2为根的子树，同理在中序序列中，2或在序列首或在序列尾，ABD皆满足，C不满足。</p>
</blockquote>
</li>
<li><p>【2012】若一棵二叉树的前序遍历序列为{ a, e, b, d, c}，后序遍历序列为{ b, c, d, e, a}，则根结点的孩子结点 → 只有 e</p>
<blockquote>
<p>由先序遍历第一个结点为a,则可知道树的根节点为a。后序遍历序列中根节点会把序列分为左右两段，左段为左子树上结点，右段为右子树上结点，所以由后序遍历序列可知b,c,d,e均为a结点的左子树上的点，a不存在右子树。再由先序遍历序列知道e为根结点a的左孩子结点。即根节点的孩子结点只有e，且为左孩子。</p>
</blockquote>
</li>
<li><p>【2013】若X是后序线索二叉树中的叶结点，且X存在左兄弟结点Y，则X的右线索指向的是–&gt;A</p>
<p>A. X的父结点<br>B. 以Y为根的子树的最左下结点<br>C. X的左兄弟结点Y<br>D. 以Y为根的子树的最右下结点</p>
<blockquote>
<p>根据题意，x存在左兄弟结点y,说明x是右边的那个结点</p>
<p>由于是后序线索二叉树，后序遍历的规则是DLR，X的后继就是其双亲结点</p>
<p>因此右线索指向的是：X的父结点</p>
</blockquote>
</li>
<li><p>【2014】若对下图所示的二叉树进行中序线索化，则结点X的左、右线索指向的结点分别是–&gt;b，a</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-84.png" style="zoom: 80%;" />

<blockquote>
<p>中序线索化即根据中序遍历的顺序，找出该字母的前驱和后继。中序遍历结果为debxac。x的前驱是b，后继是a。所以结点x的左、右线索指向的结点分别是b，a。</p>
</blockquote>
</li>
<li><p>【2015】先序序列为a,b,c,d的不同二叉树的个数是–&gt;14</p>
<blockquote>
<p>根据二叉树前序遍历和中序遍历的递归算法中递归工作栈的状态变化得出：前序序列和中序序列的关系相当于以前序序列为入栈次序，以中序序列为出栈次序。因为前序序列和中序序列可以唯一地确定一棵二叉树，所以题意相当于“以序列 a,b,c,d 为入栈次序，则出栈序列的个数为？”，对于 n 个不同元素进栈，出栈序列的个数为14</p>
</blockquote>
</li>
<li><p>【2017】某二叉树的树形如图所示，其后序序列为e,a,c,b,d,g,f，树中与结点a同层的结点是–&gt;d</p>
<p><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-85.png"></p>
<blockquote>
<p>后序序列是先左子树，接着右子树，最后父结点，递归进行。根结点左子树的叶结点首先被访问，它是e。接下来是它的父结点a,然后是a的父结点c。接着访问根结点的右子树。它的叶结点b首先被访问，然后是b的父结点d，再后是d的父结点g,最后是根结点f,如右图所示。因此d与a同层。</p>
</blockquote>
</li>
<li><p>【2017】要使一棵非空二叉树的先序序列与中序序列相同，其所有非叶结点须满足的条件是–&gt;B</p>
<p>A. 只有左子树<br>B. 只有右子树<br>C. 结点的度均为1<br>D. 结点的度均为2</p>
<blockquote>
<p>先序序列是先父结点，接着左子树，然后右子树。中序序列是先左子树，接着父结点，然后右子树，递归进行。如果所有非叶结点只有右子树，先序序列和中序序列都是先父结点，然后右子树，递归进行，因此B正确。</p>
</blockquote>
</li>
<li><p>线索二叉树是一种什么结构？「逻辑、逻辑和存储、物理、线性」?→ 物理</p>
</li>
<li><p>一棵左子树为空的二叉树在先序线索化后，其中空的链域的个数是 →2 个</p>
</li>
<li><p>【2010】下列线索二叉树中(用虚线表示线索)，符合后序线索树定义的是–&gt;D</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds5-83.png" style="zoom:67%;" />

<blockquote>
<p>题中所给二叉树的后序序列为dbca。结点d无前驱和左子树，左链域空，无右子树，右链域指向其后继结点b；结点b无左子树，左链域指向其前驱结点d；结点c无左子树，左链域指向其前驱结点b，无右子树，右链域指向其后继结点a。</p>
</blockquote>
</li>
<li><p>二叉树在线索化后，仍不能有效求解的问题是？→D</p>
<p>A 先序线索二叉树中求先序后继<br>B 中序线索二叉树中求中序后继<br>C 中序线索二叉树中求中序前驱<br>D 后序线索二叉树中求后序后继 </p>
</li>
<li><p>（ ）的遍历仍需要栈的支持→C</p>
<p>A 前序线索树<br>B 中序线索树<br>C 后序线索树<br>D 所有线索树 </p>
</li>
<li><p>综合【2014】二叉树的带权路径长度(WPL)是二叉树中所有叶结点的带权路径长度之和。给定一棵二叉树T，采用二叉链表存储，结点结构为</p>
<table>
<thead>
<tr>
<th>left</th>
<th>weight</th>
<th>right</th>
</tr>
</thead>
</table>
<p>其中叶节点的weight域保存该结点的非负权值。设root为指向T的根节点的指针，设计求T的WPL的算法。要求：</p>
<p>（1）给出算法的基本设计思想；</p>
<p>（2）使用C或C++语言，给出二叉树结点的数据类型定义；</p>
<p>（3）根据设计思想，采用C或C++语言描述算法，关键之处给出注释。</p>
<blockquote>
<p>(1)算法的基本设计思想： </p>
<p>① 基于先序递归遍历的算法思想是用一个static变量记录wpl，把每个结点的深度作为递归函数的一个参数传递，算法步骤如下： </p>
<p>若该结点是叶子结点，那么变量wpl加上该结点的深度与权值之积； </p>
<p>若该结点非叶子结点，那么若左子树不为空，对左子树调用递归算法，若右子树不为空，对右子树调用递归算法，深度参数均为本结点的深度参数加1；</p>
<p>最后返回计算出的wpl即可。 </p>
<p>② 基于层次遍历的算法思想是使用队列进行层次遍历，并记录当前的层数， </p>
<p>当遍历到叶子结点时，累计wpl； </p>
<p>当遍历到非叶子结点时对该结点的把该结点的子树加入队列； </p>
<p>当某结点为该层的最后一个结点时，层数自增1； </p>
<p>队列空时遍历结束，返回wpl。</p>
<p>(2)算法中使用的二叉树结点的数据类型定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>

<p>(3)代码实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">WPL</span><span class="params">(BitNode root)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> wplPreOrder(root,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">wplPreOrder</span><span class="params">(BitNode root,<span class="type">int</span> deep)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> wpl=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;left= =<span class="literal">NULL</span> &amp;&amp; root-&gt;right= =<span class="literal">NULL</span>)<span class="comment">//若为叶结点，则累积WPL</span></span><br><span class="line">&#123;</span><br><span class="line">  wpl+=deep*root-&gt;weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;left! =<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  wplPreOrder(root-&gt;left,deep+<span class="number">1</span>);<span class="comment">//如果左子树不为空，则对左子树进行递归遍历</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;right! =<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  wplPreOrder(root-&gt;right,deep+<span class="number">1</span>);<span class="comment">//如果右子树不为空，则对右子树进行递归遍历</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> wpl;<span class="comment">//返回WPL值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://tikxeis.fun">kailin2eis</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://tikxeis.fun/p/48066/">http://tikxeis.fun/p/48066/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://tikxeis.fun" target="_blank">派总</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/408%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">408数据结构</a></div><div class="post_share"><div class="social-share" data-image="/img/1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/56280/"><img class="prev-cover" src="/img/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第五章 树与二叉树(下)</div></div></a></div><div class="next-post pull-right"><a href="/p/63944/"><img class="next-cover" src="/img/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第五章 树与二叉树(上)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/p/24523/" title="第一章 绪论"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第一章 绪论</div></div></a></div><div><a href="/p/14457/" title="第二章 线性表(上)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第二章 线性表(上)</div></div></a></div><div><a href="/p/12625/" title="第二章 线性表(下)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第二章 线性表(下)</div></div></a></div><div><a href="/p/63528/" title="第三章 栈、队列和数组(上)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第三章 栈、队列和数组(上)</div></div></a></div><div><a href="/p/58315/" title="第三章 栈、队列和数组(下)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-28</div><div class="title">第三章 栈、队列和数组(下)</div></div></a></div><div><a href="/p/17647/" title="第四章 串"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-28</div><div class="title">第四章 串</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">kailin2eis</div><div class="author-info__description">派总's blog</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">5.3 二叉树的遍历和线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86-PreOrder"><span class="toc-text">先序遍历 PreOrder</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-InOrder"><span class="toc-text">中序遍历 InOrder</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86-PostOrder"><span class="toc-text">后续遍历 PostOrder</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E7%AE%97%E7%BB%83%E4%B9%A0"><span class="toc-text">手算练习</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6-%E5%BA%94%E7%94%A8"><span class="toc-text">求树的深度(应用)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E5%92%8C%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">递归算法和非递归算法的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95"><span class="toc-text">中序遍历的非递归算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95"><span class="toc-text">先序遍历的非递归算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95"><span class="toc-text">后序遍历的非递归算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">层序遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B1%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">由遍历序列构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="toc-text">前序+中序遍历序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%BB%AD-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="toc-text">后续+中序遍历序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="toc-text">层序+中序遍历序列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">线索二叉树的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">线索二叉树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-text">中序线索二叉树的存储</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">先序线索二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">后序线索二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">三种线索二叉树的对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="toc-text">二叉树的线索化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="toc-text">中序线索化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="toc-text">先序线索化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="toc-text">后序线索化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%BE%E5%89%8D%E9%A9%B1-%E5%90%8E%E7%BB%A7"><span class="toc-text">线索二叉树找前驱&#x2F;后继</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%BE%E4%B8%AD%E5%BA%8F%E5%90%8E%E7%BB%A7"><span class="toc-text">中序线索二叉树找中序后继</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%BE%E4%B8%AD%E5%BA%8F%E5%89%8D%E9%A9%B1"><span class="toc-text">中序线索二叉树找中序前驱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%BE%E5%85%88%E5%BA%8F%E5%90%8E%E7%BB%A7"><span class="toc-text">先序线索二叉树找先序后继</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%BE%E5%85%88%E5%BA%8F%E5%89%8D%E9%A9%B1"><span class="toc-text">先序线索二叉树找先序前驱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%BE%E5%90%8E%E5%BA%8F%E5%89%8D%E9%A9%B1"><span class="toc-text">后序线索二叉树找后序前驱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%BE%E5%90%8E%E5%BA%8F%E5%90%8E%E7%BB%A7"><span class="toc-text">后序线索二叉树找后序后继</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98"><span class="toc-text">习题</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/12342/" title="第六章 图(下)">第六章 图(下)</a><time datetime="2022-09-28T07:19:14.000Z" title="发表于 2022-09-28 15:19:14">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/63800/" title="第六章 图(上)">第六章 图(上)</a><time datetime="2022-09-28T07:04:39.000Z" title="发表于 2022-09-28 15:04:39">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/56280/" title="第五章 树与二叉树(下)">第五章 树与二叉树(下)</a><time datetime="2022-09-28T06:47:26.000Z" title="发表于 2022-09-28 14:47:26">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/48066/" title="第五章 树与二叉树(中)">第五章 树与二叉树(中)</a><time datetime="2022-09-28T06:37:49.000Z" title="发表于 2022-09-28 14:37:49">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/63944/" title="第五章 树与二叉树(上)">第五章 树与二叉树(上)</a><time datetime="2022-09-28T04:50:11.000Z" title="发表于 2022-09-28 12:50:11">2022-09-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By kailin2eis</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="关关雎鸠,在河之洲,窈窕淑女,what' your qq" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>