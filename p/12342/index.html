<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>第六章 图(下) | 派总</title><meta name="keywords" content="408数据结构"><meta name="author" content="kailin2eis"><meta name="copyright" content="kailin2eis"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="6.4 图的应用最小生成树 Minimum-Spanning-Tree, MST之前我们已经学过什么是生成树。 连通图的生成树是包含图中全部顶点的一个极小连通子图。 若图中顶点数为n，则它的生成树含有n-1条边。对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。   一个图可以有许多棵不同的生成树，所有生成树具有以下共同特点：  生成树的顶点个数与图的顶点个数相同 生">
<meta property="og:type" content="article">
<meta property="og:title" content="第六章 图(下)">
<meta property="og:url" content="http://tikxeis.fun/p/12342/index.html">
<meta property="og:site_name" content="派总">
<meta property="og:description" content="6.4 图的应用最小生成树 Minimum-Spanning-Tree, MST之前我们已经学过什么是生成树。 连通图的生成树是包含图中全部顶点的一个极小连通子图。 若图中顶点数为n，则它的生成树含有n-1条边。对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。   一个图可以有许多棵不同的生成树，所有生成树具有以下共同特点：  生成树的顶点个数与图的顶点个数相同 生">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://tikxeis.fun/img/1.png">
<meta property="article:published_time" content="2022-09-28T07:19:14.000Z">
<meta property="article:modified_time" content="2022-09-28T07:24:35.898Z">
<meta property="article:author" content="kailin2eis">
<meta property="article:tag" content="408数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tikxeis.fun/img/1.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://tikxeis.fun/p/12342/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第六章 图(下)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-28 15:24:35'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/1.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">派总</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">第六章 图(下)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-28T07:19:14.000Z" title="发表于 2022-09-28 15:19:14">2022-09-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-28T07:24:35.898Z" title="更新于 2022-09-28 15:24:35">2022-09-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/408%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">408数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="第六章 图(下)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="6-4-图的应用"><a href="#6-4-图的应用" class="headerlink" title="6.4 图的应用"></a>6.4 图的应用</h2><h3 id="最小生成树-Minimum-Spanning-Tree-MST"><a href="#最小生成树-Minimum-Spanning-Tree-MST" class="headerlink" title="最小生成树 Minimum-Spanning-Tree, MST"></a>最小生成树 Minimum-Spanning-Tree, MST</h3><p>之前我们已经学过什么是生成树。</p>
<p>连通图的<strong>生成树</strong>是包含图中全部顶点的一个极小连通子图。</p>
<p>若图中顶点数为n，则它的生成树含有n-1条边。对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-57.png" style="zoom:80%;" />

<p>一个图可以有许多棵不同的生成树，所有生成树具有以下共同特点：</p>
<ul>
<li>生成树的顶点个数与图的顶点个数相同</li>
<li>生成树是图的极小连通子图，去掉一条边则非连通</li>
<li>一个有n个顶点的连通图的生成树有 n-1 条边（含有n个顶点，n-1条边的图不一定是生成树。）</li>
<li>在生成树中再加一条边必然形成回路</li>
<li>生成树中任意两个顶点间的路径是唯一的。</li>
</ul>
<h4 id="无向图的生成树"><a href="#无向图的生成树" class="headerlink" title="无向图的生成树"></a>无向图的生成树</h4><p>就在上一小节，我们也介绍了，广度优先生成树和深度优先生成树。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-58.png" style="zoom: 67%;" />

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-59.png" style="zoom: 67%;" />

<h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><p>给定一个无向网，在该网中的所有生成树中，使得各边权值之和最小的那棵生成树称为该网的<strong>最小生成树</strong>，也叫<strong>最小代价生成树</strong>。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-60.png" style="zoom:67%;" />

<p>构造最小生成树的算法很多，其中多数算法都利用了 MST 的性质。</p>
<p><font color='red'>MST性质</font>：设N=(V,E)是一个连通网，U是顶点集V的一个非空子集。若边(u,v)是一条具有最小权值的边，其中u∈U，v∈V-U，则必存在一棵包含边(u,v)的最小生成树。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-61.png" style="zoom: 67%;" />

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-62.png" style="zoom:67%;" />

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-63.png" style="zoom:67%;" />

<h4 id="Prim算法-普利姆"><a href="#Prim算法-普利姆" class="headerlink" title="Prim算法(普利姆)"></a>Prim算法(普利姆)</h4><p><strong>Prim算法</strong>:从某一个顶点开始构建生成树；每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止。</p>
<p><strong>算法思想</strong>:</p>
<p>此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。</p>
<ol>
<li>图的所有顶点集合为V；初始令集合u={s},v=V−u={s},v=V−u;</li>
<li>在两个集合u,v能够组成的边中，选择一条代价最小的边(u0,v0)，加入到最小生成树中，并把v0并入到集合u中。</li>
<li>重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。</li>
</ol>
<p>例如：</p>
<p>我们要构造如下图的最小生成树，我们选取一个顶点，这个顶点就是U集合，其他顶点就是V-U集合</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-64.png" style="zoom: 67%;" />

<p>在U集合当中的顶点和V-U集合当中的顶点中找一条权值最小的边，将边关联的顶点选取到我们的U集合，其他顶点为V-U集合</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-65.png" style="zoom: 67%;" />

<p>之后在U集合当中的顶点和V-U集合当中的顶点中找一条权值最小的边，V1到V2为6，V1到V4为5，V3到V2为5，V3到V4为5，V3到V5为6，V3到V6为4。所以选取权值最小的边4，其关联的顶点为V6，将其加入到U集合中。此时U集合为{V1,V3,V6}</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-66.png" style="zoom:67%;" />

<p>重复上述操作，V1周边的权值为6，5，V3周边的权值为5,5,6，V6周边的权值为6，V4周边不能选(一旦选了有回路成环了)</p>
<p>我们选择权值最小的V3到V2的5，将V2加入到U集合中</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-67.png" style="zoom:67%;" />

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-72.png" style="zoom:67%;" />

<h4 id="Kruskal算法-克鲁斯卡尔"><a href="#Kruskal算法-克鲁斯卡尔" class="headerlink" title="Kruskal算法(克鲁斯卡尔)"></a>Kruskal算法(克鲁斯卡尔)</h4><p><strong>Kruskal算法</strong>:每次选择一条权值最小的边，使这条边的两头连通(原本已经连通的就不选) 直到所有结点都连通</p>
<p><strong>算法思想</strong>：</p>
<p>此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。</p>
<ol>
<li>把图中的所有边按代价从小到大排序；</li>
<li>把图中的n个顶点看成独立的n棵树组成的森林；</li>
<li>按权值从小到大选择边，所选的边连接的两个顶点ui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。</li>
<li>重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。</li>
</ol>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-68.png" style="zoom: 67%;" />

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-71.png" style="zoom:67%;" />

<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><table>
<thead>
<tr>
<th align="left">算法名</th>
<th align="left">普里姆算法</th>
<th align="left">克鲁斯卡尔算法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">算法思想</td>
<td align="left">选择点</td>
<td align="left">选择边</td>
</tr>
<tr>
<td align="left">时间复杂度</td>
<td align="left">O(|V|^2)</td>
<td align="left">O(|E|log|E|)(E为边数)</td>
</tr>
<tr>
<td align="left">适应范围</td>
<td align="left">稠密图</td>
<td align="left">稀疏图</td>
</tr>
</tbody></table>
<h4 id="代码思想"><a href="#代码思想" class="headerlink" title="代码思想"></a>代码思想</h4><h5 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h5><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds-142.png" style="zoom: 67%;" />

<p>从v0开始。</p>
<ul>
<li><p>由于当前树中只有v0，所以isJoin数组中只有v0是TRUE，其他为FALSE。此外，lowCost中的各个结点加入树的最低代价，是看从v0出发，加入各个结点的最低代价。</p>
</li>
<li><p>第1轮：循环遍历所有结点，找到lowCost最低的，且还没加入树的顶点。于是将v3加入树。</p>
</li>
<li><p>此时，由于v3的加入，isJoin数组中v3也是TRUE。且，此时lowCost中的各个结点加入树的最低代价，不止是看由v0出发的边，而是也要看v3出发的边，因此lowCost数组应该更新。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds-142.png" style="zoom: 67%;" /></li>
<li><p>第2轮：和第1轮是一模一样的。循环遍历所有结点，找到lowCost最低的，且还没加入树的顶点。因此我们会把v2加入到树里面。并同时需要把lowCost数组的内容重新更新。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-145.png" style="zoom:67%;" /></li>
<li><p>第3轮：同理。把v5加入。并且更新lowCost。</p>
</li>
<li><p>第4轮：同理。把v1加入。并且更新lowCost值。</p>
</li>
<li><p>第5轮：只剩下v4。所以再把v4加入。</p>
</li>
</ul>
<blockquote>
<p>由v0开始，总共需要n-1轮处理。</p>
<p>每一轮处理：循环遍历所有结点，找到lowCost最低的，且还没加入树的顶点。接着，再次循环遍历，更新还没加入的各个顶点的lowCost值。（所以每一轮的时间复杂度为O(2n)）。</p>
<p>所以总的时间复杂度的数量级为O(n^2)， 也就是O(|V|^2)。</p>
</blockquote>
<p>算法的大致执行就是这样的。有能力的可以自己动手实现一遍。但是对于考研初试阶段来说我们可以先不展开此处代码的编写</p>
<h5 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h5><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-144.png" style="zoom: 50%;" />



<p>由于这个算法每次要选择权值最小的一条边。所以我们要做这样的一个预处理，就是要先把各条边按照权值递增的顺序做一个排序。那么这个算法的执行，就是要把所有的这些边都检查一遍。</p>
<p>第1轮：检查第1条边的两个顶点是否连通（是否属于同一个集合）。将v0——v3连起来。</p>
<ul>
<li>进行这个判断实际上是用到了<strong>并查集</strong>，并查集相关的内容由于在408中不要求掌握，我们只是大概说一下。</li>
<li>我们首先把不同的顶点看作一个个不同的集合。那么v0和v3刚开始是从属于不同的集合的。也就意味着它们此时不连通。那么我们就可以把这条边给选上。</li>
<li>同时，如果把这两个顶点给连上的话，那么这两个顶点此时就变成了同一个集合。</li>
</ul>
<p>第2轮：检查第2条边的两个顶点是否连通（是否属于同一个集合）。将v2——v5连起来。</p>
<p>第3轮：检查第3条边的两个顶点是否连通（是否属于同一个集合）。将v1——v4连起来。</p>
<p>第4轮：检查第4条边的两个顶点是否连通（是否属于同一个集合）。将v2——v3连起来。</p>
<p>第5轮：检查第5条边的两个顶点是否连通（是否属于同一个集合）。由于<strong>已连通，则跳过</strong>。</p>
<p>接下来的过程省略，总之我们需要把所有边都遍历一遍。在遍历到每条边的时候我们都要判断，这条边的两个顶点，它们是否从属于同一个集合。如果不属于一个集合，那就把这条边选上。</p>
<blockquote>
<p>整个图里，总共有|E|条边。</p>
<p>那么这个算法总共要执行|E|轮。</p>
<p>每轮判断两个顶点是否属于同一集合，需要O(log₂|E|)。（需要用到并查集）。</p>
<p>总时间复杂度为O(|E|log₂|E|)。</p>
</blockquote>
<h3 id="最短路径-Short-Path-First-SPF"><a href="#最短路径-Short-Path-First-SPF" class="headerlink" title="最短路径 Short Path First, SPF"></a>最短路径 Short Path First, SPF</h3><p>问题抽象：在有向网中A点(源点)到达B点(终点)的多条路径中，寻找一条各边权值之和最小的路径。即最短路径。</p>
<p><font color='cornflowerblue'>最短路径与最小生成树不同，路径上不一定包含n个顶点，也不一定包含n-1条边。</font></p>
<p>第一类问题:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-73.png" style="zoom:67%;" />

<p>第二类问题:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-74.png" style="zoom:67%;" />

<ul>
<li>单源最短路径<ul>
<li>BFS算法（无权图）</li>
<li>Dijkstra算法（带权图、无权图）</li>
</ul>
</li>
<li>各顶点间的最短路径<ul>
<li>Floyd算法（带权图、无权图）</li>
</ul>
</li>
</ul>
<h4 id="BFS求无权图的单源最短路径"><a href="#BFS求无权图的单源最短路径" class="headerlink" title="BFS求无权图的单源最短路径"></a>BFS求无权图的单源最短路径</h4><p><strong>注</strong>：无权图可以视为一种特殊的带权图，只是每条边的权值都为1。</p>
<p>对这个图执行一次广度优先遍历，我们就可以得到由某个源点出发，到其他各个结点的最短路径。</p>
<p><strong>代码实现</strong>:</p>
<p>先看BFS算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];	<span class="comment">//访问初始数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    visit(v);</span><br><span class="line">    Enqueue(Q,v);</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q)) &#123;</span><br><span class="line">        DeQueue(Q,v);</span><br><span class="line">        <span class="keyword">for</span>(w=FirstNeighbor(G,v); w&gt;=<span class="number">0</span>; w=NextNeighbor(G,v,w)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[w]) &#123;</span><br><span class="line">                visit(w);</span><br><span class="line">                visited[w] = TRUE;</span><br><span class="line">                EnQueue(Q,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们要通过BFS算法来求单源最短路径，那么主体框架不变，对其中的一些地方的处理进行一些改变就可以。如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求顶点u到其他顶点的最短路径</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS_MIN_Distance</span><span class="params">(Graph G, <span class="type">int</span> u)</span> &#123;</span><br><span class="line">    <span class="comment">//d[i]表示从u到i结点的最短路径</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;G.vexnum; ++i) &#123;</span><br><span class="line">        d[i] = ∞;	<span class="comment">//初始化路径长度</span></span><br><span class="line">        path[i] = <span class="number">-1</span>;	<span class="comment">//最短路径从哪个顶点过来</span></span><br><span class="line">    &#125;</span><br><span class="line">    d[u] = <span class="number">0</span>;</span><br><span class="line">    visited[u] = TRUE;</span><br><span class="line">    EnQueue(Q,u);</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q)) &#123;	<span class="comment">//BFS算法主体过程</span></span><br><span class="line">        DeQueue(Q,u);	<span class="comment">//队头元素u出队</span></span><br><span class="line">        <span class="keyword">for</span>(w=FirstNeighbor(G,u); w&gt;=<span class="number">0</span>; w=NextNeighbor(G,u,w)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[w]) &#123;		<span class="comment">//w为u的尚未访问的邻接点</span></span><br><span class="line">                d[w] = d[u] + <span class="number">1</span>;	<span class="comment">//路径长度+1</span></span><br><span class="line">                path[w] = u;		<span class="comment">//最短路径应从u到w</span></span><br><span class="line">                visited[w] = TRUE;	<span class="comment">//设已访问标记</span></span><br><span class="line">                EnQueue(Q,w);	<span class="comment">//顶点w入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-146.png"></p>
<p><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-147.png"></p>
<p>就是对BFS算法的小修改。</p>
<p>在visit一个顶点时，修改其最短路径长度<code>d[]</code>并在<code>path[]</code>记录前驱结点。</p>
<blockquote>
<p>可以看出。2到8的最短路径长度 = <code>d[8]</code> = 3</p>
<p>通过path数组可知，2到8的最短路径为：<code>8&lt;--7&lt;--6&lt;--2</code></p>
</blockquote>
<p>之前也说到，通过广度优先遍历，能够得到广度优先生成树。那么也可以观察一下这个广度优先生成树：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-148.png" style="zoom:67%;" />

<p>这个生成树，它的每个结点在第几层，也直接地反映了从根结点2，到达它的最短路径是多少。</p>
<p>不难得知，通过广度优先遍历构造出的这个广度优先生成树，它的高度一定是最小的。</p>
<h4 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-83.png" style="zoom:67%;" />

<p><strong>BFS算法的局限性</strong>:BFS算法求单源最短路径只适用于<font color='orange'>无权图</font>，或<font color='orange'>所有边的权值都相同</font>的图</p>
<p>Dijkstra(迪杰斯特拉)算法是典型的<font color='orange'>单源最短路径算法</font>，用于计算一个节点到其他所有节点的最短路径。主要特点是<font color='orange'>以起始点为中心向外层层扩展，直到扩展到终点为止</font>。Dijkstra算法是很有代表性的最短路径算法，在很多专业课程中都作为基本内容有详细的介绍，如数据结构，图论，运筹学等等。注意该算法要求图中不存在负权边。</p>
<p><strong>问题描述</strong>：在无向图 G=(V,E) 中，假设每条边 E[i] 的长度为 w[i]，找到由顶点 V0 到其余各点的最短路径。（单源最短路径）</p>
<ol>
<li>初始化：先找出从源点V0到各终点Vk的直达路径(V0,VK),即通过一条弧到达的路径。</li>
<li>选择：从这些路径中找出一条长度最短的路径(V0,u)</li>
<li>更新：然后对其余各条路径进行适当调整<ul>
<li>若在图中存在弧(u,Vk),且(V0,u)+(u,Vk) &lt; (V0,Vk)，则以路径(V0,u,Vk)代替(V0,Vk)</li>
<li>在调整后的各条路径中，再找长度最短的路径，以此类推。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>迪杰斯特拉算法</strong>：按路径长度递增次序产生最短路径</p>
<ol>
<li><p>把V分成两组：</p>
<p>(1)S：已求出最短路径的顶点的集合</p>
<p>(2)T=V-S：尚未确定最短路径的顶点集合</p>
</li>
<li><p>将T中顶点按最短路径递增的次序加入到S中，保证：</p>
<p>(1)从源点V0到S中各顶点的最短路径长度都不大于从V0到T中的任何顶点的最短路径长度。</p>
<p>(2)每个顶点对应一个距离值：</p>
<p> S中顶点：从V0到此顶点的最短路径长度</p>
<p> T中顶点：从V0到此顶点的只包括S中顶点作中间顶点的最短路径长度。</p>
</li>
</ol>
<p>执行动画过程如下图</p>
<p><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-75.gif"></p>
<p><strong>多说无益，我们来看一个例子</strong></p>
<h5 id="王卓版本"><a href="#王卓版本" class="headerlink" title="王卓版本"></a>王卓版本</h5><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-76.png" style="zoom:67%;" />

<p>初始时令 S = {V0}，T={其余顶点}</p>
<p>记录V0到其他顶点的距离：若&lt;V0,Vi&gt;存在，则为其权值，若不存在，则为∞。使用辅助数组D存放</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-77.png" style="zoom:67%;" />

<p>V0到V1可以直达，为其权值13。V0到V2可以直达，为其权值8。V0到V3不可以直达，为∞。以此类推，然后从T中选取一个距离值最小的顶点Vj，加入S。例如我们上图中的8最小，则将V2加入S。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-78.png" style="zoom:67%;" />

<p>接下来我们要计算 <strong>从V0直接出发到各个顶点的路径和从V0出发经过V2再到各个顶点的路径</strong>，看是否有距离减少，没有减少则不需要改值。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-79.png" style="zoom:67%;" />

<p>如上图，加入V2之后：</p>
<p>V0到V1的值为13，V0经过V2再到V1是无法直达为∞，所以V0到V1的最短路径依旧是13</p>
<p>V2已经加入到S集合，所以不需要管V2。</p>
<p>V0到V3无法直达为∞，V0经过V2再到V3可以直达为 8+5=13，所以V0到V3的最短路径为13</p>
<p>V0到V4直达为30，V0经过V2再到V4无法直达为∞，所以V0到V4的最短路径为30</p>
<p>V0到V5无法直达为∞，V0经过V2再到V5也无法直达为∞，所以V0到V5的最短路径为∞</p>
<p>V0到V6直达为36，V0经过V2再到V6无法直达为∞，所以V0到V6的最短路径为32</p>
<p>从上述最短路径中选出最小的为13，我们选择序号更小的V1，将其加入到S集合中。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-80.png" style="zoom:67%;" />

<p>此时S集合为V0、V1、V2</p>
<p>V0到V3的最短路径依旧13</p>
<p>V0到V4的最短路径依旧是30</p>
<p>V0到V5无法直达，但是可以经过V1再直达，所以最短路径为 13+9=22</p>
<p>V0到V6直达为32，但是可以经过V1再直达，所以最短路径为 13+7=20</p>
<p>从上述最短路径中挑选值最小的为13，所以将V3加入到集合S中。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-81.png" style="zoom:67%;" />

<p>最终结果如下：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-82.png" style="zoom:67%;" />

<hr>
<h5 id="王道版本"><a href="#王道版本" class="headerlink" title="王道版本"></a>王道版本</h5><p>这里以有向图举例。为什么不用无向图呢，因为无向图的边等价于两条有向边，是一样的道理。我们只需要说清楚有向图的原理，无向图自然也就清楚了。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-149.png" style="zoom: 50%;" />

<p>由v0作为源点出发。</p>
<p>我们需要设三个数组</p>
<ul>
<li>final数组，表示各顶点是否已找到最短路径。显然先设v0为TRUE。</li>
<li>dist数组（distance），表示目前已知条件下，到达某结点的最短路径长度。<ul>
<li>此时只有一个v0是可知的，那么目前来看，到v1的最短路径是10，到v4的最短路径是5，而到v2和v3是∞。</li>
</ul>
</li>
<li>path数组，和BFS算法中的path数组是一个意思，就是记录通往结点的路径是由哪个结点过来的，也就是最短路径上的前驱结点。<ul>
<li>v1结点目前能找到的最好的一条路径，是从v0过来的，那么path设为0。v4同理。</li>
</ul>
</li>
</ul>
<p>以上是三个数组的初始化，接下来我们开始一轮一轮的处理。</p>
<p><strong>第一轮</strong>：</p>
<p>循环遍历所有结点，找到还没确定最短路径，且dist最小的顶点Vi，令final[i] = TRUE。</p>
<ul>
<li>那么显然，在V1~V4中，dist最小的顶点是V4的5。并将V4的final设为TRUE。也就是说，我现在已经可以确定V4的最短路径长度就是5，并且它的直接前驱是0号结点。</li>
</ul>
<p>检查所有邻接自Vi的顶点，若其final值为false，则更新dist和path信息。</p>
<ul>
<li>也就是检查V1~V3，看看它们如果由V4过来的话，有没有可能比之前的路径更短。<ul>
<li>对于V1：如果改用从V4过来，那么总长度为5+3=8，比原先的10更短，则更新。</li>
<li>对于V2：原先我们根本就没有到达V2的路径，现在如果我们从V4出发，则有一条到V2的路径，则更新。</li>
<li>对于V3：和V2同理，更新。</li>
</ul>
</li>
</ul>
<p>第一轮处理结果如下</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-150.png" style="zoom: 67%;" />

<p><strong>第二轮</strong>：</p>
<p>处理逻辑和第一轮是相同的。</p>
<ul>
<li>遍历V1~V3，看看谁的dist最小，找到V3，将V3的final设为TRUE。</li>
<li>检查所有能够从V3过去的顶点，当然我们只需要检查final为false的顶点。<ul>
<li>从V3过去的顶点有V0和V2，但是V0我们不需要考虑，所以只看V2。</li>
<li>对V2这个顶点，如果我们是从V3过去的，那么路径长度为7+6=13的路径，显然比原先的14更短，则更新V2的dist为13，并更新V2的path为3。</li>
</ul>
</li>
</ul>
<p>第二轮处理结果：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-151.png" style="zoom: 67%;" />

<p><strong>第三轮</strong>：</p>
<ul>
<li>遍历V1~V2，看看谁的dist最小，则找到V1，并将其final设为TRUE。</li>
<li>检查所有从V1过去，且final为false的顶点。即V2。<ul>
<li>对于V2，检查是否需要更新dist和path信息。</li>
<li>若V2是由V1过去的，则路径长度为8+1=9，比原先的13短。于是更新dist为9，更新path为1。</li>
</ul>
</li>
</ul>
<p>第三轮处理结果：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-152.png" style="zoom: 67%;" />

<p><strong>第四轮</strong>：</p>
<ul>
<li>遍历V2，V2的dist最小，将V2的final设为TRUE。</li>
<li>所有结点的final全部为TRUE。此时已经找不到final为false的顶点了。</li>
<li>算法到此结束。</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-153.png" style="zoom:67%;" />

<p>以上就是Dijkstra算法的执行过程。</p>
<blockquote>
<p>通过执行结果可知，</p>
<p>V0到V2的最短（带权）路径长度为：dist[2] = 9</p>
<p>通过<code>path[]</code>可知，V0到V2的最短（带权）路径：<code>V2&lt;--V1&lt;--V4&lt;--V0</code></p>
</blockquote>
<h5 id="Dijkstra算法的时间复杂度"><a href="#Dijkstra算法的时间复杂度" class="headerlink" title="Dijkstra算法的时间复杂度"></a>Dijkstra算法的时间复杂度</h5><p><strong>对于考研来说，这个算法只需要理解手动执行的过程，能够手算即可。</strong></p>
<p>我们也简单的提一下，如果用代码实现，大致的思路是什么样的。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-154.png" style="zoom:67%;" />

<ul>
<li>初始：若从V0开始。令<code>final[0] = TRUE</code>；<code>dist[0] = 0</code>；<code>path[0] = -1</code>。其余顶点<code>final[k] = false</code>；<code>dist[k] = arcs[0][k]</code>；<code>path[k] = (arcs[0][k]==∞) ? -1 : 0</code>。</li>
<li>第n-1轮处理:<ul>
<li>循环遍历所有顶点，找到还没确定最短路径，且dist最小的顶点Vi，令其<code>final[i] = true</code>。并遍历所有邻接自Vi，且还没确定最短路径的顶点，即<code>final[j] == false</code>，若<code>final[j] == false &amp;&amp; dist[i]+arcs[i][j] &lt; dist</code>，则令<code>dist[j] = dist[i] + arcs[i][j]; path[j] = i;</code>（注：<code>arcs[i][j]</code>表示Vi到Vj的弧的权值）</li>
</ul>
</li>
</ul>
<p><strong>现在探讨一下其时间复杂度的问题</strong></p>
<p>对于每一轮处理来说，我们都要循环<strong>遍历所有顶点</strong>，找到还没确定最短路径，且dist最小的顶点。所以需要O(n)的时间复杂度。此外，找到这个结点之后，还需要检查所有和它相邻的邻接点，又需要O(n)的时间复杂度。</p>
<p>所以每一轮处理的时间复杂度为O(2n)，即O(n)。</p>
<p>而总共需要n-1轮处理。所以整个算法的时间复杂度为O(n²)。即O(|V|²)。</p>
<blockquote>
<p>可以发现，这个算法其实和Prim算法是比较类似的。此代码的<code>dist[]</code>数组，和Prim算法中的<code>lowCost[]</code>数组的作用是很类似的。</p>
</blockquote>
<h5 id="用于负权值带权图"><a href="#用于负权值带权图" class="headerlink" title="用于负权值带权图"></a>用于负权值带权图</h5><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-155.png" style="zoom:50%;" />



<p>这是Dijkstra算法的一个小坑。</p>
<p>如果带权图里，有负权值的边。那么Dijkstra算法有可能就会失效，找不到最短路径。</p>
<p>按照算法的规则，我们执行一遍：</p>
<ul>
<li>初始：如上图所示。</li>
<li>第一轮：<ul>
<li>遍历V1、V2，找到V2的dist最短，设其final为true，path为0。</li>
<li>第一轮结束。</li>
</ul>
</li>
<li>第二轮：<ul>
<li>只剩下V1，将其final设为true，path为0。</li>
</ul>
</li>
<li>此时所有结点的final均为TRUE，算法执行完毕。</li>
</ul>
<p>最终结果如下</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-156.png" style="zoom: 50%;" />

<p>但是，事实上，V0到V2的最短带权路径长度为5。</p>
<p>因此，<strong>Dijkstra算法不适用于有负权值的带权图</strong>。</p>
<h4 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-86.png" style="zoom:67%;" />

<p><strong>Floyd-Warshall算法</strong>（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd-Warshall算法的时间复杂度为O(N3)，空间复杂度为O(N2)。</p>
<p><strong>算法思想</strong>:</p>
<p><font color='cornflowerblue'>Floyd算法是一个经典的动态规划算法</font>。用通俗的语言来描述的话，首先我们的目标是寻找从点i到点j的最短路径。从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在）</p>
<p>   从任意节点i到任意节点j的最短路径不外乎2种可能，1是直接从i到j，2是从i经过若干个节点k到j。所以，我们假设Dis(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，我们<font color='cornflowerblue'>检查Dis(i,k) + Dis(k,j) &lt; Dis(i,j)</font>是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，我们<font color='cornflowerblue'>便设置Dis(i,j) = Dis(i,k) + Dis(k,j)</font>，这样一来，当我们遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。</p>
<p>对于n个顶点的图G，求任意一对顶点Vi—&gt;Vj之间的最短路径可分为如下几个阶段：</p>
<ul>
<li>初始：不允许在其他顶点中转，最短路径是？</li>
<li>0：若允许在V0中转，最短路径是？</li>
<li>1：若允许在V0、V1中转，最短路径是？</li>
<li>2：若允许在V0、V1、V2中转，最短路径是？</li>
<li>……</li>
<li>n-1：若允许在V0、V1、V2……V(n-1)中转，最短路径是？</li>
</ul>
<p>步骤如下：</p>
<ol>
<li>初始时设置一个n阶方阵，令其对角线元素为0，若存在弧 &lt;Vi,Vj&gt;,则对应元素为权值，否则为∞</li>
<li>逐步试着在原直接路径中增加中间顶点，若加入中间顶点后路径变短，则修改之，否则，维持原值。所有顶点试探完毕，算法结束</li>
</ol>
<p><strong>来看一个例子</strong>：</p>
<h5 id="王卓版本-1"><a href="#王卓版本-1" class="headerlink" title="王卓版本"></a>王卓版本</h5><p>有3各顶点，则设置一个3阶方阵，令其对角线为0，若存在弧，则对应元素为权值。</p>
<p>例如&lt;A,B&gt;权值为4，&lt;A,C&gt;权值为11.</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-84.png" style="zoom:67%;" />

<p>加入A顶点后：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-85.png" style="zoom:67%;" />

<p>A到B，A到C距离没有变化。B到A，B到C距离也没有变化。C到A距离没有变化，C到B之前没有直达路径，加入A顶点之后可以从C经过A再到B，所以距离为 3+4=7</p>
<p>加入B顶点之后：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-87.png" style="zoom:67%;" />

<p>A带B距离无变化，A到C直达路径为11，但是经过B路径为 4+2=6。</p>
<p>B到A，B到C距离无变化。</p>
<p>C到A，C到B距离无变化。</p>
<p>加入C顶点后：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-88.png" style="zoom:67%;" />

<hr>
<h5 id="王道版本-1"><a href="#王道版本-1" class="headerlink" title="王道版本"></a>王道版本</h5><p>我们来把这个算法流程跑一遍。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-157.png" style="zoom:67%;" />

<p>我们设置两个矩阵（二维数组）。</p>
<p>第一个矩阵，其实就是这个有向图的邻接矩阵。</p>
<blockquote>
<p>由于初始阶段，我们不允许有其他顶点中转的情况出现，因此，例如V0——V2，就只能走13这条路。</p>
<p>所以，第一个矩阵中，第一行第三列就是13。</p>
</blockquote>
<p>第二个矩阵，存放的就是，我们目前能够找到的最短路径当中，两个顶点之间的一个中转点。</p>
<blockquote>
<p>初始阶段，所有顶点之间都不可以有中转点，所以全是-1。</p>
</blockquote>
<p>以上是<strong>初始阶段</strong>的流程。</p>
<p><strong>0阶段</strong>：</p>
<p>若允许在<strong>V0</strong>中转，最短路径是？——求A(0)和path(0)。</p>
<p>我们要基于上一轮求得的两个矩阵的信息，得到这一轮的两个矩阵中应该填入的最优信息。</p>
<p>求解的方法很简单，我们需要遍历上一阶段留下来的这个矩阵A，对于矩阵A当中的每一个具体的元素，我们都需要进行以下处理：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-158.png" style="zoom:67%;" />

<blockquote>
<p>例如对于矩阵A中，第三行第二列，也就是V2——V1的这个数据。如果允许在V0中转，那么考虑<br>$$<br>A^{(-1)}[2][1]&gt;A^{(-1)}[2][0]+A^{(-1)}[0][1]=11<br>$$</p>
<p>$$<br>则A^{(0)}[2][1]=11<br>$$</p>
<p>$$<br>path^{(0)}[2][1]=0<br>$$</p>
</blockquote>
<p>当然，对于这个矩阵中的所有位置的元素，都需要依次循环遍历一遍，各进行判断。（按照上面的处理方法）</p>
<p>实际上，在对所有位置元素均各执行一遍判断之后，需要改变的也就只有这一个位置，如下图</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-159.png" style="zoom:67%;" />

<p><strong>1阶段</strong>：</p>
<p>若允许在V0、<strong>V1</strong>中转，最短路径是？——求A(1)和path(1)。</p>
<p>我们需要在基于0阶段得到的两个矩阵的基础上，来计算该阶段的矩阵内容，也就是1阶段的最优解。</p>
<p>那还是利用刚才的这个规则：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-159.png" style="zoom:67%;" />

<p>我们要基于前一个阶段的矩阵的值，来对此阶段的矩阵内容进行一个判断。</p>
<blockquote>
<p>对所有元素都遍历一遍之后，我们会发现这样一个地方，是满足需要被处理的条件的：<br>$$<br>A^{(0)}[0][2]&gt;A^{(0)}[0][1]+A^{(0)}[1][2]=10<br>$$</p>
<p>$$<br>则A^{(1)}[0][2]=10<br>$$</p>
<p>$$<br>path^{(1)}[0][2]=1<br>$$</p>
</blockquote>
<p>经过修改之后，矩阵会变成这样：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-160.png" style="zoom:67%;" />

<p><strong>2阶段</strong>：</p>
<p>若允许在V0、V1、<strong>V2</strong>中转，最短路径是？——求A(2)和path(2)。</p>
<p>要以1阶段得出的矩阵信息，作进一步处理，得到此阶段的最优解。</p>
<p>依然是同样的处理规则。依次扫描矩阵中的所有元素，并处理满足条件的元素。</p>
<blockquote>
<p>全部扫描过后，可以发现只有一个地方满足，如下<br>$$<br>A^{(1)}[1][0]&gt;A^{(1)}[1][2]+A^{(1)}[2][0]=9<br>$$</p>
<p>$$<br>则A^{(2)}[1][0]=9<br>$$</p>
<p>$$<br>path^{(2)}[1][0]=2<br>$$</p>
</blockquote>
<p>到此，我们就求出了A(2)和path(2)：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-161.png" style="zoom:67%;" />

<p>到了这一步，从A(-1)和path(-1)开始，我们已经经过了<strong>n轮递推，</strong>每一轮递推，我们都会增加考虑一个新的结点作为中转点，**得到A(n-1)和path(n-1)**。到此，我们便得到了每两个顶点之间最短路径的长度，和路径上的信息。（n指的是总结点个数）</p>
<blockquote>
<p>观察两表，</p>
<p>例如，V1到V2的最短路径。检查A数组，发现长度是4；再检查path数组，发现它们之间是不经过任何中转点的，因此这条最短路径为V1—V2。</p>
<p>例如，V0到V2的最短路径。查找A数组，发现长度是10；再查path数组，V0到V2之间的中转点是1号中转点，因此这条最短路径为V0—V1—V2。</p>
<p>同理，V1到V0的最短路径长度为9，路径为V1—V2—V0。</p>
</blockquote>
<p>所以，Floyd算法的思想虽然有些抽象，但是实现起来还是比较简单的。</p>
<p><strong>Floyd算法核心代码</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//......准备工作，根据图的信息初始化矩阵A和path（如上图）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;n; k++) &#123;		<span class="comment">//考虑以Vk作为中转点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;	<span class="comment">//遍历整个矩阵，i为行号，j为列号</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i][j] &gt; A[i][k] + A[k][j]) &#123;	<span class="comment">//以Vk为中转点的路径更短</span></span><br><span class="line">                A[i][j] = A[i][k] + A[k][j];	<span class="comment">//更新最短路径长度</span></span><br><span class="line">                path[i][j] = k;		<span class="comment">//中转点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，这个算法的时间复杂度为O(n³)，即O(|V|³)。（三层嵌套）；空间复杂度为O(|V|²)。（两个矩阵）。</p>
<blockquote>
<p>注意，上面这个例子，只是有三个结点，这个例子虽然能帮助我们理解Floyd算法的流程，但是，这个例子在我们考虑加入中转点的时候，最多也就只需要走两条边。</p>
<p>而对于Floyd算法的真正的作用、效果，这个例子体现的并不是很好。</p>
</blockquote>
<h5 id="一个较复杂的例子"><a href="#一个较复杂的例子" class="headerlink" title="一个较复杂的例子"></a>一个较复杂的例子</h5><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-162.png" style="zoom:67%;" />

<p><strong>0阶段</strong>：</p>
<p>若允许在<strong>V0</strong>中转，最短路径是？</p>
<p>依次检查矩阵中所有元素，检查规则为：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-158.png" style="zoom:67%;" />

<p>代码体现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;		<span class="comment">//遍历整个矩阵，i为行号，j为列号</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i][j] &gt; A[i][k] + A[k][j]) &#123;	<span class="comment">//以Vk为中转点的路径更短</span></span><br><span class="line">            A[i][j] = A[i][k] + A[k][j];	<span class="comment">//更新最短路径长度</span></span><br><span class="line">            path[i][j] = k;	<span class="comment">//中转点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这个代码，此阶段就是执行k=0的情况。</p>
<p>遍历矩阵中所有元素后，会发现所有元素都不需要更新。</p>
<p>得到A(0)和path(0)：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-163.png" style="zoom:67%;" />

<blockquote>
<p>实际上，从这个图本身也很好理解。V0这个结点只有出边，没有入边。那么，没有任何一个结点能够进入V0处，又怎么可能在V0中转呢？所以两矩阵内容并没有发生任何改变。</p>
</blockquote>
<p><strong>1阶段</strong>：</p>
<p>若允许在V0、<strong>V1</strong>中转，最短路径是？</p>
<p>依然是遵循同样的规则/代码（k=1）。</p>
<p>遍历过后，发现需要更改的地方，如下</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-164.png" style="zoom:67%;" />

<p>经过这一轮的处理，两矩阵更新如下：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-165.png" style="zoom:67%;" />

<p><strong>2阶段</strong>：</p>
<p>若允许在V0、V1、<strong>V2</strong>中转，最短路径是？</p>
<p>遍历过后，发现需要更改的地方，如下：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-166.png" style="zoom:67%;" />

<blockquote>
<p><strong>注意</strong>：</p>
<p>分析此步骤所反映出的结果。</p>
<p>也就是有两处需要优化：</p>
<p>0结点到1结点，改为了0—2，再2—1，OK；</p>
<p>0结点到3结点，改为了0—2，再2—3，？？？</p>
<p>通过看图，我们发现V2到V3之间没有“边”呀？为什么呢？</p>
<p><strong>这就是因为，在上一阶段，对于V2到V3的路径，已经是由V1中转过的结果了（也就是为什么每一阶段要在上一阶段两个矩阵中的信息的基础之上进行求最优解）</strong>。而不是单纯的理解为V2到V3是否有”边“的问题。</p>
<p>实际上，这个<code>A^&#123;(1)&#125;[2][3]</code>，它反映的就是在上一阶段处理2结点到3结点最短路径问题，所得的结果。（即1阶段中，允许由V0、V1中转，所求得的V2到V3的最短路径）。</p>
</blockquote>
<p>由此，我们就能很好的体会到，我们在之前就已经考虑到，增加V1作为中转节点，然后，现在我们的计算，是基于之前已经求得的最优结果的基础之上，再增加V2作为中转点。</p>
<blockquote>
<p>所以此处这个0结点到3结点的最优路径，表面上看是0—2，再2—3，其实是0—2，再2—1，再1—3。</p>
</blockquote>
<p>而对于整个路径来看，其实就已经考虑到了以V0、V1、V2作为中转点的所有情况了。</p>
<p>此阶段处理完后，两矩阵的最新信息如下：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-167.png" style="zoom:67%;" />

<p><strong>3阶段</strong>：略</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-168.png" style="zoom:67%;" />

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-169.png" style="zoom:67%;" />

<p><strong>4阶段</strong>：略。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-170.png" style="zoom:67%;" />

<p>结束。最终得到的两个矩阵内容如上图</p>
<blockquote>
<p>现在我们来看一下，怎么解读这两个矩阵中的信息：</p>
<p>例如，要找V0到V4的最短路径。</p>
<ul>
<li>由A矩阵可知长度为4。</li>
<li>由path矩阵<ul>
<li>首先可以知道V0到V4需要经过一个中转点是V3，也就是说V0需要先到V3，V3再到V4。但是由图中可以看出，V0到V3并没有一条直接存在的路径供我们经过，其实V0到V3的最短路径，其中还是要经过一些中转节点的。而V3到V4是不需要中转的（由path的值为-1即可看出）。</li>
<li>再看V0到V3怎么走。由path数组可知，V0到V3，中间还要经过V2。也就是V0需要先到V2，V2再到V3。V0到V2（path的值为-1）是没有中转点的；而V2到V3（path值为1）还需要经过V1中转点。</li>
<li>到这一步，整理一下，即<code>V0 V2 V1 V3 V4</code>，实际上这就是最终结果了。</li>
</ul>
</li>
</ul>
<p>总结一下获取最短路径走法的过程（通过path矩阵递归地找到完整路径）：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-171.png" style="zoom:67%;" />
</blockquote>
<p>可以用path矩阵配合上递归算法很好的解决这个问题。</p>
<p>但是单从考试的角度来看，会手算即可。</p>
<p>但是有个问题，在手算A矩阵的时候，由于这是5行5列的矩阵，我们如果要把所有元素依次完整地执行一遍，其实我们总共需要5³=125次检查。所以在考试的时候，不可能会给你这么复杂的一个图的。让你在考场上进行125次加法、比大小，是没什么意义的。所以考试的时候给的图一般阶数都比较小。</p>
<h5 id="用于负权值带权图-1"><a href="#用于负权值带权图-1" class="headerlink" title="用于负权值带权图"></a>用于负权值带权图</h5><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-172.png" style="zoom:67%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//......准备工作，根据图的信息初始化矩阵A和path（见上图）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;n; k++) &#123;	<span class="comment">//考虑以Vk作为中转点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;	<span class="comment">//遍历整个矩阵，i为行号，j为列号</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i][j] &gt; A[i][k] + A[k][j]) &#123;	<span class="comment">//以Vk作为中转点的路径更短</span></span><br><span class="line">                A[i][j] = A[i][k] + A[k][j];	<span class="comment">//更新最短路径长度</span></span><br><span class="line">                path[i][j] = k;		<span class="comment">//中转点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Floyd算法可以用于负权值带权图</strong>。（就解决了Dijkstra算法解决不了的问题）</p>
<p>但是，这个算法也有它所解决不了的问题。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-173.png" style="zoom:67%;" />

<p>对于这个图，其中的这个回路来说，你会发现，你走这个回路，走的次数越多，你的带权路径长度会越来越小。因此根本就找不到最短路径。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-174.png" style="zoom:69%;" />

<blockquote>
<p>BFS算法有两种时间复杂度的情况，是由于图的存储方式，是邻接矩阵还是邻接表存储的区别导致的。</p>
</blockquote>
<h3 id="有向无环图"><a href="#有向无环图" class="headerlink" title="有向无环图"></a>有向无环图</h3><h4 id="有向无环图-DAG"><a href="#有向无环图-DAG" class="headerlink" title="有向无环图(DAG)"></a>有向无环图(DAG)</h4><p><strong>有向无环图</strong>：若一个<strong>有向图</strong>中<strong>不存在环</strong>，则称为有向无环图，简称<strong>DAG图</strong>（Directed Acyclic Graph）</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds7-199.png" style="zoom: 45%;" />

<h4 id="DAG描述表达式"><a href="#DAG描述表达式" class="headerlink" title="DAG描述表达式"></a>DAG描述表达式</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-190.png" style="zoom:40%;" />

<p>之前我们说过，算术表达式可以用树来表示。但是对于上图来说，不难看出，有两部分是重复的，<code>((c+d)*e)</code>出现了两次。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-191.png" style="zoom: 30%;" />

<p>实际上，图中红色、绿色两棵子树，其计算结果是一样的。所以其实可以去除其中一棵，只保留一棵。就成了如下这种样子：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-244.png" style="zoom:60%;" />

<p>这么做的好处显而易见，能够节省存储空间。而现在产生的这种结构，其实就是有向无环图。</p>
<p>其实我们继续再看一下，里面还有重复的部分：<code>(c+d)</code>。可以继续进行“合并”。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-245.png" style="zoom:60%;" />

<p>合并后，就变成如下这样：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-194.png" style="zoom:30%;" />

<p>到此，继续观察，还是有相同的“子树”：<code>b</code>出现了两次。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-195.png" style="zoom:30%;" />

<p>“合并”后，结果如下：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-196.png" style="zoom:30%;" />

<p>这个过程，如果不细心的话，有可能会无法找全所有可以合并的点。</p>
<p>但是在考研408真题中，又会遇到类似的题，如下：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-197.png" style="zoom: 50%;" />

<p>经过合并，如下图所示</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-198.png" style="zoom:33%;" />

<p>由于这种题<strong>容易遗漏可以合并的点</strong>，因此总结以下解题规律：</p>
<ul>
<li>顶点中不可能出现重复的操作数。</li>
</ul>
<hr>
<p>因此，有以下解题步骤：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-199.png" style="zoom:67%;" />

<ul>
<li>第一步：把各个操作数不重复地排成一排，如下图所示。</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-200.png" style="zoom:67%;" />

<ul>
<li>第二步：标出各个运算符的生效顺序（先后顺序有点出入无所谓，目的是为了不重不漏地处理完毕所有运算符）</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-201.png"  />

<ul>
<li>第三步：按顺序加入运算符，注意“分层”。（分层的意思见下图）</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-202.png" style="zoom:67%;" />

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-203.png" style="zoom:67%;" />

<ul>
<li><p>第四步：从底向上逐层检查同层的运算符是否可以合体。</p>
<p>（为什么一层一层检查同层的运算符，不难体会到，如果是不同层的，则是一定不可能合并的。这也是第三步构造的过程中要注意“分层”的原因）</p>
<ul>
<li>看最下面一层运算符。有四个加法。但是最左边的那一个加号，它是对<code>a和b</code>进行相加，右边三个加号，均是对<code>c和d</code>进行相加。因此右边三个加号可以合并，而左边一个加号不能合并。</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-204.png" style="zoom:69%;" />

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-205.png" style="zoom:67%;" /></li>
<li><p>运算符合体完毕如下图所示。此时我们就得到了一个最简的有向无环图。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-206.png" style="zoom:67%;" /></li>
</ul>
<h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><h5 id="如何进行拓扑排序"><a href="#如何进行拓扑排序" class="headerlink" title="如何进行拓扑排序"></a>如何进行拓扑排序</h5><p><strong>AOV网</strong>（Activity On Vertex NetWork，用顶点表示活动的网）：</p>
<p><strong>用DAG图</strong>（有向无环图）表示一个工程。顶点表示活动，有向边<code>&lt;Vi, Vj&gt;</code>表示活动<code>Vi</code>必须先于活动<code>Vj</code>进行。</p>
<p>如果存在环路，则一定不是AOV网。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-207.png" style="zoom: 33%;" />

<blockquote>
<p><strong>拓扑排序</strong>：在图论中，由一个<strong>有向无环图</strong>的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：</p>
<p>①每个顶点出现且只出现一次。</p>
<p>②若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径。</p>
<p>或定义为：</p>
<p>拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条从顶点A到顶点B的路径，则在排序中顶点B出现在顶点A的后面。<strong>每个AOV网都有一个或多个拓扑排序序列</strong>。</p>
</blockquote>
<p>上述定义可能看不懂，我们直接看如何进行拓扑排序。拓扑排序实际上就是：找到做事的先后顺序。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-208.png" style="zoom: 33%;" />

<p>例如这个AOV网，我们可以从<code>准备厨具</code>或<code>买菜</code>开始做起。</p>
<ul>
<li>例如我们将<code>准备厨具</code>作为第一件事开始。</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-209.png" style="zoom: 50%;" />

<ul>
<li>那么第二件事是什么？第二件事一定是<code>买菜</code>。因为如果不这样，那么是不可能进行其他操作的。</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-210.png" style="zoom: 33%;" />

<ul>
<li>第三件事，同理，可以先选择<code>打鸡蛋</code>，也可以先选择<code>洗番茄</code>。例如我们先选择洗番茄。</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-211.png" style="zoom:33%;" />

<ul>
<li>第四件事，我们可以先选择<code>打鸡蛋</code>，也可以先选择<code>切番茄</code>。例如我们选择先切番茄。</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-212.png" style="zoom:33%;" />

<ul>
<li>至此，剩下的事情顺序，就必须是<code>打鸡蛋、下锅炒、吃</code>了。最终拓扑排序如下所示：</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-213.png" style="zoom:67%;" />

<p><strong>拓扑排序的实现</strong>：</p>
<p>①从AOV网中选择一个没有前驱（<strong>入度为0</strong>）的顶点并输出。</p>
<p>②从网中删除该顶点和所有以它为起点的有向边。</p>
<p>③重复①和②直到当前的<strong>AOV网为空</strong>或<strong>当前网中不存在无前驱的顶点为止（说明有回路）</strong>。</p>
<blockquote>
<p><strong>注</strong>:如果③的结果为<code>当前网中不存在无前驱的顶点</code>，则说明有回路，则说明其是不可以拓扑排序的。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-214.png" style="zoom:33%;" />

<p>例如，若有回路，则，到这一步时，发现没有入度为0的结点。说明原图存在回路。</p>
<p>所以，对于存在回路的图，是不可能存在拓扑排序序列的。</p>
<p>如果原图是一个DAG图（有向无环图），那么就存在拓扑排序序列。</p>
</blockquote>
<h5 id="拓扑排序的代码实现"><a href="#拓扑排序的代码实现" class="headerlink" title="拓扑排序的代码实现"></a>拓扑排序的代码实现</h5><p>其实代码实现思路很简单，就是把刚才说的那两个需要不断重复的步骤①②，不断地重复，直到达到③的条件就可以。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-215.png" style="zoom:35%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100	<span class="comment">//图中顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> &#123;</span>	<span class="comment">//边表结点 </span></span><br><span class="line">	<span class="type">int</span> adjvex;		<span class="comment">//该弧所指向的顶点的位置</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span>	<span class="comment">//指向下一条弧的指针</span></span><br><span class="line">	<span class="comment">//InfoType info;	//网的边权值 </span></span><br><span class="line">&#125;ArcNode </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span> &#123;</span>	<span class="comment">//顶点表结点 </span></span><br><span class="line">	VertexType data;	<span class="comment">//顶点信息</span></span><br><span class="line">	ArcNode *firstarc;	<span class="comment">//指向第一条依附该顶点的弧的指针 </span></span><br><span class="line">&#125;VNode, AdjList[MaxVertexNum];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	AdjList vertices;	<span class="comment">//邻接表</span></span><br><span class="line">	<span class="type">int</span> vexnum, arcnum;	<span class="comment">//图的顶点数和弧数 </span></span><br><span class="line">&#125;Graph;		<span class="comment">//Graph是以邻接表存储的图类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">TopologicalSort</span><span class="params">(Graph G)</span> &#123;</span><br><span class="line">	InitStack(S);	<span class="comment">//初始化栈，存储入度为0的顶点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;G.vexnum; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)</span><br><span class="line">			Push(S, i);	<span class="comment">//将所有入度为0的顶点进栈 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;	<span class="comment">//计数，记录当前已经输出的顶点数</span></span><br><span class="line">	<span class="keyword">while</span>(!IsEmpty(S)) &#123;	<span class="comment">//栈不空，则存在入度为0的顶点 </span></span><br><span class="line">		Pop(S, i);	<span class="comment">//栈顶元素出栈</span></span><br><span class="line">		print[count++] = i;	<span class="comment">//输出顶点i</span></span><br><span class="line">		<span class="keyword">for</span>(p=G.vertices[i].firstarc; p; p=p-&gt;nextarc) &#123;</span><br><span class="line">			<span class="comment">//将所有i指向的顶点的入度减1，并且将入度为0的顶点压入栈S</span></span><br><span class="line">			v = p-&gt;adjvex;</span><br><span class="line">			<span class="keyword">if</span>(!(--indegree[v])) </span><br><span class="line">				Push(S, v);	<span class="comment">//入度为0，则入栈 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">//while</span></span><br><span class="line">	<span class="keyword">if</span>(count &lt; G.vexnum)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//排序失败，有向图中有回路 </span></span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">//拓扑排序成功 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-216.png" style="zoom:35%;" />

<p><strong>时间复杂度</strong>:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-217.png" style="zoom:45%;" />

<p>由于每个顶点都需要处理一次，每条边都需要处理一次。</p>
<p>时间复杂度：<code>O(|V|+|E|)</code>若采用邻接矩阵，则需<code>O(|V|²)</code></p>
<h4 id="逆拓扑排序"><a href="#逆拓扑排序" class="headerlink" title="逆拓扑排序"></a>逆拓扑排序</h4><h5 id="如何进行逆拓扑排序"><a href="#如何进行逆拓扑排序" class="headerlink" title="如何进行逆拓扑排序"></a>如何进行逆拓扑排序</h5><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-218.png" style="zoom: 33%;" />

<p>对一个AOV网，如果采用下列步骤进行排序，则称之为<strong>逆拓扑排序</strong>：</p>
<p>①从AOV网中选择一个没有后继（<strong>出度为0</strong>）的顶点并输出。</p>
<p>②从网中删除该顶点和所有以它为终点的有向边。</p>
<p>③重复①和②直到当前的AOV网为空。</p>
<blockquote>
<p>上图的逆拓扑排序如下：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-219.png" style="zoom:67%;" />
</blockquote>
<h5 id="逆拓扑排序的代码实现"><a href="#逆拓扑排序的代码实现" class="headerlink" title="逆拓扑排序的代码实现"></a>逆拓扑排序的代码实现</h5><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-246.png" style="zoom: 50%;" />

<p>把“拓扑排序”中，进行<code>入度为0</code>的条件判断改为<code>出度为0</code>即可实现逆拓扑排序的代码。</p>
<p>自己练习：模仿拓扑排序的思想实现逆拓扑排序。</p>
<p>思考：使用不同的存储结构（即改用邻接矩阵实现）对时间复杂度的影响。</p>
<blockquote>
<p>对于逆拓扑排序来说，由于每次都要寻找该顶点的入边，若采用邻接表存储，则需要重新整个遍历所有邻接表，找到指向该顶点的边。是很低效的。而如果采用邻接矩阵，会很方便。</p>
<p>甚至，还可以采用“逆邻接表”：邻接表中，每一个顶点所对应的边的信息，是由该顶点发射出的边；而逆邻接表中，每一个顶点所对应的边的信息，是指入该顶点的边。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-247.png" style="zoom:50%;" />
</blockquote>
<h5 id="逆拓扑排序的实现-DFS算法"><a href="#逆拓扑排序的实现-DFS算法" class="headerlink" title="逆拓扑排序的实现(DFS算法)"></a>逆拓扑排序的实现(DFS算法)</h5><blockquote>
<p>用深度优先算法实现拓扑排序或逆拓扑排序。</p>
<p>这里先不讲。但是这里先补充一个课本中没有讲的，DFS算法实现逆拓扑排序。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(Graph G)</span> &#123;	<span class="comment">//对图G进行深度优先遍历 </span></span><br><span class="line">	<span class="keyword">for</span>(v=<span class="number">0</span>; v&lt;G.vexnum; ++v) &#123;</span><br><span class="line">		visited[v] = FALSE;	<span class="comment">//初始化已访问标记数据 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(v=<span class="number">0</span>; v&lt;G.vexnum; ++v) &#123;	<span class="comment">//本代码中是从v=0开始遍历 </span></span><br><span class="line">		<span class="keyword">if</span>(!visited[v])</span><br><span class="line">			DFS(G, v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span> &#123;	<span class="comment">//从顶点v出发，深度优先遍历图G </span></span><br><span class="line">	visit(v);	<span class="comment">//访问顶点v</span></span><br><span class="line">	visited[v] = TRUE;	<span class="comment">//设已访问标记</span></span><br><span class="line">	<span class="keyword">for</span>(w=FirstNeighbor(G, v); w&gt;=<span class="number">0</span>; w=NextNeighbor(G,v,w)) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!visited[w]) &#123;	<span class="comment">//w为u的尚未访问的邻接顶点 </span></span><br><span class="line">			DFS(G, w);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    print(v);	<span class="comment">//输出顶点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在DFS算法的基础上，添加一个<code>print(v);</code>的操作，输出出来的就是逆拓扑序列。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-222.png" style="zoom:80%;" />

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-223.png" style="zoom:80%;" />

<blockquote>
<p>上图，本身是不存在环路的。且我们的代码实现也没有考虑回路的问题。</p>
<p>思考：如果存在回路，则不存在逆拓扑排序序列，那么如何判断回路的存在？试着对代码进行一个改进。</p>
</blockquote>
<h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><h4 id="AOE网"><a href="#AOE网" class="headerlink" title="AOE网"></a>AOE网</h4><p>AOE网:</p>
<p>在带权有向图中，以<strong>顶点表示事件</strong>，以<strong>有向边表示活动</strong>，以<strong>边上的权值表示完成该活动的开销</strong>（如完成活动所需的时间），称之为用边表示活动的网络，简称<strong>AOE网</strong>（Activity On Edge NetWord）。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-224.png" style="zoom: 33%;" />

<blockquote>
<p>AOV网，V表示<code>Vertex</code>，指用顶点表示活动；</p>
<p>AOE网，E表示<code>Edge</code>，指用边表示活动。</p>
</blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-225.png" style="zoom: 33%;" />

<blockquote>
<p>顶点表示事件，是一瞬间发生的事情；边表示活动，是需要持续一段时间的。</p>
</blockquote>
<p>AOE网具有以下两个性质：</p>
<p>①只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始；</p>
<p>②只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。另外，有些活动是可以并行进行的。</p>
<h4 id="关键路径-1"><a href="#关键路径-1" class="headerlink" title="关键路径"></a>关键路径</h4><p>AOE网还有一些概念：</p>
<ul>
<li>在AOE网中<strong>仅有一个</strong>入度为0的顶点，称为<strong>开始顶点</strong>（<strong>源点</strong>），它表示整个工程的开始；</li>
<li>也<strong>仅有一个</strong>出度为0的顶点，称为<strong>结束顶点</strong>（<strong>汇点</strong>），它表示整个工程的结束。</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-226.png" style="zoom:33%;" />

<p>从源点到汇点的有向路径可能有多条，所有路径中，具有最大路径长度的路径称为<strong>关键路径</strong>，而把关键路径上的活动称为<strong>关键活动</strong>。</p>
<p>完成整个工程的最短时间就是关键路径的长度，若关键活动不能按时完成，则整个工程的完成时间就会延长。</p>
<blockquote>
<p>找到关键活动是哪些，我们就知道了影响整个项目的，是哪些事。</p>
</blockquote>
<blockquote>
<p>对于上图：</p>
<p>最快多久可以开始做？——现在，立刻（0分钟）    最快多久可以开切？——1分钟</p>
<p>最快多久可以开炒？——4分钟                  最快多久可以吃？——6分钟</p>
</blockquote>
<p>**事件<code>Vk</code>的最早发生时间<code>Ve(k)</code>**——决定了所有从<code>Vk</code>开始的活动能够开工的最早时间。</p>
<blockquote>
<p>（等于其前驱活动的最早开始时间 + 该活动需要消耗的时间）</p>
<p>例如，<code>可以切了</code>事件它的最早发生时间为1分钟，则在它之后的所有活动最早也要在1分钟时开工。</p>
</blockquote>
<p>**活动<code>ai</code>的最早开始时间<code>e(i)</code>**——指该活动弧的起点所表示的事件的最早发生时间。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-227.png" style="zoom:40%;" />

<p>上图，黄色为事件的最早发生时间，红色为活动的最早开始时间。</p>
<blockquote>
<p>如果有一个人说：6分钟后我一定要吃到，不然我会被饿死。</p>
<p>之后厨师分析了一下：整个项目6分钟可以结束。</p>
<p>由于炒菜需要2分钟，于是推出：4分钟时一定要开始炒菜这一活动。(如果4分钟时不能完成<code>可以炒了</code>事件，就意味着6分钟不可能结束)</p>
<p>继续往前推，由切番茄需要3分钟，可以推出：<code>可以切了</code>事件，必须在1分钟时就发生。</p>
<p>继续，由洗番茄需要1分钟，推出：<code>开始</code>必须是现在。</p>
</blockquote>
<p>上述我们从后往前推，推出了每个事件允许发生的最迟的时间。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-228.png" style="zoom:40%;" />

<p>**事件<code>Vk</code>的最迟发生时间<code>Vl(k)</code>**——它是指在不推迟整个工程完成的前提下，该事件最迟必须发生的时间。</p>
<p>**活动<code>ai</code>的最迟开始时间<code>l(i)</code>**——它是指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差。</p>
<blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-229.png" style="zoom:43%;" />

<p>上图，红色表示活动的最早开始时间，绿色表示活动的最迟开始时间。</p>
</blockquote>
<p>**活动<code>ai</code>的时间余量<code>d(i) = l(i)-e(i)</code>**，表示在不增加完成整个工程所需总时间的情况下，活动<code>ai</code>可以拖延的时间。</p>
<p>若一个活动的时间余量为零，则说明该活动必须要如期完成，<code>d(i)=0</code>即<code>l(i)=e(i)</code>的活动<code>a(i)</code>是<strong>关键活动</strong>。</p>
<h4 id="求关键路径的步骤"><a href="#求关键路径的步骤" class="headerlink" title="求关键路径的步骤"></a>求关键路径的步骤</h4><p>①求所有事件的最早发生时间<code>ve()</code></p>
<p>②求所有事件的最迟发生时间<code>vl()</code></p>
<p>③求所有活动的最早发生时间<code>e()</code></p>
<p>④求所有活动的最迟发生时间<code>l()</code></p>
<p>⑤求所有活动的时间余量<code>d()</code></p>
<blockquote>
<p>到第⑤步，由于<code>d(i)=0</code>的活动就是关键活动，由关键活动可得关键路径。</p>
</blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-230.png" style="zoom: 67%;" />

<h5 id="求所有事件的最早发生时间"><a href="#求所有事件的最早发生时间" class="headerlink" title="求所有事件的最早发生时间"></a>求所有事件的最早发生时间</h5><blockquote>
<p>①求所有事件的最早发生时间<code>ve()</code></p>
<p>（某一事件的最早发生时间，等于其前驱活动的最早开始时间 + 该活动需要消耗的时间）</p>
</blockquote>
<p>按<strong>拓扑排序</strong>序列，依次求各个顶点的<code>ve(k)</code>：</p>
<p>ve(源点) = 0</p>
<p>ve(k) = Max{ ve(j) + Weight(Vj, Vk) }，Vj为Vk的任意前驱</p>
<blockquote>
<p>首先我们要对这个AOE网进行一个拓扑排序。</p>
</blockquote>
<p><strong>拓扑序列</strong>：V1、V3、V2、V5、V4、V6</p>
<blockquote>
<p>根据拓扑排序序列的顺序，来依次计算各个顶点所代表的事件的最早发生时间。</p>
<p>这是因为，拓扑排序表示活动所必需的先后次序，我们根据拓扑排序序列依次计算最早发生时间，可以做到有条不紊。</p>
</blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-237.png" style="zoom: 50%;" />

<blockquote>
<p>一般有多个入边才需要取max</p>
<p>而取max是因为当前事件要发生的前提是它的入边的弧的起点所代表的事件要完成了</p>
</blockquote>
<h5 id="求所有事件的最迟发生时间"><a href="#求所有事件的最迟发生时间" class="headerlink" title="求所有事件的最迟发生时间"></a>求所有事件的最迟发生时间</h5><blockquote>
<p>②求所有事件的最迟发生时间<code>vl()</code></p>
<p>（某一事件的最迟发生时间，等于其后继活动的最迟发生时间-该活动需要消耗的时间）</p>
</blockquote>
<p>按<strong>逆拓扑排序</strong>序列，依次求各个顶点的<code>vl(k)</code>：</p>
<p>vl(汇点) = ve(汇点)</p>
<p>vl(k) = Min{ vl(j) - Weight(Vk，Vj) }，Vj为Vk的任意后继</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-238.png" style="zoom:50%;" />

<blockquote>
<p>当有多个出边时才需要取min</p>
<p>取min是表示，当该事件的所有弧中所指向的事件在完成的情况下，当前事件最迟发生的事件，为了确保所有指向的事件都完成，所以取min</p>
</blockquote>
<h5 id="求所有活动的最早发生时间"><a href="#求所有活动的最早发生时间" class="headerlink" title="求所有活动的最早发生时间"></a>求所有活动的最早发生时间</h5><blockquote>
<p>③求所有活动的最早发生时间<code>e()</code></p>
<p>（某活动的最早发生时间，等于其弧尾事件的最早发生时间）</p>
</blockquote>
<p>若边<code>&lt;Vk, Vj&gt;</code>表示活动<code>ai</code>，则有<code>e(i) = ve(k)</code></p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-239.png" style="zoom:67%;" />

<h5 id="求所有活动的最迟发生时间"><a href="#求所有活动的最迟发生时间" class="headerlink" title="求所有活动的最迟发生时间"></a>求所有活动的最迟发生时间</h5><blockquote>
<p>④求所有活动的最迟发生时间<code>l()</code></p>
<p>（某活动的最迟发生时间，等于其弧头事件的最迟发生时间 - 该活动所需时间）</p>
</blockquote>
<p>若边<code>&lt;Vk, Vj&gt;</code>表示活动<code>ai</code>，则有<code>l(i) = vl(j) - Weight(Vk, Vj)</code></p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-240.png" style="zoom:67%;" />

<h5 id="求所有活动的时间余量"><a href="#求所有活动的时间余量" class="headerlink" title="求所有活动的时间余量"></a>求所有活动的时间余量</h5><blockquote>
<p>⑤求所有活动的时间余量<code>d()</code></p>
<p>用活动的最迟发生时间 - 活动的最早发生时间</p>
</blockquote>
<p>d(i) = l(i) - e(i)</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-241.png" style="zoom: 67%;" />

<h5 id="找出关键路径"><a href="#找出关键路径" class="headerlink" title="找出关键路径"></a>找出关键路径</h5><p>根据最终得到的各个活动的时间余量，可以发现活动a2、a5、a7的时间余量都等于0，也就是说这几个活动是绝对不允许拖延的。因此我们就找到了所有的关键活动。</p>
<blockquote>
<p>关键活动：a2、a5、a7</p>
<p>关键路径：V1——&gt;V3——&gt;V4——&gt;V6</p>
</blockquote>
<h4 id="关键活动、关键路径的特性"><a href="#关键活动、关键路径的特性" class="headerlink" title="关键活动、关键路径的特性"></a>关键活动、关键路径的特性</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-242.png" style="zoom: 50%;" />

<ul>
<li>若关键活动耗时增加，则整个工程的工期将增长</li>
<li>缩短关键活动的时间，可以缩短整个工程的工期</li>
<li>当缩短到一定程度时，关键活动可能会变成非关键活动</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-243.png" style="zoom:50%;" />

<ul>
<li>可能有多条关键路径，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的<ul>
<li>要么把两条路径上的关键活动分别都加速。要么把这两个关键路径的交集路线上的活动加速（也相当于给两条路径都加速了）。</li>
</ul>
</li>
</ul>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><ul>
<li><p>【2010】对下面进行拓扑排序，可得不同拓扑序列的个数是–&gt;3</p>
<p><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-102.png"></p>
<blockquote>
<p>a没有被其他节点指向;d没有指向其他节点;</p>
<p>**所以拓扑排序的形式如下:aXXXd;**又因为b指向c,<strong>那么b一定是在c的前面</strong>;</p>
<p>所以可能的拓扑排序如下:<strong>abced,aebcd,abecd</strong>。</p>
</blockquote>
</li>
<li><p>【2012】下列关于最小生成树的叙述中，正确的是→①<br>① 最小生成树的代价唯一<br>② 所有权值最小的边一定会出现在所有的最小生成树中<br>③ 使用 Prim 算法从不同定点开始得到的最小生成树一定相同<br>④ 使用 Prim 算法和 Kruskal 算法得到的最小生成树总不相同</p>
<blockquote>
<p>Ⅰ．最小生成树的代价唯一这种叙述是正确的。Ⅱ．如果利用kruskal算法，那么权值最小的边一定会出现在所有的最小生成树中，但是利用prim算法权值最小的边不一定会在最小生成树中。Ⅲ．用prim算法从不同的顶点开始得到的最小生成树也不一定相同。最后，用prim算法和kruskal算法得到的最小生成树也有可能相同。</p>
</blockquote>
</li>
<li><p>【2012】对下图所示的有向带权图，若采用Dijkstra算法求从源点a到其他各顶点的最短路径，则得到的第一条最短路径的目标顶点是b，第二条最短路径的目标顶点是c,后续得到的其余各最短路径的目标顶点依次是–&gt;f,d,e</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-103.png"  />

<blockquote>
<p>从a到各顶点的最短路径的求解过程：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-104.png" style="zoom:60%;" />

<p>后续目标顶点依次为f,d,e</p>
<p>【排除法】对于A，若下一个顶点为d，路径a,b,d的长度5，而a,b,c,f的长度仅为4，显然错误。同理可以排除B。将f加入集合S后，采用上述的方法也可以排除D。</p>
</blockquote>
</li>
<li><p>【2013】下列AOE网表示一项包含8个活动的工程。通过同时加快若干活动的进度可以缩短整个工程的工期。下列选项中，加快其进度就可以缩短工程工期的是–&gt;f 和 d</p>
<p><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-105.png"></p>
<blockquote>
<p>这个网有三条关键路径：</p>
<ul>
<li>b、d、c、g</li>
<li>b、d、e、h</li>
<li>b、f、h</li>
</ul>
<p>缩短工期的活动要涵盖三条路径。</p>
<p>具体运算如下:@牛客 我是超越迷妹了</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-106.png" style="zoom: 25%;" /></blockquote>
</li>
<li><p>【2012】若用邻接矩阵存储有向图，矩阵中主对角线以下的元素均为零，则关于该图拓扑序列的结论是–&gt;C</p>
<p>A.存在,且唯一          B.存在,且不唯<br>C.存在,可能不唯一      D.无法确定是否存在</p>
<blockquote>
<p>1)若邻接矩阵为 </p>
<p>0 1 1 </p>
<p>0 0 0 </p>
<p>0 0 0 </p>
<p>满足主对角线以下元素均为零 </p>
<p>且只有从结点1到结点2，3的边，此时拓扑序列有1，2和1，3，不唯一 </p>
<p>2)若邻接矩阵为   </p>
<p>0 1 0 </p>
<p>0 0 1 </p>
<p>0 0 0 </p>
<p>满足主对角线以下元素均为零， </p>
<p>且只有结点1到结点2，结点2到结点3的边，此时拓扑序列为1，2，3，唯一</p>
</blockquote>
</li>
<li><p>【2014】对下图所示的有向图进行拓扑排序，得到的拓扑序列可能是–&gt;3,1,4,2,6,5</p>
<p><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-107.png"></p>
<blockquote>
<p>每次选取极大顶点（入度为0的顶点），并把它跟它的出度一起从图中删掉</p>
<p>第一次删掉3。第二次删掉1。第三次删掉4</p>
<p>第四次可以删掉2或者6，若依据选项CD删掉2，那么第五次删掉6，最后删掉5</p>
<p>314265，选D</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-108.png"  /></blockquote>
</li>
<li><p>【2015】求下面的带权图的最小生成树时，可能是Kruskal算法第2次选中但不是Prim算法（从 V4 开始）第 2 次选中的边是–&gt;C</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-109.png"  />

<p>A. (V1,V3)   B. (V1,V4)<br>C. (V2,V3)   D. (V3,V4)</p>
<blockquote>
<p>从V4开始，Kruskal算法选中的第一条边一定是权值最小的（V1,V4），B 错误。由于  V1和V4已经可达，第二条边含有V1和V4的权值为8的一定符合Prim算法，排除A、D  。</p>
</blockquote>
</li>
<li><p>【2016】使用Dijkstra算法求下图中从顶点1到其他各顶点的最短路径，依次得到的各最短路径的目标顶点是–&gt;5, 2, 3, 6, 4</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-110.png" style="zoom: 50%;" />

<blockquote>
<p>对于dijkstra算法来说，只有当一个点的所有入度都被遍历过之后，才能完全确认起点到这个点的距离。但这道题没有那么严谨，它的意思似乎仅仅是给各最短路径排序，从短到长。</p>
</blockquote>
</li>
<li><p>【2016】若对 n 个顶点、e 条弧的有向图采用邻接表存储，则拓扑排序算法的时间复杂度是 →O(n+e)</p>
<blockquote>
<p>对有n个顶点和e条弧的有向图而言，建立求各顶点的入度的时间复杂度为O(e)；建零入度顶点栈的时间复杂度为O(n)；在拓扑排序过程中，若有向图无环，则每个顶点进一次栈、出一次栈，入度减1的操作在while语句中总共执行e次，所以总的时间复杂度为O(n+e)。 拓扑排序初始参数只有邻接表，所以第一步建立入度数组，因为每1入度对应一条弧，总共e条弧，建立入度数组的复杂度为O(e)。每个节点输出一次，n个节点遍历一次，时间复杂度为O(n)。（使用零入度节点栈的原因是，如果不把零入度节点入栈，每次输出时都要遍历节点。建立此栈，只需遍历一次。）然后节点入度减1的操作，也是一条弧对应一次，e条弧总共O(e)。以上总计O(n+2e)即O(n+e)。 即对每条弧要建立入度数组操作和删除操作，每个顶点要遍历一次并删除。故时间复杂度为O(n+e)</p>
</blockquote>
</li>
<li><p>【2018】下列选项中，不是如下有向图的拓扑序列是–&gt;D</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-111.png" style="zoom:50%;" />

<p>A.1,5,2,3,6,4     B.5,1,2,6,3,4</p>
<p>C.5,1,2,3,6,4     D.5,2,1,6,3,4</p>
<blockquote>
<p>拓扑排序每次选取入度为0的结点输出，经观察不难发现拓扑序列前两位一定是1，5或5，1(因为只有1和5的入度均为0，且其他结点都不满足仅有1或仅有5作为前驱)。</p>
</blockquote>
</li>
<li><p>【2019】下图所示的AOE网表示一项包含8个活动的工程。活动d的最早开始时间和最迟开始时间分别是–&gt;12 和 14</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-112.png" style="zoom:67%;" />

<blockquote>
<p>因为活动d的最早开始时间等于该活动弧的起点所表示的时间的最早发生时间=max(a,b+c)=max(3,12)=12 </p>
<p>活动d的最迟开始时间等于该活动弧的最迟发生时间与该活动所需时间之差，图中的关键路径长度为27，所以事件发生的最迟时间为min(27-g)=21,所以d的最迟开始时间为21-d=14</p>
</blockquote>
</li>
<li><p>【2019】用有向无环图描述表达式<code>(x+y)((x+y)/x)</code>，需要的顶点个数至少是 →5</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/amoscn/article/details/103452640">https://blog.csdn.net/amoscn/article/details/103452640</a></p>
</blockquote>
</li>
<li><p>【2020】修改递归方式实现的图的深度优先搜索（DFS）算法，将输出（访问）顶点信息的语句移到退出递归前（即执行输出语句后立刻退出递归）。采用修改后的算法遍历有向无环图 G，若输出结果中包含 G 的全部顶点，则输出的顶点序列是G的–&gt;B<br>A 拓扑有序序列       B 逆拓扑有序序列<br>C 广度优先搜索序列   D 深度优先搜索序列 </p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/cuisl37186486/article/details/117968121">https://blog.csdn.net/cuisl37186486/article/details/117968121</a></p>
</blockquote>
</li>
<li><p>【2020】若使用AOE网估算工程进度，则下列叙述中正确的是–&gt;B</p>
<p>A. 关键路径是从源点到汇点边数最多的一条路径<br>B. 关键路径是从源点到汇点路径长度最长的路径<br>C. 增加任一关键活动的时间不会延长工程的工期<br>D. 缩短任一关键活动的时间将会缩短工程的工期</p>
<blockquote>
<p>关键路径是指权值之和最大而非边数最多的路径，故选项A错误。选项B正确，是关键路径的概念。无论是存在一条还是存 在多条关键路径，增加任一关键活动的时间都会延长工程的工期，因为关键路径始终是权值之和最大的那条路径，选项C错误。仅有一条关键路径时，减少关键活动的时间会缩短工程的工期;存在多条关键路径时，缩短一条关键活动的时间不一定会缩短工程的工期，缩短了路径长度的那条关键路径不一定还是关键路径,选项D错误。</p>
</blockquote>
</li>
<li><p>【2020】已知无向图G如下所示，使用克鲁斯卡尔（Kruskal）算法求图G的最小生成树，加入到最小生成树中的边依次是：</p>
<p>A．(b,f)(b,d)(a,e)(c,e)(b,e)</p>
<p>B．(b,f)(b,d)(b,e)(a,e)(e,c)</p>
<p>C．(a,e)(b,e)(c,e)(b,d)(b,f)</p>
<p>D．(a,e)(c,e)(b,e)(b,f)(b,d)</p>
<p><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-114.png"></p>
<blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-115.png" style="zoom:80%;" /></blockquote>
</li>
<li><p>【2021】给定如下有向图，该图的拓扑有序序列的个数是–&gt;A</p>
<p>A. 1      B. 2</p>
<p>C. 3      D. 4</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-116.png" style="zoom:67%;" />

<blockquote>
<p>求拓扑序列的过程如下:从图中选择无入边的结点，输出该结点并删除该结点的所有出边,重复上述过程，直至全部结点都已输出，求得拓扑序列ABCDEF.每次输出一个结点并删除该结点的所有出边后，都发现仅有一个结点无入边，因此该拓扑序列唯一</p>
</blockquote>
</li>
<li><p>【2021】使用Djkstra算法求下图中从顶点1到其余各顶点的最短路径，将当前找到的从顶点1到顶点2,3, 4, 5的最短路径长度保存在数组dist中，求出第二条最短路径后，dist 中的内容更新为–&gt;C</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-117.png" style="zoom:67%;" />

<p>A、26,3,14,6      B、25,3,14,6</p>
<p>C、21,3,14,6      D、15,3,14,6</p>
<blockquote>
<p>在执行Dijkstra算法时，首先初始化dist],若顶点1到顶点i(i=2,3,4, 5)有边，就初始化为边的权值;若无边，就初始化为∞;初始化顶点集s只含顶点1。Djkstra算法每次选择一个到顶点1距离最近的顶点j加入顶点集s,并判断由顶点1绕行顶点j后到任一顶点k是否距离更短，若距离更短(即distj] + arcs[j][k] &lt; dist[k])， 则将dist[x]更新为dist[j] +arcs[j][k];重复该过程，直至所有顶点都加入顶点集S。数组dist的变化过程如下图所示,可知将第二个顶点5加入顶点集S后，数组dist更新为21,3, 14,6,故选C。</p>
</blockquote>
</li>
</ul>
<blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-118.png" style="zoom:67%;" />
</blockquote>
<ul>
<li><p>综合题【2009】带权图(权值非负，表示边连接的两顶点)的最短路径问题是找出从初始顶点到目标顶点之间的一条最短路径。假设从初始顶点到目标顶点之间存在路径，现有一种解决该问题的方法∶<br>①设最短路径初始时仅包含初始顶点，令当前顶点u为初始顶点;<br>② 选择离u最近且尚未在最短路径中的一个顶点v，加入最短路径中，修改当前顶点u=v;<br>③ 重复步骤②，直到u是目标顶点时为止。<br>请问上述方法能否求得最短路径?若该方法可行，请证明之;否则，请举例说明。</p>
<blockquote>
<p>该方法不一定能（或不能）求得最短路径。  </p>
<p>举例说明： </p>
<p>图A-4中，设初始顶点为1，目标顶点为4，欲求从顶点1到顶点4之间的最短路径，显然这两点之间的最短路径长度为2。利用给定方法求得的路径长度为3，但这条路径并不是这两点之间的最短路径。 </p>
<p>图A-5中，设初始顶点为1，目标顶点为3，欲求从顶点1到顶点3之间的最短路径。利用给定的方法，无法求出顶点1到顶点3的路径。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-119.png" style="zoom:80%;" />

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-120.png" style="zoom:80%;" /></blockquote>
</li>
<li><p>综合题【2017】使用Prim算法求带权连通图的最小生成树(MST)。请回答下列问题:</p>
<p>(1)对下列图 G，从顶点 A 开始求 G 的 MST，依次给出按算法选出的边。</p>
<p>(2)图 G 的 MST 是唯一的吗？</p>
<p>(3)对任意的带权连通图，满足什么条件时，其 MST 是唯一的？</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-128.png" style="zoom:50%;" />

<blockquote>
<p>(1)Prim 算法属于贪心策略。算法从一个任意的顶点开始，一直长大到覆盖图中所有顶点为止。算法每一步在连接 树集合 S 中顶点和其他顶点的边中，选择一条使得树的总权重增加最小的边加入集合 S。当算法终止时，S 就是最小生 成树。 </p>
<p>①S 中顶点为 A，候选边为(A,D)、(A,B)、(A,E)，选择(A,D)加入 S。 </p>
<p>②S 中顶点为 A、D，候选边为(A,B)、(A,E)、(D,E)、(C,D)，选择(D,E)，加入 S。 </p>
<p>③S 中顶点为 A、D、E，候选边为(A,B)、(C,D)、(C,E)，选择(C,E)加入 S。 </p>
<p>④S 中顶点为 A、D、E、C，候选边为(A,B)、(B,C)，选择(B,C)加入 S。 </p>
<p>⑤S 就是最小生成树。 依次选出的边为： (A，D),(D，E),(C，E),(B，C) </p>
<p>(2)图 G 的 MST 是唯一的 第一小题的最小生成树包括了图中权值最小的四条边，其他边都比这四条 边大，所以此图的 MST 唯一。</p>
<p>(3)当带权连通图的任意一个环中所包含的边的权值均不相同时，其 MST 是唯一的</p>
</blockquote>
</li>
<li><p>综合题【2011】已知有6个顶点(顶点编码为0~5)的有向带权图G，其邻接矩阵 A 为上三角矩阵，按行为主序（行优先）保存在如下的一维数组中。</p>
<table>
<thead>
<tr>
<th>4</th>
<th>6</th>
<th>∞</th>
<th>∞</th>
<th>∞</th>
<th>5</th>
<th>∞</th>
<th>∞</th>
<th>∞</th>
<th>4</th>
<th>3</th>
<th>∞</th>
<th>∞</th>
<th>3</th>
<th>3</th>
</tr>
</thead>
</table>
<p>要求∶<br>（1）写出图G的邻接矩阵 A。<br>（2）画出有向带权图 G。<br>（3）求图 G的关键路径，并计算该关键路径的长度。</p>
<blockquote>
<p>(1)给的一维数组可以理解为上三角矩阵的压缩存储。图有6个顶点，而且第一个值是4，说明，它没有记录节点自己到自己的节点。那么，上三角的第一行就有5个值，第二行有4个值，第三行有3个值，第四行有2个值，第五行有1个值。5+4+3+2+1 正好是给定的一维数组值得个数。主对角线都是零。</p>
<p>因为是有向图，下三角部分没有给值，说明没有路径。就都是无穷。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-121.png" style="zoom: 25%;" />

<p>（2）根据邻接矩阵画出图</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-122.png" style="zoom: 50%;" />

<p>（3）关键路径的求法:<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kt411R7SD/">https://www.bilibili.com/video/BV1Kt411R7SD/</a></p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-123.png" style="zoom: 33%;" />

<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">0</th>
<th align="left">1</th>
<th align="left">2</th>
<th align="left">3</th>
<th align="left">4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td align="left">事件最早开始时间</td>
<td align="left">0</td>
<td align="left">4</td>
<td align="left">9</td>
<td align="left">13</td>
<td align="left">12</td>
<td>16</td>
</tr>
<tr>
<td align="left">事件最晚开始时间</td>
<td align="left">0</td>
<td align="left">4</td>
<td align="left">9</td>
<td align="left">13</td>
<td align="left">13</td>
<td>16</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">a1</th>
<th align="left">a2</th>
<th align="left">a3</th>
<th align="left">a4</th>
<th align="left">a5</th>
<th align="left">a6</th>
<th>a7</th>
</tr>
</thead>
<tbody><tr>
<td align="left">活动最早开始时间</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">4</td>
<td align="left">9</td>
<td align="left">9</td>
<td align="left">13</td>
<td>12</td>
</tr>
<tr>
<td align="left">活动最晚开始时间</td>
<td align="left">0</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">9</td>
<td align="left">10</td>
<td align="left">13</td>
<td>13</td>
</tr>
</tbody></table>
<p>关键路径为：0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 5      路径长度为：16</p>
</blockquote>
</li>
<li><p>综合题【2014】某网络中的路由器运行OSPF路由协议，下表是路由器R1维护的主要链路状态信息(LSI)，R1构造的网络拓扑图(见下图)是根据题下表及R1的接口名构造出来的网络拓扑</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-124.png" style="zoom:67%;" />

<p> 请回答下列问题。</p>
<ol>
<li>  本题中的网络可抽象为数据结构中的哪种逻辑结构？</li>
<li>  针对题42表中的内容，设计合理的链式存储结构，以保存题42表中的链路状态信息(LSI)。要求给出链式存储结构的数据类型定义，并画出对应题42表的链式存储结构示意图(示意图中可仅以ID标识结点)。</li>
<li>  按照迪杰斯特拉(Dijkstra)算法的策略，依次给出R1到达题42图中子网192.1.x.x的最短路径及费用。</li>
</ol>
<blockquote>
<p>1)题中给出的是一个简单的网络拓扑图，可以抽象为无向图。</p>
<p>2)链式存储结构的如下图所示</p>
<p><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-125.png"></p>
<p>其数据类型定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ID, IP;</span><br><span class="line"></span><br><span class="line">&#125;LinkNode; <span class="comment">//Link 的结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Prefix, Mask;</span><br><span class="line"></span><br><span class="line">&#125;NetNode; <span class="comment">//Net 的结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Flag; <span class="comment">//Flag=1 为Link;Flag=2为Net</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line"></span><br><span class="line"> LinkNode Lnode;</span><br><span class="line"></span><br><span class="line"> NetNode Nnode</span><br><span class="line"></span><br><span class="line">&#125;LinkORNet;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Metric;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;ArcNode; <span class="comment">//弧结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HNode</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> RouterID;</span><br><span class="line"></span><br><span class="line">ArcNode *LN_link;</span><br><span class="line"></span><br><span class="line">Struct HNode *next;</span><br><span class="line"></span><br><span class="line">&#125;HNODE; <span class="comment">//表头结点</span></span><br></pre></td></tr></table></figure>

<p>对应题42表的链式存储结构示意图如下</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-126.png" style="zoom: 80%;" />

<p>3)计算结果如下表所示</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-127.png" style="zoom: 67%;" /></blockquote>
</li>
<li><p>综合题【2018】拟建设一个光通信骨干网络连通BJ,CS,XA,OD,JN,NJ,TL 和 WH 8 个城市，下图中无向边上的权值表示两个城市间备选光纤的铺设费用。</p>
<p>请回答下列问题。 </p>
<p>  （1）仅从铺设费用角度出发，给出所有可能的最经济的光纤铺设方案（用带权图表示）， 并计算相应方案的总费用。 </p>
<p>  （2）题 42 图可采用图的哪种存储结构？给出求解问题（1）所使用的算法名称。 </p>
<p>  （3）假设每个城市采用一个路由器按（1）中得到的最经济方案组网，主机 H1 直接连接在 TL 的路由器上，主机 H2 直接连接在 BJ 的路由器上。若 H1 向 H2 发送一个 TTL = 5 的 IP 分组， 则 H2 是否可以收到该 IP 分组？</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-129.png" style="zoom: 33%;" />

<blockquote>
<p>1)为了求解最经济的方案，可以把问题抽象为求无向带权图的最小生成树。可以采用手 动 Prim 算法或 Kruskal 算法作图。注意本题最小生成树有两种构造，如下图所示。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-130.png" style="zoom: 67%;" />

<p>方案的总费用为 16。</p>
<p>2)存储题中的图可以采用邻接矩阵（或邻接表）。构造最小生成树采用 Prim 算法（或 Kruskal 算法）</p>
<p>3)TTL = 5，即 IP 分组的生存时间（最大传递距离）为 5，方案 1 中 TL 和 BJ 的距离过远， TTL = 5 不足以让 IP 分组从 H1 传送到 H2，因此 H2 不能收到 IP 分组。而方案 2 中 TL 和 BJ 邻近，H2 可以收到 IP 分组。</p>
</blockquote>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://tikxeis.fun">kailin2eis</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://tikxeis.fun/p/12342/">http://tikxeis.fun/p/12342/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://tikxeis.fun" target="_blank">派总</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/408%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">408数据结构</a></div><div class="post_share"><div class="social-share" data-image="/img/1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/p/63800/"><img class="next-cover" src="/img/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第六章 图(上)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/p/24523/" title="第一章 绪论"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第一章 绪论</div></div></a></div><div><a href="/p/14457/" title="第二章 线性表(上)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第二章 线性表(上)</div></div></a></div><div><a href="/p/63528/" title="第三章 栈、队列和数组(上)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第三章 栈、队列和数组(上)</div></div></a></div><div><a href="/p/63944/" title="第五章 树与二叉树(上)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-28</div><div class="title">第五章 树与二叉树(上)</div></div></a></div><div><a href="/p/17647/" title="第四章 串"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-28</div><div class="title">第四章 串</div></div></a></div><div><a href="/p/12625/" title="第二章 线性表(下)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第二章 线性表(下)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">kailin2eis</div><div class="author-info__description">派总's blog</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">6.4 图的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-Minimum-Spanning-Tree-MST"><span class="toc-text">最小生成树 Minimum-Spanning-Tree, MST</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">无向图的生成树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">最小生成树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Prim%E7%AE%97%E6%B3%95-%E6%99%AE%E5%88%A9%E5%A7%86"><span class="toc-text">Prim算法(普利姆)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kruskal%E7%AE%97%E6%B3%95-%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94"><span class="toc-text">Kruskal算法(克鲁斯卡尔)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83"><span class="toc-text">比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%80%9D%E6%83%B3"><span class="toc-text">代码思想</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Prim%E7%AE%97%E6%B3%95"><span class="toc-text">Prim算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Kruskal%E7%AE%97%E6%B3%95"><span class="toc-text">Kruskal算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-Short-Path-First-SPF"><span class="toc-text">最短路径 Short Path First, SPF</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BFS%E6%B1%82%E6%97%A0%E6%9D%83%E5%9B%BE%E7%9A%84%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-text">BFS求无权图的单源最短路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dijkstra%E7%AE%97%E6%B3%95"><span class="toc-text">Dijkstra算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8E%8B%E5%8D%93%E7%89%88%E6%9C%AC"><span class="toc-text">王卓版本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8E%8B%E9%81%93%E7%89%88%E6%9C%AC"><span class="toc-text">王道版本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Dijkstra%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">Dijkstra算法的时间复杂度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E8%B4%9F%E6%9D%83%E5%80%BC%E5%B8%A6%E6%9D%83%E5%9B%BE"><span class="toc-text">用于负权值带权图</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Floyd%E7%AE%97%E6%B3%95"><span class="toc-text">Floyd算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8E%8B%E5%8D%93%E7%89%88%E6%9C%AC-1"><span class="toc-text">王卓版本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8E%8B%E9%81%93%E7%89%88%E6%9C%AC-1"><span class="toc-text">王道版本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E8%BE%83%E5%A4%8D%E6%9D%82%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-text">一个较复杂的例子</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E8%B4%9F%E6%9D%83%E5%80%BC%E5%B8%A6%E6%9D%83%E5%9B%BE-1"><span class="toc-text">用于负权值带权图</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE"><span class="toc-text">有向无环图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE-DAG"><span class="toc-text">有向无环图(DAG)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DAG%E6%8F%8F%E8%BF%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">DAG描述表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-text">拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-text">如何进行拓扑排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">拓扑排序的代码实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%86%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-text">逆拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%80%86%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-text">如何进行逆拓扑排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%86%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">逆拓扑排序的代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%86%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0-DFS%E7%AE%97%E6%B3%95"><span class="toc-text">逆拓扑排序的实现(DFS算法)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-text">关键路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AOE%E7%BD%91"><span class="toc-text">AOE网</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84-1"><span class="toc-text">关键路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-text">求关键路径的步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%82%E6%89%80%E6%9C%89%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%9C%80%E6%97%A9%E5%8F%91%E7%94%9F%E6%97%B6%E9%97%B4"><span class="toc-text">求所有事件的最早发生时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%82%E6%89%80%E6%9C%89%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%9C%80%E8%BF%9F%E5%8F%91%E7%94%9F%E6%97%B6%E9%97%B4"><span class="toc-text">求所有事件的最迟发生时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%82%E6%89%80%E6%9C%89%E6%B4%BB%E5%8A%A8%E7%9A%84%E6%9C%80%E6%97%A9%E5%8F%91%E7%94%9F%E6%97%B6%E9%97%B4"><span class="toc-text">求所有活动的最早发生时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%82%E6%89%80%E6%9C%89%E6%B4%BB%E5%8A%A8%E7%9A%84%E6%9C%80%E8%BF%9F%E5%8F%91%E7%94%9F%E6%97%B6%E9%97%B4"><span class="toc-text">求所有活动的最迟发生时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%82%E6%89%80%E6%9C%89%E6%B4%BB%E5%8A%A8%E7%9A%84%E6%97%B6%E9%97%B4%E4%BD%99%E9%87%8F"><span class="toc-text">求所有活动的时间余量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%BE%E5%87%BA%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-text">找出关键路径</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%B4%BB%E5%8A%A8%E3%80%81%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">关键活动、关键路径的特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98"><span class="toc-text">习题</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/12342/" title="第六章 图(下)">第六章 图(下)</a><time datetime="2022-09-28T07:19:14.000Z" title="发表于 2022-09-28 15:19:14">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/63800/" title="第六章 图(上)">第六章 图(上)</a><time datetime="2022-09-28T07:04:39.000Z" title="发表于 2022-09-28 15:04:39">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/56280/" title="第五章 树与二叉树(下)">第五章 树与二叉树(下)</a><time datetime="2022-09-28T06:47:26.000Z" title="发表于 2022-09-28 14:47:26">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/48066/" title="第五章 树与二叉树(中)">第五章 树与二叉树(中)</a><time datetime="2022-09-28T06:37:49.000Z" title="发表于 2022-09-28 14:37:49">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/63944/" title="第五章 树与二叉树(上)">第五章 树与二叉树(上)</a><time datetime="2022-09-28T04:50:11.000Z" title="发表于 2022-09-28 12:50:11">2022-09-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By kailin2eis</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="关关雎鸠,在河之洲,窈窕淑女,what' your qq" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>