<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>第二章 线性表(下) | 派总</title><meta name="keywords" content="408数据结构"><meta name="author" content="kailin2eis"><meta name="copyright" content="kailin2eis"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="2.3 线性表的链式表示链表——用链式存储方式实现的线性表。 链表主要有四种：单链表、双链表、循环链表、静态链表。  优点：不要求大片连续空间，改变容量方便 缺点：不可随机存取，要耗费一定空间存指针域  单链表的定义   线性表的链式存储又称单链表，它是指通过一组任意的存储单元来存储线性表中的数据元素。为了建立数据元素之间的线性关系，对每个链表结点，除存放元素自身的信息外，还需要存放一个指向其后继">
<meta property="og:type" content="article">
<meta property="og:title" content="第二章 线性表(下)">
<meta property="og:url" content="http://tikxeis.fun/p/12625/index.html">
<meta property="og:site_name" content="派总">
<meta property="og:description" content="2.3 线性表的链式表示链表——用链式存储方式实现的线性表。 链表主要有四种：单链表、双链表、循环链表、静态链表。  优点：不要求大片连续空间，改变容量方便 缺点：不可随机存取，要耗费一定空间存指针域  单链表的定义   线性表的链式存储又称单链表，它是指通过一组任意的存储单元来存储线性表中的数据元素。为了建立数据元素之间的线性关系，对每个链表结点，除存放元素自身的信息外，还需要存放一个指向其后继">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://tikxeis.fun/img/1.png">
<meta property="article:published_time" content="2022-09-25T06:14:10.000Z">
<meta property="article:modified_time" content="2022-09-25T06:19:30.012Z">
<meta property="article:author" content="kailin2eis">
<meta property="article:tag" content="408数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tikxeis.fun/img/1.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://tikxeis.fun/p/12625/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第二章 线性表(下)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-25 14:19:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/1.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">派总</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">第二章 线性表(下)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-25T06:14:10.000Z" title="发表于 2022-09-25 14:14:10">2022-09-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-25T06:19:30.012Z" title="更新于 2022-09-25 14:19:30">2022-09-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/408%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">408数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="第二章 线性表(下)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="2-3-线性表的链式表示"><a href="#2-3-线性表的链式表示" class="headerlink" title="2.3 线性表的链式表示"></a>2.3 线性表的链式表示</h2><p><strong>链表</strong>——用<strong>链式存储</strong>方式实现的<strong>线性表</strong>。</p>
<p>链表主要有四种：单链表、双链表、循环链表、静态链表。</p>
<ul>
<li>优点：不要求大片连续空间，改变容量方便</li>
<li>缺点：不可随机存取，要耗费一定空间存指针域</li>
</ul>
<h3 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h3><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-6.png" style="zoom: 75%;" />

<ul>
<li>线性表的链式存储又称<strong>单链表</strong>，它是指通过一组任意的存储单元来存储线性表中的数据元素。为了建立数据元素之间的线性关系，对每个链表结点，<font color='red'>除存放元素自身的信息外，还需要存放一个指向其后继的指针</font>。</li>
</ul>
<p><strong>单链表的代码实现</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>		<span class="comment">//单链表结点的结构类型 </span></span><br><span class="line">	ElemType data;	<span class="comment">//数据域 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>	<span class="comment">//指针域 </span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">p</span> =</span> (<span class="keyword">struct</span> LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));	<span class="comment">//增加一个新的结点</span></span><br></pre></td></tr></table></figure>

<p>此处，我们发现，每次定义一个新结点，都要将它定义为<code>struct LNode</code>的类型。</p>
<p>于是我们直接将原结构类型<code>struct LNode</code>使用typedef重命名一下，以简化。</p>
<h4 id="typedef的使用问题"><a href="#typedef的使用问题" class="headerlink" title="typedef的使用问题"></a>typedef的使用问题</h4><blockquote>
<p>typedef &lt;数据类型&gt; &lt;别名&gt;</p>
<p>例如：  typedef int zhengshu;  typedef int * zhengshuzhizhen;</p>
<p>这样以后，原本的  int a = 1;   int * p;</p>
<p>就可以写为  zhengshu a = 1;  zhengshuzhizhen p;</p>
</blockquote>
<p><strong>于是就有了如下的类型定义代码</strong></p>
<p><strong>结点的类型定义</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>				<span class="comment">//定义单链表结点类型</span></span><br><span class="line">    ElemType data;					<span class="comment">//定义单链表结点类型(数据域)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> * <span class="title">next</span>;</span>			<span class="comment">//每个节点存放一个数据元素(指针域)</span></span><br><span class="line">&#125;LNode,*LinkList;					<span class="comment">//LinkList为指向结构体LNode的指针类型</span></span><br><span class="line"><span class="comment">//增加一个新的结点:在内存中申请一个结点所需空间,并用指针p指向这个结点</span></span><br><span class="line">LNode *p =(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述定义代码等价于</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> <span class="title">LNode</span>;</span>			<span class="comment">//struct LNode = LNode</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> * <span class="title">LinkList</span>;</span>	<span class="comment">//struct LNode *= LinkList </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//增加一个新的结点:在内存中申请一个结点所需空间,并用指针p指向这个结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">p</span> =</span>(<span class="keyword">struct</span> LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode))</span><br></pre></td></tr></table></figure>

<p>通常只需声明一个头指针L来表示一个单链表，指向单链表的第一个结点</p>
<p><code>LNode *L;        //声明一个指向单链表的第一个结点的指针</code><br>这样一来，我就可以这样写我的代码:<br><code>LinkList L;   //声明一个指向单链表的第一个结点的指针</code></p>
<p><font color='orange'>但是，也并不是说，写LNode 的地方，都要写作LinkList。因为，代码不论怎么写，始终是为了简洁性、可读性的。看下面这个例子：</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType * data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单链表查找某元素</span></span><br><span class="line">LNode * <span class="title function_">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i)</span>&#123;	<span class="comment">//函数返回值LNode *是想强调其返回结果是一个结点；</span></span><br><span class="line">    								<span class="comment">//参数L类型LinkList是想强调这是一个单链表（头结点代表单链表）</span></span><br><span class="line">	<span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">	LNode *p = L-&gt;next;</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">return</span> L;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i)&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;	<span class="comment">//最终返回一个结点，类型为LNode *</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：此段代码中，并没有将LNode *全部写为LinkList。可以注意到，在我使用LNode *的地方，我往往是想要强调这是一个结点(例如函数返回值LNode *，例如其中用来索引的指针p是LNode *)，而在使用LinkList的地方，我想要强调的是这是一个单链表（例如函数的参数L是LinkList，它虽然是一个头结点，但它根本上是代表着一个单链表）</p>
</blockquote>
<p><strong>总之，这种重命名的方法（typedef），以及对重命名之后的别名的使用（是有所强调的，而不是一概而论的），希望能够好好体会。</strong></p>
<h4 id="不带头结点的单链表"><a href="#不带头结点的单链表" class="headerlink" title="不带头结点的单链表"></a>不带头结点的单链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>		<span class="comment">//定义单链表结点的结构类型</span></span><br><span class="line">	ElemType data;		<span class="comment">//数据域 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>	<span class="comment">//指针域 </span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个空的单链表（不带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span> &#123;</span><br><span class="line">	L = <span class="literal">NULL</span>;	<span class="comment">//空表，暂时还没有任何结点	//初始并设为空，防止脏数据</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">	LinkList L;	<span class="comment">//声明一个指向单链表的指针	//（1）</span></span><br><span class="line">	InitList(L);	<span class="comment">//初始化一个空表</span></span><br><span class="line">	<span class="comment">//...... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>（1）处并没有创建一个结点。</p>
<p>要始终去体会，<strong>别名的使用是在含义上有所强调的</strong>，而不仅仅是理论上来说代码能否编译问题</p>
<h4 id="带头结点的单链表"><a href="#带头结点的单链表" class="headerlink" title="带头结点的单链表"></a>带头结点的单链表</h4><p>单链表第一个结点之前附加一个结点，称为头结点。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhenyusoso/article/details/6092843">https://blog.csdn.net/zhenyusoso/article/details/6092843</a></p>
<p>引入头结点后，可用带来两个优点:</p>
<ol>
<li>由于第一个数据结点的位置被存放在头结点的指针域中，因此在链表的第一个位置上的操作和在表的其他位置上的操作一致，无须进行特殊处理。</li>
<li>无论链表是否为空，其头指针都指向头结点的非空指针(空表中头结点的指针域为空)，因此空表和非空表的处理也就得到了统一。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个单链表（带头结点） </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">	L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));	<span class="comment">//分配一个头结点</span></span><br><span class="line">	<span class="keyword">if</span>(L == <span class="literal">NULL</span>)  <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//内存不足，分配失败</span></span><br><span class="line">	L-&gt;next = <span class="literal">NULL</span>;	<span class="comment">//头结点之后暂时还没有结点</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">	LinkList L;	<span class="comment">//声明一个指向头结点的指针</span></span><br><span class="line">	InitList(L);	<span class="comment">//初始化一个空表</span></span><br><span class="line">	<span class="comment">//...... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：此头结点的数据域是不存储数据元素的，只有指针域有意义。这是为了方便后续的链表操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断单链表是否为空（带头结点） </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(LinkList L)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="不带-带头结点的区别"><a href="#不带-带头结点的区别" class="headerlink" title="不带/带头结点的区别"></a>不带/带头结点的区别</h4><ul>
<li>不带头结点，写代码更麻烦。对第一个数据结点和后续数据结点的处理需要用不同的代码逻辑。对空表和非空表的处理需要用不同的代码逻辑。</li>
<li>带头结点，写代码更方便。一般都是带头结点的。</li>
<li>不带头结点，头指针L所指向的下一个结点，就是实际用于存放数据的结点。而带头结点，头指针所指向的结点，也就是头结点，是不存放实际的数据元素的，而头结点指向的下一个结点才会用于存放数据。</li>
<li>不带头结点，空表判断：<code>L==NULL</code>；带头结点，空表判断：<code>L-&gt;next==NULL</code></li>
</ul>
<h3 id="单链表上基本操作的实现"><a href="#单链表上基本操作的实现" class="headerlink" title="单链表上基本操作的实现"></a>单链表上基本操作的实现</h3><h4 id="采用头插法建立单链表"><a href="#采用头插法建立单链表" class="headerlink" title="采用头插法建立单链表"></a>采用头插法建立单链表</h4><ul>
<li>头插法建立单链表时，读入数据的顺序与生成的链表中的元素的顺序是相反的。每个结点插入的时间为O(1),设单链表长n,时间复杂度O(n)。</li>
<li><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-9.png"  /></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span>&#123;<span class="comment">//逆向建立单链表</span></span><br><span class="line">    LNode *s; <span class="type">int</span> x;</span><br><span class="line">    L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建头结点；</span></span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;                    <span class="comment">//初始为空链表[*]</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);                   <span class="comment">//输入结点的值</span></span><br><span class="line">    <span class="keyword">while</span>(x! = <span class="number">9999</span>)&#123;                 <span class="comment">//输入9999表示结束</span></span><br><span class="line">        s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建新结点</span></span><br><span class="line">        s- &gt;data=x;</span><br><span class="line">        s- &gt;next=L- &gt;next;</span><br><span class="line">        L- &gt;next=s;                   <span class="comment">//将新结点插入表中，L为头指针</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://data.biancheng.net/view/93.html">头插法创建单链表（带源码+解析）</a></p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-8.png" style="zoom: 75%;" />

<blockquote>
<p>注意:在代码[*]处，初始化空链表的时候，必须将L的next置为NULL。否则插入若干数据结点后，表尾的next会是一个脏数据，而不是NULL。而尾插法为什么不用，是因为尾插法在最后执行了尾结点指针域置空的操作。但总之，你只要是初始化单链表，都先把头指针指向NULL，这是一个好习惯。</p>
</blockquote>
<blockquote>
<p><strong>重要应用：链表的逆置</strong>！！<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yU4y1U7L2?spm_id_from=333.337.search-card.all.click&vd_source=278af11bcc7fe34571197ce600d488f4">B站-链表逆置的两种方法</a></p>
<p>在使用头插法插入数据的时候，你依次插入a、b、c。那么在此单链表中，从头结点开始，依次为：c、b、a。于是这里引起了一个重要的应用，<strong>链表的逆置</strong>。</p>
<p>也就是再建立一个新的链表，之后将原来的链表从头到尾依次头插法插入新链表中，新链表就是原链表的逆置。</p>
<p>当然，你也可以不建立新链表，而是在原链表，直接依次对每个结点，向原链表的头结点后执行头插，最终得到的结果也是原链表的逆置。</p>
</blockquote>
<h4 id="采用尾插法建立单链表"><a href="#采用尾插法建立单链表" class="headerlink" title="采用尾插法建立单链表"></a>采用尾插法建立单链表</h4><ul>
<li><p>时间复杂度O(n)</p>
</li>
<li><p><strong>头插法</strong>建立单链表的算法虽然简单，但生成的链表中结点的次序和输入数据的顺序<strong>不一致</strong>。若希望两者次序一致，可采用尾插法。该方法是将新结点插入到当前链表的表尾上，为此必须增加一个尾指针r,使其始终指向当前链表的尾结点，如图所示。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-10.png"  /></li>
</ul>
<p><strong>初始化单链表后，向单链表末尾进行后插操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在第i个位置插入元素e（带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	LNode *p;	<span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">	<span class="type">int</span> j=<span class="number">0</span>;	<span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">	p = L;	<span class="comment">//L指向头结点</span></span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>) &#123;	<span class="comment">//循环找到第i-1个结点 </span></span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//i值不合法</span></span><br><span class="line">	LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	s-&gt;data = e;</span><br><span class="line">	s-&gt;next = p-&gt;next;</span><br><span class="line">	p-&gt;next = s;	<span class="comment">//将结点s连到p之后 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是此时有一个问题。即每次向表尾插入一个元素，都要从表头开始循环，找到表尾结点。那么若要插入n个元素进去，则时间复杂度为O(n²)。</p>
<p>但是实际上，我们每次向表尾插入新的元素，没有必要每次都从表头再全部遍历一次。我们可以设立一个表尾指针r，专门用于指向表尾。之后若要插入新元素，对表尾指针r做一个后插操作即可。</p>
<p>如何对表尾指针r做后插操作，见指定结点的后插操作。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">List_TailInsert</span><span class="params">(LinkList &amp;L)</span>&#123;<span class="comment">//正向建立单链表</span></span><br><span class="line">    <span class="type">int</span> x;                            <span class="comment">//设元素类型为整型</span></span><br><span class="line">    L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建头结点；</span></span><br><span class="line">    LNode *s,*r=L;                    <span class="comment">//r为表尾指针</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);                   <span class="comment">//输入结点的值</span></span><br><span class="line">    <span class="keyword">while</span>(x! =<span class="number">9999</span>)&#123;                   <span class="comment">//输入9999表示结束</span></span><br><span class="line">        s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s- &gt;data=x;</span><br><span class="line">        r- &gt;next=s;                  <span class="comment">//在r结点之后插入元素x</span></span><br><span class="line">        r=s;                         <span class="comment">//r指向新的表尾结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    r- &gt;next=<span class="literal">NULL</span>;                   <span class="comment">//尾结点指针置空</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="按序号查找结点值"><a href="#按序号查找结点值" class="headerlink" title="按序号查找结点值"></a>按序号查找结点值</h4><p>在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止，否则返回最后一个结点指针域NULL。</p>
<p>时间复杂度O(n)</p>
<p><code>GetElem(L,i)</code>：按位查找操作。获取表L中第i个位置的元素的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位查找,返回第i个元素(带头结点)</span></span><br><span class="line">LNode *<span class="title function_">GetElem</span><span class="params">(LinkList L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;	<span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;	<span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;		<span class="comment">//L指向头结点,头结点是第0个结点(不存数据)</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i)	<span class="comment">//循环找到第i个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;		<span class="comment">//让p指针依次向后移</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果i=0</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-44.png" style="zoom: 50%;" />

<p>如果i=8(i大于链表长度)</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-45.png" style="zoom: 50%;" />

<p><strong>王道书版本</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LLNode <span class="title function_">GetElem</span><span class="params">(LinkList L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="comment">//本算法取出单链表L（带头结点）中第i个位置的结点指针</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;  <span class="comment">//计数，初始为1</span></span><br><span class="line">    LNode *p = L-&gt;next;  <span class="comment">//头结点指针赋给p</span></span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> L;  <span class="comment">//若i等于0，则返回头结点</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">//若 i 无效，则返回 NULL</span></span><br><span class="line">    <span class="keyword">while</span>( p &amp;&amp; j&lt;i ) &#123;  <span class="comment">//从第1个结点开始找，查找第i个结点</span></span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">//返回第i个结点的指针，如果i大于表长，p=NULL，直接返回p即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，封装之后。我们下面会提到的<strong>按位插入</strong>、<strong>按位删除</strong>中相应的代码段就都可以直接调用这个封装好的函数来实现。</p>
<p>如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在第i个位置插入元素e（带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	LNode *p = GetElem(L, i<span class="number">-1</span>);	<span class="comment">//找到第i-1个结点</span></span><br><span class="line">	<span class="keyword">return</span> InsertNextNode(p, e);	<span class="comment">//p后插入新元素e</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="按值查找表结点"><a href="#按值查找表结点" class="headerlink" title="按值查找表结点"></a>按值查找表结点</h4><p>从单链表第一个结点开始，由前往后依次比较表中各结点数据域的值，若某结点数据域的值等于给定值e，则返回该结点的指针。若整个单链表中没有这样的结点，则返回NULL。按值查找结点的算法如下：</p>
<p>时间复杂度O(n)</p>
<p><code>LocateElem(L,e)</code>：按值查找操作。在表L中查找具有给定关键字值的元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LNode *<span class="title function_">LocateElem</span> <span class="params">(LinkList L, ElemType e)</span> &#123;</span><br><span class="line">    <span class="comment">//本算法查找单链表 L （带头结点）中数据域值等于e的结点指针，否则返回NULL</span></span><br><span class="line">    LNode *p=L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;data!=e)  <span class="comment">//从第1个结点开始查找data域为e的结点</span></span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;  <span class="comment">//找到后返回该结点指针，否则返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此处同样需要注意一点：由于e的类型是ElemType，其有可能是基本类型，也有可能是结构类型。当其为结构类型时，就不能直接通过”! =”来判断了。原理同前文一致，不再赘述。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/pikaqiu_JBR99/article/details/107616129">单链表的两种查找方式</a></p>
<h4 id="插入结点操作-单链表的插入和删除"><a href="#插入结点操作-单链表的插入和删除" class="headerlink" title="插入结点操作 单链表的插入和删除"></a>插入结点操作 <a target="_blank" rel="noopener" href="https://itcn.blog/p/1649535832.html">单链表的插入和删除</a></h4><h5 id="按位序插入"><a href="#按位序插入" class="headerlink" title="按位序插入"></a>按位序插入</h5><h6 id="带头结点"><a href="#带头结点" class="headerlink" title="带头结点"></a>带头结点</h6><p><code>ListInsert(&amp;L,i,e)</code>：插入操作。<strong>在表L中的第i个位置上插入指定元素e</strong></p>
<p>(找到第i-1个结点，将新结点插入其后)</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-36.png" style="zoom:67%;" />

<p><strong>此时，带头结点的好处就体现出来了。当我插入的位置为1时，可以把头结点看作第0个结点，向头结点后进行插入。由此，我不论在何处插入一个结点，我的处理逻辑都是统一的</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;		<span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;		<span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;			<span class="comment">//L指向头结点,头结点是第0个结点(不存是数据)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(P! =<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;	<span class="comment">//循环找到第 i-1 个结点</span></span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)		<span class="comment">//i值不合法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data=e;</span><br><span class="line">    <span class="comment">//将s指向结点的next指针指向p指向结点的next指针</span></span><br><span class="line">    s-&gt;next = p-&gt;next;	 </span><br><span class="line">    p-&gt;next = s;	<span class="comment">//将p指向结点的next指针指向s</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">//插入成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color='red'>分析</font>:</p>
<p>如果 i=1(也就是在表头插入元素)：时间复杂度O(1)</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-37.png" style="zoom: 50%;" />

<p>如果 i = 3(也就是在表中插入元素)</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-38.png" style="zoom: 50%;" />

<p>如果 i = 5(也就是在表尾插入元素)：时间复杂度O(n)</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-39.png" style="zoom: 50%;" />

<h6 id="不带头结点"><a href="#不带头结点" class="headerlink" title="不带头结点"></a>不带头结点</h6><p><code>ListInsert(&amp;L,i,e)</code>：插入操作。<strong>在表L中的第i个位置上插入指定元素e</strong></p>
<p>(找到第i-1个结点，将新结点插入其后)</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-40.png" style="zoom: 50%;" />



<p><strong>此时，由于不带头结点，也就是不存在“第0个”结点。因此i=1时需要特殊处理。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)		<span class="comment">//插入第1个结点的操作与其他结点操作不同</span></span><br><span class="line">    &#123;</span><br><span class="line">        LNode *s =(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = e;</span><br><span class="line">        s-&gt;next = L;</span><br><span class="line">        L = s;		<span class="comment">//头指针指向新结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;		<span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;		<span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;			<span class="comment">//p指向第1个结点(注意:不是头结点)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(P!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;	<span class="comment">//循环找到第 i-1 个结点</span></span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)		<span class="comment">//i值不合法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data=e;</span><br><span class="line">    <span class="comment">//将s指向结点的next指针指向p指向结点的next指针</span></span><br><span class="line">    s-&gt;next = p-&gt;next;	</span><br><span class="line">    p-&gt;next = s;	<span class="comment">//将p指向结点的next指针指向s</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">//插入成功</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果不带头结点，则插入、删除第1个元素时，需要更改头指针L。</p>
<p>如果带头结点的话，头指针肯定永远都是指向头结点的。</p>
<p>但是除了第1个元素外，后续的元素操作，其逻辑和带头结点的一样。</p>
</blockquote>
<p><strong>结论</strong>：不带头结点写代码不方便，推荐用带头结点</p>
<h5 id="指定结点的后插操作"><a href="#指定结点的后插操作" class="headerlink" title="指定结点的后插操作"></a>指定结点的后插操作</h5><p>后插操作：在结点之后插入元素</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-41.png" style="zoom:67%;" />

<blockquote>
<p>给定一个结点，在这个结点之后插入一个数据元素e。</p>
<p>由于单链表的链接指针只能往后寻找，所以如果给定一个结点p的话，那么p之后的那些结点我们都是可知的，我们都可以用循环的方式把它们都找出来。</p>
<p>但是p结点之前的，我们就没办法知道了。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后插操作:在p结点之后插入元素e</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextNode</span><span class="params">(LNode *p,ElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s =(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)		<span class="comment">//某些情况下有可能分配失败,比如内存不足</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;	</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这个函数只是在已经找到p结点后执行的操作。其时间复杂度为O(1)。</p>
<p>但是真正进行插入的时候，首先肯定是要先通过循环，找到结点p的。即如下代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在第i个位置插入元素e（带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	LNode *p;	<span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;	<span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">	p = L;	<span class="comment">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>) &#123;	<span class="comment">//循环找到第i-1个结点 </span></span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> InsertNextNode(p, e);	<span class="comment">//封装（当然，上面那几行也可以封装）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="指定结点的前插操作"><a href="#指定结点的前插操作" class="headerlink" title="指定结点的前插操作"></a>指定结点的前插操作</h5><p>前插操作是指在某结点的前面插入一个新结点，后插操作的定义刚好与之相反，在单链表插入算法中，通常都是釆用后插操作的。</p>
<h6 id="单链表的基本插入算法"><a href="#单链表的基本插入算法" class="headerlink" title="单链表的基本插入算法"></a>单链表的基本插入算法</h6><p>插入操作是将值为x的新结点插入到单链表的第i个位置上。先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第i-1个结点，再在其后插入新结点。</p>
<p>算法首先调用上面的按序号查找算法GetElem(L, i-1)，查找第i-1个结点。假设返回的第i-1个结点为 *p，然后令新结点 *s的指针域指向 *p的后继结点，再令结点 *p的指针域指向新插入的结点 *s。其操作过程如图所示。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-11.png" style="zoom:80%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p=GetElem(L, i<span class="number">-1</span>) ;  <span class="comment">// 语句①，查找插入位置的前驱结点</span></span><br><span class="line">s-&gt;next=p-&gt;next;  <span class="comment">// 语句②，图 2-6 中辑作步骤 1</span></span><br><span class="line">p-&gt;next=s;  <span class="comment">// 语句③，图2-6中操作步骤2</span></span><br></pre></td></tr></table></figure>

<p>算法中，语句②③的顺序不能颠倒，否则，当先执行p-&gt;next=s后，指向其原后继的指针就不存在了，再执行s-&gt;next = p-&gt;next时，相当于执行了 s-&gt;next=s,显然是错误的。本算法主要的时间开销在于查找第i-1个元素，时间复杂度为O(n)。若是在给定的结点后面插入新结点，则时间复杂度仅为O(1)。</p>
<p>以上面的算法为例，首先调用函数GetElem()找到第i-1个结点，即待插入结点的前驱结点后，再对其执行后插操作。由此可知，对结点的前插操作均可以转化为后插操作，前提是从单链表的头结点开始顺序查找到其前驱结点，时间复杂度为O(n)。</p>
<h6 id="拓展-对某一结点的前插操作"><a href="#拓展-对某一结点的前插操作" class="headerlink" title="拓展:对某一结点的前插操作"></a>拓展:对某一结点的前插操作</h6><p>此外，可以釆用另一种方式将其转化为后插操作来实现，设待插入结点为s，将插入到p的前面。我们仍然将s插入到p的后面，然后将p-&gt;data与s-&gt;data交换即可，这样既满足了逻辑关系，又能使得时间复杂度为O(1)。算法的代码片段如下：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-42.png" style="zoom:67%;" />

<blockquote>
<p>在p结点之前插入元素e。</p>
<p>此时就会出现一个问题：如何找到p结点的前驱？</p>
<p>思路一：</p>
<p>我们可以传入一个头指针。当给出头指针之后，那么我们链表的所有信息就都能够知道了。</p>
<p>我们可以从头指针开始，依次遍历各个结点，从而找到p结点的前驱结点，再对p的前驱进行后插操作。</p>
<p>那么用这种方法进行前插，时间复杂度是O(n)。</p>
<p>思路二：</p>
<p>我依然是对p进行后插。但是后插过后，我将p结点和新结点，之中的数据域进行互换。最终也能实现前插的效果。</p>
<p>这种的本质是后插，时间复杂度O(1)。</p>
</blockquote>
<p><strong>思路二代码实现</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前插操作:在p结点之前插入元素e</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertPriorNode</span><span class="params">(LNode *p,ElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s =(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)			<span class="comment">//内存分配失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = p-&gt;next;	</span><br><span class="line">    p-&gt;next = s;		<span class="comment">//新结点 s 连接到 p 之后</span></span><br><span class="line">    s-&gt;data = p-&gt;data;	<span class="comment">//将p中元素复制到s中</span></span><br><span class="line">    p-&gt;data = e;		<span class="comment">//p中元素覆盖为e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>王道书中的版本</strong>:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-43.png" style="zoom:67%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前插操作:在p结点之前插入结点s</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertPriorNode</span><span class="params">(LNode *p,LNode *s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span> || s==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;				<span class="comment">//s连到p之后</span></span><br><span class="line">    ElemType temp = p-&gt;data;	<span class="comment">//交换数据域部分</span></span><br><span class="line">    p-&gt;data = s-&gt;data;</span><br><span class="line">    s-&gt;data = temp;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除结点操作-单链表的插入和删除"><a href="#删除结点操作-单链表的插入和删除" class="headerlink" title="删除结点操作 单链表的插入和删除"></a>删除结点操作 <a target="_blank" rel="noopener" href="https://itcn.blog/p/1649535832.html">单链表的插入和删除</a></h4><p>删除操作是将单链表的第i个结点删除。先检查删除位置的合法性，然后查找表中第i-1个结点，即被删结点的前驱结点，再将其删除。其操作过程如图所示。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-12.png"  />

<p>假设结点p为找到的被删结点的前驱结点，为了实现这一操作后的逻辑关系的变化，仅需修改p的指针域，即将p的指针域next指向q的下一结点。</p>
<p>时间复杂度O(n)</p>
<h5 id="带头结点按位序删除"><a href="#带头结点按位序删除" class="headerlink" title="带头结点按位序删除"></a>带头结点按位序删除</h5><p><code>ListDelete(&amp;L,i,&amp;e)</code>：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值(找到第i-1个结点，将其指针指向第i+1个结点，并释放第i个结点)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;	<span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;	<span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;		<span class="comment">//L指向头结点,头结点是第0个结点(不存数据)</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)	<span class="comment">//循环找到第 i-1 个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)  			<span class="comment">// i值不合法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == <span class="literal">NULL</span>)		<span class="comment">//第 i-1 个结点之后已无其他结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *q = p-&gt;next;		<span class="comment">//令q指向被删除结点</span></span><br><span class="line">    e = q-&gt;data;			<span class="comment">//用e返回元素的值</span></span><br><span class="line">    p-&gt;next = q-&gt;next;		<span class="comment">//将*q结点从链中断开</span></span><br><span class="line">    <span class="built_in">free</span>(q);				<span class="comment">//释放结点的存储空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;			<span class="comment">//删除成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="扩展：删除指定结点p"><a href="#扩展：删除指定结点p" class="headerlink" title="扩展：删除指定结点p"></a>扩展：删除指定结点p</h5><p>要实现删除某一个给定结点p，通常的做法是先从链表的头结点开始顺序找到其前驱结点，然后再执行删除操作即可，算法的时间复杂度为O(n)。</p>
<p>其实，删除结点p的操作可以用删除p的后继结点操作来实现，实质就是将其后继结点的值赋予其自身，然后删除后继结点，也能使得时间复杂度为O(1)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除指定结点p</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeleteNode</span><span class="params">(LNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *q = p-&gt;next;		<span class="comment">//令q指向*p的后继结点</span></span><br><span class="line">    p-&gt;data = p-&gt;next-&gt;data;<span class="comment">//和后继结点交换数据域</span></span><br><span class="line">    p-&gt;next = q-&gt;next;		<span class="comment">//将*q结点从链中&quot;断开&quot;</span></span><br><span class="line">    <span class="built_in">free</span>(q);				<span class="comment">//释放后继结点的存储空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是有个问题:如果要删除的这个结点，刚好是单链表的最后一个结点。那么在进行p结点与其后继结点数据域的互换的时候，就会出现问题。即<code>p-&gt;data = p-&gt;next-&gt;data</code>;的时候，就会出现空指针的错误。</p>
<p>那么如果是最后一个结点，该怎么办呢。那就只能从头结点开始，循环找到p的前驱，进行删除。时间复杂度O(n)。</p>
</blockquote>
<h4 id="求表长操作"><a href="#求表长操作" class="headerlink" title="求表长操作"></a>求表长操作</h4><p>求表长操作就是计算单链表中数据结点（不含头结点）的个数，需要从第一个结点开始顺序依次访问表中的每一个结点，为此需要设置一个计数器变量，每访问一个结点，计数器加1，直到访问到空结点为止。算法的时间复杂度为O(n)。</p>
<p>需要注意的是，因为单链表的长度是不包括头结点的，因此，不带头结点和带头结点的单链表在求表长操作上会略有不同。对不带头结点的单链表，当表为空时，要单独处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求表的长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Length</span><span class="params">(LinkList L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;			<span class="comment">//统计表长</span></span><br><span class="line">    LNode *p = L;		</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next !=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双链表-双链表的基本操作"><a href="#双链表-双链表的基本操作" class="headerlink" title="双链表 双链表的基本操作"></a>双链表 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_16933601/article/details/105351119">双链表的基本操作</a></h3><p>单链表结点中只有一个指向其后继的指针，这使得单链表只能从头结点依次顺序地向后遍历。若要访问某个结点的前驱结点（插入、删除操作时），只能从头开始遍历，访问后继结点的时间复杂度为O(1)，访问前驱结点的时间复杂度为O(n)。</p>
<p>为了克服单链表的上述缺点，引入了双链表，双链表结点中有两个指针prior和next，分别指向其前驱结点和后继结点，如图所示。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-13.png" style="zoom: 75%;" />

<p>结点类型定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> &#123;</span>  <span class="comment">//定义双链表结点类型</span></span><br><span class="line">    ElemType data;  <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span>  <span class="comment">//前驱和后继指针</span></span><br><span class="line">&#125;DNode, *DLinklist;</span><br></pre></td></tr></table></figure>

<h4 id="双链表的初始化"><a href="#双链表的初始化" class="headerlink" title="双链表的初始化"></a>双链表的初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化双链表(带头结点)</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitDLinkList</span><span class="params">(DLinklist &amp;L)</span>&#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));			<span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)									<span class="comment">//内存不足,分配失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;prior = <span class="literal">NULL</span>;							<span class="comment">//头结点的prior永远指向NULL</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;								<span class="comment">//头结点之后暂时还没有结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">testDLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//初始化双链表</span></span><br><span class="line">    DLinklist L;</span><br><span class="line">    InitDLinkList(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>DLinklist</code> 等价于<code>DNode *</code></li>
<li><code>DLinklist</code> 强调这是一个链表</li>
<li><code>DNode *</code> 强调这是一个结点</li>
</ul>
<h4 id="判断双链表是否为空"><a href="#判断双链表是否为空" class="headerlink" title="判断双链表是否为空"></a>判断双链表是否为空</h4><p>判断双链表是否为空:判断头结点的下一个是否为空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断双链表是否为空(带头结点)</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(DLinklist L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双链表的插入操作"><a href="#双链表的插入操作" class="headerlink" title="双链表的插入操作"></a>双链表的插入操作</h4><p>在双链表中p所指的结点之后插入结点s，其指针的变化过程如图所示</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-14.png"  />

<p>时间复杂度O(n)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;next=p-&gt;next;  <span class="comment">// 语句①，将结点*s插入到结点*p之后</span></span><br><span class="line">p-&gt;next-&gt;prior=s;  <span class="comment">// 语句②</span></span><br><span class="line">s-&gt;prior=p;  <span class="comment">// 语句③</span></span><br><span class="line">p-&gt;next=s;  <span class="comment">// 语句④</span></span><br></pre></td></tr></table></figure>

<p>上述代码的语句顺序不是唯一的，但也不是任意的，①②两步必须在④步之前，否则p的后继结点的指针就丢掉了，导致插入失败。</p>
<blockquote>
<p>但是，<strong>会有一个问题</strong>。</p>
<p>当p结点为双链表最后一个结点时，在执行该操作时。其中<code>p-&gt;next-&gt;prior = s;</code>会出现空指针错误。</p>
<p>因此我们要优化一下这段代码，如下所示。</p>
</blockquote>
<h5 id="后插操作"><a href="#后插操作" class="headerlink" title="后插操作"></a>后插操作</h5><p>如果p结点是最后一个结点(特殊情况)：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-46.png" style="zoom: 50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在p结点之后插入s结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextDNode</span><span class="params">(DNode *p,DNode *s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p=<span class="literal">NULL</span> || s=<span class="literal">NULL</span>)							<span class="comment">//非法参数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;												<span class="comment">//如果p结点有后继结点</span></span><br><span class="line">        p-&gt;next-&gt;prior = s;</span><br><span class="line">    &#125;<span class="comment">//如果p没有后继节点，则当然不需要修改p的后继节点的前驱指针</span></span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;	</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果p是中间一个结点:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-47.png" style="zoom:67%;" />

<blockquote>
<p>同样要注意赋值时的顺序。有些能调换，有些调换了就是错误的逻辑。</p>
<p>实现了双链表后，在对p结点执行前插操作时。就可以立即找到p结点的前驱结点q，再对q进行后插操作即可。实际上都是可以转化为，利用后插来实现。</p>
</blockquote>
<h5 id="按位序插入-1"><a href="#按位序插入-1" class="headerlink" title="按位序插入"></a>按位序插入</h5><p>按位序插入：只需从头结点开始，找到某一个位序的前驱结点，然后对这个前驱结点执行后插操作</p>
<h5 id="前插操作"><a href="#前插操作" class="headerlink" title="前插操作"></a>前插操作</h5><p>前插操作：只需找到此结点的前驱结点，然后对其前驱结点进行后插操作，即为前插操作</p>
<h4 id="双链表的删除操作"><a href="#双链表的删除操作" class="headerlink" title="双链表的删除操作"></a>双链表的删除操作</h4><p>删除双链表中结点p的后继结点q，其指针的变化过程如图所示。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-15.png"  />

<p>时间复杂度O(n)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next=q-&gt;next;  <span class="comment">// 图2-10中步骤①</span></span><br><span class="line">q-&gt;next-&gt;prior=p;  <span class="comment">//图 2-10 中步骤②</span></span><br><span class="line"><span class="built_in">free</span> (q) ; <span class="comment">//释放结点空间</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>但这样写，同样会有一个问题。就是q为最后一个结点的时候。q的后继节点为NULL，没有前驱结点prior。也就是[*]会引起空指针错误。</p>
</blockquote>
<p>当q结点不是最后一个结点时：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-48.png" style="zoom:67%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除p结点的后继结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeleteNextDNode</span><span class="params">(DNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DNode *q = p-&gt;next;				<span class="comment">//找到p的后继结点q</span></span><br><span class="line">    <span class="keyword">if</span>(q = <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;				<span class="comment">//p没有后继结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;next != <span class="literal">NULL</span>)				<span class="comment">//q结点不是最后一个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        q-&gt;next-&gt;prior = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(q);						<span class="comment">//释放结点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当q结点是最后一个结点时:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-49.png" style="zoom: 50%;" />

<h4 id="双链表的销毁"><a href="#双链表的销毁" class="headerlink" title="双链表的销毁"></a>双链表的销毁</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DestoryList</span><span class="params">(DLinklist &amp;L)</span>&#123;</span><br><span class="line">    <span class="comment">//循环释放各个数据结点</span></span><br><span class="line">    <span class="keyword">while</span>(L-&gt;next !=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DeleteNextDNode(L);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(L);		<span class="comment">//释放头结点</span></span><br><span class="line">    L=<span class="literal">NULL</span>;			<span class="comment">//头指针指向NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双链表的遍历"><a href="#双链表的遍历" class="headerlink" title="双链表的遍历"></a>双链表的遍历</h4><h5 id="后向遍历"><a href="#后向遍历" class="headerlink" title="后向遍历"></a>后向遍历</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理</span></span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="前向遍历"><a href="#前向遍历" class="headerlink" title="前向遍历"></a>前向遍历</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理</span></span><br><span class="line">    p = p-&gt;prior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="前向遍历-跳过头结点"><a href="#前向遍历-跳过头结点" class="headerlink" title="前向遍历(跳过头结点)"></a>前向遍历(跳过头结点)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(p-&gt;prior!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理</span></span><br><span class="line">    p = p-&gt;prior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>知道怎么前向、后向遍历，那么按位查找、按值查找也就没什么问题。</p>
<ul>
<li>按位查找：在知道如何前后向遍历的基础上，设置一个遍历次数i，每遍历一次，执行i++，即可实现按位查找。</li>
<li>按值查找：在知道如何前后向遍历的基础上，每遍历到一个结点，判断该结点的数据域是否等于e，即可实现按值查找。</li>
</ul>
<p>时间复杂度O(n)。</p>
</blockquote>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><h4 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h4><p>循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-16.png" style="zoom:67%;" />

<p>在循环单链表中，表尾结点的next域指向L，故表中没有指针域为NULL的结点，因此，<font color='orange'>循环单链表的判空条件不是头结点的指针是否为空，而是它是否等于头指针</font>。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-21.png" style="zoom: 75%;" />

<p>循环单链表的插入、删除算法与单链表的几乎一样，所不同的是如果操作是在表尾进行，则执行的操作不相同，以让单链表继续保持循环的性质。当然，正是因为循环单链表是一个 “环”，因此，在任何一个位置上的插入和删除操作都是等价的，无须判断是否是表尾。</p>
<p>在单链表中只能从表头结点开始往后顺序遍历整个链表，而循环单链表可以从表中的任一结点开始遍历整个链表。有时对单链表常做的操作是在表头和表尾进行的，此时可对循环单链表不设头指针而仅设尾指针，从而使得操作效率更高。</p>
<h5 id="初始化循环单链表"><a href="#初始化循环单链表" class="headerlink" title="初始化循环单链表"></a>初始化循环单链表</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>		<span class="comment">//定义单链表结点类型</span></span><br><span class="line">    ElemType data;			<span class="comment">//每个结点存放一个数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>		<span class="comment">//指针指向下一个结点</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个循环单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));		<span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = L;							<span class="comment">//头结点next指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="判断循环单链表是否为空"><a href="#判断循环单链表是否为空" class="headerlink" title="判断循环单链表是否为空"></a>判断循环单链表是否为空</h5><p>判断循环单链表是否为空:判断头结点的next指针是否指向它自己</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == L)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="判断循环单链表表尾结点"><a href="#判断循环单链表表尾结点" class="headerlink" title="判断循环单链表表尾结点"></a>判断循环单链表表尾结点</h5><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-50.png" style="zoom: 33%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断结点p是否是循环单链表的表尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isTail</span><span class="params">(LinkList L,LNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == L)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="循环单链表的好处"><a href="#循环单链表的好处" class="headerlink" title="循环单链表的好处"></a>循环单链表的好处</h5><p><strong>单链表</strong></p>
<ul>
<li>从一个结点出发，只能找到后续的各个结点，而前驱的各个结点，除非获得单链表的表头指针，否则无法得知。</li>
<li>从头结点找到尾部，依次循环遍历，时间复杂度为O(n)。</li>
</ul>
<p><strong>循环单链表</strong></p>
<ul>
<li>从一个结点出发可以找到其他任意一个结点。</li>
<li><strong>我们让L不再指向头结点，而是指向尾结点</strong>。那么从尾部找到头部，时间复杂度为O(1)。那么此时，我既有尾结点，又有头结点了（往后找一个即可）。而很多时候，链表的操作都是在头部或尾部。那么这样一来，就大大方便了操作，时间复杂度为O(1)。</li>
</ul>
<h4 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h4><p>由循环单链表的定义不难推出循环双链表，不同的是在循环双链表中，头结点的prior 指针还要指向表尾结点</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-17.png" style="zoom: 80%;" />

<p>在循环双链表L中，某结点*p为尾结点时，p-&gt;next=L;当循环双链表为空表时，其头结点的prior域和next域都等于L</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-18.png" style="zoom: 75%;" />

<p>循环双链表的<strong>优势</strong>:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-19.png" style="zoom: 75%;" />

<p>我们知道，在p为表尾结点的时候，<font color='orange'>箭头</font>处的语句会出现空指针错误。但如果我们是<strong>循环双链表</strong>的话，那么上述代码的逻辑就是<strong>完全正确</strong>的。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-20.png" style="zoom: 75%;" />

<p>我们知道，在q为表尾结点的时候，<font color='orange'>箭头</font>处的语句会出现空指针错误。但如果我们是<strong>循环双链表</strong>的话，那么上述代码的逻辑就是<strong>完全正确</strong>的。</p>
<h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>静态链表是<font color='cornflowerblue'>借助数组来描述线性表的链式存储结构</font>，结点也有数据域data和指针域next，与前面所讲的链表中的指针不同的是，这里的指针是<strong>结点的相对地址</strong>(数组下标)，又称为<strong>游标</strong>。和顺序表一样，静态链表也要预先分配一块连续的内存空间。</p>
<p><strong>静态链表和单链表的对应关系如图</strong></p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-22.png" style="zoom: 75%;" />

<blockquote>
<p>单链表中的结点是离散的，分布在内存中的各个角落。每个节点包括一个数据域（数据元素），还有一个指针域（指向下一个结点的指针（地址））。</p>
</blockquote>
<blockquote>
<p>静态链表分配一整片的内存空间，其中的数据元素存放在这片内存空间的某些位置。静态链表中的每个结点包含了数据元素，还有下一个结点的数组下标（游标）。</p>
<p>静态链表中，0号结点充当“头结点”，它是不存放数据元素的。</p>
<p>静态链表中每个结点的游标相当于单链表中的指针域。只不过指针域是指明了下一个结点的具体地址，而游标只是指明了在此数组中的下标。</p>
<p>静态链表如果要表示该结点为最后一个结点的话，可以将它的游标的值设为-1。</p>
</blockquote>
<blockquote>
<p>这样一来，若0号结点的游标为2，那么就可以直接寻找到下标为2的结点的地址。（即静态链表的起始地址<code>addr + sizeof(Node) * 2</code>，实际上就是数组）</p>
</blockquote>
<h4 id="结点类型定义"><a href="#结点类型定义" class="headerlink" title="结点类型定义"></a>结点类型定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50  <span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>  <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ElemType data;  <span class="comment">//存储数据元素</span></span><br><span class="line">    <span class="type">int</span> next;  <span class="comment">//下一个元素的数组下标</span></span><br><span class="line">&#125;SLinkList[MaxSize];</span><br></pre></td></tr></table></figure>

<p>上下的代码定义等价</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50  <span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>  <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ElemType data;  <span class="comment">//存储数据元素</span></span><br><span class="line">    <span class="type">int</span> next;  <span class="comment">//下一个元素的数组下标</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">SLinkList</span>[<span class="title">MaxSize</span>];</span><span class="comment">//可用SLinkList定义&quot;一个长度为MaxSize的Node型数组&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>问题</strong>：</p>
<p>用typedef给一个结构类型起别名我理解，但是这个别名怎么是一个“数组”呢？</p>
<p>实际上这样写以后。你就可以直接通过<strong>SLinkList</strong>定义“<strong>一个长度为MaxSize的Node型数组</strong>”了。</p>
<p>即如下所示，这两个写法是等价的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">testSLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">	SLinkList a;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testSLinkList2</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">a</span>[<span class="title">MaxSize</span>];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>追问：</strong></p>
<p>我理解了这种定义方式的作用了。但是为什么要这样写呢？这样写不别扭吗？为什么不用我们传统的<code>struct Node a[MaxSize];</code>呢？</p>
<p>其实这个地方，和我们之前提到过的<code>LinkLise</code>和<code>LNode *</code>其想要<strong>强调含义</strong>是一个道理。</p>
<p>我使用<code>SLinkList a;</code>来定义，是想<strong>强调</strong>我这里正在定义一个<strong>静态链表</strong>。你一看就明白了，a是一个静态链表。</p>
<p>但是使用<code>struct Node a[MaxSize];</code>，它仅仅是定义一个Node型的数组a。</p>
</blockquote>
<h4 id="基本操作的实现"><a href="#基本操作的实现" class="headerlink" title="基本操作的实现"></a>基本操作的实现</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-24.png" style="zoom: 75%;" />

<h3 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h3><p><strong>逻辑结构</strong>:都属于线性表，都是线性结构</p>
<p><strong>物理结构</strong>:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-25.png" style="zoom: 75%;" />

<p><strong>基本操作</strong>:</p>
<ul>
<li><p><strong>创建</strong>:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-52.png" style="zoom:55%;" /></li>
<li><p><strong>销毁</strong>:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-53.png" style="zoom:55%;" /></li>
<li><p><strong>增、删</strong>:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-54.png" style="zoom:55%;" /></li>
<li><p><strong>查</strong>:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-55.png" style="zoom:55%;" /></li>
</ul>
<p><strong>在实际应用中应该怎样选取存储结构呢</strong>？</p>
<ul>
<li><p><strong>基于存储的考虑</strong></p>
<p>难以估计线性表的长度或存储规模时，不宜采用顺序表；链表不用事先估计存储规模，但链表的存储密度较低，显然链式存储结构的存储密度是小于1的。</p>
</li>
<li><p><strong>基于运算的考虑</strong></p>
<p>在顺序表中按序号访问ai的时间复杂度为O(1)，而链表中按序号访问的时间复杂度为O(n)，因此若经常做的运算是按序号访问数据元素，则显然顺序表优于链表。</p>
<p>在顺序表中进行插入、删除操作时，平均移动表中一半的元素，当数据元素的信息量较大且表较长时，这一点是不应忽视的；在链表中进行插入、删除操作时，虽然也要找插入位置，但操作主要是比较操作，从这个角度考虑显然后者优于前者。</p>
</li>
<li><p><strong>基于环境的考虑</strong></p>
<p>顺序表容易实现，任何高级语言中都有数组类型；链表的操作是基于指针的，相对来说前者实现较为简单，这也是用户考虑的一个因素。</p>
</li>
</ul>
<p><strong>开放式问题的回答思路</strong></p>
<p><strong>注意</strong>：对于一些开放式问题的答题思路，例如</p>
<ul>
<li>请描述顺序表和链表的…（区别、联系…）</li>
<li>实现线性表时，用顺序表还是链表好？</li>
</ul>
<p>你都可以用这样的思路（框架），来让自己的答题逻辑更加的清晰。</p>
<p><strong>这样的思路（框架）</strong>：指的是本节中，对顺序表和链表分别从<strong>逻辑结构</strong>、<strong>存储结构</strong>、<strong>基本操作</strong>三个角度进行了对比，并指出<strong>优缺点</strong>、<strong>效率</strong>上的差异等。</p>
<blockquote>
<p>具体的回答思路，例如：</p>
<p>顺序表和链表的逻辑结构都是线性结构，都属于线性表。</p>
<p>但是二者的存储结构不同，顺序表采用顺序存储…，具有…的特点，从而导致其优点…，缺点…；而链表采用链式存储，具有…的特点，从而导致其优点…，缺点…。</p>
<p>由于采用不同的存储方式实现，因此基本操作的实现效率也不同。当初始化时…；当插入一个数据元素时…；当删除一个数据元素时…；当查找一个数据元素时…。</p>
</blockquote>
<p>当然，也并不是说这其中的每一个点都必须写出来，意思就是，你可以根据实际情况，按照这个大致思路进行回答，并且选择把哪些点答上去，哪些可以不答上去。总之，思路是清晰的。</p>
<p>此外，这样的框架性的思路除了便于答题外，也有助于自己的复习、回顾。</p>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><ul>
<li><p>【2016】已知一个带有表头结点的双向循环链表L，结点结构为<code>prev|data|next</code>,其中，prev 和 next 分别是指向其直接前驱和直接后继结点的指针。现要删除指针 p 所指的结点，正确的语句序列是</p>
<blockquote>
<p> p-&gt;next-&gt;prev=p-&gt;prev; p-&gt;prev-&gt;next=p-&gt;next; free(p);</p>
</blockquote>
</li>
<li><p>【2016】已知表头元素为 c 的单链表在内存中的存储状态如下表所示。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-30.png"  />

<p>现将 f 存放于 1014H 处并插入到单链表中，若 f 在逻辑上位于 a 和 e 之间，则 a, e, d 的“链接地址”依次是–&gt;1014H 1004H NULL</p>
<blockquote>
<p>链表的遍历顺序c（1008H）-&gt;a（1000H）-&gt;e（1010H）-&gt;b（1004H）-&gt;d（100CH）-&gt;null，然后你插入f到a,e 之间，则a要链接的地址就变成了f的地址，则a的链接地址为1014H ，而f的链接地址则是为e的地址1010H，最后的e后面的链接是没有变的依然是到b。总结：插入后链表的遍历顺序c（1008H）-&gt;a（1000H）-&gt;f(1014H)-&gt;e（1010H）-&gt;b（1004H）-&gt;d（100CH）-&gt;null</p>
</blockquote>
</li>
<li><p>【2021】已知头指针h指向一个带头结点的非空单循环链表，结点结构为<code>data|next</code>,其中next是指向直接后继结点的指针，p是尾指针，q是临时指针。现要删除该链表的第一个元素，正确的语句序列是–&gt; </p>
<p>q= h-&gt;next; h-&gt;next=q-&gt;next; if(p==q) p=h; free(q);</p>
<blockquote>
<p>删除该链表的第一个元素就是让你删除头结点后面的第一个结点。</p>
<p>普通情况:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-31.png" style="zoom:67%;" />

<p>特殊情况:要注意当我们删除head后面的节点以后，整个链表就只剩下head节点一个了。 那尾指针只能指向head，所以D选项里的if(p==q)  p=h; free(q);就非常正确。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-32.png" style="zoom:67%;" /></blockquote>
</li>
<li><p>综合【2009】已知一个带有表头结点的单链表，结点结构为<code>data|link</code> 假设该链表只给出了头指针list。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第k个位置上的结点（k为正整数）。若查找成功，算法输出该结点的data域的值，并返回1；否则，只返回0。要求： </p>
<p>① 描述算法的基本设计思想 </p>
<p>② 描述算法的详细实现步骤 </p>
<p>③ 根据设计思想和实现步骤，采用程序设计语言描述算法，关键之处请给出简要注释</p>
<blockquote>
<p>1)关键是设计尽可能高效的算法，通过链表的一次遍历，找到倒数第k个结点的位置。算法的基本设计思想是:定义两个指针变量p和q，初始时均指向头结点的下一个结点(链表的第一个结点)，p指针沿链表移动；当p指针移动到第k个结点时，q指针开始与p指针同步移动；当p指针移动到最后一个结点时，q指针所指示结点为倒数第k个结点。</p>
<p>2)算法详细实现步骤:</p>
<p>1.count=0,p和q指向链表表头结点的下一个结点。</p>
<p>2.若p为空，转5</p>
<p>3.若count等于k，则q指向下一个结点；否则，count=count+1。</p>
<p>4.p指向下一个结点，转2</p>
<p>5.若count等于k，则查找成功，输出该结点的data域的值，返回1；否则，说明k值超过了线性表的长度，查找失败，返回0.</p>
<p>6.算法结束。</p>
<p>3)算法实现如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">link</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Search_k</span><span class="params">(LinkList <span class="built_in">list</span>,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">	<span class="comment">//查找链表list倒数第k个结点，并输出该结点data域的值</span></span><br><span class="line">	LNode *p=<span class="built_in">list</span>-&gt;link;<span class="comment">//指针p,q指向链表的第一个结点 </span></span><br><span class="line">	LNode *q=<span class="built_in">list</span>-&gt;link;</span><br><span class="line">	<span class="type">int</span> count=<span class="number">0</span>;<span class="comment">//计数器初始化为0 </span></span><br><span class="line">	<span class="keyword">while</span>(p! =<span class="literal">NULL</span>)&#123;<span class="comment">//指针p依次遍历链表直至最后一个结点 </span></span><br><span class="line">		<span class="keyword">if</span>(count&lt;k) count++;</span><br><span class="line">		<span class="keyword">else</span>  q=q-&gt;link;</span><br><span class="line">		 p=p-&gt;link;</span><br><span class="line">	&#125; <span class="comment">//while</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	上面这几行是这个算法的核心思想，我来解释一下</span></span><br><span class="line"><span class="comment">	首先算法开始运行时，p在动，而q不动</span></span><br><span class="line"><span class="comment">	直到p向右移动了k次，此时k和count相等，这时候p和q一起向右移动</span></span><br><span class="line"><span class="comment">	如果k小于链表的长度，则返回q指针指向的数据域 </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span>(count&lt;k)<span class="comment">//若k值大于链表的长度，则找不到该结点，返回0 </span></span><br><span class="line">	   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,q-&gt;data);<span class="comment">//找到该结点则返回该结点的数据域 </span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>综合【2012】假定采用带头结点的单链表保存单词，当两个单词有相同的后缀时，可共享相同的后缀存储空间，例如,”loading”和”being”的存储影像如下图所示。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-33.png"  />

<p>设str1和str2分别指向两个单词所在单链表的头结点，链表结点结构为<code>data|next</code>，请设计一个时间上尽可能高效的算法，找出由str1和str2所指向两个链表共同后缀的起始位置(如图中字符i所在结点的位置p)。要求:</p>
<p>1)给出算法的设计思想</p>
<p>2)根据设计思想，采用程序语言描述算法，关键之处给出注释</p>
<p>3)说明你所设计算法的时间复杂度</p>
<blockquote>
<p>1)分别求出str1和str2所指的两个链表的长度m和n；<br>将两个链表以表尾对齐：令指针p、q分别指向str1和str2的头结点；如果m&gt;=n，则p指针先走，使p指向链表中的第m-n+1个结点；如果m&lt;n，则使q指针指向链表的第n-m+1个结点；即：使得指针p、q所指的结点到表尾的长度相等；<br>反复将指针q和q同步向后移动，当p、q指向同一位置时停止，即：共同后缀的起始位置。算法结束。<br>2）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line"> <span class="type">char</span> data;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求链表的长度;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetListLen</span><span class="params">(LNode *head)</span>&#123;</span><br><span class="line"> <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span>(head-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">     len++;</span><br><span class="line">     head = head-&gt;next;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找出共同后缀的起始位置；</span></span><br><span class="line">LNode* <span class="title function_">find_addr</span><span class="params">(LNode *str1,LNode *str2)</span>&#123;</span><br><span class="line"> <span class="type">int</span> m,n;</span><br><span class="line"> m = GetListLen(str1);</span><br><span class="line"> n = GetListLen(str2);</span><br><span class="line"></span><br><span class="line"> LNode *p,*q;</span><br><span class="line"> <span class="keyword">if</span>(m &gt;= n)&#123;</span><br><span class="line">     <span class="keyword">for</span>(p = str1;m&gt;n;m--)&#123;</span><br><span class="line">         p = p-&gt;next;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(q = str2;n&gt;m;n--)&#123;</span><br><span class="line">         q = q-&gt;next;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//得到p和q的起始位置后，找出共同后缀的起始地址；</span></span><br><span class="line"> <span class="keyword">while</span>(p-&gt;next !=<span class="literal">NULL</span> &amp;&amp; p-&gt;next != q-&gt;next)&#123;</span><br><span class="line">     p = p-&gt;next;</span><br><span class="line">     q = q-&gt;next;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3)**O(max(m,n))**（m、n分别为两个链表的长度）；</p>
</blockquote>
</li>
<li><p>综合【2015】用单链表保存m个整数，结点的结构为[data]|[link]，且|data|&lt;=n(n为正整数)。现要求设计一个时间复杂度尽可能高效的算法，对于链表中data的绝对值相等的结点，仅保留第一次出现的结点而删除其余绝对值相等的结点。例如，若给定的单链表head如下:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-34.png" style="zoom:80%;" />

<p>则删除结点后的head为：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds2-35.png" style="zoom:80%;" />

<p>要求：  </p>
<p>   1）给出算法的基本设计思想。  </p>
<p>   2）使用C或C++语言，给出单链表结点的数据类型定义。  </p>
<p>   3）根据设计思想，采用C或C++语言描述算法，关键之处给出注释。  </p>
<p>   4）说明你所设计算法的时间复杂度和空间复杂度。</p>
<blockquote>
<p>1）算法的基本设计思想 </p>
<p>算法的核心思想是用空间换时间。使用辅助数组记录链表中已出现的数值，从而只需对链表进行一趟扫描。 因为|data|≤n，故辅助数组q的大小为n+1，各元素的初值均为0。依次扫描链表中的各结点，同时检查q[|data|]的值，如果为0，则保留该结点，并令q[|data|]=1；否则，将该结点从链表中删除。 </p>
<p>2）使用C语言描述的单链表结点的数据类型定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="type">int</span>         data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>   *<span class="title">link</span>;</span></span><br><span class="line">&#125;NODE;</span><br><span class="line">Typedef NODE *PNODE;</span><br></pre></td></tr></table></figure>

<p>3）算法实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span> <span class="params">(PNODE h,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">PNODE p=h,r;</span><br><span class="line"><span class="type">int</span> *q,m;</span><br><span class="line">q=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(n+<span class="number">1</span>));  <span class="comment">//申请n+1个位置的辅助空间</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)                <span class="comment">//数组元素初值置0</span></span><br><span class="line">*(q+i)=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;link!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">m=p-&gt;link-&gt;data&gt;<span class="number">0</span>? p-&gt;link-&gt;data:-p-&gt;link-&gt;data;</span><br><span class="line"><span class="keyword">if</span>(*(q+m)==<span class="number">0</span>)                      <span class="comment">//判断该结点的data是否已出现过</span></span><br><span class="line">&#123;</span><br><span class="line">*(q+m)=<span class="number">1</span>;                      <span class="comment">//首次出现</span></span><br><span class="line">p=p-&gt;link;                     <span class="comment">//保留</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>                               <span class="comment">//重复出现</span></span><br><span class="line">&#123;   r=p-&gt;link;                     <span class="comment">//删除</span></span><br><span class="line">p-&gt;link=r-&gt;link</span><br><span class="line"><span class="built_in">free</span>(r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）时间复杂度为O(m)，空间复杂度为O(n)</p>
</blockquote>
</li>
<li><p>【2019】设线性表L=(a1,a2,a3,…,a(n-2),a(n-1),an)采用带头结点的单链表保存，链表中的结点定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; NODE;</span><br></pre></td></tr></table></figure>

<p>请设计一个空间复杂度为 <code>O(1)</code> 且时间上尽可能高效的算法，重新排列 L 中的各节点，得到线性表 <code>L&#39;=(a1, an, a2, a(n-1), a3, a(n-2), ...)</code>。要求:</p>
<p>1)给出算法的设计思想</p>
<p>2)根据设计思想，采用程序语言描述算法，关键之处给出注释</p>
<p>3)说明你所设计算法的时间复杂度</p>
<blockquote>
<p>1)先观察L=(a1,a2,a3,…,a(n-2),a(n-1),an)和L’=(a1,an,a2,a(n-1),a3,a(n-2),…)，发现L’是由L摘取第一个元素，再摘取倒数第一个元素……依次合并而成的。为了方便链表后半段取元素，需要先将L后半段原地逆置[题目要求空间复杂度为O(1)，不能借助栈]，否则每取最后一个结点都需要遍历一次链表。1.先找出链表L的中间结点，为此设置两个指针p和q,指针p每次走一步，指针q每次走两步，当指针q到达链尾时，指针p正好在链表的中间结点；2.然后将L的后半段结点原地逆置。3.从单链表前后两段中依次各取一个结点，按要求重排。</p>
<p>2)算法实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Change_list</span><span class="params">(Linklist h)</span>&#123;</span><br><span class="line">	LNode *p,*q,*r,*s;</span><br><span class="line">	p=q=h;</span><br><span class="line">	<span class="comment">/*双指针找链表的中点*/</span> </span><br><span class="line">	<span class="keyword">while</span>(q-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		p=p-&gt;next;					<span class="comment">//p走一步 </span></span><br><span class="line">		q=q-&gt;next;</span><br><span class="line">		<span class="keyword">if</span>(q-&gt;next!=<span class="literal">NULL</span>)q=q-&gt;next; <span class="comment">//q走两步 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*链表的逆置*/</span></span><br><span class="line">	q=p-&gt;next;			<span class="comment">//p所指结点为中点 </span></span><br><span class="line">	p-&gt;next=<span class="literal">NULL</span>;		<span class="comment">//q为后半链表的首结点 </span></span><br><span class="line">	<span class="keyword">while</span>(q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		r=q-&gt;next;</span><br><span class="line">		q-&gt;next=p-&gt;next;</span><br><span class="line">		p-&gt;next=q;</span><br><span class="line">		q=r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*后半部分的链表头插进入前半部分*/</span></span><br><span class="line">	s=h-&gt;next;</span><br><span class="line">	q=p-&gt;next;</span><br><span class="line">	p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span>(q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		q-&gt;next=s-&gt;next;<span class="comment">//将q所指结点插入到s所指结点之后 </span></span><br><span class="line">		s-&gt;next=q;</span><br><span class="line">		s=q-&gt;next;		<span class="comment">//将s指向前半段的下一个插入点 </span></span><br><span class="line">		q=r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3)第一步找中间结点的时间复杂度为O(n),第二步逆置的时间复杂度为O(n)，第3步合并链表的时间复杂度为O(n),所以该算法的时间复杂度为O(n)。</p>
</blockquote>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://tikxeis.fun">kailin2eis</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://tikxeis.fun/p/12625/">http://tikxeis.fun/p/12625/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://tikxeis.fun" target="_blank">派总</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/408%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">408数据结构</a></div><div class="post_share"><div class="social-share" data-image="/img/1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/63528/"><img class="prev-cover" src="/img/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第三章 栈、队列和数组(上)</div></div></a></div><div class="next-post pull-right"><a href="/p/14457/"><img class="next-cover" src="/img/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第二章 线性表(上)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/p/24523/" title="第一章 绪论"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第一章 绪论</div></div></a></div><div><a href="/p/14457/" title="第二章 线性表(上)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第二章 线性表(上)</div></div></a></div><div><a href="/p/58315/" title="第三章 栈、队列和数组(下)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-28</div><div class="title">第三章 栈、队列和数组(下)</div></div></a></div><div><a href="/p/63528/" title="第三章 栈、队列和数组(上)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第三章 栈、队列和数组(上)</div></div></a></div><div><a href="/p/17647/" title="第四章 串"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-28</div><div class="title">第四章 串</div></div></a></div><div><a href="/p/63944/" title="第五章 树与二叉树(上)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-28</div><div class="title">第五章 树与二叉树(上)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">kailin2eis</div><div class="author-info__description">派总's blog</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA"><span class="toc-text">2.3 线性表的链式表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">单链表的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#typedef%E7%9A%84%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-text">typedef的使用问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-text">不带头结点的单链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-text">带头结点的单链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%B8%A6-%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">不带&#x2F;带头结点的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">单链表上基本操作的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%87%E7%94%A8%E5%A4%B4%E6%8F%92%E6%B3%95%E5%BB%BA%E7%AB%8B%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-text">采用头插法建立单链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%87%E7%94%A8%E5%B0%BE%E6%8F%92%E6%B3%95%E5%BB%BA%E7%AB%8B%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-text">采用尾插法建立单链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E5%BA%8F%E5%8F%B7%E6%9F%A5%E6%89%BE%E7%BB%93%E7%82%B9%E5%80%BC"><span class="toc-text">按序号查找结点值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E5%80%BC%E6%9F%A5%E6%89%BE%E8%A1%A8%E7%BB%93%E7%82%B9"><span class="toc-text">按值查找表结点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E7%BB%93%E7%82%B9%E6%93%8D%E4%BD%9C-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-text">插入结点操作 单链表的插入和删除</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E5%BA%8F%E6%8F%92%E5%85%A5"><span class="toc-text">按位序插入</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9"><span class="toc-text">带头结点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%8D%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9"><span class="toc-text">不带头结点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E7%BB%93%E7%82%B9%E7%9A%84%E5%90%8E%E6%8F%92%E6%93%8D%E4%BD%9C"><span class="toc-text">指定结点的后插操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E7%BB%93%E7%82%B9%E7%9A%84%E5%89%8D%E6%8F%92%E6%93%8D%E4%BD%9C"><span class="toc-text">指定结点的前插操作</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%8F%92%E5%85%A5%E7%AE%97%E6%B3%95"><span class="toc-text">单链表的基本插入算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8B%93%E5%B1%95-%E5%AF%B9%E6%9F%90%E4%B8%80%E7%BB%93%E7%82%B9%E7%9A%84%E5%89%8D%E6%8F%92%E6%93%8D%E4%BD%9C"><span class="toc-text">拓展:对某一结点的前插操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E6%93%8D%E4%BD%9C-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-text">删除结点操作 单链表的插入和删除</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E6%8C%89%E4%BD%8D%E5%BA%8F%E5%88%A0%E9%99%A4"><span class="toc-text">带头结点按位序删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E7%BB%93%E7%82%B9p"><span class="toc-text">扩展：删除指定结点p</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E8%A1%A8%E9%95%BF%E6%93%8D%E4%BD%9C"><span class="toc-text">求表长操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8-%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">双链表 双链表的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">双链表的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%8F%8C%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA"><span class="toc-text">判断双链表是否为空</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-text">双链表的插入操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E6%8F%92%E6%93%8D%E4%BD%9C"><span class="toc-text">后插操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E5%BA%8F%E6%8F%92%E5%85%A5-1"><span class="toc-text">按位序插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E6%8F%92%E6%93%8D%E4%BD%9C"><span class="toc-text">前插操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-text">双链表的删除操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E9%94%80%E6%AF%81"><span class="toc-text">双链表的销毁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">双链表的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E5%90%91%E9%81%8D%E5%8E%86"><span class="toc-text">后向遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E5%90%91%E9%81%8D%E5%8E%86"><span class="toc-text">前向遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E5%90%91%E9%81%8D%E5%8E%86-%E8%B7%B3%E8%BF%87%E5%A4%B4%E7%BB%93%E7%82%B9"><span class="toc-text">前向遍历(跳过头结点)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-text">循环链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-text">循环单链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-text">初始化循环单链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA"><span class="toc-text">判断循环单链表是否为空</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A1%A8%E5%B0%BE%E7%BB%93%E7%82%B9"><span class="toc-text">判断循环单链表表尾结点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">循环单链表的好处</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-text">循环双链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8"><span class="toc-text">静态链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E7%82%B9%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-text">结点类型定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">基本操作的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">顺序表和链表的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98"><span class="toc-text">习题</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/12342/" title="第六章 图(下)">第六章 图(下)</a><time datetime="2022-09-28T07:19:14.000Z" title="发表于 2022-09-28 15:19:14">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/63800/" title="第六章 图(上)">第六章 图(上)</a><time datetime="2022-09-28T07:04:39.000Z" title="发表于 2022-09-28 15:04:39">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/56280/" title="第五章 树与二叉树(下)">第五章 树与二叉树(下)</a><time datetime="2022-09-28T06:47:26.000Z" title="发表于 2022-09-28 14:47:26">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/48066/" title="第五章 树与二叉树(中)">第五章 树与二叉树(中)</a><time datetime="2022-09-28T06:37:49.000Z" title="发表于 2022-09-28 14:37:49">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/63944/" title="第五章 树与二叉树(上)">第五章 树与二叉树(上)</a><time datetime="2022-09-28T04:50:11.000Z" title="发表于 2022-09-28 12:50:11">2022-09-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By kailin2eis</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="关关雎鸠,在河之洲,窈窕淑女,what' your qq" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>