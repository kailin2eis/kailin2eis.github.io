<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>第八章 排序(一) | 派总</title><meta name="keywords" content="408数据结构"><meta name="author" content="kailin2eis"><meta name="copyright" content="kailin2eis"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="8.1 排序的基本概念排序的定义排序啥意思，就是字面意思 😆！比如原来数组的元素是[1, 3, 2]，排完序就是[1, 2, 3]，所谓排序，就是把n个关键字，按照递增或递减的顺序，把它们给重新排列一遍。 输入:n个记录R1，R2,…,Rn，对应的关键字为k1,k2,…,kn。 输出:输入序列的一个重排R1‘，R2’，…,Rn’,使得有k1’&lt;&#x3D;k2’&lt;&#x3D;…&lt;&#x3D;kn’(也可递减">
<meta property="og:type" content="article">
<meta property="og:title" content="第八章 排序(一)">
<meta property="og:url" content="http://tikxeis.fun/p/27129/index.html">
<meta property="og:site_name" content="派总">
<meta property="og:description" content="8.1 排序的基本概念排序的定义排序啥意思，就是字面意思 😆！比如原来数组的元素是[1, 3, 2]，排完序就是[1, 2, 3]，所谓排序，就是把n个关键字，按照递增或递减的顺序，把它们给重新排列一遍。 输入:n个记录R1，R2,…,Rn，对应的关键字为k1,k2,…,kn。 输出:输入序列的一个重排R1‘，R2’，…,Rn’,使得有k1’&lt;&#x3D;k2’&lt;&#x3D;…&lt;&#x3D;kn’(也可递减">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://tikxeis.fun/img/1.png">
<meta property="article:published_time" content="2022-09-28T11:47:17.000Z">
<meta property="article:modified_time" content="2022-09-28T11:55:55.155Z">
<meta property="article:author" content="kailin2eis">
<meta property="article:tag" content="408数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tikxeis.fun/img/1.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://tikxeis.fun/p/27129/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第八章 排序(一)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-28 19:55:55'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><style>.mjpage .MJX-monospace {
  font-family: monospace;
}

.mjpage .MJX-sans-serif {
  font-family: sans-serif;
}

.mjpage {
  display: inline;
  font-style: normal;
  font-weight: normal;
  line-height: normal;
  font-size: 100%;
  font-size-adjust: none;
  text-indent: 0;
  text-align: left;
  text-transform: none;
  letter-spacing: normal;
  word-spacing: normal;
  word-wrap: normal;
  white-space: nowrap;
  float: none;
  direction: ltr;
  max-width: none;
  max-height: none;
  min-width: 0;
  min-height: 0;
  border: 0;
  padding: 0;
  margin: 0;
}

.mjpage * {
  transition: none;
  -webkit-transition: none;
  -moz-transition: none;
  -ms-transition: none;
  -o-transition: none;
}

.mjx-svg-href {
  fill: blue;
  stroke: blue;
}

.MathJax_SVG_LineBox {
  display: table !important;
}

.MathJax_SVG_LineBox span {
  display: table-cell !important;
  width: 10000em !important;
  min-width: 0;
  max-width: none;
  padding: 0;
  border: 0;
  margin: 0;
}

.mjpage__block {
  text-align: center;
  margin: 1em 0em;
  position: relative;
  display: block !important;
  text-indent: 0;
  max-width: none;
  max-height: none;
  min-width: 0;
  min-height: 0;
  width: 100%;
}
</style></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/1.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">派总</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">第八章 排序(一)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-28T11:47:17.000Z" title="发表于 2022-09-28 19:47:17">2022-09-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-28T11:55:55.155Z" title="更新于 2022-09-28 19:55:55">2022-09-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/408%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">408数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="第八章 排序(一)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="8-1-排序的基本概念"><a href="#8-1-排序的基本概念" class="headerlink" title="8.1 排序的基本概念"></a>8.1 排序的基本概念</h2><h3 id="排序的定义"><a href="#排序的定义" class="headerlink" title="排序的定义"></a>排序的定义</h3><p>排序啥意思，就是字面意思 😆！比如原来数组的元素是<code>[1, 3, 2]</code>，排完序就是<code>[1, 2, 3]</code>，所谓排序，就是把n个关键字，按照递增或递减的顺序，把它们给重新排列一遍。</p>
<p><strong>输入</strong>:n个记录R1，R2,…,Rn，对应的关键字为k1,k2,…,kn。</p>
<p><strong>输出</strong>:输入序列的一个重排R1‘，R2’，…,Rn’,使得有k1’&lt;=k2’&lt;=…&lt;=kn’(也可递减)</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-1.png" style="zoom:67%;" />

<h3 id="排序的应用"><a href="#排序的应用" class="headerlink" title="排序的应用"></a>排序的应用</h3><p>排序着有非常的应用。是生活中必不可少的算法。</p>
<p>如王者荣耀战力</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-2.jpg" style="zoom: 33%;" />

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-3.jpg" style="zoom: 25%;" />

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-285.jpg" style="zoom: 25%;" />

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-286.jpg" style="zoom:33%;" />

<h3 id="排序算法的评价指标"><a href="#排序算法的评价指标" class="headerlink" title="排序算法的评价指标"></a>排序算法的评价指标</h3><p>算法的<strong>稳定性</strong>。若待排序表中有两个元素Ri和Rj，其对应的关键字相同即keyi = keyj，且在排序前Ri在Rj的前面，若使用某一排序算法排序后，Ri仍在Rj的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-4.png" style="zoom:67%;" />

<blockquote>
<p>稳定的：关键字相同的元素在排序之后相对位置不变。反之是不稳定的。</p>
</blockquote>
<p><strong>问：稳定的排序算法一定比不稳定的好？</strong></p>
<p>答：不一定，要结合实际需求出发。例如实际场景对排序的稳定性没有要求，或者关键字根本就没有重复的，那么稳定不稳定都一样。</p>
<h3 id="排序算法的分类"><a href="#排序算法的分类" class="headerlink" title="排序算法的分类"></a>排序算法的分类</h3><ul>
<li>内部排序：数据都在内存中</li>
<li>外部排序：数据太多，无法全部放入内存</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-5.png" style="zoom: 70%;" />

<p>所谓的内部排序，指的是我们可以把所有需要排序的数据，全部放到内存当中。比如说我们自己写的排序，我们自己定义一个数组之类的，其数据量不是很大，都是放在内存当中的。</p>
<p>但是有的时候，我们又难免要遇到，我们需要排序的数据量很大，没有办法全部放入内存的情况。我们的外部磁盘的容量一般是很大的，而内存就小很多。比如我们现在有一个超大的文件，超过了8G，不可能将它一次性全部放入内存。那么这时，我们想对相关的数据进行排序，就只能采取一部分一部分处理这样的策略。对于一个内部排序，由于数据都在内存中，而内存又是一个很高速的设备，所以我们在设计排序算法的时候，我们会更多地关注这个算法的时间复杂度、空间复杂度是怎么样的。</p>
<p>而当我们在设计外部排序算法的时候，除了这个算法的时间、空间复杂度之外，我们还需要关注，怎么追求更少的读写磁盘的次数。</p>
<blockquote>
<p>因为我们磁盘的读写速度很慢，比如对于一个机械硬盘来说，其读写速度在100MB/s左右。相比之下，我们内存读写的速度可以到60GB/s。</p>
<p>所以我们要将磁盘中的数据和内存之间进行读写，就会很慢。而数据一旦读入内存后，对数据的处理就不会消耗什么时间。</p>
<p>所以在设计外部排序的时候，我们也需要关注怎么使读写磁盘次数更少的问题。</p>
</blockquote>
<h3 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h3><p>接下来会介绍很多排序，光看代码挺无聊的，这里推荐一个很好玩的网站</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://visualgo.net/zh/sorting">https://visualgo.net/zh/sorting</a></li>
</ul>
<p>这是一个，先从感性上理解各种各样的排序网站 😉</p>
<h2 id="8-2-插入排序"><a href="#8-2-插入排序" class="headerlink" title="8.2 插入排序"></a>8.2 插入排序</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><blockquote>
<p>算法思想：每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。</p>
</blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-6.png" style="zoom: 67%;" />

<p>一开始会从第二个元素开始入手。</p>
<p>我们会认为，当前这个元素之前的所有元素，是已经排好序的。</p>
<p>我们现在需要将当前元素<code>38</code>，与之前元素依次进行对比，之前元素中比38大的，都要将之依次后移。</p>
<p>49&gt;38，所以49需要后移。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-7.png" style="zoom: 67%;" />

<p>接下来要处理的是<code>65</code>这个元素。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-8.png" style="zoom: 67%;" />

<p>而65&gt;49，所以其之前的元素都不需要移动，直接把65放回来即可。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-9.png" style="zoom: 67%;" />

<p>接下来处理的是<code>97</code>，它比它前边的65还大，所以依然直接放回来。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-10.png" style="zoom: 67%;" />

<p>接下来要处理<code>76</code>这个元素。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-11.png" style="zoom: 67%;" />

<p>在76之前的这些元素是已经排好序的。我们从76依次往前检查，大于76的就后移一位。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-12.png" style="zoom: 67%;" />

<p>因此97需要后移一位，之后继续往前检查，65&lt;76，则停止检查。并将76插入到65后面的位置。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-13.png" style="zoom: 67%;" />

<p>接下来要处理<code>13</code>这个元素。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-14.png" style="zoom: 67%;" />

<p>再其之前的元素依次检查，都比13要大，在检查到38并将其后移之后，再往前检查就没有元素了。所以13应该放入0号位置。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-15.png" style="zoom: 67%;" />

<p>接下来，27的处理方式是一样的。</p>
<p>之后我们要处理49这个元素。最后一个49加一个下划线，是为了和前面的那个49作区分。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-16.png" style="zoom: 67%;" />

<p>处理的方法一样，我们要把其之前的排好序的序列中，大于49的元素依次后移一位，然后插入。结果如下。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-17.png" style="zoom: 67%;" />

<blockquote>
<p>注意，我们是把比它更大的元素右移，而与之相等的元素是没有右移的。</p>
<p>这样可以保证算法的稳定性。</p>
</blockquote>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i, j, temp;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++)&#123;		<span class="comment">//将各元素插入已排好序的序列中 </span></span><br><span class="line">		<span class="keyword">if</span>(A[i] &lt; A[i<span class="number">-1</span>])&#123;		<span class="comment">//若A[i]关键字小于前驱 </span></span><br><span class="line">			temp = A[i];		<span class="comment">//用temp暂存A[i] </span></span><br><span class="line">			<span class="keyword">for</span>(j = i<span class="number">-1</span>; j&gt;=<span class="number">0</span> &amp;&amp; A[j]&gt;temp; --j)&#123;	<span class="comment">//检查所有前面已排好序的元素 </span></span><br><span class="line">				A[j+<span class="number">1</span>] = A[j];		<span class="comment">//所有大于temp的元素都向后挪位 </span></span><br><span class="line">			&#125;</span><br><span class="line">			A[j+<span class="number">1</span>] = temp;		<span class="comment">//赋值到插入位置 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>另一种实现方法(带哨兵)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接插入排序（带哨兵）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">2</span>; i&lt;=n; i++) &#123;		<span class="comment">//依次将A[2]~A[n]插入到前面已排序序列 </span></span><br><span class="line">		<span class="keyword">if</span>(A[i] &lt; A[i<span class="number">-1</span>])&#123;		<span class="comment">//若A[i]关键字小于其前驱，将A[i]插入有序表 </span></span><br><span class="line">			A[<span class="number">0</span>] = A[i];		<span class="comment">//赋值为哨兵，A[0]不存放元素 </span></span><br><span class="line">			<span class="keyword">for</span>(j = i<span class="number">-1</span>; A[<span class="number">0</span>] &lt; A[j]; --j)&#123;		<span class="comment">//从后往前查找待插入位置 </span></span><br><span class="line">				A[j+<span class="number">1</span>] = A[j];		<span class="comment">//向后挪位 </span></span><br><span class="line">			&#125;</span><br><span class="line">			A[j+<span class="number">1</span>] = A[<span class="number">0</span>];		<span class="comment">//赋值到插入位置 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color='orange'>带哨兵，优点：不用每轮循环都判断j&gt;=0</font></p>
<h3 id="算法效率分析"><a href="#算法效率分析" class="headerlink" title="算法效率分析"></a>算法效率分析</h3><p>空间复杂度：O(1)</p>
<p>时间复杂度：主要来自对比关键字、移动元素。若有n个元素，则需要n-1趟处理</p>
<blockquote>
<p>最好情况：</p>
<p>原始的表就是一个有序表。</p>
<p>共n-1趟处理，每一趟只需要对比关键字1次，不用移动元素。</p>
<p>最好时间复杂度——O(n)</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-18.png" style="zoom: 67%;" />
</blockquote>
<blockquote>
<p>最坏情况：</p>
<p>表中元素全部都是逆序排放。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-285.png" style="zoom: 50%;" />

<p>这种情况下，我们每一趟处理，都需要把当前元素，与它之前所有元素都进行一次对比，并且把之前排好序的元素依次后移。</p>
<p>第1趟：对比关键字2次，移动元素3次；</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-286.png" style="zoom: 55%;" />

<p>第2趟：对比关键字3次，移动元素4次；</p>
<p>第i趟：对比关键字i+1次，移动元素i+2次；</p>
<p>…</p>
<p>第n-1趟：对比关键字n次，移动元素n+1次。</p>
<p>最坏时间复杂度——O(n²)</p>
</blockquote>
<blockquote>
<p>稳定性:由于每次插入元素时总是从后向前先比较再移动。所以不会出现相同元素相对位置发送变化的情况，即直接插入排序是一种稳定的排序算法。</p>
<p>适用性:直接插入排序算法适用于顺序存储和链式存储的线性表。为链式存储时，可以从前往后查找指定元素的位置。</p>
</blockquote>
<p><font color='red'>注意</font>:其实大部分排序算法都适用于顺序存储的线性表。</p>
<p>所以总结一下:</p>
<ul>
<li>空间复杂度：O(1)</li>
<li>最好时间复杂度（全部有序）：O(n)</li>
<li>最坏时间复杂度（全部逆序）：O(n²)</li>
<li>平均时间复杂度：O(n²)</li>
<li>算法稳定性：稳定</li>
</ul>
<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><p>之前我们执行插入的时候，都是从当前元素顺序地往前依次寻找，找到它应该插入的位置。</p>
<p>但是由于当前处理的元素，它之前的元素已经是有序的了，并且还是顺序存储的话，那么就可以用折半查找的方法，更快的找到当前处理元素应该插入的位置。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-19.png" style="zoom: 50%;" />

<blockquote>
<p>先把当前处理的元素a[i]保存下来。（放入哨兵，或者存入temp）</p>
<p>之后，对当前元素之前的元素(已经有序)，进行折半查找。</p>
</blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-20.png" style="zoom: 67%;" />

<p>当low&gt;high时折半查找停止，此时应该将<code>[low, i-1]</code>内的元素全部右移，并将A[0]赋值到low所指位置。</p>
<p>之后，处理下一个元素，60。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-21.png" style="zoom: 50%;" />

<p>同样利用折半查找的算法，但是有一个问题。当mid所指元素为60时，由于折半查找算法的原理，当查找到相同的元素，就会停止折半查找。</p>
<p>但是此处我们为了保证插入排序的稳定性，当我们发现和当前元素相等的元素时，我们还应该继续查找，继续往右半部分确定处理元素的插入位置。</p>
<p>所以此时并不会让折半查找停止，我们还会继续在mid所指的60的右半部分，继续进行折半查找，即令low=mid+1。</p>
<blockquote>
<p>当A[mid] == A[0]时，为了保证算法的“稳定性”，应继续在mid所指位置右边寻找插入位置。</p>
</blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-22.png" style="zoom: 67%;" />

<p>继续执行，到low&gt;high时，停止折半查找。并将<code>[low, i-1]</code>范围内的元素全部右移，并将A[0]复制到low所指位置。剩下的步骤不多说了。</p>
<p><strong>代码实现</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//折半插入排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i, j, low, high, mid;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">2</span>; i&lt;=n; i++)&#123;	<span class="comment">//依次将A[2]~A[n]插入前面的已排序序列 </span></span><br><span class="line">		A[<span class="number">0</span>] = A[i];	<span class="comment">//将A[i]暂存到A[0]</span></span><br><span class="line">		low=<span class="number">1</span>; high=i<span class="number">-1</span>;	<span class="comment">//设置折半查找的范围</span></span><br><span class="line">		<span class="keyword">while</span>(low&lt;=high)&#123;	<span class="comment">//折半查找 </span></span><br><span class="line">			mid = (low + high) / <span class="number">2</span>;	<span class="comment">//取中间点</span></span><br><span class="line">			<span class="keyword">if</span>(A[mid] &gt; A[<span class="number">0</span>])</span><br><span class="line">				high = mid - <span class="number">1</span>; <span class="comment">//查找左半子表</span></span><br><span class="line">			<span class="keyword">else</span> low = mid + <span class="number">1</span>;	<span class="comment">//查找右半子表 </span></span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">for</span>(j = i<span class="number">-1</span>; j&gt;=high+<span class="number">1</span>; --j)&#123;</span><br><span class="line">			A[j+<span class="number">1</span>] = A[j];		<span class="comment">//统一后移元素，空出插入位置 </span></span><br><span class="line">		&#125;</span><br><span class="line">		A[high+<span class="number">1</span>] = A[<span class="number">0</span>];		<span class="comment">//插入操作 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当low&gt;high时折半查找停止，应将[low, i-1]内的元素全部右移，并将A[0]复制到low所指位置。</p>
<p>当A[mid]==A[0]时，为了保证算法的“稳定性”，应继续在mid所指位置右边寻找插入位置。</p>
</blockquote>
<p>比起“直接插入排序”，比较关键字的次数减少了,约为O(nlog₂n),该比较次数与待排序表的初始状态无关，仅取决于表中的元素个数n，但是元素的移动元素的次数没变，它依赖于待排序表的初始状态，整体来看<strong>时间复杂度依然是O(n²)</strong>。对于数据量不很大的排序，折半插入排序往往能表现出很好的性能。折半插入排序是一种稳定的排序方法。</p>
<h3 id="对链表进行插入排序"><a href="#对链表进行插入排序" class="headerlink" title="对链表进行插入排序"></a>对链表进行插入排序</h3><p>插入排序的思想也可以对链表进行。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-23.png" style="zoom: 67%;" />

<p>对链表的插入排序，代码实现自己思考。</p>
<p>此处要说的是，当我们用链表进行插入排序的话，移动元素的次数变少了。但是关键字对比的次数依然是O(n²)数量级，整体来看<strong>时间复杂度依然是O(n²)</strong>。（因为链表没办法用折半查找，所以只能顺序地，从后往前依次对比各个元素）</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><blockquote>
<p>希尔排序是一个叫希尔的人发明的。</p>
<p>它是对上一面中讲的插入排序，进行的一个优化。</p>
</blockquote>
<p>对于插入排序来说，若原本表中的元素是有序的，则在这种情况下，直接插入排序可以得到一个很不错的执行效率。</p>
<p>那么，再把这个条件放宽一点，若原本表中的元素是<strong>基本有序</strong>的。那这种情况下，直接插入排序的效率也会很不错。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-24.png" style="zoom:67%;" />

<p>总之，如果能保证表中元素基本有序的话，我们的插入排序也能得到很好的执行。</p>
<p>希尔排序的思想就是基于这样的一个考虑。</p>
<p>我们先追求表中的元素部分有序，再逐渐逼近全局有序。</p>
<h4 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h4><p>希尔排序：先将待排序表分割成若干形如<code>L[i, i+d, i+2d, ..., i+kd]</code>的“特殊”子表，对各个子表分别进行直接插入排序。缩小<strong>增量d</strong>，重复上述过程，直到d=1为止。</p>
<blockquote>
<p>在每一趟排序时，我们都会设一个增量d，然后对相距距离为d的各个元素，对它们进行直接插入排序。</p>
</blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-25.png" style="zoom:80%;" />

<p>若<strong>第一趟</strong>排序，令d=4。则子表情况如下:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-26.png" style="zoom:80%;" />

<p>接下来要对各个子表分别进行直接插入排序。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-28.png" style="zoom:80%;" />

<p>在进行完毕第一趟排序之后，表中的数据应该如下所示。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-27.png" style="zoom:80%;" />

<p><strong>第二趟</strong>：令d = d/2 = 2。则子表情况如下：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-29.png" style="zoom:80%;" />

<p>接下来对各个子表分别进行直接插入排序。</p>
<p>在进行完毕第二趟排序之后，表中数据如下。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-30.png" style="zoom:80%;" />

<p><strong>第三趟</strong>：令d = d/2 = 1。则子表情况如下：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-31.png" style="zoom:80%;" />

<p>最后一趟处理就相当于总体对所有元素直接进行插入排序。</p>
<p>但这时，经过前两趟处理，我们这时这个序列已经达成了基本有序的状态。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-32.png" style="zoom:80%;" />

<p>经过三趟的处理之后，最终得到一个递增序列。</p>
<blockquote>
<p>整个过程如下图所示：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-33.png" style="zoom: 80%;" />
</blockquote>
<p>此处，我们每次将增量d缩小一半。实际上这也是希尔本人建议的。</p>
<p>不过，考试当中，可能会遇到各种的增量。按照原理分析即可。</p>
<h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="type">int</span> d, i, j;</span><br><span class="line">    <span class="comment">//A[0]只是暂存单元，不是哨兵，当j&lt;=0时，插入位置已到</span></span><br><span class="line">	<span class="keyword">for</span>(d = n/<span class="number">2</span>; d&gt;=<span class="number">1</span>; d = d/<span class="number">2</span>)	<span class="comment">//步长变化 </span></span><br><span class="line">		<span class="keyword">for</span>(i = d+<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">			<span class="keyword">if</span>(A[i] &lt; A[i-d])&#123;	<span class="comment">//需将A[i]插入有序增量子表 </span></span><br><span class="line">				A[<span class="number">0</span>] = A[i];	<span class="comment">//暂存在A[0] </span></span><br><span class="line">				<span class="keyword">for</span>(j = i-d; j&gt;<span class="number">0</span> &amp;&amp; A[<span class="number">0</span>]&lt;A[j]; j-=d)&#123;</span><br><span class="line">					A[j+d] = A[j];	<span class="comment">//记录后移，查找插入的位置 </span></span><br><span class="line">				&#125;</span><br><span class="line">				A[j+d] = A[<span class="number">0</span>];	<span class="comment">//插入 </span></span><br><span class="line">			&#125;<span class="comment">//if	</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="算法性能分析"><a href="#算法性能分析" class="headerlink" title="算法性能分析"></a>算法性能分析</h4><p><strong>空间复杂度</strong>:O(1)</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-34.png" style="zoom:80%;" />

<p>我们的d，如果依次采用不同的增量序列，如取4、2、1，和取3、1，其希尔排序过程的趟数会受到影响，同时在每一趟排序当中，各个元素的对比、元素的移动这些也都会受到影响。</p>
<p><font color='cornflowerblue'>所以希尔排序的时间复杂度是怎么样的，到目前为止分析起来都很困难。</font></p>
<p><strong>时间复杂度</strong>：和增量序列d的选择有关，目前<strong>无法用数学手段证明确切的时间复杂度</strong>。</p>
<blockquote>
<p>如果第一趟就取d=1，那么希尔排序就会退化成直接插入排序。</p>
<p>于是其最坏时间复杂度为O(n²)。</p>
<p>另外，当n在某个范围内时，希尔排序的时间复杂度可以达到O(n^{1.3})，可见与直接插入排序相比，效率还是提升了很多的。</p>
</blockquote>
<p><font color='orange'>接下来看这个算法的稳定性如何。</font></p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-35.png" style="zoom: 80%;" />

<p>对于这个表，第一趟取d=2，会导致49跑到49的前边。所以，显然是不稳定的。</p>
<p>此外，其必须要具有随机访问的特性，才可以实现。因此希尔排序仅适用于顺序表，不适用于链表。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>希尔排序</strong></p>
<ul>
<li>先将待排序表分割成若干形如<code>L[i, i+d, i+2d, ..., i+kd]</code>的“特殊”子表，对各个子表分别进行直接插入排序。缩小增量d，重复上述过程，直到d=1为止。</li>
<li>性能<ul>
<li>空间复杂度：O(1)</li>
<li>时间复杂度：未知，但优于直接插入排序</li>
<li>稳定性：不稳定</li>
<li>适用性：仅可用于顺序表</li>
</ul>
</li>
<li><font color='red'>高频题型</font>：给出增量序列，分析每一趟排序后的状态</li>
</ul>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><ul>
<li><p>对于5个不同的数据元素进行直接插入排序，最多需要进行的比较次数是（不包含与哨兵的比较）→10次；</p>
<blockquote>
<p>4+3+2+1=10次，如果加上与哨兵的比较就是14次（5+4+3+2）</p>
</blockquote>
</li>
<li><p>【2012】 对同一待排序序列分别进行折半插入排序和直接插入排序，两者之间可能的不同之处是→④</p>
<p>① 排序的总趟数</p>
<p>② 元素的移动次数</p>
<p>③ 使用辅助空间的数量</p>
<p>④ 元素之间的比较次数</p>
<blockquote>
<p>折半插入排序，是对插入排序算法的一种改进，由于排序算法过程中，就是不断的依次将元素插入前面已排好序的序列中。由于前半部分为已排好序的数列，这样我们不用按顺序依次寻找插入点，可以采用折半查找的方法来加快寻找插入点的速度。 所以，很明显比较的次数减少了</p>
</blockquote>
</li>
<li><p>对有 n 个元素的顺序表采用直接插入排序算法进行排序，在最坏情况下所需的比较次数是多少？最好情况呢？（不考虑和哨兵的比较）?→最坏情况 ( n - 1 ) n / 2，最好情况 n - 1</p>
</li>
<li><p>【2009】若数据元素序列{11,12,13,7,8,9,23,4,5}是采用下列排序方法之一得到的第二趟排序后的结果，则该排序算法只能是–&gt;C</p>
<p>A. 冒泡排序<br>B. 选择排序<br>C. 插入排序<br>D. 归并排序</p>
<blockquote>
<p>解答本题需要对各种排序算法的特点极为清楚。对于冒泡排序和选择排序，每一趟都能确定一个元素的最终位置，而题目中，前  2  个元素和后  2  个元素均不是最小或最大的  2  个元素并按序排列。选项  D  中的  2  路归并排序，第一趟排序结束都可以得到若干个有序子序列，而此时的序列中并没有两两元素有序排列。插入排序在每趟排序后能确定前面的若干元素是有序的，而此时第二趟排序后，序列的前三个元素是有序的，符合其特征。</p>
</blockquote>
</li>
<li><p>【2014】 用希尔排序方法对一个数据序列排序，若第1趟排序结果为<code>9 1 4 13 7 8 20 23 15</code> ，则采用的增量间隔可能是 ?→3</p>
<blockquote>
<p>希尔排序：设待排序元素序列由n个，首先取gap(增量)&lt;n作为间隔，将全部元素分为gap个子序列，所有距离为gap的元素放在同一个子序列中，在每个子序列进行直接插排。</p>
<p>从定义可知，在进行第一趟希尔排序后，由于执行了直接插排，每个子序列都是有序的。 </p>
<p>根据题目，反过来，找间隔gap，使得每个子序列{a[i],a[i+gap],a[i+2*gap]….}有序，其中i~[0,n-1]。</p>
<p><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-36.png" alt=""></p>
<p>如图，相同颜色的属于同一个子序列，增序。因此题目中第一趟gap=3.</p>
<p>关于疑问：算法的定义不是gap=gap/3+1吗？那为什么不选择4呢？</p>
<p>可以看出该公式相当于a1=a0/3+1,是基于本次gap来计算下一次的gap。而第一次的gap是给定的，不是计算得来的</p>
</blockquote>
</li>
<li><p>【2015】希尔排序的组内排序采用的是→A </p>
<p>A 直接插入排序<br>B 折半插入排序<br>C 快速排序<br>D 归并排序</p>
<blockquote>
<p>希尔排序的思想是：先将待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成），分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。</p>
</blockquote>
</li>
<li><p>【2018】对初始数据序列(8,3,9,11,2,1,4,7,5,10,6)进行希尔排序，若第一趟排序结果为(1,3,7,5,2,6,4,9,11,10,8)，则两趟排序采用的增 量（间隔）依次是–&gt;5，3</p>
<blockquote>
<p>第一趟分组: 8,1,6; 3,4; 9,7; 11,5; 2, 10;间隔为5,排序后组内递增。<br>第二趟分组: 1,5,4,10; 3,2,9,8; 7,6,11; 间隔为3，排序后组内递增。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-37.png" style="zoom:80%;" />
</blockquote>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://tikxeis.fun">kailin2eis</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://tikxeis.fun/p/27129/">http://tikxeis.fun/p/27129/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://tikxeis.fun" target="_blank">派总</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/408%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">408数据结构</a></div><div class="post_share"><div class="social-share" data-image="/img/1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/43357/"><img class="prev-cover" src="/img/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第八章 排序(二)</div></div></a></div><div class="next-post pull-right"><a href="/p/15017/"><img class="next-cover" src="/img/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第七章 查找(四)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/p/24523/" title="第一章 绪论"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第一章 绪论</div></div></a></div><div><a href="/p/14457/" title="第二章 线性表(上)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第二章 线性表(上)</div></div></a></div><div><a href="/p/12625/" title="第二章 线性表(下)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第二章 线性表(下)</div></div></a></div><div><a href="/p/63528/" title="第三章 栈、队列和数组(上)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第三章 栈、队列和数组(上)</div></div></a></div><div><a href="/p/17647/" title="第四章 串"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-28</div><div class="title">第四章 串</div></div></a></div><div><a href="/p/58315/" title="第三章 栈、队列和数组(下)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-28</div><div class="title">第三章 栈、队列和数组(下)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">kailin2eis</div><div class="author-info__description">派总's blog</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">8.1 排序的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">排序的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">排序的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="toc-text">排序算法的评价指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">排序算法的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90"><span class="toc-text">推荐</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">8.2 插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90"><span class="toc-text">算法效率分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">折半插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">对链表进行插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-text">希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-1"><span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">算法性能分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98"><span class="toc-text">习题</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/44803/" title="第八章 排序(四)">第八章 排序(四)</a><time datetime="2022-09-28T11:54:17.000Z" title="发表于 2022-09-28 19:54:17">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/14847/" title="第八章 排序(三)">第八章 排序(三)</a><time datetime="2022-09-28T11:52:50.000Z" title="发表于 2022-09-28 19:52:50">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/43357/" title="第八章 排序(二)">第八章 排序(二)</a><time datetime="2022-09-28T11:50:30.000Z" title="发表于 2022-09-28 19:50:30">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/27129/" title="第八章 排序(一)">第八章 排序(一)</a><time datetime="2022-09-28T11:47:17.000Z" title="发表于 2022-09-28 19:47:17">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/15017/" title="第七章 查找(四)">第七章 查找(四)</a><time datetime="2022-09-28T11:33:21.000Z" title="发表于 2022-09-28 19:33:21">2022-09-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By kailin2eis</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="关关雎鸠,在河之洲,窈窕淑女,what' your qq" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>