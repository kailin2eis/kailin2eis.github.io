<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>第六章 图(上) | 派总</title><meta name="keywords" content="408数据结构"><meta name="author" content="kailin2eis"><meta name="copyright" content="kailin2eis"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="6.1 图的基本概念图的定义   有向图、无向图 无向图：每条边都是无方向的 有向图：每条边都是有方向的    简单图、多重图    顶点的度、入度和出度  例如微信好友关系图，我们如何评判某人是否是“交际达人”？只需看某人这个结点，连接的边数，即可。连接的边数越多，则越有可能是一个交际达人。 例如微博粉丝关注图，如何评判某人是否是“微博大V”？只需看这个人的结点，它作为弧尾的弧有多少条，即可。">
<meta property="og:type" content="article">
<meta property="og:title" content="第六章 图(上)">
<meta property="og:url" content="http://tikxeis.fun/p/63800/index.html">
<meta property="og:site_name" content="派总">
<meta property="og:description" content="6.1 图的基本概念图的定义   有向图、无向图 无向图：每条边都是无方向的 有向图：每条边都是有方向的    简单图、多重图    顶点的度、入度和出度  例如微信好友关系图，我们如何评判某人是否是“交际达人”？只需看某人这个结点，连接的边数，即可。连接的边数越多，则越有可能是一个交际达人。 例如微博粉丝关注图，如何评判某人是否是“微博大V”？只需看这个人的结点，它作为弧尾的弧有多少条，即可。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://tikxeis.fun/img/1.png">
<meta property="article:published_time" content="2022-09-28T07:04:39.000Z">
<meta property="article:modified_time" content="2022-09-28T07:16:39.644Z">
<meta property="article:author" content="kailin2eis">
<meta property="article:tag" content="408数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tikxeis.fun/img/1.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://tikxeis.fun/p/63800/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第六章 图(上)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-28 15:16:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/1.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">派总</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">第六章 图(上)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-28T07:04:39.000Z" title="发表于 2022-09-28 15:04:39">2022-09-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-28T07:16:39.644Z" title="更新于 2022-09-28 15:16:39">2022-09-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/408%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">408数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="第六章 图(上)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="6-1-图的基本概念"><a href="#6-1-图的基本概念" class="headerlink" title="6.1 图的基本概念"></a>6.1 图的基本概念</h2><h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-1.png" style="zoom:69%;" />

<ul>
<li><p>有向图、无向图</p>
<p>无向图：每条边都是无方向的</p>
<p>有向图：每条边都是有方向的</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-2.png" style="zoom: 80%;" />

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-3.png" style="zoom:80%;" /></li>
<li><p>简单图、多重图</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-4.png" style="zoom: 80%;" />

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-5.png" style="zoom: 80%;" /></li>
<li><p>顶点的度、入度和出度</p>
<blockquote>
<p>例如微信好友关系图，我们如何评判某人是否是“交际达人”？只需看某人这个结点，连接的边数，即可。连接的边数越多，则越有可能是一个交际达人。</p>
<p>例如微博粉丝关注图，如何评判某人是否是“微博大V”？只需看这个人的结点，它作为弧尾的弧有多少条，即可。</p>
<p>因此，无论是有向图还是无向图，讨论某个结点所联系的边或弧的条数，是很有意义的一件事。</p>
</blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-6.png" style="zoom: 78%;" />

<p>如上面这张有向图，对于顶点A</p>
<p>ID(A) = 1</p>
<p>OD(A) = 4</p>
<p>TD(A) = 1+4 = 5</p>
</li>
<li><p>顶点-顶点的关系描述</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-7.png" style="zoom:78%;" /></li>
<li><p>连通图、强连通图</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-8.png" style="zoom:78%;" /></li>
<li><p>研究图的局部–子图</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-9.png" style="zoom:70%;" />

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-10.png" style="zoom:70%;" /></li>
<li><p>连通分量、强连通分量</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-11.png" style="zoom:70%;" />

<p><strong>极大连通子图</strong>，即<strong>子图必须连通，且包含尽可能多的顶点和边</strong>。</p>
<blockquote>
<p>连通分量这个概念也是有很多现实意义的，比如说全国铁路线路图</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-176.png" style="zoom:65%;" />

<p>这个图里面有三个连通分量——整个大陆区域的铁路图、海南岛铁路图、台湾岛铁路图。</p>
<p>当然，对于大陆区域的铁路图，你可以把其中长江三角区的铁路图挑出来，那么挑出来的这个图，它是一个子图，但是并不是极大连通子图。</p>
</blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-12.png" style="zoom:70%;" /></li>
<li><p>生成树、生成森林</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-175.png" style="zoom:70%;" />

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-14.png" style="zoom:70%;" />

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-15.png" style="zoom:70%;" />

<blockquote>
<p>其实生成树和生成森林有很多意义：</p>
<p>例如有图上顶点那么多的村庄，这些村庄之间如果要开通公路，但是由于经费有限，不可能把所有的路都修起来，但是又想让每个村庄之间道路都连通。如何能有一个成本最低的修路方案呢。</p>
<p>就可以用无向图，推出所有可能的生成树。因为生成树能保证是连通的，且能保证边的数量是尽可能的少的。</p>
<p>于是，通过生成树，就可以初步得到若干个修路的施工方案。</p>
<p>但是在不同的生成树之间，选择哪种方案，能让修路的成本最低呢？</p>
<p>其实就要看一下每一条边，修起路来的成本到底是多少。</p>
<p>于是在生成树的基础上，再将各个边的成本考虑进去，就能得到一个最经济的方案。</p>
</blockquote>
</li>
<li><p>边的权、带权图/网</p>
<blockquote>
<p>可以发现，图这种数据结构，我们除了在顶点部分保存信息外，有时候也需要给各条边赋予一个数值，来表示权值。用这个数值来表示一些具有现实含义的一些信息。</p>
</blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-16.png" style="zoom:78%;" /></li>
<li><p>完全图</p>
<p>完全图：任意两个点都有一条边相连</p>
<p>无向完全图：n个顶点，任意两个顶点都要有边。所以n个顶点，共有<br>$$<br>C_n^2 = n(n-1)/2<br>$$<br>条边。</p>
<p>有向完全图：n个顶点，任意两个顶点都要有两条边。所以n个顶点，共有<br>$$<br>2C_n^2 = n(n-1)<br>$$<br>条边</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-17.png" style="zoom:80%;" /></li>
<li><p>稀疏图、稠密图</p>
<p>稀疏图：有很少或弧(有向图的边也称作弧)的图</p>
<p>稠密图：有较多边或弧的图</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-18.png" style="zoom:80%;" /></li>
<li><p>有向树</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-19.png" style="zoom:80%;" /></li>
</ul>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><ul>
<li><p>【2011】下列关于图的叙述中，正确的–&gt;仅 ③</p>
<p>① 回路是简单路径<br>② 存储稀疏图，用邻接矩阵比邻接表更省空间<br>③ 若有向图中存在拓扑序列，则该图不存在回路</p>
<blockquote>
<p>第一个顶点和最后一个顶点相同的路径称为回路；序列中顶点不重复出现的路径称为简单路径；回路显然不是简单路径，故  Ⅰ  错误；稀疏图是边比较少的情况，此时用邻接矩阵的空间复杂度为  O(n²)  ，必将浪费大量的空间，而邻接表的空间复杂度为  O(n+e)  ，应该选用邻接表，故  Ⅱ  错误。存在回路的有向图不存在拓扑序列，若拓扑排序输出结束后所余下的顶点都有前驱，则说明只得到了部分顶点的拓扑有序序列，图中存在回路，故  Ⅲ  正确。</p>
</blockquote>
</li>
<li><p>【2009】下列关于无向连通图特性的叙述中，正确的是–&gt;只有Ⅰ</p>
<p>Ⅰ．所有顶点的度之和为偶数</p>
<p>Ⅱ．边数大于顶点个数</p>
<p>Ⅲ．至少有一个顶点的度为1</p>
<blockquote>
<p>1，每条边连接两个顶点，所有顶点的度之和等于边数的2倍，是偶数，正确<br>2，如两个顶点一条边的图就不满足这个条件，错<br>3，如三个顶点三条边连成一个三角形的图每个顶点度为2，错</p>
</blockquote>
</li>
<li><p>设有无向图 G=(V, E)和 G’(V’, E’)，若 G’是 G 的生成树，则下列不正确的→ 只有 ①</p>
<p>① G’为 G 的连通分量</p>
<p>② G’为 G 的无环子图</p>
<p>③ G’为 G 的极小连通子图且 V’=V</p>
</li>
<li><p>【2013】设图的邻接矩阵A如下图所示，各顶点的度依次是–&gt;C<br>$$<br> A=\left[<br> \begin{matrix}<br>   0 &amp; 1 &amp; 0 &amp;1\<br>   0 &amp; 0 &amp; 1 &amp;1\<br>   0 &amp; 1 &amp; 0 &amp;0\<br>   1 &amp; 0 &amp; 0 &amp;0<br>  \end{matrix}<br>  \right]<br>$$<br>A.1,2,1,2       B.2,2,1,1</p>
<p>C.3,4,2,3       D.4,4,2,2</p>
<blockquote>
<p>无向图的边数组（邻接矩阵）是对阵矩阵。各顶点的度为邻接矩阵中对应行的元素之和。</p>
<p>有向图的各顶点的度为出度加上入度之和。出度为对应顶点所在行的所有元素之和，入度为对应顶点所在列的所有元素之和。</p>
<p>该图明显为有向图。所以各个顶点的度为其出度和入度之和，即所在行和列元素之和。</p>
</blockquote>
</li>
<li><p>【2017】已知无向图G含有16条边，其中度为4的顶点个数为3，度为3的顶点个数为4，其他顶点的度均小于3。图G所含的顶点个数至少是–&gt;11</p>
<blockquote>
<p>无向图边数的两倍等于各顶点度数的总和。由于其他顶点的度均小于3，可以设它们的度都为2，设它们的数量是x，可列出这样的方程4×3+3×4+2×x=16x2，解得x=4。4+3+4=11，B正确。</p>
</blockquote>
</li>
</ul>
<h2 id="6-2-图的存储及基本操作"><a href="#6-2-图的存储及基本操作" class="headerlink" title="6.2 图的存储及基本操作"></a>6.2 图的存储及基本操作</h2><h3 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h3><p>所谓邻接矩阵存储，是指用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息(即各顶点之间的邻接关系)，存储顶点之间的邻接关系的二维数组称为<strong>邻接矩阵</strong>。</p>
<p>结点数为n的图G=(V,E)的邻接矩阵A是n×n的。将G的顶点编号为v1,v2,…,vn则</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-253.png" style="zoom: 80%;" />

<p>上述解释为：如果两个顶点之间存在边或者弧，那么二维数组就为1，如果两个顶点之间不存在边或者弧，那么二维数组就为0</p>
<h4 id="邻接矩阵表示法"><a href="#邻接矩阵表示法" class="headerlink" title="邻接矩阵表示法"></a>邻接矩阵表示法</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-20.png" style="zoom: 80%;" />

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-21.png" style="zoom:80%;" />

<ul>
<li>无向图的邻接矩阵是<strong>对称</strong>的。</li>
<li>顶点i的度 = 第i行(列)中1的个数。</li>
<li><strong>特别的，完全图(任意两个顶点都有边)的邻接矩阵中，对角元素为0，其余均为1</strong>。</li>
</ul>
<p>邻接矩阵的实现也很简单，只需要用一个二维数组就可以。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100	<span class="comment">//顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> Vex[MaxVertexNum];	<span class="comment">//顶点表</span></span><br><span class="line">    <span class="type">int</span> Edge[MaxVertexNum][MaxVertexNum];	<span class="comment">//邻接矩阵，边表</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;	<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure>

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-22.png" style="zoom:80%;" />

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-23.png" style="zoom: 67%;" />

<p>在有向图的邻接矩阵中：</p>
<ul>
<li>第i行含义：以结点Vi为尾的弧(即出度边)</li>
<li>第i列含义：以结点Vi为头的弧(即出度边)</li>
</ul>
<p>分析：</p>
<ul>
<li>有向图的邻接矩阵<strong>可能是不对称</strong>的。</li>
<li>顶点的出度 = 第 i 行元素之和</li>
<li>顶点的入度 = 第 i 列元素之和</li>
<li>顶点的度 = 第i行元素之和+第i列元素之和</li>
</ul>
<p><font color='red'>邻接矩阵法求顶点的度/出度/入度的时间复杂度为O(|V|)</font></p>
<h4 id="网-带权图-的邻接矩阵表示法"><a href="#网-带权图-的邻接矩阵表示法" class="headerlink" title="网(带权图)的邻接矩阵表示法"></a>网(带权图)的邻接矩阵表示法</h4><p>对于带权图而言，若顶点vi和vj之间有边相连，则邻接矩阵中对应项存放着该边对应的权值，若顶点vi给vj不相连，则用 ∞ 来代表着两个顶点之间不存在边:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-254.png" style="zoom:80%;" />

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-24.png" style="zoom:80%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带权图</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100  <span class="comment">//顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;  <span class="comment">//顶点的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;     <span class="comment">//带权图中边上权值的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VertexType Vex[MaxVertexNum];  <span class="comment">//顶点表</span></span><br><span class="line">    EdgeType Edge[MaxVertexNum][MaxVertexNum]; <span class="comment">//邻接矩阵，边表</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;     <span class="comment">//图的当前顶点数和弧数</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure>

<h4 id="邻接矩阵法的性质"><a href="#邻接矩阵法的性质" class="headerlink" title="邻接矩阵法的性质"></a>邻接矩阵法的性质</h4><ol>
<li><p>无向图的邻接矩阵一定是一个对称矩阵(唯一)。因此，在实际存储邻接矩阵时只需要存储上(或下)三角矩阵的元素。</p>
</li>
<li><p>对于无向图，邻接矩阵的第i行(或第i列)非零元素(或非∞元素)的个数正好是顶点i的度TD(vi)。</p>
</li>
<li><p>对于有向图，邻接矩阵的第i行非零元素(或非∞元素)的个数正好是顶点i的出度OD(vi);第i列非零元素(或非∞元素)的个数正好是顶点i的入度ID(vi)。</p>
</li>
<li><p>用邻接矩阵存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。</p>
</li>
<li><p>稠密图适合使用邻接矩阵的存储表示。</p>
</li>
<li><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-26.png" style="zoom:85%;" />

<blockquote>
<p>上图中的话是什么意思呢？我们举个例子来看一下，例如A²</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-177.png" style="zoom:80%;" />

<p>我们挑其中的一项看一下它具有什么实际意义，如a(1,2)*a(2,4)</p>
<p>其中a(1,2)的意思是A到B是否有边，a(2,4)表示B到D是否有边。</p>
<p>因此a(1,2)*a(2,4)便表示从A到D，但是是由A经过B到D的路径的数目。</p>
<p>那么其他项也是从A到D，但是是经过不同顶点到D的路径的数目。</p>
<p>把这些乘积的项都加起来，就表示从A到D，且长度为2的路径的数目。</p>
<p>具体的矩阵乘法去学线代吧。</p>
</blockquote>
<blockquote>
<p>如果是A³，那么原理也是类似的。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-132.png" style="zoom: 80%;" />

<p>看最右侧的那个结果，其中第一行第四列的值为1，就意味着，从A到D，长度为3的路径，只有一条。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-133.png" style="zoom:80%;" />

<p>其背后的含义是什么呢？</p>
<p>由于这个1是前一个矩阵的第一行对应相乘后一个矩阵的第四列得到的，我们分别看这四个加项的含义。</p>
<p>第一项（1*0）的含义是说：从A到A且长度为2的路径有1条；而从A到D长度为1的路径有0条。</p>
<p>所以我们没办法把这两条路径凑起来，拼成一个更长的路径。</p>
<p>第二项（0*1）同理。</p>
<p>第三项（1*1）的含义是说：从A到C且长度为2的路径有1条；从C到D且长度为1的路径有1条。</p>
<p>我们把这两条路径一拼接，就能得到从A到D，且是经过C的，长度为3的路径有1条。</p>
<p>第四项（0*0）同理。</p>
<p>最后，求和之后，就能得到，由A到D，长度为3的所有路径的数目。 </p>
</blockquote>
</li>
</ol>
<h4 id="邻接矩阵法的性能分析"><a href="#邻接矩阵法的性能分析" class="headerlink" title="邻接矩阵法的性能分析"></a>邻接矩阵法的性能分析</h4><ol>
<li><p>在简单应用中，可直接用二维数组作为图的邻接矩阵(顶点信息等均可省略)。</p>
</li>
<li><p>当邻接矩阵的元素仅表示相应边是否存在时，EdgeType可采用值为0和1的枚举类型。</p>
</li>
<li><p>无向图的邻接是对称矩阵，对规模特大的邻接矩阵可采用压缩存储(只存储上三角区/下三角区)。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-25.png" style="zoom:80%;" /></li>
<li><p>邻接矩阵表示法的空间复杂度为<font color='orange'>O(n²)</font>,其中n为图的顶点数|V|。所以只和顶点数相关，和实际的边数无关</p>
</li>
<li><p>适用于存储稠密图</p>
</li>
</ol>
<p>邻接矩阵的<strong>优点</strong>：</p>
<ul>
<li>直观、简单、好理解</li>
<li>方便检查任意一对顶点间是否存在边</li>
<li>方便找任一顶点的所有”邻接点”(有边直接相连的顶点)</li>
<li>方便计算任一顶点的”度”(从该点发出的边数为”出度”,指向该点的边数为”入度”)</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>不便于删除和增加顶点</li>
<li>浪费空间-存稀疏图(点很多而边很少)，有大量无效元素</li>
<li>浪费时间-统计稀疏图中一共有多少条边</li>
</ul>
<h3 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h3><p>所谓邻接表，是指对图G中的每个顶点vi建立一个单链表，第i个单链表中的结点表示依附于顶点vi的边(对于有向图则是以顶点vi为尾的弧)，这个单链表就称为顶点vi的<strong>边表</strong>(d4对于有向图则称为<strong>出边表</strong>)。</p>
<p>边表的头指针和顶点的数据信息采用顺序存储(称为<strong>顶点表</strong>)，所以在邻接表中存在两种结点:顶点表结点和边表结点</p>
<h4 id="无向图的邻接表"><a href="#无向图的邻接表" class="headerlink" title="无向图的邻接表"></a>无向图的邻接表</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-27.png" style="zoom: 67%;" />

<p>顶点：按编号顺序将顶点数据存储在<strong>一维数组中</strong>。</p>
<p>关联同一顶点的边(以顶点为尾的弧)：用线性<strong>链表</strong>存储</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-178.png" style="zoom:67%;" />

<p>例如，由A指向B有一条边，那么在A的*first域中，就有一个顶点号为1的结点（顶点号为1的就是B），下一个依次为2、3（即C、D顶点）。</p>
<p>如果我们要存的是带权图，我们可以在存放边的类型中定义权值的信息。</p>
<blockquote>
<p>其实不难发现，这种邻接表法的实现，和我们之前讲的树的孩子表示法，是相同的一种实现方式。</p>
<p>各个结点顺序存储，然后再用一个链表来指明和这个结点相连的各个边。</p>
</blockquote>
<hr>
<p>无向图的邻接表特点：</p>
<ul>
<li>邻接表不唯一</li>
<li>若无向图中有n个顶点、e条边，则其邻接表需n个头结点和2e个表结点。适宜存储稀疏图。</li>
<li>无向图中顶点Vi的度为第 i 个单链表中的结点数。</li>
</ul>
<h4 id="有向图的邻接表"><a href="#有向图的邻接表" class="headerlink" title="有向图的邻接表"></a>有向图的邻接表</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-179.png" style="zoom:67%;" />

<p>原理是类似的。有一条弧是从A指向B，所以A的后面跟了顶点号为1的结点。</p>
<blockquote>
<p>实际上就是，对于有向图来说，它后面这个链域存储的信息，只是由这个顶点向外射的一些弧。</p>
<p>而对于无向图来说，是不分方向的一个个边。实际上，在无向图中，每一条边在邻接表中都会对应两个结点。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-180.png" style="zoom: 38%;" />

<p>比如这个，0号结点（A）后存放了一个1号结点（B）；同时，1号结点（B）后面也存放了一个0号结点（A）。而这两个结点表示了同一条边。</p>
<p>实际上在无向图中，边的数据的存放实际是有冗余的。是实际边的数量的两倍。边结点的数量是2|E|，整体空间复杂度为O(|V|+2|E|)。</p>
</blockquote>
<blockquote>
<p>而有向图，每一条弧，都只对应于一个边结点。所以边结点的数量为|E|。所以空间复杂度为O(|V|+|E|)。</p>
</blockquote>
<p><font color='cornflowerblue'>接下来需要探讨的一个问题是</font>：</p>
<ul>
<li>如何求顶点的度、入度、出度？</li>
<li>如何找到与一个顶点相连的边/弧。</li>
</ul>
<p>首先来看无向图，对于无向图我们只讨论度。如何确定一个顶点的度是多少？</p>
<ul>
<li>我们只需要遍历，和这个顶点相关的这个边链表就可以。有多少个边结点，它的度就是多少。同时，这些边结点就是与这个顶点相连的边。</li>
</ul>
<p>再来看有向图，有向图的度=入度+出度。</p>
<ul>
<li>如果要找到一个顶点的出度很简单，我们只需要遍历这个结点相关的边链表就可以。同时，它也反应了从这个顶点发射出去的弧有哪些。</li>
<li>但是如果我们要找一个顶点的入度，或者是指向该顶点的弧有哪些，就有些麻烦了。<ul>
<li>比如我们要统计A结点的入度，或者要找到指向A结点的弧。那唯一的办法就是，把所有的结点的边链表，都依次地遍历一遍。是很麻烦的，时间复杂度也会很高。这是邻接表法存储有向图的一个比较大的缺点。</li>
</ul>
</li>
</ul>
<blockquote>
<p>此外，由于在一个图中，各个边出现的先后顺序是任意的，因此图的邻接表表示方式并不是唯一的。（如A的边链表可以是1、2、3，也可以是3、2、1）</p>
<p>而上一小节中我们讲的邻接矩阵，只要确定了顶点编号，图的邻接矩阵表示方式就是唯一的。（这是选择题可能会考察的一个点）</p>
</blockquote>
<h4 id="图的邻接表存储结构定义"><a href="#图的邻接表存储结构定义" class="headerlink" title="图的邻接表存储结构定义"></a>图的邻接表存储结构定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100 <span class="comment">//图中顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span>  <span class="comment">//边表结点</span></span><br><span class="line">    <span class="type">int</span> adjvex;          <span class="comment">//该弧所指向的顶点的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span><span class="comment">//指向下一条弧的指针</span></span><br><span class="line">    <span class="comment">//InfoType info;     //网的边权值</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span>    <span class="comment">//顶点表结点</span></span><br><span class="line">    VertexType data;     <span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *first;      <span class="comment">//指向第一条依附该顶点的弧的指针</span></span><br><span class="line">&#125;VNode,AdjList[MaxVertexNum];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    AdjList vertices;    <span class="comment">//邻接表</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;   <span class="comment">//图的顶点数和弧数</span></span><br><span class="line">&#125; ALGraph;               <span class="comment">//ALGraph是以邻接表存储的图类型</span></span><br></pre></td></tr></table></figure>

<h4 id="邻接表的特点"><a href="#邻接表的特点" class="headerlink" title="邻接表的特点"></a>邻接表的特点</h4><ol>
<li>若G是无向图，则所需的存储空间为<font color='orange'>O(|V|+2|E|)</font>;若G是有向图，则所需的存储空间为<font color='orange'>O(|V|+|E|)</font>。|E|是边的数量，前者的倍数2是由于无向图中，每条边在邻接表中出现了两次。</li>
<li>对于稀疏图，采用邻接表表示将极大地<font color='orange'>节省存储空间</font>。</li>
<li>在邻接表中，给定一顶点，能很容易地找出它的所有邻边，因为只需要读取它的邻接表。在邻接矩阵中，相同的操作则需要扫描一行，花费的时间为O(n)。但是，若要确定给定的两个顶点间是否存在边，则在邻接矩阵中可以立刻查到，而在邻接表中则需要在相应结点对应的边表中查找另一结点，效率低。</li>
<li>在有向图的邻接表表示中，求一个给定顶点的出度只需计算其邻接表中的结点个数；但求其顶点的入度则需要遍历全部的邻接表。因此，也有人采用逆邻接表的存储方式来加速求解给定顶点的入度。当然，这实际上与邻接表存储方式是类似的。</li>
<li>图的邻接表表示并不唯一，因为在每个顶点对应的单链表中，各边结点的链接次序可以是任意的，它取决于建立邻接表的算法及边的输入次序。</li>
</ol>
<h4 id="邻接表和邻接矩阵的关系"><a href="#邻接表和邻接矩阵的关系" class="headerlink" title="邻接表和邻接矩阵的关系"></a>邻接表和邻接矩阵的关系</h4><p>联系：邻接表中每个链表对应于邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数。</p>
<table>
<thead>
<tr>
<th></th>
<th>邻接表</th>
<th>邻接矩阵</th>
</tr>
</thead>
<tbody><tr>
<td>空间复杂度</td>
<td>无向图O(|V|+2|E|);有向图O(|V|+|E|)</td>
<td>O(|V|²)</td>
</tr>
<tr>
<td>适合用于</td>
<td>存储稀疏图</td>
<td>存储稠密图</td>
</tr>
<tr>
<td>表示方式</td>
<td>不唯一</td>
<td>唯一</td>
</tr>
<tr>
<td>计算度/出度/入度</td>
<td>计算有向图的度、入度不方便，其余很方便</td>
<td>必须遍历对应的行或列</td>
</tr>
<tr>
<td>找相邻的边</td>
<td>找有向图的入边不方便，其余很方便</td>
<td>必须遍历对应行或列</td>
</tr>
</tbody></table>
<h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-31.png" style="zoom: 67%;" />

<p>邻接矩阵的缺点是空间复杂度太高；邻接表的缺点是当它存储有向图的时候，计算入度、找入边不方便。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-32.png" style="zoom:67%;" />

<p>十字链表是<font color='cornflowerblue'>有向图</font>的另一种链式存储结构。我们也可以把它看成是将有向图的邻接表和逆邻接表结合起来形成的一种链表。</p>
<p>有向图中的每一条弧对应十字链表中的一个<strong>弧结点</strong>，同时有向图中的每个顶点在十字链表中对应有一个结点，叫做顶点结点。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-181.png" style="zoom:55%;" />

<blockquote>
<p>例如顶点A。</p>
<p>若要找从A射出的弧，则找A顶点结点的“绿色”部分指针，找到0→1（即A→B），而在此个弧结点的“绿色”部分指针，存放着A发出的下一条弧0→2（即A→C），下一个绿色指针为空，意味着已经没有其他从A顶点出发的弧了。</p>
<p>若要找进入A的弧，则找A顶点结点的“橙色”部分指针，找到2→0（即C→A），继续找该弧结点的下一个“橙色”指针，找到下一个进入A的弧3→0（即D→A），下一个橙色指针为空，意味着已经没有其他指向A顶点的弧了。</p>
</blockquote>
<p>顶点结点中有一个数据域和两个指针域（分别用 firstin 和 firstout 表示）：</p>
<ul>
<li>firstin 指针用于连接以当前顶点为弧头的其他顶点构成的链表；</li>
<li>firstout 指针用于连接以当前顶点为弧尾的其他顶点构成的链表；</li>
<li>data 用于存储该顶点中的数据；</li>
</ul>
<p>十字链表中弧节点的存储分为 5 部分内容，它们各自的作用是：</p>
<ul>
<li>tailvex 用于存储以首元节点为弧尾的顶点位于数组中的位置下标；</li>
<li>headvex 用于存储以首元节点为弧头的顶点位于数组中的位置下标；</li>
<li>hlink 指针：用于链接下一个存储以首元节点为弧头的顶点的节点；</li>
<li>tlink 指针：用于链接下一个存储以首元节点为弧尾的顶点的节点；</li>
<li>info 指针：用于存储与该顶点相关的信息，例如量顶点之间的权值；</li>
</ul>
<p><strong>空间复杂度</strong>:<font color='orange'>O(|V|+|E|)</font>（顶点的个数+边的个数）</p>
<p>可以看到，空间复杂度和邻接表是一样优秀的，并不会像邻接矩阵那样有空间的冗余。</p>
<p>此外，还可以很方便的找到所有的边，包括出边和入边。</p>
<ul>
<li>如何找到指定顶点的所有出边?–顺着绿色线路找</li>
</ul>
<ul>
<li>如何找到指定顶点的所有入边?–顺着橙色线路找</li>
</ul>
<p><font color='red'>注意:十字链表只用于存储有向图</font></p>
<p>十字链表的构建过程:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  InfoType int<span class="comment">//图中弧包含信息的数据类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  VertexType int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcBox</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> tailvex,headvex;<span class="comment">//弧尾、弧头对应顶点在数组中的位置下标</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcBox</span> *<span class="title">hlik</span>,*<span class="title">tlink</span>;</span><span class="comment">//分别指向弧头相同和弧尾相同的下一个弧</span></span><br><span class="line">    InfoType *info;<span class="comment">//存储弧相关信息的指针</span></span><br><span class="line">&#125;ArcBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VexNode</span>&#123;</span></span><br><span class="line">    VertexType data;<span class="comment">//顶点的数据域</span></span><br><span class="line">    ArcBox *firstin,*firstout;<span class="comment">//指向以该顶点为弧头和弧尾的链表首个结点</span></span><br><span class="line">&#125;VexNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VexNode xlist[MAX_VERTEX_NUM];<span class="comment">//存储顶点的一维数组</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;<span class="comment">//记录图的顶点数和弧数</span></span><br><span class="line">&#125;OLGraph;</span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateVex</span><span class="params">(OLGraph * G,VertexType v)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历一维数组，找到变量v</span></span><br><span class="line">    <span class="keyword">for</span> (; i&lt;G-&gt;vexnum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (G-&gt;xlist[i].data==v) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果找不到，输出提示语句，返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (i&gt;G-&gt;vexnum) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no such vertex.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构建十字链表函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateDG</span><span class="params">(OLGraph *G)</span>&#123;</span><br><span class="line">    <span class="comment">//输入有向图的顶点数和弧数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;(G-&gt;vexnum),&amp;(G-&gt;arcnum));</span><br><span class="line">    <span class="comment">//使用一维数组存储顶点数据，初始化指针域为NULL</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;G-&gt;vexnum; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;(G-&gt;xlist[i].data));</span><br><span class="line">        G-&gt;xlist[i].firstin=<span class="literal">NULL</span>;</span><br><span class="line">        G-&gt;xlist[i].firstout=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建十字链表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;G-&gt;arcnum; k++) &#123;</span><br><span class="line">        <span class="type">int</span> v1,v2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;v1,&amp;v2);</span><br><span class="line">        <span class="comment">//确定v1、v2在数组中的位置下标</span></span><br><span class="line">        <span class="type">int</span> i=LocateVex(G, v1);</span><br><span class="line">        <span class="type">int</span> j=LocateVex(G, v2);</span><br><span class="line">        <span class="comment">//建立弧的结点</span></span><br><span class="line">        ArcBox * p=(ArcBox*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcBox));</span><br><span class="line">        p-&gt;tailvex=i;</span><br><span class="line">        p-&gt;headvex=j;</span><br><span class="line">        <span class="comment">//采用头插法插入新的p结点</span></span><br><span class="line">        p-&gt;hlik=G-&gt;xlist[j].firstin;</span><br><span class="line">        p-&gt;tlink=G-&gt;xlist[i].firstout;</span><br><span class="line">        G-&gt;xlist[j].firstin=G-&gt;xlist[i].firstout=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p>邻接多重表是<font color='cornflowerblue'>无向图</font>的另一种链式存储结构</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-182.png" style="zoom: 35%;" />

<p>怎么解决这些问题呢？我们可以用邻接多重表的方式来存储无向图</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-183.png" style="zoom:70%;" />

<blockquote>
<p>例如，A结点，顺着它的指针域寻找，能够找到0—1（即A—B）这条边，之后继续顺着“橙色”（即iLink）指针继续寻找，则能够找到0—3（即A—D）这条边，接着继续顺着”橙色“指针，发现为空，则表示没有与A相连的边了。</p>
<p>对于B结点，顺着它的指针，找到0—1（即A—B）这条边，可见B结点在此处存放于右侧的编号域上（实际上在左边还是在右边是没区别的），于是我们便顺着“绿色”（即jLink）指针继续寻找，继续找到2—1（同样的，B也是在右边这个位置上的），4—1（B在右边），接着继续找“绿色”结点，为空，则到此为止找到所有和B相连的边的信息。</p>
</blockquote>
<p>可见，利用邻接多重表想要找到某顶点的所有边是很方便的。同时每个边只对应一份边结点的数据，因此，就不必像邻接表那样，同时维护两份冗余的数据，可以保证我们在删除一个结点或删除一条边的时候，操作会方便很多。</p>
<blockquote>
<p>比如，现在我们要删除A—B这条边。这条边对应的结点是0—1这个结点。那么我们想要把这个结点删掉，并且重新改变A结点、B结点的指针域，指向这个被删除结点的下一个结点即可。那么，A结点的指针域需要顺着被删除结点的“橙色”指针，指到下一个结点上去；B结点的指针域需要顺着被删除结点的“绿色”指针，指到下一个节点上去。<br><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-134.png" style="zoom: 50%;" /></p>
</blockquote>
<blockquote>
<p>比如，要删除E这个顶点。</p>
<p>那么除了删除E这个顶点外，还需要删除与E相连的所有边。</p>
<p>通过与E相连的指针，可以找到，4—1和2—4两条边。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-135.png" style="zoom: 33%;" />

<p>此时需要注意，将这两个边结点删除之后，会影响到另外两个指针的指向问题。即2—1中的“1”，和2—3中的“2”的下一结点指针指向。</p>
<p>不过，可以看到，对于2—1的“绿色”指针，它指向4—1后便停止了，没有再指向下一个结点。因此将4—1删除后，只需修改2—1的“绿色”指针为空即可。另一个受影响的结点同理。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-136.png" style="zoom:50%;" />
</blockquote>
<p><strong>空间复杂度</strong>:<font color='orange'>O(|V|+|E|)</font></p>
<p>顶点结点:</p>
<ul>
<li>data：存储此顶点的数据；</li>
<li>firstedge：指针域，用于指向同该顶点有直接关联的存储其他顶点的节点。</li>
</ul>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-36.png" style="zoom:80%;" />

<p>边结点:</p>
<ul>
<li>mark：标志域，用于标记此节点是否被操作过，例如在对图中顶点做遍历操作时，为了防止多次操作同一节点，mark 域为 0 表示还未被遍历；mark 为 1 表示该节点已被遍历；</li>
<li>ivex 和 jvex：数据域，分别存储图中各边两端的顶点所在数组中的位置下标；</li>
<li>ilink：指针域，指向下一个存储与 ivex 有直接关联顶点的节点；</li>
<li>jlink：指针域，指向下一个存储与 jvex 有直接关联顶点的节点；</li>
<li>info：指针域，用于存储与该顶点有关的其他信息，比如无向网中各边的权；</li>
</ul>
<p><font color='red'>注意:邻接多重表只适用于存储无向图</font></p>
<p>邻接多重表的整体结构:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20                   <span class="comment">//图中顶点的最大个数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InfoType int                        <span class="comment">//边含有的信息域的数据类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VertexType int                      <span class="comment">//图顶点的数据类型</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>unvisited,visited&#125;VisitIf;    <span class="comment">//边标志域</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EBox</span>&#123;</span></span><br><span class="line">    VisitIf mark;                           <span class="comment">//标志域</span></span><br><span class="line">    <span class="type">int</span> ivex,jvex;                          <span class="comment">//边两边顶点在数组中的位置下标</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EBox</span> * <span class="title">ilink</span>,*<span class="title">jlink</span>;</span>             <span class="comment">//分别指向与ivex、jvex相关的下一个边</span></span><br><span class="line">    InfoType *info;                         <span class="comment">//边包含的其它的信息域的指针</span></span><br><span class="line">&#125;EBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VexBox</span>&#123;</span></span><br><span class="line">    VertexType data;                        <span class="comment">//顶点数据域</span></span><br><span class="line">    EBox * firstedge;                       <span class="comment">//顶点相关的第一条边的指针域</span></span><br><span class="line">&#125;VexBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VexBox adjmulist[MAX_VERTEX_NUM];<span class="comment">//存储图中顶点的数组</span></span><br><span class="line">    <span class="type">int</span> vexnum,degenum;<span class="comment">//记录途中顶点个数和边个数的变量</span></span><br><span class="line">&#125;AMLGraph;</span><br></pre></td></tr></table></figure>

<p><code>总结</code></p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-184.png" style="zoom:67%;" />

<p><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-185.png"></p>
<p>对于十字链表和邻接多重表，其实现方式比较复杂。所以在考研当中不太可能让大家用手写的方式来实现十字链表和邻接多重表。因此这两种实现方式，只需要理解它们的一些特性就可以。</p>
<ul>
<li>十字链表用来存放有向图，可以解决在邻接矩阵中空间复杂度较高的问题，以及在邻接表中不方便查找入度、入边的问题。</li>
<li>邻接多重表用来存放无向图，可以解决邻接矩阵中空间复杂度较高的问题，以及在邻接表中存放无向图需要存放两份冗余数据，导致删除边、删除顶点操作较复杂的问题。</li>
<li>另外，对于一个给定的图，采用十字链表或是邻接多重表，表示方式都是不唯一的。</li>
</ul>
<h3 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h3><ul>
<li>Adjacent(G, x, y)</li>
<li>Neighbors(G, x)</li>
<li>InsertVertex(G, x)</li>
<li>AddEdge(G, x, y)</li>
<li>RemoveEdge(G, x, y)</li>
<li>FirstNeighbor(G, x)</li>
<li>NextNeighbor(G, x, y)</li>
<li>Get_edge_value(G, x, y)</li>
<li>Set_edge_value(G, x, y, v)</li>
</ul>
<p>那么基本操作的实现，还是和图的存储结构密不可分的。</p>
<p>我们说过，考研当中最常考的还是邻接矩阵和邻接表法。（因为十字链表和邻接多重表实现起来较为复杂，所以不太会考察代码的书写而只考察性质的理解）</p>
<p>此外还有图的遍历算法见下一节</p>
<h3 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h3><ul>
<li><p>4 带权有向图G用邻接矩阵存储，则vi的入度等于邻接矩阵中→D</p>
<p>A 第i行非∞的元素个数<br>B 第i列非∞的元素个数<br>C 第i行非∞且非0的元素个数<br>D 第i列非∞且非0的元素个数</p>
</li>
<li><p>13 假设有n个顶点、e条边的有向图用邻接表表示，则删除与某个顶点v相关的所有边的时间复杂度为多少？答案→O(n+e)</p>
</li>
<li><p>综合【2015】已知含有5个顶点的图G如下图所示。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-37.png" style="zoom:50%;" />

<p>请回答下列问题： </p>
<p>1）写出图 G 的邻接矩阵 A（行、列下标从 0 开始）。 </p>
<p>2）求 A²，矩阵 A^2中位于 0 行 3 列元素值的含义是什么？ </p>
<p>3）若已知具有 n（n≥2）个顶点的图的邻接矩阵为B，则 B^m（2≤m≤n）中非零元素的含义是什么？</p>
<blockquote>
<p>1)图G的邻接矩阵A如下:<br>$$<br>A=\left[<br>\begin{matrix}<br>0 &amp; 1 &amp; 1 &amp; 0 &amp; 1\<br>1 &amp; 0 &amp; 0 &amp; 1 &amp; 1\<br>1 &amp; 0 &amp; 0 &amp; 1 &amp; 0\<br>0 &amp; 1 &amp; 1 &amp; 0 &amp; 1\<br>1 &amp; 1 &amp; 0 &amp; 1 &amp;0<br>\end{matrix}<br>\right]<br>$$<br>2）A²如下:<br>$$<br>A^2=\left[<br>\begin{matrix}<br>3 &amp; 1 &amp; 0 &amp; 3 &amp; 1\<br>1 &amp; 3 &amp; 2 &amp; 1 &amp; 2\<br>0 &amp; 2 &amp; 2 &amp; 0 &amp; 2\<br>3 &amp; 1 &amp; 0 &amp; 3 &amp; 1\<br>1 &amp; 2 &amp; 2 &amp; 1 &amp; 3<br>\end{matrix}<br>\right]<br>$$<br>0行3列的元素值3表示从顶点0到顶点3之间长度为2的路径共有3条</p>
<p>3)B^m(2&lt;=m&lt;=n)中位于i行j列(0&lt;=i,j&lt;=n-1)的非零元素的含义是:图中从顶点i到顶点j长度为m的路径条数。</p>
</blockquote>
</li>
<li><p>【2021】已知无向连通图G由顶点集V和边集E组成，|E| &gt;0,当G中度为奇数的顶点个数为不大于2的偶数时，G存在包含所有边且长度为|E|的路径（称为EL路径）。设图G采用邻接矩阵存储类型定义如下;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> <span class="comment">//图的定义</span></span><br><span class="line"><span class="type">int</span> numVertices,numEdges;</span><br><span class="line"><span class="comment">//图中实际的顶点数和边数</span></span><br><span class="line"><span class="type">char</span> Vericeslist[MAXV];</span><br><span class="line"><span class="comment">//顶点表。MAXV为已定义常量</span></span><br><span class="line"><span class="type">int</span> Edge[MAXV][MAXV];</span><br><span class="line"><span class="comment">// 邻接矩阵</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure>

<p>请设计算法∶int IsExistEL（MGraph G），判断 G是否存在 EL 路径，若存在，则返回1，否则，返回 0。要求：<br>（1）给出算法的基本设计思想。<br>（2）根据设计思想，，采用C或C++语言描述算法，关键之处给出注释。<br>（3）说明你所设计算法的时间复杂度和空间复杂度。</p>
<blockquote>
<p>（1）算法的基本设计思想<br>对于采用邻接矩阵存储的无向图，邻接矩阵每一行（列）中非零元素的个数为本行（列）对应顶点的度。可以依次计算连通图 G中各顶点的度，并记录度为奇数的顶点个数，若个数为0或2，则返回1，否则返回0。</p>
<p>（2）算法实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">IsExistEL</span><span class="params">(MGraph G)</span>&#123;</span><br><span class="line"><span class="comment">//采用邻接矩阵存储，判断图是否存在 EL路径</span></span><br><span class="line"><span class="type">int</span> degree,i,j,count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.numVertices;i++)&#123;</span><br><span class="line">    degree=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.numVertices;j++)</span><br><span class="line">        degree+=G.Edge[i][j]; <span class="comment">//依次计算各个顶点的度</span></span><br><span class="line">    <span class="keyword">if</span>(degree%<span class="number">2</span>! =<span class="number">0</span>)</span><br><span class="line">        count++; <span class="comment">//对度为奇数的顶点计数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(count == <span class="number">0</span> || count == <span class="number">2</span>)</span><br><span class="line"> <span class="keyword">return</span> l; <span class="comment">//存在 EL路径，返回1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//不存在 EL路径，返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）时间复杂度是O（n²），空间复杂度是0（1）</p>
</blockquote>
</li>
</ul>
<h2 id="6-3-图的遍历"><a href="#6-3-图的遍历" class="headerlink" title="6.3 图的遍历"></a>6.3 图的遍历</h2><h3 id="深度优先和广度优先遍历-可先点开看"><a href="#深度优先和广度优先遍历-可先点开看" class="headerlink" title="深度优先和广度优先遍历(可先点开看)"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/wdy00000/article/details/123295871">深度优先和广度优先遍历</a>(可先点开看)</h3><p>从已给的连通图中某一顶点出发，沿着一些边访遍图中的所有的顶点，且使每个顶点仅被访问依次，就叫做图的遍历，它是图的基本运算。</p>
<p>图中可能存在回路，且图的任一顶点都可能与其他顶点相通，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。那么怎么样避免重复访问呢？</p>
<p>解决思路：设置辅助数组 visited[n]，用来标记每个被访问过的顶点。</p>
<ul>
<li>初始状态 visited[i] 为0</li>
<li>顶点i被访问，改visited[i]为1，防止被多次访问</li>
</ul>
<h3 id="广度优先搜索-Breadth-First-Search-BFS"><a href="#广度优先搜索-Breadth-First-Search-BFS" class="headerlink" title="广度优先搜索 Breadth-First-Search, BFS"></a>广度优先搜索 Breadth-First-Search, BFS</h3><p>广度优先搜索算法(Breadth First Search)，又称为”宽度优先搜索”或”横向优先搜索”，简称BFS</p>
<p>方法如下：</p>
<p>从图的某一顶点出发，首先依次访问该结点的所有邻接点Vi1，Vi2，Vi3…Vin ，再按这些顶点被访问的先后次序依次访问与它们想邻接的所有未被访问的顶点。重复此过程，直至所有顶点均被访问为止。</p>
<p>换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2…的顶点。</p>
<h4 id="无向图的广度优先搜索"><a href="#无向图的广度优先搜索" class="headerlink" title="无向图的广度优先搜索"></a>无向图的广度优先搜索</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-38.png" style="zoom: 50%;" />

<p><strong>第1步</strong>：访问A。</p>
<p><strong>第2步</strong>：依次访问C,D,F。<br>  在访问了A之后，接下来访问A的邻接点。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，C在”D和F”的前面，因此，先访问C。再访问完C之后，再依次访问D,F。</p>
<p><strong>第3步</strong>：依次访问B,G。<br>  在第2步访问完C,D,F之后，再依次访问它们的邻接点。首先访问C的邻接点B，再访问F的邻接点G。</p>
<p><strong>第4步</strong>：访问E。<br>  在第3步访问完B,G之后，再依次访问它们的邻接点。只有G有邻接点E，因此访问G的邻接点E。</p>
<p>因此访问顺序是：<strong>A -&gt; C -&gt; D -&gt; F -&gt; B -&gt; G -&gt; E</strong></p>
<hr>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-186.png" style="zoom:50%;" />

<p>比如我们从2号结点出发，开始进行图的广度优先遍历。</p>
<p>那同样地，首先我们找到2号结点。然后，找到与之相连的1、6号结点。</p>
<p>再由1、6出发，找到与它们相连的5、3、7号结点。</p>
<p>接着，再由5、3、7号结点，找到它们更下一层的结点，4、8。</p>
<h4 id="有向图的广度优先搜索"><a href="#有向图的广度优先搜索" class="headerlink" title="有向图的广度优先搜索"></a>有向图的广度优先搜索</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-39.png" style="zoom: 50%;" />

<p><strong>第1步</strong>：访问A。</p>
<p><strong>第2步</strong>：访问B。</p>
<p><strong>第3步</strong>：依次访问C,E,F。<br>  在访问了B之后，接下来访问B的出边的另一个顶点，即C,E,F。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，因此会先访问C，再依次访问E,F。</p>
<p><strong>第4步</strong>：依次访问D,G。<br>  在访问完C,E,F之后，再依次访问它们的出边的另一个顶点。还是按照C,E,F的顺序访问，C的已经全部访问过了，那么就只剩下E,F；先访问E的邻接点D，再访问F的邻接点G。</p>
<p>因此访问顺序是：<strong>A -&gt; B -&gt; C -&gt; E -&gt; F -&gt; D -&gt; G</strong></p>
<h4 id="非连通图的广度优先遍历"><a href="#非连通图的广度优先遍历" class="headerlink" title="非连通图的广度优先遍历"></a>非连通图的广度优先遍历</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-40.png" style="zoom: 50%;" />

<h4 id="树VS图"><a href="#树VS图" class="headerlink" title="树VS图"></a>树VS图</h4><p>图的广度优先遍历，这个过程其实和树的广度优先是很类似的。我们看看有什么联系和区别。</p>
<p>首先，不论是树还是图的广度优先遍历，我们都需要实现这样一个操作，就是通过某一个结点，找到与之相邻的其它结点。因为只有实现了这个操作，我们才有可能一层一层的往下找到所有的结点。</p>
<p>对于树来说，找到与之相邻的其他结点，其实就是找它的孩子结点。而对于图来说，我们可以利用之前学过的两个基本操作来完成这件事情。</p>
<p>另外，对于树来说，是不存在“回路”的，搜索相邻的结点时，不可能搜到已经访问过的结点。而对于图来说，搜索相邻的结点时，有可能搜索到已经访问过的顶点，所以我们需要对这一问题进行处理，而处理起来也很简单， 我们只需要对每个结点进行一个标记来表示有没有被访问过就可以了。</p>
<h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-41.png" style="zoom: 80%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];<span class="comment">//访问标记数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span>&#123; <span class="comment">//从顶点v出发，广度优先遍历图G</span></span><br><span class="line">    visit(v);   <span class="comment">//访问初始顶点v</span></span><br><span class="line">    visited[v]=TRUE;   <span class="comment">//对v做已访问标记</span></span><br><span class="line">    Enqueue(Q,v);    <span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,v);  <span class="comment">//顶点v出队列</span></span><br><span class="line">        <span class="keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,v,w)) <span class="comment">//检测v所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;  <span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">                visit(w);    <span class="comment">//访问顶点w</span></span><br><span class="line">                visited[w]=TRUE;<span class="comment">//对w做已访问标记</span></span><br><span class="line">                EnQueue(Q,w);  <span class="comment">//顶点w入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，对于<code>visited[]</code>数组，刚开始我们把它全部设为false，并且数组的下标和各个结点的编号是一一对应的。（此处为了与顶点编号对应，数组的0号下标弃置不用）</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-248.png" style="zoom: 55%;" />

<blockquote>
<p>对于上图：</p>
<p>从顶点2出发得到的广度优先遍历序列：<code>2 1 6 5 3 7 4 8</code></p>
<p>从顶点1出发得到的广度优先遍历序列：<code>1 2 5 6 3 7 4 8</code></p>
<p>从顶点3出发得到的广度优先遍历序列：<code>3 4 6 7 8 2 1 5</code></p>
</blockquote>
<p><strong>遍历序列的可变性</strong></p>
<p>每一“层”的顶点，应该按照什么样的一个顺序？</p>
<p>实际上，这要看是按照什么存储结构来存储的。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-249.png" style="zoom:55%;" />

<ul>
<li>如果是用邻接表存储的，由于每个顶点后面的链表中，结点的顺序是不确定的，所以顺序不确定。这个遍历序列是可变的，是不唯一的。<ul>
<li>即：同一个图的<strong>邻接矩阵</strong>表示方式<strong>唯一</strong>，因此广度优先<strong>遍历序列唯一</strong>。</li>
</ul>
</li>
<li>如果是用邻接矩阵存储的，由于遍历某顶点的所有边，是按照该结点在矩阵中对应行的一个从左向右的遍历，所以遍历出来的序列应该是按照由小到大的一个递增的顺序。（一定是这样的）这个遍历序列是唯一的。<ul>
<li>即：同一个图的<strong>邻接表</strong>表示方式<strong>不唯一</strong>，因此广度优先<strong>遍历序列不唯一</strong>。</li>
</ul>
</li>
</ul>
<p><strong>算法存在的问题</strong></p>
<p>至此，我们发现一个问题。</p>
<p>刚刚对于图的广度优先遍历，无论是从哪个顶点出发，都是能够遍历到图中所有顶点的。</p>
<p>这是因为它是一个连通图。如果是非连通图，则无法遍历完所有结点。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-250.png" style="zoom:55%;" />

<p>对于一个非连通图来说，通过刚才的代码。例如从2号结点出发，就没有办法访问到9、10、11三个结点。</p>
<p><strong>怎么解决？</strong></p>
<p>我们不是定义了一个<code>visited[]</code>数组吗，这个数组记录了所有顶点是否已经被访问的信息。那么当我们在第一次调用BFS这个函数遍历完毕之后，可以检查一下在visited数组当中能否找到值为false的顶点，如果能找到，那么从这个顶点出发，再次调用BFS这个函数，就可以了。</p>
<h4 id="BFS算法-Final版"><a href="#BFS算法-Final版" class="headerlink" title="BFS算法(Final版)"></a>BFS算法(Final版)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];<span class="comment">//访问标记数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTraverse</span><span class="params">(Graph G)</span>&#123; <span class="comment">//对图G进行广度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)</span><br><span class="line">        visited[i]=FALSE;   <span class="comment">//访问标记数组初始化</span></span><br><span class="line">    InitQueue(Q);           <span class="comment">//初始化辅助队列Q</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i) <span class="comment">//从0号顶点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i])     <span class="comment">//对每个连通分量调用一次BFS</span></span><br><span class="line">            BFS(G,i);       <span class="comment">//vi未访问过，从vi开始BFS</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span>&#123; <span class="comment">//从顶点v出发，广度优先遍历图G</span></span><br><span class="line">    visit(v);   <span class="comment">//访问初始顶点v</span></span><br><span class="line">    visited[v]=TRUE;   <span class="comment">//对v做已访问标记</span></span><br><span class="line">    Enqueue(Q,v);    <span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,v);  <span class="comment">//顶点v出队列</span></span><br><span class="line">        <span class="keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,v,w)) </span><br><span class="line">            <span class="comment">//检测v所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;  <span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">                visit(w);    <span class="comment">//访问顶点w</span></span><br><span class="line">                visited[w]=TRUE;<span class="comment">//对w做已访问标记</span></span><br><span class="line">                EnQueue(Q,w);  <span class="comment">//顶点w入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-251.png" style="zoom:55%;" />

<p>到此，我们就可以遍历完非连通图里的所有结点。此外，对于<strong>无向图</strong>，<strong>调用BFS函数的次数 = 连通分量数</strong>。</p>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>对于空间复杂度来说，其关键是要看辅助队列所需要的空间大小。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-46.png" style="zoom:67%;" />

<p>再看时间复杂度。在这个BFS算法中，我们首先要visit(v)这个顶点，其次对于每个顶点，我们还需要探索其所有的边。所以我们可以简要的认为，它的时间开销主要用于，探索每个顶点，和探索每条边。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-252.png" style="zoom:55%;" />

<blockquote>
<p>可以看出，这个算法的时间复杂度的分析，并不是单纯地看最深层循环的次数。</p>
<p>而是看关键代码的次数。这个算法的关键代码在于visit(v)，和深层for循环，两者兼具（访问顶点+找各条边）。</p>
<p>这是由问题的实际过程考虑得出的，而不要一味地只顾最深层循环。</p>
</blockquote>
<h4 id="广度优先生成树"><a href="#广度优先生成树" class="headerlink" title="广度优先生成树"></a>广度优先生成树</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-137.png" style="zoom: 33%;" />

<p>标红的这些边，表示这个结点在被访问的时候，是由哪条边过去的。例如4号结点，在被访问到的时候，是由3号结点过去的，而不是由7或8过去的。</p>
<p>对于这个n个结点的图来说，我们总共标红了n-1条边。如果把其余的那些边去掉，那么这个图其实就变成了树，因为它里面已经没有回路存在了。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-138.png" style="zoom: 33%;" />

<p>那么这就是这个图的广度优先生成树。</p>
<p>这个生成树是由广度优先遍历，遍历的顺序得来的。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-139.png" style="zoom:67%;" />

<blockquote>
<p>注意其中遍历序列的顺序。例如，由6得来的结点，有3、7，但是要注意在这个实际存储当中，是3在前、7在后的。</p>
<p>而，如果按照下面的存储，那么生成树中的次序也会随之改变，如下。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-140.png" style="zoom: 67%;" />
</blockquote>
<p>可以看到，两棵广度优先生成树，是有区别的。</p>
<p>广度优先生成树由广度优先遍历过程确定。由于邻接表的表示方式不唯一，因此基于邻接表的广度优先生成树也不唯一。</p>
<p>但是如果一个图是用邻接矩阵来存储的，那么它的广度优先生成树肯定也是唯一的了</p>
<p>可以看看下面的视频：</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1sS4y1p7v2?spm_id_from=333.337.search-card.all.click&vd_source=278af11bcc7fe34571197ce600d488f4">暨大830数据结构每周一讲-广度优先生成树</a></p>
<h4 id="广度优先生成森林"><a href="#广度优先生成森林" class="headerlink" title="广度优先生成森林"></a>广度优先生成森林</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-187.png" style="zoom:43%;" />

<p>对非连通图的广度优先遍历，可以得到广度优先生成森林。很好理解，对于其中的每一个连通分量，都能得到一个广度优先生成树。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-188.png" style="zoom:43%;" />

<p>这两棵树放在一起，就可以组成一个广度优先生成森林。</p>
<h3 id="深度优先搜索-Depth-First-Search-DFS"><a href="#深度优先搜索-Depth-First-Search-DFS" class="headerlink" title="深度优先搜索 Depth-First-Search, DFS"></a>深度优先搜索 Depth-First-Search, DFS</h3><p>它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p>
<p>方法如下：</p>
<ul>
<li>在访问图中某一起始顶点 v 后，由 v 出发，访问它的任一邻接顶点W1</li>
<li>再从 W1 出发，访问与 W1 邻接但还未被访问过的顶点W2</li>
<li>然后再从 W2 出发，进行类似的访问</li>
<li>如此进行下去，直至到达所有的邻接顶点都被访问过的顶点u为止</li>
<li>接着，退回一步，退到前一次刚访问过的顶点，看是否还有其他没有被访问的邻接顶点</li>
<li>如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问</li>
<li>如果没有，那就再退回一步进行搜索。重复上述过程，直到连通图中的所有顶点都被访问过为止。</li>
</ul>
<h4 id="无向图的深度优先搜索"><a href="#无向图的深度优先搜索" class="headerlink" title="无向图的深度优先搜索"></a>无向图的深度优先搜索</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-48.png" style="zoom:67%;" />

<p><strong>第1步</strong>：访问A。</p>
<p><strong>第2步</strong>：访问(A的邻接点)C。<br>  在第1步访问A之后，接下来应该访问的是A的邻接点，即”C,D,F”中的一个。但在本文的实现中，顶点ABCDEFG是按照顺序存储，C在”D和F”的前面，因此，先访问C。</p>
<p><strong>第3步</strong>：访问(C的邻接点)B。<br>  在第2步访问C之后，接下来应该访问C的邻接点，即”B和D”中一个(A已经被访问过，就不算在内)。而由于B在D之前，先访问B。</p>
<p><strong>第4步</strong>：访问(C的邻接点)D。<br>  在第3步访问了C的邻接点B之后，B没有未被访问的邻接点；因此，返回到访问C的另一个邻接点D。</p>
<p><strong>第5步</strong>：访问(A的邻接点)F。<br>  前面已经访问了A，并且访问完了”A的邻接点B的所有邻接点(包括递归的邻接点在内)”；因此，此时返回到访问A的另一个邻接点F。</p>
<p><strong>第6步</strong>：访问(F的邻接点)G。</p>
<p><strong>第7步</strong>：访问(G的邻接点)E。</p>
<p>因此访问顺序是：<strong>A -&gt; C -&gt; B -&gt; D -&gt; F -&gt; G -&gt; E</strong></p>
<h4 id="有向图的深度优先搜索"><a href="#有向图的深度优先搜索" class="headerlink" title="有向图的深度优先搜索"></a>有向图的深度优先搜索</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-49.png" style="zoom:67%;" />

<p><strong>第1步</strong>：访问A。</p>
<p><strong>第2步</strong>：访问B。<br>  在访问了A之后，接下来应该访问的是A的出边的另一个顶点，即顶点B。</p>
<p><strong>第3步</strong>：访问C。<br>  在访问了B之后，接下来应该访问的是B的出边的另一个顶点，即顶点C,E,F。在本文实现的图中，顶点ABCDEFG按照顺序存储，因此先访问C。</p>
<p><strong>第4步</strong>：访问E。<br>  接下来访问C的出边的另一个顶点，即顶点E。</p>
<p><strong>第5步</strong>：访问D。<br>  接下来访问E的出边的另一个顶点，即顶点B,D。顶点B已经被访问过，因此访问顶点D。</p>
<p><strong>第6步</strong>：访问F。<br>  接下应该回溯”访问A的出边的另一个顶点F”。</p>
<p><strong>第7步</strong>：访问G。</p>
<p>因此访问顺序是：<strong>A -&gt; B -&gt; C -&gt; E -&gt; D -&gt; F -&gt; G</strong></p>
<h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];	<span class="comment">//访问标记数组（初始都为false）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span> &#123;	<span class="comment">//从顶点v出发，深度优先遍历图G</span></span><br><span class="line">    visit(v);	<span class="comment">//访问顶点v</span></span><br><span class="line">    visited[v] = TRUE;	<span class="comment">//设已访问标记</span></span><br><span class="line">    <span class="keyword">for</span>(w = FirstNeighbor(G,v); w&gt;=<span class="number">0</span>; w = NextNeighbor(G,v,w)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])&#123;	<span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">            DFS(G,w);</span><br><span class="line">        &#125;<span class="comment">//if</span></span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-141.png" style="zoom: 50%;" />

<blockquote>
<p>如果由2号顶点出发。</p>
<p>2号顶点有子树1，则访问1号，1号还有子树5，则继续访问5号。</p>
<p>5号执行结束没有子树，则返回到1号结点，1号没有其他子树，则返回到2号顶点。</p>
<p>找到2号顶点的下一个邻接点，即6号顶点。</p>
<p>和6号相邻的，访问3号结点，接着访问4号顶点，接着访问7号结点，接着访问8号顶点。</p>
<p>8号执行完后，由于与之相邻的所有顶点都已经被访问过，因此可以结束执行，向上返回，一路返回到最上层。最终整个函数执行完毕。</p>
<p>从2出发的深度遍历序列：2 1 5 6 3 4 7 8。</p>
</blockquote>
<p><strong>算法存在的问题</strong></p>
<p>这段代码也存在类似的问题，就是，如果是非连通图，则无法遍历完所有结点</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-50.png" style="zoom:80%;" />

<p>处理的方法类似。</p>
<p>我们在进行了一次DFS后，还可以扫描一次visited[]数组，如果在这个数组中发现了有某一个元素，它依然是false，那么就说明与之相对应的顶点是没有被访问过的，那么我们再从这个顶点出发再调用一次DFS函数就可以了。</p>
<h4 id="DFS算法-Final版"><a href="#DFS算法-Final版" class="headerlink" title="DFS算法(Final版)"></a>DFS算法(Final版)</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-51.png" style="zoom:80%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];	<span class="comment">//访问标记数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(Graph G)</span> &#123;		<span class="comment">//对图G进行深度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>; v&lt;G.vexnum; ++v) &#123;</span><br><span class="line">        visited[v] = FALSE;		<span class="comment">//初始化已访问标记数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>; v&lt;G.vexnum; ++v) &#123;	<span class="comment">//本代码中是从v=0开始遍历（也可以从1开始）</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[v]) &#123;</span><br><span class="line">            DFS(G, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span> &#123;	<span class="comment">//从顶点v出发，深度优先遍历图G</span></span><br><span class="line">    visit(v);	<span class="comment">//访问顶点v</span></span><br><span class="line">    visited[v] = TRUE;	<span class="comment">//设已访问标记</span></span><br><span class="line">    <span class="keyword">for</span>(w=FirstNeighbor(G,v); w&gt;=<span class="number">0</span>; w=NextNeighbor(G,v,w)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[w]) &#123;	<span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">            DFS(G,w);</span><br><span class="line">        &#125;<span class="comment">//if</span></span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-52.png" style="zoom:67%;" />

<p>**最坏情况，递归深度为O(|V|)**。即，从1号顶点出发进行深度优先遍历，一直遍历到8号，才能发现其没有继续的子树，才能结束DFS并依次返回。那么此时函数调用栈中存放了8层递归。</p>
<p>**最好情况，O(1)**。找到一个子树就结束DFS并返回上级。那么我们的递归调用栈只会有2层。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-53.png" style="zoom:80%;" />

<p>广度优先和深度优先，都可以把代码的时间开销简化为访问各结点+探索各条边的时间开销。</p>
<p>无论是广度优先还是深度优先，其时间复杂度都是分为邻接矩阵和邻接表两种存储方式讨论的。</p>
<h3 id="图的遍历与图的连通性"><a href="#图的遍历与图的连通性" class="headerlink" title="图的遍历与图的连通性"></a>图的遍历与图的连通性</h3><p>图的遍历算法可以用来判断图的连通性。</p>
<p>对于无向图来说，如果无向图是连通的，则从任一结点出发，仅需一次遍历就能够访问图中所有顶点；</p>
<p>如果无向图是非连通的，则从某一个顶点出发，一次遍历只能访问到该顶点所在连通分量的所有顶点，而对于图中其他连通分量的顶点无法通过这次遍历访问。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-255.png" style="zoom:67%;" />

<p>对于有向图来说，若从初始点到图中的每个顶点都有路径，则能够访问图中的所有顶点，否则不能访问到所有顶点。</p>
<p>故而在BFSTraverse()和DFSTraverse()中添加了第二个for循环，再选取初始点，继续进行遍历，以防止一次无法遍历图中所有顶点。</p>
<p>对于无向图，上述两个函数调用BFS(G,i)或DFS(G,i)的次数等于图中的连通分量树；</p>
<p>而对于有向图，则不是这样没因为一个连通的有向图分为强连通的和非强连通的，它的连通子图也分为强连通分量和非强连通分量，非强连通分量一次调用BFS(G,i)或DFS(G,i)无法访问到该连通分量的所有顶点。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-256.png" style="zoom:67%;" />

<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/37792015">https://zhuanlan.zhihu.com/p/37792015</a></p>
<h3 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h3><ul>
<li><p>【2013】若对如下无向图进行遍历，则下列选项中，不是广度优先遍历序列的是–&gt;D</p>
<p>A.h，c，a，b，d，e，g，f    B.e，a，f，g，b，h，c，d</p>
<p>C.d，b，c，a，h，e，f，g    D.a，b，c，d，h，e，f，g</p>
<p><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-54.png"></p>
<blockquote>
<p>图的广度优先遍历，类似树的层序遍历，需要借助辅助队列实现。 以A答案为例，从结点h开始访问，h先入队。此时队列非空，h出队，然后依次访问与h邻接但未被访问过的c，a结点，c,a结点入队。此时队列非空，取出队头元素c，依次访问与c邻接但未被访问过的结点b,d，b,d结点入队(现在队列中有abd)。队列非空，取出队头元素a，依次访问与a结点邻接但未访问过的e结点，e入队。后面的操作类似，在整个执行过程中，结点被访问的次序是hcabdegf。D是深度优先遍历</p>
</blockquote>
</li>
<li><p>【2015】设有向图 G=(V, E)，顶点集 V={V0, V1, V2, V3}，边集E={&lt;v0,v1&gt;, &lt;v0,v2&gt;, &lt;v0,v3&gt;, &lt;v1,v3&gt;}。若从顶点 V0 开始对图进行深度优先遍历，则可能得到的不同遍历序列个数是 –&gt;5</p>
<blockquote>
<p>画出该有向图图形如下：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-55.png" style="zoom:80%;" />

<p>采用图的深度优先遍历，共5种可能&lt;v0, v1, v3, v2&gt;，&lt;v0, v2, v3, v1&gt;，&lt;v0, v2, v1, v3&gt;，&lt;v0, v3, v2, v1&gt;，&lt;v0, v3, v1, v2&gt;</p>
</blockquote>
</li>
<li><p>【2016】下列选项中，不是下图深度优先搜索序列的是–&gt;D</p>
<p><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds6-56.png"></p>
<p>　　A.V1，V5，V4，V3，V2 B.V1，V3，V2，V5，V4</p>
<p>　　C.V1，V2，V5，V4，V3 D.V1，V2，V3，V4，V5</p>
<blockquote>
<p>对于本题，只需按深度优先遍历的策略进行遍历即可。对于选项A：先访问V1，然后访问与V1邻接且未被访问的任一顶点（满足的有V2、V3和V5），此时访问V5，然后从V5出发，访问与V5邻接且未被访问的任一顶点（满足的只有V4），然后从V4出发，访问与V4邻接且未被访问的任一顶点（满足的只有V3），然后从V3出发，访问与V3邻接且未被访问的任一顶点（满足的只有V2），结束遍历。选项B和C的分析方法与选项A相同，不再赘述。对于选项D，首先访问V1，然后从V1出发，访问与V1邻接且未被访问的任一顶点（满足的有V2、V3和V5），然后从V2出发，访问与V2邻接且未被访问的任一顶点（满足的只有V5），按规则本应该访问V5，但选项D却访问V3，D错误。</p>
</blockquote>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://tikxeis.fun">kailin2eis</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://tikxeis.fun/p/63800/">http://tikxeis.fun/p/63800/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://tikxeis.fun" target="_blank">派总</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/408%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">408数据结构</a></div><div class="post_share"><div class="social-share" data-image="/img/1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/12342/"><img class="prev-cover" src="/img/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第六章 图(下)</div></div></a></div><div class="next-post pull-right"><a href="/p/56280/"><img class="next-cover" src="/img/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第五章 树与二叉树(下)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/p/24523/" title="第一章 绪论"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第一章 绪论</div></div></a></div><div><a href="/p/12625/" title="第二章 线性表(下)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第二章 线性表(下)</div></div></a></div><div><a href="/p/14457/" title="第二章 线性表(上)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第二章 线性表(上)</div></div></a></div><div><a href="/p/58315/" title="第三章 栈、队列和数组(下)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-28</div><div class="title">第三章 栈、队列和数组(下)</div></div></a></div><div><a href="/p/63528/" title="第三章 栈、队列和数组(上)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第三章 栈、队列和数组(上)</div></div></a></div><div><a href="/p/17647/" title="第四章 串"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-28</div><div class="title">第四章 串</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">kailin2eis</div><div class="author-info__description">派总's blog</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">6.1 图的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">图的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98"><span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">6.2 图的存储及基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%B3%95"><span class="toc-text">邻接矩阵法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-text">邻接矩阵表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91-%E5%B8%A6%E6%9D%83%E5%9B%BE-%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-text">网(带权图)的邻接矩阵表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%B3%95%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-text">邻接矩阵法的性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">邻接矩阵法的性能分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%B3%95"><span class="toc-text">邻接表法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-text">无向图的邻接表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-text">有向图的邻接表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-text">图的邻接表存储结构定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">邻接表的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%92%8C%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">邻接表和邻接矩阵的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8"><span class="toc-text">十字链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8"><span class="toc-text">邻接多重表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">图的基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-1"><span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">6.3 图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-%E5%8F%AF%E5%85%88%E7%82%B9%E5%BC%80%E7%9C%8B"><span class="toc-text">深度优先和广度优先遍历(可先点开看)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-Breadth-First-Search-BFS"><span class="toc-text">广度优先搜索 Breadth-First-Search, BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-text">无向图的广度优先搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-text">有向图的广度优先搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-text">非连通图的广度优先遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91VS%E5%9B%BE"><span class="toc-text">树VS图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BFS%E7%AE%97%E6%B3%95-Final%E7%89%88"><span class="toc-text">BFS算法(Final版)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">广度优先生成树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%94%9F%E6%88%90%E6%A3%AE%E6%9E%97"><span class="toc-text">广度优先生成森林</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-Depth-First-Search-DFS"><span class="toc-text">深度优先搜索 Depth-First-Search, DFS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-text">无向图的深度优先搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-text">有向图的深度优先搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DFS%E7%AE%97%E6%B3%95-Final%E7%89%88"><span class="toc-text">DFS算法(Final版)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1"><span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E4%B8%8E%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7"><span class="toc-text">图的遍历与图的连通性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-2"><span class="toc-text">习题</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/12342/" title="第六章 图(下)">第六章 图(下)</a><time datetime="2022-09-28T07:19:14.000Z" title="发表于 2022-09-28 15:19:14">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/63800/" title="第六章 图(上)">第六章 图(上)</a><time datetime="2022-09-28T07:04:39.000Z" title="发表于 2022-09-28 15:04:39">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/56280/" title="第五章 树与二叉树(下)">第五章 树与二叉树(下)</a><time datetime="2022-09-28T06:47:26.000Z" title="发表于 2022-09-28 14:47:26">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/48066/" title="第五章 树与二叉树(中)">第五章 树与二叉树(中)</a><time datetime="2022-09-28T06:37:49.000Z" title="发表于 2022-09-28 14:37:49">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/63944/" title="第五章 树与二叉树(上)">第五章 树与二叉树(上)</a><time datetime="2022-09-28T04:50:11.000Z" title="发表于 2022-09-28 12:50:11">2022-09-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By kailin2eis</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="关关雎鸠,在河之洲,窈窕淑女,what' your qq" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>