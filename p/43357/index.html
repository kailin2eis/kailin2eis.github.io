<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>第八章 排序(二) | 派总</title><meta name="keywords" content="408数据结构"><meta name="author" content="kailin2eis"><meta name="copyright" content="kailin2eis"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="8.3 交换排序冒泡排序 Bubble Sort算法思想从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即A[i-1] &gt; A[i]），则交换它们，直到序列比较完。称这样过程为“一趟”冒泡排序。    从后往前两两对比相邻元素，依次对27 49，13 27……进行对比 由于我们的目标是使整个表呈递增，因此，若后一个元素较小，则交换这两个元素。    第二趟同理。并且同样将最小的元素“冒">
<meta property="og:type" content="article">
<meta property="og:title" content="第八章 排序(二)">
<meta property="og:url" content="http://tikxeis.fun/p/43357/index.html">
<meta property="og:site_name" content="派总">
<meta property="og:description" content="8.3 交换排序冒泡排序 Bubble Sort算法思想从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即A[i-1] &gt; A[i]），则交换它们，直到序列比较完。称这样过程为“一趟”冒泡排序。    从后往前两两对比相邻元素，依次对27 49，13 27……进行对比 由于我们的目标是使整个表呈递增，因此，若后一个元素较小，则交换这两个元素。    第二趟同理。并且同样将最小的元素“冒">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://tikxeis.fun/img/1.png">
<meta property="article:published_time" content="2022-09-28T11:50:30.000Z">
<meta property="article:modified_time" content="2022-09-28T11:55:55.160Z">
<meta property="article:author" content="kailin2eis">
<meta property="article:tag" content="408数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tikxeis.fun/img/1.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://tikxeis.fun/p/43357/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第八章 排序(二)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-28 19:55:55'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><style>.mjpage .MJX-monospace {
  font-family: monospace;
}

.mjpage .MJX-sans-serif {
  font-family: sans-serif;
}

.mjpage {
  display: inline;
  font-style: normal;
  font-weight: normal;
  line-height: normal;
  font-size: 100%;
  font-size-adjust: none;
  text-indent: 0;
  text-align: left;
  text-transform: none;
  letter-spacing: normal;
  word-spacing: normal;
  word-wrap: normal;
  white-space: nowrap;
  float: none;
  direction: ltr;
  max-width: none;
  max-height: none;
  min-width: 0;
  min-height: 0;
  border: 0;
  padding: 0;
  margin: 0;
}

.mjpage * {
  transition: none;
  -webkit-transition: none;
  -moz-transition: none;
  -ms-transition: none;
  -o-transition: none;
}

.mjx-svg-href {
  fill: blue;
  stroke: blue;
}

.MathJax_SVG_LineBox {
  display: table !important;
}

.MathJax_SVG_LineBox span {
  display: table-cell !important;
  width: 10000em !important;
  min-width: 0;
  max-width: none;
  padding: 0;
  border: 0;
  margin: 0;
}

.mjpage__block {
  text-align: center;
  margin: 1em 0em;
  position: relative;
  display: block !important;
  text-indent: 0;
  max-width: none;
  max-height: none;
  min-width: 0;
  min-height: 0;
  width: 100%;
}
</style></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/1.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">派总</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">第八章 排序(二)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-28T11:50:30.000Z" title="发表于 2022-09-28 19:50:30">2022-09-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-28T11:55:55.160Z" title="更新于 2022-09-28 19:55:55">2022-09-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/408%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">408数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="第八章 排序(二)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="8-3-交换排序"><a href="#8-3-交换排序" class="headerlink" title="8.3 交换排序"></a>8.3 交换排序</h2><h3 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序 Bubble Sort"></a>冒泡排序 Bubble Sort</h3><h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><p>从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即A[i-1] &gt; A[i]），则交换它们，直到序列比较完。称这样过程为“一趟”冒泡排序。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-38.png" style="zoom:80%;" />

<blockquote>
<p>从后往前两两对比相邻元素，依次对<code>27 49</code>，<code>13 27</code>……进行对比</p>
<p>由于我们的目标是使整个表呈递增，因此，若后一个元素较小，则交换这两个元素。</p>
</blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-39.png" style="zoom:80%;" />

<p>第二趟同理。并且同样将最小的元素“冒”到最前面。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-40.png" style="zoom:80%;" />

<p>此时需要注意，之前已经确定位置的元素，不用再与之进行对比了。</p>
<p>因此，第二趟结束后，会导致，最小的两个元素已经“冒”到了最前边。</p>
<p>第三趟同理。同样地，之前确定过位置的元素不用再与之对比。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-41.png" style="zoom:80%;" />

<p>第三趟结束后，值最小的三个元素已经“冒”到了最前边。</p>
<p>第四趟同理，两两对比，该交换交换。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-42.png" style="zoom:80%;" />

<p><strong>当两个数的值相等时，我们不应该交换它们两个的位置，这么做能保证算法的稳定性。能保证原本在右边的元素不会跑到左边去。</strong></p>
<p>接下来，进行第五趟排序。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-43.png" style="zoom:80%;" />

<p>会发现，两两对比，每一对数字都不需要进行交换。那么这种情况其实说明，整体已经达到了一个有序的状态了。所以经过第五趟处理，我们就可以确定，整个表已经有序了，我们就不需要再进行后续的处理。</p>
<h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>理清楚逻辑之后，代码的理解就很简单了。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-287.png" style="zoom:67%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span> &#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">		<span class="type">bool</span> flag = <span class="literal">false</span>;	<span class="comment">//表示本趟冒泡是否发生交换的标志</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-1</span>; j&gt;i; j--)&#123;	<span class="comment">//一趟冒泡过程 </span></span><br><span class="line">			<span class="keyword">if</span>(A[j<span class="number">-1</span>] &gt; A[j])&#123;		<span class="comment">//若为逆序 </span></span><br><span class="line">				swap(A[j<span class="number">-1</span>], A[j]);	<span class="comment">//交换</span></span><br><span class="line">				flag = <span class="literal">true</span>; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag == <span class="literal">false</span>)</span><br><span class="line">			<span class="keyword">return</span>;		<span class="comment">//本趟遍历没有发生交换，说明表已经有序 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只有A[j-1] &gt; A[j]时才交换，相等时不交换，因此可以保证此算法是稳定的。</p>
</blockquote>
<h4 id="算法性能分析"><a href="#算法性能分析" class="headerlink" title="算法性能分析"></a>算法性能分析</h4><p><strong>空间复杂度</strong>：O(1)</p>
<p><strong>最好时间复杂度（有序）</strong>：O(n)</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-44.png" style="zoom:80%;" />

<blockquote>
<p>进行一趟冒泡排序即可确认有序。两两对比，对比次数为n-1次；交换次数为0次。</p>
</blockquote>
<p><strong>最坏时间复杂度（逆序）</strong>：O(n²)</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-45.png" style="zoom:80%;" />

<blockquote>
<p>每一趟，首先都是需要两两对比的，对比次数为n-1、n-2…</p>
<p>其次，由于原表是完全逆序的，因此每个关键字在进行每一次两两对比时，都需要进行交换操作。</p>
<p>比较次数 = (n-1) + (n-2) + … +1 = n(n-1)/2 = 交换次数</p>
</blockquote>
<p><strong>平均时间复杂度</strong>：O(n²)</p>
<blockquote>
<p>上面我们说的都是“交换”的次数。</p>
<p>而每次交换，都需要移动元素3次。（因为t = a; a = b; b = t;）</p>
<p>所以如果题目中说的是<strong>移动元素</strong>的次数，需要和<strong>交换元素</strong>的次数进行区分。</p>
</blockquote>
<p>稳定性：稳定。</p>
<p><strong>问：冒泡排序是否适用于链表？</strong></p>
<p>显然是可以的。我们可以从链头开始，从头到尾地进行冒泡排序，若逆序则交换。</p>
<blockquote>
<p>可从前往后”冒泡”，每一趟将更大的元素”冒”到链尾。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>冒泡排序</strong></p>
<ul>
<li>算法原理<ul>
<li>从后往前（或从前往后）两两比较相邻元素的值，若为逆序，则交换它们，直到序列比较完。称这样过程为“一趟”冒泡排序。最多只需n-1趟排序。</li>
<li>每一趟排序都可以使一个元素移动到最终位置，已经确定最终位置的元素在之后的处理中无需再对比。</li>
<li>如果某一趟排序过程中未发生“交换”，则算法可提前结束。</li>
</ul>
</li>
<li>性能<ul>
<li>空间复杂度：O(1)</li>
<li>时间复杂度<ul>
<li>最好（完全有序）：O(n)</li>
<li>最差（完全逆序）：O(n²)</li>
<li>平均：O(n²)</li>
</ul>
</li>
<li>稳定性：稳定</li>
<li>适用性：顺序表、链表都可以</li>
</ul>
</li>
</ul>
<h3 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序 Quick Sort"></a>快速排序 Quick Sort</h3><blockquote>
<p>“快速排序”，它的名字就起成这个样子，可以看出它这个算法还是比较优秀的。</p>
<p>事实上，我们学习的所有内部排序的排序算法中，快速排序确实是最优秀的。</p>
</blockquote>
<blockquote>
<p>在冒泡排序中，我们每一次都会使一个最大/最小元素确定它的最终位置。</p>
<p>而在快速排序中，我们每次都会使一个中间元素确定它的最终位置。</p>
</blockquote>
<h4 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h4><blockquote>
<p>在待排序表L[1…n]中任取一个元素pivot作为枢轴（或基准，通常取首元素），通过一趟排序将待排序表划分为独立的两部分L[1…k-1]和L[k+1…n]，使得L[1…k-1]中的所有元素小于pivot，L[k+1…n]中的所有元素大于等于pivot，则pivot放在了其最终位置L(k)上，这个过程称为一次“划分”。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上。</p>
</blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-46.png" style="zoom:80%;" />

<p>这是一个含有8个元素的待排序表。我们每次选择一个元素作为枢轴（或者基准），通常取第一个元素。</p>
<p>第一次取<code>49</code>为枢轴，接下来在一趟排序之后，我们应该能够找到49所要摆放的最终位置。</p>
<p>49这个元素在整个表当中，既不是最小的，也不是最大的，它应该处于一个中间位置。</p>
<p>所以，我们要确定49这个元素的最终位置，我们就需要对整个表进行一个调整，我们需要把这个表划分为左右两个部分，左半部分所有元素都要比49更小，而右半部分所有元素都要大于等于49这个基准元素。</p>
<p>这样的一次处理，我们把它称为一次“划分”。因为我们利用49作为基准，把整个表划分为了左右两个部分。</p>
<p><strong>我们看一下一次划分的具体过程</strong>：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-47.png" style="zoom:80%;" />

<p>首先，low和high分别指向我们要处理的这个序列的头、尾处。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-48.png" style="zoom:80%;" />

<p>然后，我们选择low所指向的这个元素，把它作为基准元素。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-49.png" style="zoom: 55%;" />



<p>接下来，我们会让low和high都向中间移动，把中间的元素都给扫描一遍。</p>
<p>在扫描的过程中，我们需要保证，high指针的右边，都是大于等于49的元素；而low指针的左边，都是小于49的元素。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-50.png" style="zoom: 67%;" />

<p>扫描的过程：</p>
<p>low所指位置当前为空，不动；</p>
<p>high所指的当前元素为49，是大于等于49的，不处理，指向下一处。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-51.png" style="zoom: 55%;" />

<p>high当前所指的元素为<code>27</code>，而27&lt;49，因此27最终需要放到low指针所指位置的左边，因此我们将27放到low指针指向的位置。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-52.png" style="zoom: 55%;" />

<p>此时，high所指的位置空出来了，那么我们接下来要将low指针向右扫描了。</p>
<p>当前low所指的元素为27，27&lt;49，所以不需要处理，指向下一处；</p>
<p>当前low所指的元素为38，38&lt;49，所以不需要处理，指向下一处；</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-53.png" style="zoom:80%;" />

<p>此时，low指向的元素<code>65</code>，65≥49，因此65需要放到high指针所指位置的右边。因此我们将65放到high所指的位置</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-54.png" style="zoom:80%;" />

<p>然后，low所指位置空了，所以接下来我们令high继续扫描。</p>
<p>当前high所指元素为65，65≥49，不需要处理，继续扫描；</p>
<p>当前high所指元素为13，13&lt;49，需要把13放到low指针所指位置。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-55.png" style="zoom:55%;" />

<p>接下来让low指针右移，进行扫描。</p>
<p>当前low所指元素为13，13&lt;49，不需要处理，继续扫描；</p>
<p>当前low所指元素为97，97≥49，需要将97放到high所指位置。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-56.png" style="zoom:55%;" />

<p>然后又让high指针左移进行扫描。</p>
<p>当前high所指元素为97，不需要处理，继续扫描；</p>
<p>当前high所指元素为76，不需要处理，继续扫描，即继续左移，high–-。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-57.png" style="zoom:80%;" />

<p>当low和high碰到一起的时候，就说明我们已经把所有待排序的元素都扫描了一遍，所有比基准元素更小的元素，我们都把它放到了low指针所指位置的左边；所有大于等于基准元素的元素，我们都把它放到了high指针所指位置的右边。</p>
<p>并且此时我们可以确定，<code>49</code>就放在low和high相遇的这个位置。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-58.png" style="zoom: 80%;" />

<p>以上就是一次“划分”的过程。</p>
<blockquote>
<p>我们选定了待排序序列当中的第一个元素，作为所谓的枢轴元素，或者叫基准元素。</p>
<p>然后我们用low和high两个指针分别指向了待排序序列的最左和最右两个位置。当这两个指针往中间移动的时候，我们每扫描到一个元素，都会对比这个元素和基准元素的大小关系，如果比基准元素更小的，我们统统会把它移动到左边；如果比基准元素大于等于的，我们会把它移动到右边。</p>
<p>当low和high相遇的时候，我们就确定了这个基准元素（枢轴元素）的最终存放位置。</p>
</blockquote>
<p>那既然<code>49</code>的最终位置确定了，那么在接下来的排序中，我们就不需要再管49这个元素了。我们只需要管它左边的子表，和它右边的子表。</p>
<p>接下来我们要做的，就是对其左、右子表，再次进行同样的“划分”。</p>
<p><strong>先来看左子表，对它进行划分</strong>:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-59.png" style="zoom:80%;" />

<p>同样地，是用low和high分别指向待排序序列的头、尾两处。并选中第一个元素作为基准元素。</p>
<p>现在来让high进行扫描。</p>
<p>high当前所指向的元素，13&lt;27，因此要将13放到low所指位置。</p>
<p>然后让low进行扫描。</p>
<p>low指向13，不处理；</p>
<p>low指向38，38&gt;27，因此要将38放到high所指位置。</p>
<p>然后让high进行扫描，high左移。</p>
<p>low和high相遇，如下：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-60.png" style="zoom:80%;" />

<p>此时，low和high相遇，说明待排序序列中的所有元素都被我们扫描了一遍，说明基准元素的最终存放位置应该是low和high相遇的这个位置。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-61.png" style="zoom:80%;" />

<p>此时，这个子表，又再一次地被<code>27</code>这个基准元素划分为了左右子表。由于我们的左右两个子表都只剩余一个元素，显然，这两个子表不需要再进行处理，也就是说<code>0~2</code>这个子序列中的所有元素的最终位置，我们都已经确定了。</p>
<p><strong>接下来，对<code>49</code>的右子表进行处理</strong>:</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-62.png" style="zoom:80%;" />

<p>将low和high分别指向待处理序列的头、尾位置。同时选中low所指元素作为基准元素。</p>
<p>中间过程略。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-63.png" style="zoom:80%;" />

<p>最终确定了基准元素<code>76</code>的位置。<code>76</code>再一次地把它划分成了两个更小的部分。</p>
<p>对于<code>76</code>左半部分的处理，处理思路是一样的，结果如下图所示：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-64.png" style="zoom:80%;" />

<p>此时，显然<code>49</code>的右半部分，以及<code>76</code>的右半部分，都不需要排序了。</p>
<p>因此整个表已经排序完毕。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-65.png" style="zoom:80%;" />

<p>以上就是快速排序的整个过程。</p>
<blockquote>
<p>我们会不断地进行“划分”这个过程。</p>
<p>每次划分，我们的序列都会被分为左边和右边两个部分，左边的元素都比枢轴元素更小；右边的元素都大于等于枢轴元素。</p>
<p>然后再对枢轴元素的左、右部分，再次进行“划分”。</p>
</blockquote>
<h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用第一个元素将待排序序列划分成左右两个部分</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">	<span class="type">int</span> pivot = A[low];		<span class="comment">//第一个元素作为枢轴 </span></span><br><span class="line">	<span class="keyword">while</span>(low &lt; high)&#123;		<span class="comment">//用low、high搜索枢轴的最终位置 </span></span><br><span class="line">		<span class="keyword">while</span>(low &lt; high &amp;&amp; A[high] &gt;= pivot)&#123;</span><br><span class="line">			--high; </span><br><span class="line">		&#125;</span><br><span class="line">		A[low] = A[high];	<span class="comment">//比枢轴小的元素移动到左端 </span></span><br><span class="line">		<span class="keyword">while</span>(low &lt; high &amp;&amp; A[low] &lt;= pivot)&#123;</span><br><span class="line">			++low;</span><br><span class="line">		&#125;</span><br><span class="line">		A[high] = A[low];	<span class="comment">//比枢轴大的元素移动到右端 </span></span><br><span class="line">	&#125;</span><br><span class="line">	A[low] = pivot;		<span class="comment">//枢轴元素存放到最终位置</span></span><br><span class="line">	<span class="keyword">return</span> low;		<span class="comment">//返回存放枢轴的最终位置 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(low &lt; high)&#123;		<span class="comment">//递归跳出的条件 </span></span><br><span class="line">		<span class="type">int</span> pivotpos = Partition(A, low ,high);	<span class="comment">//划分</span></span><br><span class="line">		QuickSort(A, low, pivotpos<span class="number">-1</span>);		<span class="comment">//划分左子表</span></span><br><span class="line">		QuickSort(A, pivotpos+<span class="number">1</span>, high);		<span class="comment">//划分右子表 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="算法性能分析-1"><a href="#算法性能分析-1" class="headerlink" title="算法性能分析"></a>算法性能分析</h4><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-66.png" style="zoom: 67%;" />

<p>其实每一轮处理，都是一层QuickSort，都是Partition函数执行一遍划分的过程，都是扫描一遍待排序序列除了基准元素外的所有元素。</p>
<p>所以第一次Partition，扫描了n-1个元素，处理的时间复杂度为O(n)。</p>
<p>而在之后的“划分”，每次要扫描的元素都不可能比n-1大，因此其处理的时间复杂度都不会超过O(n)。</p>
<p>而，对于这个初始序列有8个元素的表来说，我们处理了4层QuickSort。</p>
<p>时间复杂度 = <code>O(n * 递归层数)</code></p>
<h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><p>由于快速排序，是一个递归函数，每次执行都会向递归工作栈内存放函数信息。所以如果递归调用的层数越深，那么相应的需要的空间复杂度也会越高。</p>
<p>空间复杂度 = O(递归层数)</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-67.png" style="zoom: 67%;" />

<h5 id="递归层数"><a href="#递归层数" class="headerlink" title="递归层数"></a>递归层数</h5><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-68.png" style="zoom: 67%;" />

<p>由于每次“划分”，都是由一个枢轴元素将序列划分为左右两部分，直至左右部分为空，或只有一个元素。</p>
<p>因此可以将其化为一棵二叉树。</p>
<p>然后，按照二叉树的性质，对于有n个结点的二叉树，最小高度为<code>⌊ log₂n ⌋ + 1</code>；最大高度为<code>n</code>。</p>
<p>而这个二叉树的高度，就是快速排序递归调用的深度。</p>
<p>也就是说，快速排序最少需要<code>⌊ log₂n ⌋ + 1</code>层调用，最多需要<code>n</code>层调用，才可以完成整个快速排序。</p>
<blockquote>
<p>刚才我们说了，</p>
<p>时间复杂度 = O(n * 递归层数)</p>
<p>空间复杂度 = O(递归层数)</p>
</blockquote>
<p>所以，<strong>最好</strong>时间复杂度 = <code>O(nlog₂n)</code>；<strong>最坏</strong>时间复杂度 = <code>O(n²)</code>。</p>
<p><strong>最好</strong>空间复杂度 = <code>O(log₂n)</code>；<strong>最坏</strong>空间复杂度 = <code>O(n)</code>。</p>
<blockquote>
<p>在实际应用当中，快速排序算法的时间复杂度还是接近于O(nlog₂n)的。</p>
</blockquote>
<p>平均时间复杂度 =<code>O(nlog₂n)</code>。</p>
<blockquote>
<p>快速排序是所有内部排序算法中平均性能最优的排序算法。</p>
</blockquote>
<h5 id="比较好的情况"><a href="#比较好的情况" class="headerlink" title="比较好的情况"></a>比较好的情况</h5><p>像我们一开始举的那个例子，就属于比较好的情况。</p>
<blockquote>
<p>若每一次选中的“<strong>枢轴</strong>”将待排序序列<strong>划分</strong>为<strong>均匀</strong>的两个部分，则递归深度最小，算法<strong>效率最高</strong>。</p>
</blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-69.png" style="zoom:80%;" />

<h5 id="最坏的情况"><a href="#最坏的情况" class="headerlink" title="最坏的情况"></a>最坏的情况</h5><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-70.png" style="zoom: 50%;" />

<p>若初始序列就是有序的，那么high需要不断地左移，直到与low相遇，此时才能确定当前枢轴元素在此位置。</p>
<p>之后的每一层划分都需要这么做。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-71.png" style="zoom: 67%;" />

<p>此外，经过这样的一层划分之后，划分出的左右两个部分是很不均匀的：左边有0个元素，而右边有7个元素。</p>
<p>同样，之后的每一层处理，所划分出的左右两部分都是很不均匀的。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-72.png" style="zoom:80%;" />

<p>可见，若初始序列为<strong>有序或逆序</strong>，则快速排序的<strong>性能最差</strong>。</p>
<p>因为每次选择的都是最靠边的元素，导致每次划分都很不均匀。</p>
<p>而比较好的情况是，每次选取的枢轴，都能够将带排序序列划分为均匀的两个部分。</p>
<h5 id="快速排序优化"><a href="#快速排序优化" class="headerlink" title="快速排序优化"></a>快速排序优化</h5><p>因此，我们可以将快速排序算法进行一个优化。</p>
<p>有很多方法可以提高算法的效率:一种方法是尽量选取一个可以将数据中分的枢轴元素，如从序列的头尾及中间选取三个元素，再取这三个元素的中间值作为最终的枢轴元素；或者随机地从当前表中选取枢轴元素，这样做可使得最坏情况在实际排序中几乎不会发生。</p>
<h5 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h5><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-73.png" style="zoom:80%;" />

<p>对于这么一个序列。以第一个元素作为枢轴。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-74.png" style="zoom:80%;" />

<p>由于high所指元素1&lt;2，所以该元素移到low所指位置。</p>
<p>然后令low右移。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-76.png" style="zoom:80%;" />

<p>low指向2时，由于2 == 2，所以不处理，low继续右移。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-77.png" style="zoom:80%;" />

<p>low和high相遇，放入。可见，这是不稳定的。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><strong>快速排序</strong></p>
<ul>
<li>算法表现主要取决于递归深度，若每次“划分”越均匀，则递归深度越低。“划分”越不均匀，则递归深度越深。</li>
<li>性能<ul>
<li>空间复杂度<ul>
<li>最好：O(n)</li>
<li>最坏：O(log₂n)</li>
</ul>
</li>
<li>时间复杂度<ul>
<li>最好：O(nlog₂n)——每次划分很平均</li>
<li>最坏：O(n²)——原本正序或逆序</li>
<li>平均：O(nlog₂n)</li>
</ul>
</li>
<li>稳定性：不稳定</li>
</ul>
</li>
</ul>
<p><strong>注</strong>：在王道书里面，对于“一趟排序”，指的是“进行一次划分”。</p>
<p>而408原题当中，对于所有尚未确定最终位置的所有元素进行一遍处理，称为“一趟”排序，因此一次“划分” ≠ “一趟”排序。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-78.png" style="zoom: 67%;" />

<blockquote>
<p>也就是，在408当中，每一层QuickSort，是一趟排序。</p>
</blockquote>
<p>而一次划分，只是对一个子序列进行一个Partition。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-79.png" style="zoom: 50%;" />

<p>所以一次划分，只能确定一个元素的最终位置；</p>
<p>而一趟排序，可以确定多个元素的最终位置。</p>
<blockquote>
<p>这个区别，在做习题的时候会遇到。此处先提一下。</p>
<p>很多教材会认为，一次划分就是一趟排序。</p>
<p>而对于408的考试来说，是有区别的。</p>
</blockquote>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><ul>
<li><p>【2010】对一组数据<code>2 12 16 88 5 10</code>进行排序，若前 3 趟排序结果如下<br>第一趟：<code>2 12 16 5 10 88</code><br>第二趟：<code>2 12 5 10 16 88</code>第三趟：<code>2 5 10 12 16 88</code><br>则采用的排序方法可能是 → 冒泡排序</p>
<blockquote>
<p>冒泡排序 过程:从第1个记录开始到第n个记录，对相邻记录的关键字进行比较，若与排序要求相逆，则将交换，这样一趟后，具有最大关键字的记录交换到最后；然后从第1个记录开始到第n-1个记录继续进行第2趟冒泡，使得具有次最大关键字的记录换到倒数第2个位置；进行n-1趟冒泡后，达到n个记录按关键码排序</p>
</blockquote>
</li>
<li><p>【2011】为实现快速排序算法，待排序序列宜采用的存储方式是 → A</p>
<p>A．顺序存储<br>B．散列存储<br>C．链式存储<br>D．索引存储</p>
<blockquote>
<p>快速排序中查询操作用的较多，而顺序存储 适用于频繁查询时使用； 链式存储适用于频繁地插入、删除、更新元素时使用。</p>
</blockquote>
</li>
<li><p>【2014】下列选择中，不可能是快速排序第2趟排序结果的是-&gt;</p>
<p>A. 2， 3， 5， 4， 6， 7，9 </p>
<p>B. 2， 7， 5， 6， 4， 3，9 </p>
<p>C. 3， 2， 5， 4， 7， 6，9 </p>
<p>D. 4， 2， 3， 5， 7， 6，9</p>
<blockquote>
<p>四个选项都是同样的数组元素，若完全有序，应为2345679<br>每经过一趟快排，轴点元素都必然就位，也就是说，一趟下来至少有1个元素在其最终位置<br>所以考察各个选项，看有几个元素就位即可。</p>
<p>A：2、3、6、7、9</p>
<p>B：2、9</p>
<p>C：9</p>
<p>D：5、9<br>第二趟至少应有2个元素就位，所以C不对。</p>
</blockquote>
</li>
<li><p>【2010】采用递归方式对顺序表进行快速排序。下列关于递归次数的叙述中，正确的是-&gt;D</p>
<p>A. 递归次数与初始数据的排列次序无关<br>B. 每次划分后, 先处理较长的分区可以减少递归次数<br>C. 每次划分后, 先处理较短的分区可以减少递归次数<br>D. 递归次数与每次划分后得到的分区处理顺序无关</p>
<blockquote>
<p>快排算法中</p>
<p>递归的次数与 初始 数据的排列顺序有关</p>
<p>递归次数与每次划分后得到的分区处理顺序无关</p>
<p><strong>递归次数，取决于递归树，而递归树取决于轴枢的选择。树越平衡，递归次数越少。</strong></p>
<p><strong>而对分区的长短处理顺序，影响的是递归时对栈的使用内存，而不是递归次数</strong></p>
</blockquote>
</li>
<li><p>【2019】排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一「趟」。下列序列中，不可能是快速排序第二趟结果的是→D</p>
<p>A <code>5 2 16 12 28 60 32 72</code></p>
<p>B <code>2 16 5 28 12 60 32 72</code></p>
<p>C <code>2 12 16 5 28 32 72 60</code></p>
<p>D <code>5 2 12 28 16 32 72 60</code></p>
<blockquote>
<p>每经过一趟快排，轴点元素都必然就位。也就是说，一趟下来至少有1个元素在其最终位置。所以考察各个选项，看有几个元素就位即可。</p>
<p>最终排序位置是：<strong>2, 5, 12, 16, 28, 32, 60, 72</strong>，而选项中正确的位置有：</p>
<p>A. 5, 2, 16, 12, <font color='red'>28</font>, 60, 32, <font color='red'>72</font></p>
<p>B. <font color='red'>2</font>, 16, 5, 28, 12, 60, 32, <font color='red'>72</font></p>
<p>C. <font color='red'>2</font>, 12, 16, 5, <font color='red'>28</font>, <font color='red'>32</font>, 72, 60</p>
<p>D. 5, 2, <font color='red'>12</font>, 28, 16, <font color='red'>32</font>, 72, 60</p>
<p>第一趟排序，确定一个元素位置</p>
<p>第二趟排序，又确定一个或两个元素位置</p>
<ul>
<li>当第一趟元素确认的位置为最左或最右时，第二趟排序<strong>只能确认一个</strong>位置（A，B选项情况）</li>
<li>当第一趟元素确认位置不是最左或最右时，第二趟<strong>能确认2个</strong>位置（C选项情况）</li>
</ul>
<p>所以，两趟排序共确认2或3个元素位置。</p>
</blockquote>
</li>
<li><p>综合题 【2016】已知由n(n&gt;=2)个正整数构成的集合A={ak|0&lt;=k&lt;n},将其划分为两个不相交的子集A1和 A2，元素个数分 别是 n1和 n2，A1和 A2中元素之和分别为 S1和 S2。设计一个尽可能高效的划分算法，满足|n1-n2|最小且|S1-S2|最大。要求： </p>
<p>（1）给出算法的基本设计思想。 </p>
<p>（2）根据设计思想，采用 C 或 C++语言描述算法，关键之处给出注释。 </p>
<p>（3）说明你所设计算法的平均时间复杂度和空间复杂度。</p>
<blockquote>
<p>(1)将最小的⌊n/2⌋个元素放在A1中，其余的元素放在A2中，划分满足要求。不需要对全部元素进行排序，可以仿照快速排序的思想，基于枢轴将n个整数划分为两个子集。然后将划分后的枢轴位置i进行以下处理：</p>
<p>1）若i=⌊n/2⌋，则划分结束。</p>
<p>2）若i&lt;⌊n/2⌋，则枢轴及之前的所有元素均属于A1，继续对i之后的元素进行划分。</p>
<p>3）若i&gt;⌊n/2⌋，则枢轴及之后的所有元素均属于A2，继续对i之前的元素进行划分。</p>
<p>(2)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setPartition</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line"> <span class="type">int</span> pivotkey,low=<span class="number">0</span>,low0=<span class="number">0</span>,high=n<span class="number">-1</span>,high0=n<span class="number">-1</span>,flag=<span class="number">1</span>,k=n/<span class="number">2</span>,i;</span><br><span class="line"> <span class="type">int</span> s1=<span class="number">0</span>,s2=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">     pivotkey=a[low]; <span class="comment">//选择枢轴</span></span><br><span class="line">     <span class="keyword">while</span>(low&lt;high)&#123;  <span class="comment">//基于枢轴对数据记性划分</span></span><br><span class="line">         <span class="keyword">while</span>(low&lt;high &amp;&amp; a[high]&gt;=pivotkey) --high;</span><br><span class="line">         <span class="keyword">if</span>(low!=high) a[low]=a[high];</span><br><span class="line">         <span class="keyword">while</span>(low&lt;high &amp;&amp; a[low]&lt;=pivotkey) ++low;</span><br><span class="line">         <span class="keyword">if</span>(low!=high) a[high]=a[low];</span><br><span class="line">     &#125;</span><br><span class="line">     a[low]=pivotkey;</span><br><span class="line">     <span class="keyword">if</span>(low==k<span class="number">-1</span>) <span class="comment">//若枢轴是第n/2个元素，划分成功</span></span><br><span class="line">     flag=<span class="number">0</span>；</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>(low&lt;k<span class="number">-1</span>)&#123;</span><br><span class="line">         low0=++low;</span><br><span class="line">         high=high0;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         high0=--high;</span><br><span class="line">         low=low0;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++) s1+=a[i];</span><br><span class="line"> <span class="keyword">for</span>(i=k;i&lt;n;i++) s2+=a[i];</span><br><span class="line"> <span class="keyword">return</span> s2-s1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3)算法的平均时间复杂度为O(n),空间复杂度为O(1).</p>
</blockquote>
</li>
</ul>
<h2 id="8-4-选择排序"><a href="#8-4-选择排序" class="headerlink" title="8.4 选择排序"></a>8.4 选择排序</h2><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><h4 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h4><p>每一趟在待排序元素中选取关键字最小的元素加入有序子序列。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-80.png" style="zoom:80%;" />

<p>刚开始所有元素都是无序排列的。</p>
<p>第一趟扫描，我们会找到所有元素中最小的那个元素，显然<code>13</code>是最小的。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-81.png" style="zoom:80%;" />

<p>之后，我们会把最小的元素与最前面的元素进行交换。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-82.png" style="zoom:80%;" />

<p>那这样的话，接下来我们就不需要再管最前面那个位置了。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-83.png" style="zoom:80%;" />

<p>第二趟的排序，一样的。我们要从头到尾扫描各个元素，找到关键字的值最小的一个，然后把它与最前面元素交换。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-84.png" style="zoom:80%;" />

<p>这是第二趟排序。</p>
<p>接下来，<code>13</code>和<code>27</code>的位置就确定了，不用管了，继续对后面的序列进行相同的处理。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-85.png" style="zoom:80%;" />

<p>第三趟略。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-86.png" style="zoom:80%;" />

<p>第四趟，此时最小的是<code>49</code>，但是有两个49。实际上，经过选择排序，我们会将第一个<code>49</code>交换到头部的位置。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-87.png" style="zoom:80%;" />

<p>接下来的过程略</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-88.png" style="zoom:80%;" />

<p>最后只剩下一个待排序元素。它肯定不需要再进行排序操作了。而且它一定是最大的一个。</p>
<p>因此，n个元素的简单选择排序需要n-1趟处理。</p>
<h4 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单选择排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;		<span class="comment">//一共进行n-1趟 </span></span><br><span class="line">		<span class="type">int</span> min = i;			<span class="comment">//记录最小元素位置 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;n; j++)&#123;	<span class="comment">//在A[i...n-1]中选择最小的元素 </span></span><br><span class="line">			<span class="keyword">if</span>(A[j] &lt; A[min])</span><br><span class="line">				min = j;		<span class="comment">//更新最小元素位置 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(min ! = i)</span><br><span class="line">			swap(A[i], A[min]);	<span class="comment">//交换最小元素至最头处 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span> &#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>用 i 指向当前待排序序列的最开头的位置；</p>
<p>然后用 j 依次扫描其中的各个元素，找到关键字的值最小的一个。</p>
<p>接下来把通过 j 找到的那个最小的元素，放到 i 所指的位置。</p>
</blockquote>
<h4 id="算法性能分析-2"><a href="#算法性能分析-2" class="headerlink" title="算法性能分析"></a>算法性能分析</h4><h5 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><p><strong>空间复杂度：O(1)</strong></p>
<blockquote>
<p>空间复杂度，只是存放一些变量占用的空间。</p>
</blockquote>
<h5 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-89.png" style="zoom:80%;" />

<p>对于这三个序列，我们可以看出。</p>
<p>无论是有序、逆序，还是乱序，一定都必须经过n-1趟处理。</p>
<p>而且总共需要对比关键字的次数为<code>(n-1)+(n-2)+...+1 = n(n-1)/2</code>次。</p>
<p>元素交换次数 &lt; n-1。</p>
<p><strong>时间复杂度：O(n²)</strong></p>
<h5 id="稳定性-1"><a href="#稳定性-1" class="headerlink" title="稳定性"></a>稳定性</h5><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-90.png" style="zoom:80%;" />

<p>稳定性:在第i趟找到最小元素后，和第i个元素交换，可能会导致第i个元素与其含有相同关键字元素的相对位置发送改变。例如上图的序列，第一趟和最终的序列一样，显然2与<strong>2</strong>的相对次序已经发生变化。<font color='orange'>因此简单选择排序是一种不稳定的排序方法</font>。</p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p><strong>简单选择排序</strong></p>
<ul>
<li>算法原理<ul>
<li>每一趟在待排序元素中选取关键字最小的元素加入有序子序列</li>
<li>必须进行总共n-1趟处理</li>
</ul>
</li>
<li>性能<ul>
<li>空间复杂度：O(1)</li>
<li>时间复杂度：O(n²)</li>
<li>稳定性：不稳定</li>
<li>适用性：顺序表、链表都可以</li>
</ul>
</li>
</ul>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><blockquote>
<p>堆排序比较难理解，但同时也是考察频率较高的一个算法。</p>
<p>这种算法的实现，也是和选择排序核心思想一样的，但是它是基于一种“堆”的结构。</p>
</blockquote>
<h4 id="什么是堆-Heap"><a href="#什么是堆-Heap" class="headerlink" title="什么是堆(Heap)?"></a>什么是堆(Heap)?</h4><p>若n个关键字序列L[1…n]满足下面某一条性质，则称为<strong>堆</strong>（Heap）：</p>
<p>①若满足：L(i) ≥ L(2i) 且 L(i) ≥ L(2i + 1)，（1 ≤ i ≤ n/2）——<strong>大根堆（大顶堆）</strong> 根大于左右结点</p>
<p>②若满足：L(i) ≤ L(2i) 且 L(i) ≤ L(2i + 1)，（1 ≤ i ≤ n/2）——<strong>小根堆（小顶堆）</strong> 根小于左右结点</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-91.png" style="zoom: 67%;" />

<blockquote>
<p>只看定义，其实看不出来什么。</p>
</blockquote>
<p>我们来回顾一下，<strong>二叉树的顺序存储</strong>。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-92.png" style="zoom:80%;" />

<p>对于一棵二叉树，我们按照层序，将其依次存入数组中，那么对于数组下标 i ，我们可以确定各个结点的位置，以及各个结点直接的逻辑关系。</p>
<p>此时，再回到堆这里。</p>
<p>对于堆，从物理视角上来看，它是一片连续的数据元素。但是从逻辑的视角来看，它实际上是一棵完全二叉树。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-93.png" style="zoom: 67%;" />

<p>编号为1的结点就是这个树的根结点。</p>
<p>而下标为 i 的结点，它的左孩子下标应该是 2i，右孩子下标应该是 2i+1。</p>
<p>此外，当1 ≤ i ≤ n/2 时，这个结点一定是分支结点。</p>
<p>所以，什么是<strong>大根堆</strong>呢：<strong>完全二叉树中，根 ≥ 左、右</strong>。</p>
<blockquote>
<p>在一棵完全二叉树中，对于任何一个子树，它的根结点都大于左、右子树中的所有结点的值。这样的一棵完全二叉树，就是一个大根堆。</p>
<p>可以和BST（二叉排序树）：左 ≤ 根 ≤ 右，进行一个对比。</p>
</blockquote>
<p>相应的，<strong>小根堆</strong>就是：<strong>完全二叉树中，根 ≤ 左、右</strong>。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-94.png" style="zoom: 67%;" />

<blockquote>
<p>此时，我们已经知道了，什么是“堆”。接下来我们来看，如何利用堆，来实现排序。</p>
</blockquote>
<h4 id="如何基于堆进行排序"><a href="#如何基于堆进行排序" class="headerlink" title="如何基于堆进行排序"></a>如何基于堆进行排序</h4><blockquote>
<p>首先，堆排序，它是属于选择排序中的一种。</p>
<p>而选择排序的基本思想是，它会在每一趟，在待排序元素中选取关键字最小（或）最大的元素加入有序子序列。</p>
</blockquote>
<p>那么，如果我们有一个大根堆，那么，我们在这个大根堆当中，选取关键字最大的元素，就变得非常的方便。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-95.png" style="zoom: 67%;" />

<p>对于大根堆来说，肯定是堆顶的关键字的值是最大的。</p>
<p>如果从数组的视角来看，那么肯定是第一个元素的值是最大的。</p>
<p>也就是说，对于一个数组，如果我们能够把它整理成“堆”这种形式，接着我们进行选择排序就会变得很简单了。</p>
<blockquote>
<p>所以接下来我们要探讨的问题是，对于一个给定的初试序列，我们如何把它建立成大根堆。</p>
</blockquote>
<h4 id="建立大根堆"><a href="#建立大根堆" class="headerlink" title="建立大根堆"></a>建立大根堆</h4><blockquote>
<p>对于一个给定的初试序列，我们如何把它建立成大根堆，也就是具有<code>根 ≥ 左、右</code>这样一种形态。</p>
<p>也就是，保证所有子树的根结点都比它的左右孩子更大。</p>
</blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-96.png" style="zoom: 60%;" />

<p>既然我们要保证所有子树的根结点，都要比它的左右孩子更大。</p>
<p>那么我们只需要检查这棵树中所有的分支节点，因为所有的分支结点，都是它所属的子树的根结点。</p>
<p>因此，接下来我们要做的事情就是，<strong>把所有非终端结点都检查一遍，是否满足大根堆的要求，如果不满足，则进行调整</strong>。</p>
<p>之前我们也说了，对于顺序存储的完全二叉树，<strong>非终端结点编号<code>i ≤ ⌊n/2⌋</code></strong>。</p>
<p>在这个例子中，n=8，也就是我们要检查 i ≤ 4 的所有结点。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-97.png" style="zoom: 45%;" />

<p>接下来，我们会从后往前地，依次来处理各个结点。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-98.png" style="zoom:80%;" />

<p>第一个被处理的，是4号结点，这个结点是所有分支结点中编号最大的一个。</p>
<blockquote>
<p>我们可以利用之前学过的，完全二叉树顺序存储的特性，根据下标，来找到它的左孩子和右孩子。</p>
<ul>
<li>i 的左孩子：2i</li>
<li>i 的右孩子：2i + 1</li>
<li>i 的父节点：⌊i/2⌋</li>
</ul>
</blockquote>
<p>对于这个根结点，它只有一个左孩子，而它的这个左孩子是比它要大的，不满足大根堆的特性，所以我们要进行调整。</p>
<p>调整的方式就是，<strong>将当前结点与它更大的那个孩子互换</strong>。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-99.png" style="zoom:80%;" />

<p>此时就处理完毕，满足了大根堆的要求。接下来，我们处理下一个元素，3号结点<code>78</code>。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-100.png" style="zoom: 80%;" />

<p>它的右孩子比它大，不符合大根堆的特性，所以也需要调整。调整的方法就是，把当前结点，与它的值更大的孩子互换。即78和87互换。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-101.png" style="zoom:80%;" />

<p>处理下一个节点，2号节点<code>17</code>。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-102.png" style="zoom:80%;" />

<p>当前结点比它的左右孩子都要更小，不符合大根堆的特性，所以需要把当前结点和它更大的那个孩子互换。即<code>17</code>和<code>45</code>互换。</p>
<blockquote>
<p>为什么要和更大的那个孩子互换呢？</p>
<p>因为，如果不把更大的那个孩子互换，换上去之后依然不符合大根堆的特性。</p>
</blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-103.png" style="zoom:80%;" />

<p>最后，处理1号结点<code>53</code>。它的右孩子要更大，所以需要把它和它的右孩子互换。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-104.png" style="zoom:80%;" />

<p>但是，现在问题发生了：我们把更小的结点<code>53</code>“下坠”到下一层之后，又导致了以53为根的这棵子树不符合大根堆的要求。</p>
<p>怎么办呢？和之前的处理方式是一样的。我们把这个元素继续往下调整。把它和它更大的孩子交换。即将<code>53</code>和<code>78</code>互换。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-105.png" style="zoom:80%;" />

<p>此时，小元素<code>53</code>不需要继续下坠了，即为调整完成。</p>
<blockquote>
<p><code>53</code>这个元素，从第一层，下坠了两次，直接落在了第三层。这个过程是一个<strong>小元素不断下坠</strong>的过程。（自己取的叫法，不是术语）</p>
</blockquote>
<h4 id="建立大根堆算法实现"><a href="#建立大根堆算法实现" class="headerlink" title="建立大根堆算法实现"></a>建立大根堆算法实现</h4><p>刚才我们用手算实现了大根堆的建立，接下来看看代码该怎么实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=len/<span class="number">2</span>; i&gt;<span class="number">0</span>; i--)&#123;		<span class="comment">//从后往前调整所有非终端结点 </span></span><br><span class="line">		HeadAdjust(A, i, len);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将以k为根的子树调整为大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadAdjust</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> k, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">	A[<span class="number">0</span>] = A[k];		<span class="comment">//A[0]暂存子树的根结点 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>*k; i&lt;=len; i*=<span class="number">2</span>)&#123;	<span class="comment">//沿key较大的子节点向下筛选 </span></span><br><span class="line">		<span class="keyword">if</span>(i &lt; len &amp;&amp; A[i] &lt; A[i+<span class="number">1</span>])<span class="comment">//确保当前有右孩子</span></span><br><span class="line">			i++;		<span class="comment">//取key较大的子节点的下标 </span></span><br><span class="line">		<span class="keyword">if</span>(A[<span class="number">0</span>] &gt;= A[i]) <span class="keyword">break</span>;		<span class="comment">//筛选结束</span></span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			A[k] = A[i];	<span class="comment">//将A[i]调整到双亲结点上 </span></span><br><span class="line">			k = i;		<span class="comment">//修改k值，以便继续向下筛选 </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	A[k] = A[<span class="number">0</span>];		<span class="comment">//被筛选结点的值放入最终位置 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>前边几轮处理，都是较简单的处理，不再赘述。此处分析一下处理最后一个元素<code>53</code>时的具体过程。</p>
<p>其中<code>len</code>为整个表的长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &lt; len &amp;&amp; A[i] &lt; A[i+<span class="number">1</span>])</span><br><span class="line">	i++;		<span class="comment">//取key较大的子节点的下标 </span></span><br></pre></td></tr></table></figure>

<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-288.png" style="zoom: 55%;" />

<p>它的意思是，由于 i = 2*k，i 指向了当前根结点的左孩子，然后比较<code>A[i] &lt; A[i+1]</code>，即看一下右孩子是否更大，若右孩子更大，则i++，使指针 i 指向右孩子处，此时A[i]是左右孩子中较大的那个。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-289.png" style="zoom: 55%;" />

<p>至于为什么要判断 i &lt; len，是因为，若不符合这个条件，根结点的左孩子是不存在右兄弟的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(A[<span class="number">0</span>] &gt;= A[i])  <span class="keyword">break</span>; <span class="comment">//筛选结束</span></span><br></pre></td></tr></table></figure>

<p>由于A[0]存放的是根结点的值，若A[0] &gt;= A[i]，则是满足根比左右孩子都大的条件的。所以筛选结束，跳出这一轮循环，也就是当前这个根结点是不需要处理的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">A[k] = A[i];	<span class="comment">//将A[i]调整到双亲结点上 </span></span><br><span class="line">k = i;		<span class="comment">//修改k值，以便继续向下筛选 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>若不满足A[0] &gt;= A[i]，即左右孩子中较大的那个，比根结点的值还要大。那么就需要将A[i]换到此时的根结点A[k]。</p>
<p>接下来，由于我们不能确定这个值较小的根结点“下坠”后，是否满足大根堆的要求，因此需要看看它交换后，是否满足大根堆的特性。所以令 k = i，即将根结点指向刚刚的较大孩子处，再执行下一轮的for循环。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-106.png" style="zoom:67%;" />

<p>这也是为什么for循环的第三个语句是<code>i*=2</code>，这是为了将指针接着指向下一处左孩子。</p>
<p>在将53假设放在上图空白处后（为什么说是假设放在，是因为还没有最终确认53的位置），执行一次循环。发现还需要将之与其更大的孩子78互换。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-107.png" style="zoom:80%;" />

<p>也就是之前说的“小元素下坠”的一个处理。</p>
<p>继续 i *= 2，再次执行一次for循环，由于此时 i 的值已经超过了 len ，说明此时根结点 k 已经没有左右孩子了。(也就是不满足 i &lt;= len了，for循环终止)</p>
<p>然后就可以执行<code>A[k] = A[0];</code>，即将最开始的那个子树根结点插入到最终得到的 k 处。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-108.png" style="zoom: 67%;" />
</blockquote>
<h4 id="基于大根堆进行排序"><a href="#基于大根堆进行排序" class="headerlink" title="基于大根堆进行排序"></a>基于大根堆进行排序</h4><blockquote>
<p>我们此时已经有一个大根堆了。（见上面这张图）</p>
</blockquote>
<blockquote>
<p>选择排序：每一趟在待排序元素中选取关键字最大的元素加入有序子序列。</p>
<p>堆排序：每一趟将堆顶元素加入有序子序列（与待排序序列中的最后一个元素交换）</p>
</blockquote>
<p>我们每一趟将堆顶元素，也就是整个序列最大的元素拿出来，和末尾元素交换。也就是把<code>87</code>和<code>9</code>互换，如下。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-109.png" style="zoom: 80%;" />

<p>并且，从此以后<code>87</code>这个元素的位置就最终确定下来了，不需要改变了。(二叉树中，连接87的部分标为了虚线)</p>
<p>接下来，我们再进行处理，只需要对除了<code>87</code>外，前面这个堆进行排序。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-110.png" style="zoom: 80%;" />

<p>而由于刚才<code>9</code>被换到了堆顶，此时显然这个堆不是一个大根堆。</p>
<p>所以我们需要对<code>9</code>这个元素进行一个“下坠”的调整。</p>
<blockquote>
<p>即调用<code>void HeadAdjust(int A[], int k, int len)</code>，注意此时len变为7了。</p>
</blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-111.png" style="zoom:80%;" />

<p>调整结束。此时待排序元素序列再次构成一个大根堆。</p>
<p>此时我们完成了<strong>第一趟</strong>的处理。</p>
<blockquote>
<p>在第一趟处理中，我们把最大的元素（堆顶元素）换到了末尾，同时把剩余元素重新调整成了一个大根堆。</p>
</blockquote>
<p>接下来进行<strong>第二趟</strong>的处理。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-112.png" style="zoom: 80%;" />

<p>将堆顶元素与末尾元素互换，即78和53互换。同时，78确定了最终位置，往后不再考虑。</p>
<p>此时，由于53被换到了堆顶，不符合大根堆的特性，所以需要调整，令53不断下坠。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-113.png" style="zoom: 80%;" />



<p>53需要和它的右孩子互换，且此时53比左孩子更大（此时53是没有右孩子的，因为右孩子已经被排除在外了）。因此下坠完毕。第二趟结束。</p>
<p>中间趟数的处理方法同理，不再赘述，直接看最后两趟。</p>
<p><strong>第六趟开始时</strong>，如图所示：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-114.png" style="zoom:80%;" />

<p>将堆顶元素与堆底元素互换，即<code>32</code>与<code>9</code>互换。并且互换后，还需要将9下坠，再次构成大根堆，才能进行第七趟处理。</p>
<p><strong>第七趟开始</strong>，如下：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-115.png" style="zoom:80%;" />

<p>堆顶元素与堆底元素互换，且堆顶元素换到堆底后不再参与处理。那么，此时只剩下最后一个待排序元素。此时就不用继续处理了。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-116.png" style="zoom: 80%;" />

<p>最后，排序结果如下。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-117.png" style="zoom:80%;" />

<p>可见，我们在经过n-1趟处理之后，就得到了一个递增序列。</p>
<blockquote>
<p>我们刚才是基于<strong>大根堆</strong>进行的排序，最终得到的是<strong>递增序列</strong>；</p>
<p>如果是基于<strong>小根堆</strong>，原理是一样的，但是得到的是<strong>递减序列</strong>。</p>
</blockquote>
<h4 id="基于大根堆进行排序-代码"><a href="#基于大根堆进行排序-代码" class="headerlink" title="基于大根堆进行排序(代码)"></a>基于大根堆进行排序(代码)</h4><p>弄清楚怎么用大根堆进行排序后，看一看如何用代码实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=len/<span class="number">2</span>; i&gt;<span class="number">0</span>; i--)&#123;		<span class="comment">//从后往前调整所有非终端结点 </span></span><br><span class="line">		HeadAdjust(A, i, len);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将以k为根的子树调整为大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadAdjust</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> k, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">	A[<span class="number">0</span>] = A[k];		<span class="comment">//A[0]暂存子树的根结点 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>*k; i&lt;=len; i*=<span class="number">2</span>)&#123;	<span class="comment">//沿key较大的子节点向下筛选 </span></span><br><span class="line">		<span class="keyword">if</span>(i &lt; len &amp;&amp; A[i] &lt; A[i+<span class="number">1</span>])</span><br><span class="line">			i++;		<span class="comment">//取key较大的子节点的下标 </span></span><br><span class="line">		<span class="keyword">if</span>(A[<span class="number">0</span>] &gt;= A[i])</span><br><span class="line">			<span class="keyword">break</span>;		<span class="comment">//筛选结束</span></span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			A[k] = A[i];	<span class="comment">//将A[i]调整到双亲结点上 </span></span><br><span class="line">			k = i;		<span class="comment">//修改k值，以便继续向下筛选 </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	A[k] = A[<span class="number">0</span>];		<span class="comment">//被筛选结点的值放入最终位置 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//堆排序的完整逻辑</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">	BuildMaxHeap(A, len);		<span class="comment">//初始建堆</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=len; i&gt;<span class="number">1</span>; i--)&#123;	<span class="comment">//n-1趟的交换和建堆过程</span></span><br><span class="line">		swap(A[i], A[<span class="number">1</span>]);	<span class="comment">//堆顶元素和堆底元素交换</span></span><br><span class="line">		HeadAdjust(A, <span class="number">1</span>, i<span class="number">-1</span>);	<span class="comment">//把剩余的待排序元素整理成堆		</span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先要将一个顺序存储的数组建立为一个堆。</p>
<p>之后对这个建好的堆进行一次排序，并且在一次排序后，把剩下的待排序元素重新整理成堆。</p>
<h4 id="算法性能分析-3"><a href="#算法性能分析-3" class="headerlink" title="算法性能分析"></a>算法性能分析</h4><p>堆排序：①建堆；②栈顶栈底互换；③重新整理成堆(下坠调整)</p>
<p>对于建堆操作，其中也包含了下坠调整的操作；对于排序操作，也包含下坠调整操作</p>
<h5 id="建堆的过程"><a href="#建堆的过程" class="headerlink" title="建堆的过程"></a>建堆的过程</h5><p>所以我们必须分析清楚，下坠调整的算法效率。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=len/<span class="number">2</span>; i&gt;<span class="number">0</span>; i--)&#123;		<span class="comment">//从后往前调整所有非终端结点 </span></span><br><span class="line">		HeadAdjust(A, i, len);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将以k为根的子树调整为大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadAdjust</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> k, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">	A[<span class="number">0</span>] = A[k];		<span class="comment">//A[0]暂存子树的根结点 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>*k; i&lt;=len; i*=<span class="number">2</span>)&#123;	<span class="comment">//沿key较大的子节点向下筛选 </span></span><br><span class="line">		<span class="keyword">if</span>(i &lt; len &amp;&amp; A[i] &lt; A[i+<span class="number">1</span>])</span><br><span class="line">			i++;		<span class="comment">//取key较大的子节点的下标 </span></span><br><span class="line">		<span class="keyword">if</span>(A[<span class="number">0</span>] &gt;= A[i]) <span class="keyword">break</span>;		<span class="comment">//筛选结束</span></span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			A[k] = A[i];	<span class="comment">//将A[i]调整到双亲结点上 </span></span><br><span class="line">			k = i;		<span class="comment">//修改k值，以便继续向下筛选 </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	A[k] = A[<span class="number">0</span>];		<span class="comment">//被筛选结点的值放入最终位置 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于根结点 k 来说，每层for循环，需要进行一次对比操作（A[i] &lt; A[i+1]），即对比其左右孩子谁更大；之后再进行一次对比（A[0] &gt;= A[i]），即对比根结点是否比更大孩子的值大。</p>
<p>所以对于一个有两个孩子的根结点，它每往下下坠一层，都要进行2次关键字的对比。</p>
<p>若某个根结点只有左孩子、没有右孩子，则说明它的左孩子下标刚好等于表长，那么就不满足<code>i &lt; len</code>的条件，因此不需要对比左右孩子的关键字。</p>
<blockquote>
<p><strong>结论</strong>:</p>
<p>一个结点，每“下坠”一层，最多只需对比关键字2次。</p>
<p>若树高为h，某结点在第 i 层，则将这个结点向下调整，最多只需要“下坠” <code>h-i</code> 层，关键字对比次数不超过 <code>2(h-i)</code>。</p>
<p><strong>n个结点的完全二叉树</strong>，它的树高 <code>h = ⌊log₂n⌋ + 1</code>。</p>
<p>第 i 层最多有<code>2^(i-1)</code>个结点，而只有第<code>1~(h-1)</code>层的结点才有可能需要“下坠”调整。</p>
</blockquote>
<p>$$<br>第一层:1个结点，需要进行2^0*(h-1)次下坠<br>$$</p>
<p>$$<br>第二层:2^1个结点，需要进行2^1*(h-2)次下坠<br>$$</p>
<p>$$<br>第(h-1)层:2^{h-2}个结点，需要进行2^{h-2}*1次下坠<br>$$</p>
<p>所以，将整棵树调整为大根堆，每一层的下坠次数之和，再乘2，就是需要对比关键字的最大次数。</p>
<p>将整棵树调整为大根堆，关键字对比次数不超过:<br>$$<br>\sum_{i=h-1}^{1}{2^{i-1}2(h-i)}=\sum_{i=h-1}^{1}{2^i(h-i)}=\sum_{j=1}^{h-1}{2^{h-j}j}&lt;=2n\sum_{j=1}^{h-1}{\frac{j}{2^j}}&lt;=4n<br>$$</p>
<p>$$<br>(其中，h=\lfloor log_2n \rfloor+1,代入)<br>$$</p>
<blockquote>
<p>对于化简到最后一步的和式(即4n前面那个)，它是一个差比数列求和，用到的是错位相减法。(高考考的经典题型)</p>
</blockquote>
<p><strong>建堆的过程，关键字对比次数不超过4n，建堆时间复杂度 = <code>O(n)</code></strong>。</p>
<blockquote>
<p>如果想偷懒的话，前面推理的过程可以不用记，把结论记住也可以。</p>
</blockquote>
<h5 id="排序的过程"><a href="#排序的过程" class="headerlink" title="排序的过程"></a>排序的过程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序的完整逻辑</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">	BuildMaxHeap(A, len);		<span class="comment">//初始建堆</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=len; i&gt;<span class="number">1</span>; i--)&#123;	<span class="comment">//n-1趟的交换和建堆过程</span></span><br><span class="line">		swap(A[i], A[<span class="number">1</span>]);	<span class="comment">//堆顶元素和堆底元素交换</span></span><br><span class="line">		HeadAdjust(A, <span class="number">1</span>, i<span class="number">-1</span>);	<span class="comment">//把剩余的待排序元素整理成堆		</span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们已经知道，建堆的过程，即<code>BuildMaxHeap(A, len);</code>，其时间复杂度为O(n)。</p>
<p>接下来看排序的过程。</p>
</blockquote>
<p>排序的过程，总共需要n-1趟，而每一趟交换后都需要将根结点“下坠”调整。</p>
<p>这个”下坠“，最多只会下坠h-1层，而每下坠一层，最多只需对比关键字2次。</p>
<p>因此每一趟排序，时间复杂度不超过<font color='cornflowerblue'>O(h) = O(log₂n)</font>。</p>
<p>共n-1趟，总的时间复杂度 =<font color='cornflowerblue'>O(nlog₂n)</font>。</p>
<h5 id="堆排序结论"><a href="#堆排序结论" class="headerlink" title="堆排序结论"></a>堆排序结论</h5><p>因此，一次完整的堆排序，我们需要O(n)的时间来建堆，还需要O(nlog₂n)的时间来进行排序。</p>
<p>堆排序的时间复杂度 = <font color='cornflowerblue'>O(n) + O(nlog₂n) = O(nlog₂n)</font>。</p>
<p>堆排序的空间复杂度 = <font color='cornflowerblue'>O(1)</font>。</p>
<h5 id="稳定性-2"><a href="#稳定性-2" class="headerlink" title="稳定性"></a>稳定性</h5><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-118.png" style="zoom:80%;" />

<p>对于这个初始序列，我们要建立大根堆。</p>
<p>由于根结点<code>1</code>没有左右孩子大，所以需要调整，将孩子中更大的那个换上来。</p>
<p>但是左右孩子一样大，那么把哪个换上来呢？</p>
<p>看一下这个代码的逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=len/<span class="number">2</span>; i&gt;<span class="number">0</span>; i--)&#123;		<span class="comment">//从后往前调整所有非终端结点 </span></span><br><span class="line">		HeadAdjust(A, i, len);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将以k为根的子树调整为大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadAdjust</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> k, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">	A[<span class="number">0</span>] = A[k];		<span class="comment">//A[0]暂存子树的根结点 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>*k; i&lt;=len; i*=<span class="number">2</span>)&#123;	<span class="comment">//沿key较大的子节点向下筛选 </span></span><br><span class="line">		<span class="keyword">if</span>(i &lt; len &amp;&amp; A[i] &lt; A[i+<span class="number">1</span>])</span><br><span class="line">			i++;		<span class="comment">//取key较大的子节点的下标 </span></span><br><span class="line">		<span class="keyword">if</span>(A[<span class="number">0</span>] &gt;= A[i])</span><br><span class="line">			<span class="keyword">break</span>;		<span class="comment">//筛选结束</span></span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			A[k] = A[i];	<span class="comment">//将A[i]调整到双亲结点上 </span></span><br><span class="line">			k = i;		<span class="comment">//修改k值，以便继续向下筛选 </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	A[k] = A[<span class="number">0</span>];		<span class="comment">//被筛选结点的值放入最终位置 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color='orange'>注意其中的判断条件</font>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &lt; len &amp;&amp; A[i] &lt; A[i+<span class="number">1</span>])</span><br><span class="line">    i++;		<span class="comment">//取key较大的子节点的下标 </span></span><br></pre></td></tr></table></figure>

<p>i 这个指针首先指向左孩子，i+1 指向右孩子。</p>
<p>那么，按照这个代码逻辑，只有右孩子的值比左孩子的值更大的时候，我们才会让 i 指向右孩子。</p>
<p>也就是说，如果左孩子和右孩子相等的话，我们不会让 i++，更大的孩子仍是左孩子。</p>
<p><strong>若左右孩子一样大，则优先和左孩子交换。</strong></p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-119.png" style="zoom:80%;" />

<p>此时我们已经完成了建堆的工作。接下来需要进行堆排序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序的完整逻辑</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">	BuildMaxHeap(A, len);		<span class="comment">//初始建堆</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=len; i&gt;<span class="number">1</span>; i--)&#123;	<span class="comment">//n-1趟的交换和建堆过程</span></span><br><span class="line">		swap(A[i], A[<span class="number">1</span>]);	<span class="comment">//堆顶元素和堆底元素交换</span></span><br><span class="line">		HeadAdjust(A, <span class="number">1</span>, i<span class="number">-1</span>);	<span class="comment">//把剩余的待排序元素整理成堆		</span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把堆顶元素与堆底元素交换。且此时剩余的元素依然是一个大根堆，不需要调整。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-120.png" style="zoom:80%;" />

<p>直接进行第二趟排序。同样地，堆顶元素与堆底元素互换。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-121.png" style="zoom:80%;" />

<p>现在已经进行了n-1趟的排序，而且显然也已经排序结束了。</p>
<p>由于初始序列为：</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-122.png" style="zoom:80%;" />

<p>到此，我们可以得出结论，堆排序是<strong>不稳定</strong>的。</p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p><strong>堆排序</strong></p>
<ul>
<li>堆<ul>
<li>顺序存储的“完全二叉树”<ul>
<li>结点 i 的左孩子是 2i；右孩子是 2i+1；父节点是 i/2</li>
<li>编号 ≤ n/2 的结点都是分支结点</li>
</ul>
</li>
<li>大根堆（根 ≥ 左、右）；小根堆（根 ≤ 左、右）</li>
</ul>
</li>
<li>算法思想（以大根堆为例）<ul>
<li>建堆<ul>
<li>编号 ≤ n/2 的所有结点依次“下坠”调整（自底向上处理各分支结点）</li>
<li>调整规则：小元素逐层“下坠”（与关键字更大的孩子交换）</li>
</ul>
</li>
<li>排序<ul>
<li>将堆顶元素加入有序子序列（堆顶元素与堆底元素交换）</li>
<li>堆底元素换到堆顶后，需要进行“下坠”调整，恢复“大根堆”的特性</li>
<li>上述过程重复n-1趟</li>
</ul>
</li>
</ul>
</li>
<li>空间复杂度：O(1)</li>
<li>时间复杂度：建堆O(n)、排序O(nlog₂n)；总的时间复杂度 = O(nlog₂n)</li>
<li>稳定性：不稳定</li>
<li>基于大根堆的堆排序得到的是“递增序列”；基于小根堆的堆排序得到的是“递减序列”</li>
</ul>
<blockquote>
<p>内容确实比较多，也不算好理解的。</p>
<p>考试喜欢考堆排序，因为它顺道还考察了很多二叉树的知识。</p>
<p>所以对堆排序的理解，是很考验综合能力的。</p>
</blockquote>
<p><font color='green'>关于小根堆的建堆和排序，自己可以了解并练习一下</font></p>
<h3 id="堆的插入删除"><a href="#堆的插入删除" class="headerlink" title="堆的插入删除"></a>堆的插入删除</h3><h4 id="在堆中插入新元素"><a href="#在堆中插入新元素" class="headerlink" title="在堆中插入新元素"></a>在堆中插入新元素</h4><blockquote>
<p>给你一个大根堆或小根堆，你要往这个堆里面插入一个新的元素或者删除元素，应该怎么做呢？</p>
</blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-123.png" style="zoom: 67%;" />

<p>假设我们新插入的元素为<code>13</code>。首先，这个新插入的元素我们把它放到表尾的位置。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-124.png" style="zoom: 67%;" />

<p>从逻辑视角来看，我们把它放到了堆底。</p>
<p>原本我们是一个小根堆，但是在插入了新元素<code>13</code>之后，就破坏了原来的小根堆。小根堆要求，根结点要小于等于左、右孩子。</p>
<p><font color='cornflowerblue'>那怎么办呢？</font>我们需要做的是，把这个元素与它的父节点相比，如果新元素更小，则将二者互换。</p>
<p>我们的新元素在表尾的位置，而找到它的父节点很简单。</p>
<blockquote>
<p>i 的左孩子——2i</p>
<p>i 的右孩子——2i+1</p>
<p>i 的父节点——⌊i/2⌋</p>
</blockquote>
<p>新结点<code>13</code>存放下标为9，而<code>⌊9/2⌋ = 4</code>，因此它的父节点存放位置为4，即<code>32</code>这个元素。</p>
<p>找到父节点一比较，发现13 &lt; 32，13比它的父节点更小，所以要将<code>13</code><strong>上升</strong>一层。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-125.png" style="zoom: 67%;" />

<p>到了这层，我们还不能停止，还要继续与它的父节点进行比较。<code>13</code>同样比它的父节点<code>17</code>更小，所以同样也需要把它俩互换，让<code>13</code><strong>继续上升</strong>。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-126.png" style="zoom: 67%;" />

<p>到了这一步，同样需要把<code>13</code>和它的父节点<code>9</code>进行对比。而13&gt;9，所以到这一步时，就已经符合了小根堆的特性要求，所以<code>13</code>无法继续上升。</p>
<blockquote>
<p>对于<strong>小根堆</strong>，新元素放在表尾，与父节点相比，若<strong>新元素</strong>比父节点<strong>更小</strong>，则二者互换。新元素就这样一路“<strong>上升</strong>”，直到无法继续上升为止。</p>
</blockquote>
<p>对比关键字的次数：3次。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-127.png" style="zoom: 67%;" />

<p>接下来，再插入一个新元素<code>46</code>。新元素放在表尾，也就是堆底的位置。然后尝试着让<code>46</code>上升。</p>
<p>发现46的父节点45更小，因此是无法上升的。所以46待在此处就可以。</p>
<p>对比关键字的次数：1次。</p>
<h4 id="在堆中删除元素"><a href="#在堆中删除元素" class="headerlink" title="在堆中删除元素"></a>在堆中删除元素</h4><img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-128.png" style="zoom: 67%;" />

<p>假设我们要删除的元素是<code>13</code>这个元素。那么，把13删除之后。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-129.png" style="zoom: 67%;" />

<p>这个位置就空了。怎么处理呢？我们会用堆底的元素来代替这个被删除的元素。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-130.png" style="zoom: 67%;" />

<p>即，让<code>46</code>移到之前<code>13</code>存储的位置。</p>
<p>现在，为了让这个整体，恢复成小根堆该有的特性，所以我们需要做的事情，是让<code>46</code>这个元素不断<strong>下坠</strong>，直到无法下坠为止。</p>
<p>由于小根堆要求更小的元素在上面，所以我们要把<code>46</code>的更小的孩子和它交换。也就是将46和17互换。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-131.png" style="zoom: 67%;" />

<p>到这一步后，还要和它的下一层孩子进行对比，使更小的孩子和它互换。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-132.png" style="zoom: 67%;" />

<p>到此，<code>46</code>已经无法继续下坠了。</p>
<p>对比关键字的次数：4次。（对比两个孩子谁更小、对比父节点和较小的孩子谁更小，各算一次对比）</p>
<blockquote>
<p>其实考试还是会经常考察，问你“对比关键字的次数”的。</p>
</blockquote>
<blockquote>
<p>上一节当中，我们说过，如果一个父节点下面有两个孩子，则需要进行关键字的对比2次，一次是两个孩子的对比，一次是根结点和孩子结点的对比。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-133.png" style="zoom:80%;" />

<p>而如果说，下方只有一个孩子，则无需进行两个孩子的对比，而只需对比1次关键字。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-134.png" style="zoom: 67%;" />

<p>因此，在考虑下坠过程中，关键字的对比次数的问题，这个细节一定要注意。</p>
</blockquote>
<p>接下来，如果我们继续删除，删除<code>65</code>这个元素。删除之后，同样地，我们会将栈底元素去替代它。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-135.png" style="zoom:80%;" />

<p>会让<code>46</code>挪到下标为3的位置。</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-136.png" style="zoom:80%;" />

<p>接下来，会让<code>46</code>进行<strong>下坠</strong>的调整。</p>
<p>但是会发现，<code>46</code>下面的两个关键字都要比它更大，所以46已经无法再下坠了。</p>
<p>对比关键字的次数：2次。（第一次，是将左右孩子进行对比，选出一个更小的孩子；第二次，是将根结点与更小的孩子进行对比）</p>
<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p><strong>堆</strong></p>
<ul>
<li>插入<ul>
<li>新元素放到表尾（堆底）</li>
<li>根据大/小根堆的要求，新元素不断“上升”，直到无法继续上升为止</li>
</ul>
</li>
<li>删除<ul>
<li>被删除元素用表尾（堆底）元素替代</li>
<li>根据大/小根堆的要求，替代元素不断“下坠”，直到无法继续下坠为止</li>
</ul>
</li>
<li>关键字对比次数<ul>
<li>每次“上升”调整只需对比关键字1次</li>
<li>每次“下坠”调整可能需要对比关键字2次，也可能只需对比1次</li>
</ul>
</li>
<li>基本操作<ul>
<li>i 的左孩子 —— 2i</li>
<li>i 的右孩子 —— 2i+1</li>
<li>i 的父节点 —— ⌊i/2⌋</li>
</ul>
</li>
</ul>
<h3 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h3><ul>
<li><p>【2009】已知关键字序列5，8，12，19，28，20，15，22是小根堆，插入关键字3，调整后得到的小根推是–&gt;3，5，12，8，28，20，15，22，19</p>
<blockquote>
<p>插入3，3换19再换8再换5</p>
</blockquote>
</li>
<li><p>【2011】已知序列 <code>25 13 10 12 9</code> 是大根堆，在序列尾部插入新元素18，将其再调整为大根堆，调整过程中元素之间进行的比较次数是 →2</p>
<blockquote>
<p>把大根堆画成完全二叉树后，堆插入元素相当于是从最后面添加叶子节点18，先是18和10比较，18&gt;10，将18与10对调，继续判断18与25的大小。 所以总共比较2次。</p>
</blockquote>
</li>
<li><p>【2015】已知小根堆为 <code>8 15 10 21 34 16 12</code> ，删除关键字 8 之后需重新建堆，再次过程中，关键字之间的比较次数是 →3 </p>
<blockquote>
<p>叶结点 12 变为根结点，重新构建堆，第一次 15 和 10 比较，第二次 12 和 10 比较，交换 10 和 12，第三次 12 和 16 比较</p>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-137.png" style="zoom:50%;" />
</blockquote>
</li>
<li><p>【2018】在将序列(6,1,5,9,8,4,7)建成大根堆时，正确的序列变化过程是–&gt;A</p>
<p>A、6,1,7,9,8,4,5→6,9,7,1,8,4,5→9,6,7,1,8,4,5→9,8,7,1,6,4,5</p>
<p>B、6,9,5,1,8,4,7→ 6,9,7,1,8,4,5→9,6,7,1,8,4,5→9,8,7,1,6, 4,5</p>
<p>C、6,9,5,1,8,4,7→9,6,5,1,8,4,7→9,6,7,1,8,4,5→9,8,7,1,6,4,5</p>
<p>D、6,1,7,9,8,4,5→7,1,6,9,8,4,5→7,9,6,1,8,4,5→9,7,6,1,8,4,5→9,8,6,1,7,4,5</p>
<blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-138.png" style="zoom: 67%;" />
</blockquote>
</li>
<li><p>【2020】下列关于大根堆(至少含2个元素)的叙述中，正确的是–&gt;C</p>
<p>I.可以将堆视为一棵完全二叉树</p>
<p>II.可以采用顺序存储方式保存堆</p>
<p>III.可以将堆视为一棵二叉排序树</p>
<p>IV. 堆中的次大值一定在根的下一层</p>
<p>A、仅I、II</p>
<p>B、仅II、III</p>
<p>C、仅I、II和IV</p>
<p>D、I、III和IV</p>
<blockquote>
<p>这是一道简单的概念题。堆是一棵完全树，采用一维数组存储，故I正确，II 正确。大根堆只要求根结点值大于左右孩子值，并不要求左右孩子值有序，II 错误。堆的定义是递归的，所以其左右子树也是大根堆，所以堆的次大值一定是其左孩子或右孩子， IV正确。</p>
</blockquote>
</li>
<li><p>【2021】将关键字6,9,1,5,8,4,7依次插入到初始为空的大根堆H中，得到的H是-&gt;B</p>
<p>A、9,8,7,6,5,4,1</p>
<p>B、9,8,7,5,6,1,4</p>
<p>C、9,8,7,5,6,4,1</p>
<p>D、9,6,7,5,8,4,1</p>
<blockquote>
<img src="https://kailin-1312778500.cos.ap-nanjing.myqcloud.com/img/ds8-139.png" style="zoom: 67%;" />
</blockquote>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://tikxeis.fun">kailin2eis</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://tikxeis.fun/p/43357/">http://tikxeis.fun/p/43357/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://tikxeis.fun" target="_blank">派总</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/408%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">408数据结构</a></div><div class="post_share"><div class="social-share" data-image="/img/1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/14847/"><img class="prev-cover" src="/img/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第八章 排序(三)</div></div></a></div><div class="next-post pull-right"><a href="/p/27129/"><img class="next-cover" src="/img/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第八章 排序(一)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/p/24523/" title="第一章 绪论"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第一章 绪论</div></div></a></div><div><a href="/p/14457/" title="第二章 线性表(上)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第二章 线性表(上)</div></div></a></div><div><a href="/p/12625/" title="第二章 线性表(下)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第二章 线性表(下)</div></div></a></div><div><a href="/p/63528/" title="第三章 栈、队列和数组(上)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">第三章 栈、队列和数组(上)</div></div></a></div><div><a href="/p/17647/" title="第四章 串"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-28</div><div class="title">第四章 串</div></div></a></div><div><a href="/p/58315/" title="第三章 栈、队列和数组(下)"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-28</div><div class="title">第三章 栈、队列和数组(下)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">kailin2eis</div><div class="author-info__description">派总's blog</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-text">8.3 交换排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-Bubble-Sort"><span class="toc-text">冒泡排序 Bubble Sort</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">算法性能分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-Quick-Sort"><span class="toc-text">快速排序 Quick Sort</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-1"><span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-1"><span class="toc-text">算法性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">空间复杂度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%B1%82%E6%95%B0"><span class="toc-text">递归层数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%A5%BD%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">比较好的情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%9D%8F%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">最坏的情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96"><span class="toc-text">快速排序优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-text">稳定性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98"><span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">8.4 选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">简单选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-2"><span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-2"><span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-2"><span class="toc-text">算法性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-1"><span class="toc-text">空间复杂度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-1"><span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%B3%E5%AE%9A%E6%80%A7-1"><span class="toc-text">稳定性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86-Heap"><span class="toc-text">什么是堆(Heap)?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8E%E5%A0%86%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F"><span class="toc-text">如何基于堆进行排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%A4%A7%E6%A0%B9%E5%A0%86"><span class="toc-text">建立大根堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%A4%A7%E6%A0%B9%E5%A0%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">建立大根堆算法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%A4%A7%E6%A0%B9%E5%A0%86%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F"><span class="toc-text">基于大根堆进行排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%A4%A7%E6%A0%B9%E5%A0%86%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F-%E4%BB%A3%E7%A0%81"><span class="toc-text">基于大根堆进行排序(代码)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-3"><span class="toc-text">算法性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BB%BA%E5%A0%86%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">建堆的过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">排序的过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%E7%BB%93%E8%AE%BA"><span class="toc-text">堆排序结论</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%B3%E5%AE%9A%E6%80%A7-2"><span class="toc-text">稳定性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4"><span class="toc-text">堆的插入删除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%A0%86%E4%B8%AD%E6%8F%92%E5%85%A5%E6%96%B0%E5%85%83%E7%B4%A0"><span class="toc-text">在堆中插入新元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%A0%86%E4%B8%AD%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-text">在堆中删除元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-1"><span class="toc-text">习题</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/44803/" title="第八章 排序(四)">第八章 排序(四)</a><time datetime="2022-09-28T11:54:17.000Z" title="发表于 2022-09-28 19:54:17">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/14847/" title="第八章 排序(三)">第八章 排序(三)</a><time datetime="2022-09-28T11:52:50.000Z" title="发表于 2022-09-28 19:52:50">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/43357/" title="第八章 排序(二)">第八章 排序(二)</a><time datetime="2022-09-28T11:50:30.000Z" title="发表于 2022-09-28 19:50:30">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/27129/" title="第八章 排序(一)">第八章 排序(一)</a><time datetime="2022-09-28T11:47:17.000Z" title="发表于 2022-09-28 19:47:17">2022-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/p/15017/" title="第七章 查找(四)">第七章 查找(四)</a><time datetime="2022-09-28T11:33:21.000Z" title="发表于 2022-09-28 19:33:21">2022-09-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By kailin2eis</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="关关雎鸠,在河之洲,窈窕淑女,what' your qq" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>